     1                                  [DEFAULT REL]
     2                                  BITS 64
     3                                  
     4                                  %include "./inc/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1> ;    %ifdef retOff
    22                              <1> ;    %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1> ;    %ifdef currSegVBase
    24                              <1> ;    j%+1 short (retOff+currSegVBase)
    25                              <1> ;    %else
    26                              <1> ;    j%+1 short retOff
    27                              <1> ;    %endif  ;End ifdef currSegVBase
    28                              <1> ;    %else 
    29                              <1> ;    j%-1 short %%a
    30                              <1> ;    return
    31                              <1> ;%%a:
    32                              <1> ;    %endif  ;End the distance measurement if
    33                              <1> ;    %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1> ;    %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro rets 0
    81                              <1> cret s
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %macro retns 0
    85                              <1> cret ns
    86                              <1> %endmacro
    87                              <1> 
    88                              <1> %macro breakpoint 0
    89                              <1> xchg bx, bx
    90                              <1> %endmacro
     5                                  %include "./inc/drvStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     4                              <1> ; device driver related structures.                     ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> struc drvHdr  ;Device Driver Header for character and block devices
     8                              <1> 
     9 00000000 ????????????????    <1>     .nxtPtr dq ?  ;Pointer to the next driver header, -1 if at the end
    10 00000008 ????                <1>     .attrib dw ?  ;Attribute Word
    11 0000000A ????????????????    <1>     .strPtr dq ?  ;Strategy Entry Pointer
    12 00000012 ????????????????    <1>     .intPtr dq ?  ;Interrupt Entry Pointer
    13                              <1>     .drvUnt:        ;Number of units pointer
    14 0000001A ????????????????    <1>     .drvNam db 8 dup (?)  ;Driver name (Char) or Number of units byte (Block)
    15                              <1> 
    16                              <1> endstruc
    17                              <1> 
    18                              <1> ;Command Code equates
    19                              <1>     drvINIT         equ 0
    20                              <1>     drvMEDCHK       equ 1
    21                              <1>     drvBUILDBPB     equ 2
    22                              <1>     drvIOCTLREAD    equ 3
    23                              <1>     drvREAD         equ 4
    24                              <1>     drvNONDESTREAD  equ 5
    25                              <1>     drvINSTATUS     equ 6
    26                              <1>     drvFLUSHINBUF   equ 7
    27                              <1>     drvWRITE        equ 8
    28                              <1>     drvWRITEVERIFY  equ 9
    29                              <1>     drvOUTSTATUS    equ 10
    30                              <1>     drvFLUSHOUTBUF  equ 11
    31                              <1>     drvIOCTLWRITE   equ 12
    32                              <1>     drvOPEN         equ 13
    33                              <1>     drvCLOSE        equ 14
    34                              <1>     drvREMMEDCHECK  equ 15
    35                              <1>     drvOUTTILBUSY   equ 16
    36                              <1>     drvIOCTL        equ 19
    37                              <1>     drvGETDRVMAP    equ 23
    38                              <1>     drvSETDRVMAP    equ 24
    39                              <1>     drvMAXCMD       equ 24
    40                              <1> ;Driver Error equates 
    41                              <1>     drvWPErr        equ 0   ;Write Protect Violation
    42                              <1>     drvBadUnit      equ 1   ;Unknown unit
    43                              <1>     drvNotReady     equ 2   ;Device not ready
    44                              <1>     drvBadCmd       equ 3   ;Unknown command
    45                              <1>     drvCRCErr       equ 4   ;CRC Error
    46                              <1>     drvBadDrvReq    equ 5   ;Bad drive request structure length
    47                              <1>     drvBadSeek      equ 6   ;Seek error
    48                              <1>     drvBadMed       equ 7   ;Unknown media
    49                              <1>     drvSecNotFnd    equ 8   ;Sector not found
    50                              <1>     drvNoPaper      equ 9   ;Printer out of paper
    51                              <1>     drvWriteFault   equ 10  ;Write Fault
    52                              <1>     drvReadFault    equ 11  ;Read Fault
    53                              <1>     drvGenFault     equ 12  ;General Fault
    54                              <1>     drvBadDskChnge  equ 15  ;Invalid disk change
    55                              <1> 
    56                              <1> ;Driver status word status bit meanings
    57                              <1>     drvErrStatus    equ 8000h  
    58                              <1>     drvDonStatus    equ 0100h
    59                              <1>     drvBsyStatus    equ 0200h
    60                              <1> 
    61                              <1> ;Driver Attribute Word bit meanings
    62                              <1>     devDrvConIn     equ 1h  ;If set, device is CON input
    63                              <1>     devDrvConOut    equ 2h  ;If set, device is CON output
    64                              <1>     devDrvNulDev    equ 4h  ;If set, device is NULL device
    65                              <1>     devDrvClockDev  equ 8h  ;If set, device is CLOCK device
    66                              <1>     devDrvFastOut   equ 10h ;If set, device supports Int 29h
    67                              <1>     devDrvIOCTL     equ 40h ;If set, IOCTL and GET/SET suported
    68                              <1>     devDrvIOCTLQ    equ 80h ;If set, IOCTL Query supported (21h/4410h, 4411h)
    69                              <1>     devDrvOpClRem   equ 800h ;If set, Open, Close and Rem media supported
    70                              <1>     devDrvNotIBM    equ 2000h ;If set, media byte is meaningful for disk comps
    71                              <1>     devDrvOutToBsy  equ 2000h ;If set, char dev supports output until busy
    72                              <1>     devDrvIOCTLCtl  equ 4000h ;If set, IOCTL control strings supported
    73                              <1>     devDrvChar      equ 8000h ;If set, Char device
    74                              <1> ;Bit 0 1=Console input
    75                              <1> ;    1 1=Console output (character devices)
    76                              <1> ;    2 1=NUL device
    77                              <1> ;    3 1=CLOCK device
    78                              <1> ;    4 1=Int 29 output (CON)
    79                              <1> ;    6 1=Generic IOCTL and GET/SET logical drive supported (13,17,18) (3.2+)
    80                              <1> ;    7 1=Query IOCTL function supported (19) (5.0+)
    81                              <1> ;   11 1=Open/close/removable media supported (3.0+)
    82                              <1> ;   13 1=Output until busy supported (character devices) (3.0+)
    83                              <1> ;      1=Media descriptor in FAT required (block devices)
    84                              <1> ;   14 1=IOCTL read and write control strings supported
    85                              <1> ;   15 0=Block device
    86                              <1> ;      1=Character device
    87                              <1> 
    88                              <1> ;Driver structures
    89                              <1> 
    90                              <1> %macro drvReqPktM 0 ;Driver Request Header Macro
    91                              <1> 
    92                              <1>     .hdrlen db ?  ;Length of the request header
    93                              <1>     .unitnm db ?  ;Unit number, meaningless for character devs
    94                              <1>     .cmdcde db ?  ;Command code
    95                              <1>     .status dw ?  ;Status word
    96                              <1>     .devptr dq ?  ;Device queue pointer field, reserved for future use
    97                              <1> 
    98                              <1> %endmacro
    99                              <1> 
   100                              <1> struc drvReqPkt
   101                              <1>     drvReqPktM
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   102                              <1> endstruc
   103                              <1> 
   104                              <1> struc initReqPkt  ;Init Request Packet
   105                              <1> 
   106                              <1>     drvReqPktM   ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   107 0000000D ??                  <1>     .numunt db ?  ;Number of logical units (Block only, 0 for char)
   108 0000000E ????????????????    <1>     .endptr dq ?  ;Pointer to first free byte after driver
   109 00000016 ????????????????    <1>     .optptr dq ?  ;Ptr to BPB array (blkdev) or cmdline args
   110 0000001E ??                  <1>     .drvnum db ?  ;First Drive number
   111                              <1> 
   112                              <1> endstruc
   113                              <1> 
   114                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
   115                              <1> 
   116                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   117 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   118 0000000E ??                  <1>     .medret db ?  ;Return byte (Has media been changed?)
   119 0000000F ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field
   120                              <1> 
   121                              <1> endstruc
   122                              <1> 
   123                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
   124                              <1> 
   125                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   126 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   127 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   128 00000016 ????????????????    <1>     .bpbptr dq ?  ;Pointer to the BPB
   129                              <1> 
   130                              <1> endstruc
   131                              <1> 
   132                              <1> struc ioReqPkt   ;IO Request Packet
   133                              <1> 
   134                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   135 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   136 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   137 00000016 ????????            <1>     .tfrlen dd ?  ;Number of Sectors/bytes to transfer
   138 0000001A ????????????????    <1>     .strtsc dq ?  ;Starting sector for transfer
   139 00000022 ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field if error
   140                              <1> 
   141                              <1> endstruc
   142                              <1> 
   143                              <1> struc ndInNoWaitPkt    ;Nondestructive Input No Wait Request Packet
   144                              <1>     
   145                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   146 0000000D ??                  <1>     .retbyt db ?  ;Byte read non destructively
   147                              <1> 
   148                              <1> endstruc
   149                              <1> 
   150                              <1> struc statusReqPkt   ;Status Request Packet
   151                              <1> 
   152                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   153                              <1> 
   154                              <1> endstruc
   155                              <1> 
   156                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
   157                              <1> 
   158                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   159                              <1>      
   160                              <1> endstruc
   161                              <1> 
   162                              <1> struc openReqPkt ;Open Device Request Packet
   163                              <1> 
   164                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   165                              <1>      
   166                              <1> endstruc
   167                              <1> 
   168                              <1> struc closeReqPkt ;Close Device Request Packet
   169                              <1> 
   170                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   171                              <1>      
   172                              <1> endstruc
   173                              <1> 
   174                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   175                              <1> 
   176                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   177                              <1>      
   178                              <1> endstruc
   179                              <1> 
   180                              <1> struc outTilBusyPkt
   181                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   182 0000000D ????????????????    <1>     .pXfrBuffer dq ?    ;Pointer to the transfer buffer
   183 00000015 ????                <1>     .wXfrCount  dw ?    ;Byte count to xfr. Returns bytes xfred.
   184                              <1> endstruc
   185                              <1> 
   186                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   187                              <1> 
   188                              <1>     drvReqPktM    ;Common Driver Header Macro  
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   189 0000000D ??                  <1>     .majfun db ?  ;Major function number
   190 0000000E ??                  <1>     .minfun db ?  ;Minor function number
   191 0000000F ????????????????    <1>     .rsival dq ?  ;Contents of RSI
   192 00000017 ????????????????    <1>     .rdival dq ?  ;Contents of RDI
   193 0000001F ????????????????    <1>     .ctlptr dq ?  ;Pointer to Generic IOCTL Request Packet
   194                              <1> 
   195                              <1> endstruc
   196                              <1> 
   197                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   198                              <1>     
   199                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   200                              <1> 
   201                              <1> endstruc
   202                              <1> 
   203                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   204                              <1>     
   205                              <1>     drvReqPktM    ;Common Driver Header Macro
    91                              <2> 
    92 00000000 ??                  <2>  .hdrlen db ?
    93 00000001 ??                  <2>  .unitnm db ?
    94 00000002 ??                  <2>  .cmdcde db ?
    95 00000003 ????                <2>  .status dw ?
    96 00000005 ????????????????    <2>  .devptr dq ?
    97                              <2> 
   206                              <1> 
   207                              <1> endstruc
   208                              <1> ;IOCTL structs
   209                              <1> 
   210                              <1> struc lbaParamsBlock
   211 00000000 ??                  <1>     .bSize          db ?
   212 00000001 ??                  <1>     .bSpecFuncs     db ?    ;0 = Update drive info from medium and return that
   213                              <1>                             ;1 = Get current saved drive info w/o updating
   214                              <1>                             ;2 = Get physical parameters of the medium
   215                              <1>                             ;Only meaningful on get. Set must have this as 0
   216 00000002 ????                <1>     .wDevFlgs       dw ?    ;Only bits 0 and 1 are xmitted/read
   217 00000004 ????                <1>     .wFSType        dw ?    ;If one, it is a FAT type. Only valid on getlba
   218                              <1>                             ; If one, can use CHS functions with returned vals
   219 00000006 ????                <1>     .wRes           dw ?    ;Reserved word
   220 00000008 ????????????????    <1>     .qSectorSize    dq ?    ;Only the lower word is valid here
   221 00000010 ????????????????    <1>     .qNumSectors    dq ?    ;Only the lower dword is valid here
   222                              <1> ;The below is the absolute start sector of the partition. It is the 
   223                              <1> ; partition at which to find the BPB.
   224 00000018 ????????????????    <1>     .qStartSector   dq ?    ;Only the lower dword is valid here.
   225                              <1> endstruc
   226                              <1> 
   227                              <1> %macro lbIOCmnM 0   ;IOCTL LBA request common portion macro
   228                              <1>     .size           db ?
   229                              <1>     .numSectors     db ?  ;# sectors to act on. Returns sectors acted on
   230                              <1>     .res            db 6 dup (?)
   231                              <1>     .startSector    dq ?  ;Sector to start action on
   232                              <1> %endmacro
   233                              <1> 
   234                              <1> struc lbaIOBlock
   235                              <1>     lbIOCmnM
   228 00000000 ??                  <2>  .size db ?
   229 00000001 ??                  <2>  .numSectors db ?
   230 00000002 ????????????        <2>  .res db 6 dup (?)
   231 00000008 ????????????????    <2>  .startSector dq ?
   236 00000010 ????????????????    <1>     .xferBuffer     dq ?  ;Transfer buffer for data
   237                              <1> endstruc
   238                              <1> 
   239                              <1> struc lbaFormatBlock
   240                              <1>     lbIOCmnM
   228 00000000 ??                  <2>  .size db ?
   229 00000001 ??                  <2>  .numSectors db ?
   230 00000002 ????????????        <2>  .res db 6 dup (?)
   231 00000008 ????????????????    <2>  .startSector dq ?
   241                              <1> endstruc
   242                              <1> 
   243                              <1> struc chsParamsBlock
   244 00000000 ??                  <1>     .bSpecFuncs db ?    ;
   245 00000001 ??                  <1>     .bDevType   db ?    ;5 if fixed, 7 otherwise
   246 00000002 ????                <1>     .wDevFlgs   dw ?    ;Only bits 0 and 1 are xmitted/read
   247 00000004 ????                <1>     .wNumCyl    dw ?
   248 00000006 ??                  <1>     .bMedTyp    db ?    ;Perma 0 for us, meaningless. Reserved.
   249 00000007 <res 35h>           <1>     .deviceBPB  db 53 dup (?)   ;Full length with reserved bytes of BPB32
   250                              <1>     .TrackLayout:
   251                              <1> endstruc
   252                              <1> 
   253                              <1> ;Used for get and set params. Refer to DOS docs for meaning of bit.
   254                              <1> specFuncBPB equ 1<<0    ;Does BPB stuff
   255                              <1> ;Only used in setparams requests. Ignored for getparams 
   256                              <1> specFuncTrk equ 1<<1    ;Set if just track layout cpy. Clear if set all.
   257                              <1> specFuncSec equ 1<<2    ;Set if all sectors samze size. Clear if not.
   258                              <1> 
   259                              <1> 
   260                              <1> struc chsIOBlock
   261 00000000 ??                  <1>     .bSpecFuncs     db ?
   262 00000001 ????                <1>     .wStartHead     dw ?
   263 00000003 ????                <1>     .wStartCyl      dw ?    ;Zero based.
   264 00000005 ????                <1>     .wStartSector   dw ?    ;Zero based.
   265 00000007 ????                <1>     .wNumSectors    dw ?
   266 00000009 ????????????????    <1>     .pXferBuffer    dq ?
   267                              <1> endstruc
   268                              <1> 
   269                              <1> struc chsFormatBlock
   270 00000000 ??                  <1>     .bSpecFuncs db ?
   271 00000001 ????                <1>     .wStartHead dw ?
   272 00000003 ????                <1>     .wStartCyl  dw ?        ;Zero based.
   273                              <1> endstruc
   274                              <1> 
   275                              <1> struc accFlgBlk
   276 00000000 ??                  <1>     .bSpecFuncs db ?    ;Must be 0
   277 00000001 ??                  <1>     .bAccMode   db ?    ;Set if access allowed. Clear if not.
   278                              <1> endstruc
   279                              <1> 
   280                              <1> struc idParamBlk
   281 00000000 ????                <1>     .wCallLvl   dw ?    ;Should be zero
   282 00000002 ????????            <1>     .volId      dd ?    ;Volume Id
   283 00000006 <res Bh>            <1>     .volLab     db 11 dup (?)   ;Volume label string
   284 00000011 ????????????????    <1>     .filSysType db 8 dup (?)    ;File system type string
   285                              <1> endstruc
     6                                  %include "./inc/fatStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous FAT driver   ;
     4                              <1> ; structures. exFAT will have it's own files at a later ;
     5                              <1> ; stage.                                                ;
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ;  IMPORTANT!!! IMPORTANT!!! IMPORTANT!!! IMPORTANT!!!  ;
    10                              <1> ;   REMEMBER, CLUSTER NUMBERS START AT 2!               ;
    11                              <1> ;   THE FIRST DATA CLUSTER ON A DISK IS CLUSTER 2!!!    ;
    12                              <1> ;   ON FAT12/16, A CLUSTER NUMBER OF 0 MEANS ROOT DIR!  ;
    13                              <1> ;   ON FAT32, A CLUSTER NUMBER OF 0 ALIASES THE FIRST   ;
    14                              <1> ;       CLUSTER OF THE ROOT DIRECTORY!!                 ;
    15                              <1> ;  IMPORTANT!!! IMPORTANT!!! IMPORTANT!!! IMPORTANT!!!  ;
    16                              <1> ;-------------------------------------------------------;
    17                              <1> 
    18                              <1> struc oemHeader
    19 00000000 ??????              <1>     .jump       db 3 dup (?)    ;Jump instruction
    20 00000003 ????????????????    <1>     .oemString  db 8 dup (?)    ;OEM string
    21                              <1> endstruc
    22                              <1> 
    23                              <1> struc bpb          ;FAT 12 and 16 BPB
    24 00000000 ????                <1>     .bytsPerSec dw ?  ;Bytes per sector
    25 00000002 ??                  <1>     .secPerClus db ?  ;Sectors per cluster
    26 00000003 ????                <1>     .revdSecCnt dw ?  ;Number of reserved sectors, in volume
    27 00000005 ??                  <1>     .numFATs    db ?  ;Number of FATs on media
    28 00000006 ????                <1>     .rootEntCnt dw ?  ;Number of 32 byte entries in Root directory
    29 00000008 ????                <1>     .totSec16   dw ?  ;Number of sectors on medium
    30 0000000A ??                  <1>     .media      db ?  ;Media descriptor byte
    31 0000000B ????                <1>     .FATsz16    dw ?  ;Number of sectors per FAT
    32 0000000D ????                <1>     .secPerTrk  dw ?  ;Number of sectors per "track"
    33 0000000F ????                <1>     .numHeads   dw ?  ;Number of read "heads"
    34 00000011 ????????            <1>     .hiddSec    dd ?  ;Number of hidden sectors, preceeding volume start
    35 00000015 ????????            <1>     .totSec32   dd ?  ;32 bit count of sectors
    36                              <1> endstruc
    37                              <1> 
    38                              <1> struc extBs
    39                              <1> ;Extended bootsector structure. If present, comes immediately after 
    40                              <1> ; BPB in bootsector
    41 00000000 ??                  <1>     .drvNum     db ?  ;Logical drive number (00h or 80h)
    42 00000001 ??                  <1>     .reserved1  db ?  ;Reserved byte
    43 00000002 ??                  <1>     .bootSig    db ?  ;Extended boot signature
    44 00000003 ????????            <1>     .volId      dd ?  ;Volume serial number
    45 00000007 <res Bh>            <1>     .volLab     db 11 dup (?) ;Volume label string
    46 00000012 ????????????????    <1>     .filSysType db 8 dup (?)  ;File system type string
    47                              <1> endstruc
    48                              <1> extBsSig    equ 29h
    49                              <1> 
    50                              <1> struc bpb32       ;FAT 32 BPB
    51 00000000 ????                <1>     .bytsPerSec dw ?  ;Bytes per sector
    52 00000002 ??                  <1>     .secPerClus db ?  ;Sectors per cluster
    53 00000003 ????                <1>     .revdSecCnt dw ?  ;Number of reserved sectors
    54 00000005 ??                  <1>     .numFATs    db ?  ;Number of FATs on media
    55 00000006 ????                <1>     .rootEntCnt dw ?  ;Number of entries in Root directory
    56 00000008 ????                <1>     .totSec16   dw ?  ;Number of sectors on medium
    57 0000000A ??                  <1>     .media      db ?  ;Media descriptor byte
    58 0000000B ????                <1>     .FATsz16    dw ?  ;Number of sectors per FAT, must be 0 for FAT 32
    59 0000000D ????                <1>     .secPerTrk  dw ?  ;Number of sectors per "track"
    60 0000000F ????                <1>     .numHeads   dw ?  ;Number of read "heads"
    61 00000011 ????????            <1>     .hiddSec    dd ?  ;Number of hidden sectors
    62 00000015 ????????            <1>     .totSec32   dd ?  ;32 bit count of sectors
    63 00000019 ????????            <1>     .FATsz32    dd ?  ;32 bit count of sectors occupied by one FAT
    64 0000001D ????                <1>     .extFlags   dw ?  ;Extended Flags word
    65 0000001F ????                <1>     .FSver      dw ?  ;File system version word, must be 0
    66 00000021 ????????            <1>     .RootClus   dd ?  ;First Cluster of Root Directory
    67 00000025 ????                <1>     .FSinfo     dw ?  ;Sector number of FSINFO structure, usually 1
    68 00000027 ????                <1>     .BkBootSec  dw ?  ;Backup Boot sector, either 0 or 6
    69 00000029 <res Ch>            <1>     .reserved   db 12 dup (?) ;Reserved 12 bytes
    70                              <1> endstruc
    71                              <1> 
    72                              <1> struc FSInfo
    73 00000000 ????????            <1>     .leadSig    dd ? ;Leading Signature, should be 041615252h
    74 00000004 <res 1E0h>          <1>     .reserved1  db 480 dup (?)
    75 000001E4 ????????            <1>     .strucSig   dd ?  ;Should be 061417272h
    76 000001E8 ????????            <1>     .freeCount  dd ?  ;Contains the last known free cluster on volume
    77 000001EC ????????            <1>     .nextFree   dd ?  ;Contains the first known free cluster on volume
    78 000001F0 <res Ch>            <1>     .reserved2  db 12 dup (?) ;Should be 0
    79 000001FC ????????            <1>     .trailSig   dd ?  ;Should be 0AA550000h
    80                              <1> endstruc
    81                              <1> 
    82                              <1> fsInfoSig1  equ 041615252h
    83                              <1> fsInfoSig2  equ 061417272h
    84                              <1> fsInfoSig3  equ 0AA550000h
    85                              <1> 
    86                              <1> struc mbr
    87 00000000 <res 1B8h>          <1>     .bsCode     db 440 dup (?)
    88 000001B8 ????????            <1>     .diskID     dd ?
    89 000001BC ????                <1>     .reserved   dw ?
    90 000001BE <res 10h>           <1>     .mbrEntry1  db 16 dup (?)
    91 000001CE <res 10h>           <1>     .mbrEntry2  db 16 dup (?)
    92 000001DE <res 10h>           <1>     .mbrEntry3  db 16 dup (?)
    93 000001EE <res 10h>           <1>     .mbrEntry4  db 16 dup (?)
    94 000001FE ????                <1>     .mbrSig     dw ?
    95                              <1> endstruc
    96                              <1> 
    97                              <1> struc ebr   ;A special type of MBR
    98 00000000 <res 1BEh>          <1>     .bsCode     db 446 dup (?)    ;Basic 16-bit code to error if launched into
    99 000001BE <res 10h>           <1>     .ebrVolHdr  db 16 dup (?) ;Information about the volume itself
   100 000001CE <res 10h>           <1>     .ebrLinkHdr db 16 dup (?) ;Link ptr to next logical volume in ebr
   101 000001DE <res 20h>           <1>     .reserved   db 32 dup (?) ;Reserved
   102 000001FE ????                <1>     .mbrSig     dw ?
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc mbrEntry
   106 00000000 ??                  <1>     .ptnAtrib   db ?  ;80h = active
   107 00000001 ??????              <1>     .chsStart   db 3 dup (?)  ;Ignore practically
   108 00000004 ??                  <1>     .ptnType    db ?  ;This being 00 means free
   109 00000005 ??????              <1>     .chsEnd     db 3 dup (?)  ;Ignore
   110 00000008 ????????            <1>     .lbaStart   dd ?  ;Start of partition in 32 bit LBA
   111 0000000C ????????            <1>     .numSectors dd ?  ;Number of sectors in partition
   112                              <1> endstruc
   113                              <1> 
   114                              <1> struc fatDirEntry
   115 00000000 <res Bh>            <1>     .name       db 11 dup (?) ;8.3 File Name w/o fullstop
   116 0000000B ??                  <1>     .attribute  db ?  ;Usual attributes
   117 0000000C ??                  <1>     .ntRes      db ?  ;Reserved 0
   118 0000000D ??                  <1>     .crtTimeT   db ?  ;Count of tenths of a second of file creation time <=199
   119 0000000E ????                <1>     .crtTime    dw ?  ;Creation time, granularity of 2 seconds
   120 00000010 ????                <1>     .crtDate    dw ?  ;Creation date
   121 00000012 ????                <1>     .lastAccDat dw ?  ;Last Read/Write date, not 100% supported (consider later)
   122 00000014 ????                <1>     .fstClusHi  dw ?  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
   123 00000016 ????                <1>     .wrtTime    dw ?  ;Last modification (write) time
   124 00000018 ????                <1>     .wrtDate    dw ?  ;Last modification (write) date
   125 0000001A ????                <1>     .fstClusLo  dw ?  ;Lo word of 1st data cluster for file/dir
   126 0000001C ????????            <1>     .fileSize   dd ?  ;32-bit quantity with size of file described by entry
   127                              <1> endstruc
   128                              <1> ;Directory attribute equates
   129                              <1>     dirReadOnly     equ 01h
   130                              <1>     dirHidden       equ 02h
   131                              <1>     dirSystem       equ 04h
   132                              <1>     dirVolumeID     equ 08h
   133                              <1>     dirDirectory    equ 10h
   134                              <1>     dirArchive      equ 20h
   135                              <1>     dirCharDev      equ 40h ;Never written to disk, used to represent a Char Dev
   136                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
   137                              <1>     ;If any of the three bits are set, then ALL three bits are set
   138                              <1>     ; in addition to whatever the user passed to search for.
   139                              <1>     dirInclusive    equ dirHidden | dirSystem | dirDirectory
   140                              <1>     dirIncFiles     equ dirHidden | dirSystem
   141                              <1> 
   142                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
   143                              <1> 
   144                              <1>     ;.jmpBoot                db 3 dup (?)
   145                              <1>     ;.oemName                db 8 dup (?)  ;OEM name
   146                              <1> ;BPB starts here
   147 00000000 <res 35h>           <1>     .MustBeZero             db 53 dup (?) ;Must be 0, 53 bytes
   148 00000035 ????????????????    <1>     .partitionOffset        dq ?  ;in sectors, 0 means ignore this field
   149 0000003D ????????????????    <1>     .volumeLength           dq ?  ;Volume Length in sectors
   150 00000045 ????????            <1>     .FAToffset              dd ?  ;Volume rel offset of first FAT, in sectors
   151 00000049 ????????            <1>     .FATlength              dd ?  ;FAT length, in sectors
   152 0000004D ????????            <1>     .clusterHeapOffset      dd ?  ;Start of data area, in sectors
   153 00000051 ????????            <1>     .clusterCount           dd ?  ;Number of clusters on medium
   154 00000055 ????????            <1>     .firstClusterOfRootDir  dd ?  ;First Cluster of Root Directory, min 2
   155 00000059 ????????            <1>     .volumeSerialNum        dd ?  ;Volume Serial Number
   156 0000005D ????                <1>     .FSrevision             dw ?  ;Should be 0001 (v1.00)
   157 0000005F ????                <1>     .volumeFlags            dw ?  ;Volume Flags, refer to documentation
   158 00000061 ??                  <1>     .bytesPerSectorShift    db ?  ;min 9 (512 bps), max 12 (4096 bps)
   159 00000062 ??                  <1>     .sectorsPerClusterShift db ?  ;Result of log_2(N) for N=sec per clus
   160 00000063 ??                  <1>     .numberOfFATs           db ?  ;Number of FATs, only 1 or 2
   161 00000064 ??                  <1>     .driveSelect            db ?  ;Drive Select, 0 or 80h (Int 13h)
   162 00000065 ??                  <1>     .percentInUse           db ?  ;Rounded down. FFh means unknown
   163 00000066 ??????????????      <1>     .reserved               db 7 dup (?)  ;Reserved for alignment
   164                              <1> 
   165                              <1> endstruc
     7                                  %include "./inc/fcbStruc.inc"
     1                              <1> ;FCB related structures
     2                              <1> 
     3                              <1> ;Note: If record size > 64, high byte of randRecrd is ignored.
     4                              <1> ;This field also used for random read/write ops to find the right record
     5                              <1> struc fcb
     6 00000000 ??                  <1>     .driveNum   resb 1  ;0 based drive number
     7 00000001 ????????????????    <1>     .filename   resb 8
     8 00000009 ??????              <1>     .fileext    resb 3
     9 0000000C ????                <1>     .curBlock   resb 2  ;Current block number relative to 0
    10                              <1> ;One block consists of 128 records, of size denoted in the below
    11 0000000E ????                <1>     .recordSize resb 2  ;Record size, default 80h
    12 00000010 ????????            <1>     .fileSize   resb 4  ;File size, in bytes
    13 00000014 ????                <1>     .fileDate   resb 2  ;Standard date format
    14 00000016 ????                <1>     .fileTime   resb 2  ;Standard time format
    15                              <1>     ;----------------------------------------
    16                              <1>     ;Internal Records
    17 00000018 ??                  <1>     .sftNdx     resb 1  ;Internal, SFT ndx number
    18 00000019 ??                  <1>     .fcbMode    resb 1  ;Internal byte, to indicate format of special field
    19 0000001A ????????????        <1>     .special    resb 6  ;For use with below internal structures
    20                              <1>     ;----------------------------------------
    21 00000020 ??                  <1>     .recordNum  resb 1  ;Current record in block
    22 00000021 ????????            <1>     .randRecrd  resb 4  ;Relative record number, relative to start of file
    23                              <1> endstruc
    24                              <1> 
    25                              <1> struc exFcb
    26 00000000 ??                  <1>     .extSig     resb 1  ;If the first byte is -1, signals an exFCB
    27 00000001 ??????????          <1>     .reserved   resb 5  
    28 00000006 ??                  <1>     .attribute  resb 1  ;File attribute byte
    29 00000007 ??                  <1>     .driveNum   resb 1  ;0 based drive number
    30 00000008 ????????????????    <1>     .filename   resb 8
    31 00000010 ??????              <1>     .fileext    resb 3
    32 00000013 ????                <1>     .curBlock   resb 2  ;Current block number relative to 0
    33                              <1> ;One block consists of 128 records, of size denoted in the below
    34 00000015 ????                <1>     .recordSize resb 2  ;Record size, default 80h
    35 00000017 ????????            <1>     .fileSize   resb 4  ;File size, in bytes
    36 0000001B ????                <1>     .fileDate   resb 2  ;Standard date format
    37 0000001D ????                <1>     .fileTime   resb 2  ;Standard time format
    38                              <1>     ;----------------------------------------
    39                              <1>     ;Internal Records
    40 0000001F ??                  <1>     .sftNdx     resb 1  ;Internal, SFT ndx number
    41 00000020 ??                  <1>     .fcbMode    resb 1  ;Internal byte, to indicate format of special field
    42 00000021 ????????????        <1>     .special    resb 6  ;For use with below internal structures
    43                              <1>     ;----------------------------------------
    44 00000027 ??                  <1>     .recordNum  resb 1  ;Current record in block
    45 00000028 ????????            <1>     .randRecrd  resb 4  ;Relative record number, relative to start of file
    46                              <1> endstruc
    47                              <1> 
    48                              <1> struc renameFcb
    49                              <1> ;Used for accessing the names and drive letter for renaming
    50                              <1> ;The fcb ptr must be pointing to the drivenumber even if the passed fcb was ext
    51 00000000 ??                  <1>     .driveNum   resb 1
    52 00000001 ????????????????    <1>     .filename   resb 8
    53 00000009 ??????              <1>     .fileext    resb 3
    54 0000000C ????????            <1>     .reserved   resb 4  ;Alignment bytes, cleared by AH=29h
    55 00000010 ??                  <1>     .resDrvNum  resb 1  ;Always zero, used by AH=29h for the drive letter
    56 00000011 ????????????????    <1>     .newName    resb 8
    57 00000019 ??????              <1>     .newExt     resb 3
    58 0000001C ????????            <1>     .reserved2  resb 4  ;Alignement bytes, cleared by AH=29h
    59                              <1> endstruc
    60                              <1> 
    61                              <1> ;FCBmode equates:
    62                              <1> ;Bit 7 = Set => Share loaded, Clear => Share not loaded
    63                              <1> ;Bit 6 = Set => Char device, Clear => Disk file
    64                              <1> ;Bits [5,0] = Low 6 bits of device attribute word 
    65                              <1> fcbShareOn  equ 80h
    66                              <1> fcbCharDev  equ 40h
    67                              <1> fcbLocal    equ 40h
    68                              <1> 
    69                              <1> ;Structures of the special 6 bytes
    70                              <1> 
    71                              <1> ;Used when share is NOT loaded (fcbMode = 0xxxxxxxb)
    72                              <1> struc noShare   
    73 00000000 ??                  <1>     .attribWord resb 1  ;(lowbyte DevAttrWord && 0Ch) || open mode
    74 00000001 ????                <1>     .startClust resb 2  ;Starting cluster of file (too small for FAT32)
    75 00000003 ????                <1>     .dirSect    resb 2  ;Sector containing dir entry (too small for FAT32)
    76 00000005 ??                  <1>     .dirEntry   resb 1  ;Number of 32 byte directory entry IN sector
    77                              <1> endstruc
    78                              <1> 
    79                              <1> ;Used when the volume is local and share is loaded (fcbMode = 11xxxxxxb)
    80                              <1> struc shareLocal    
    81 00000000 ????                <1>     .strtClust  resb 2  ;Starting cluster on disk of file (too small for FAT32)
    82 00000002 ????                <1>     .shareSig   resb 2  ;Share record number for this file (to find record)
    83 00000004 ????                <1>     .fileAttr   resb 2  ;File attribute (accessed as a byte)
    84                              <1> endstruc
    85                              <1> 
    86                              <1> ;Used when the volume is remote and share is loaded (fcbMode = 10xxxxxxb)
    87                              <1> struc shareNet
    88                              <1> ;All three fields too small for FAT32
    89 00000000 ????                <1>     .dirSect    resb 2  ;Sector number containing dir entry
    90 00000002 ????                <1>     .relClust   resb 2  ;File relative cluster of last cluster accessed
    91 00000004 ????                <1>     .absClust   resb 2  ;Disk relative cluster of last cluster accessed
    92                              <1> endstruc
     8                                  %include "./inc/dosStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous internal     ;
     4                              <1> ; SCP/DOS structures.                                   ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> ;File/path length equates.
     8                              <1> MAX_FNAME_FCB   equ 8
     9                              <1> MAX_EXT_FCB     equ 3
    10                              <1> MAX_NAME_FCB    equ MAX_FNAME_FCB + MAX_EXT_FCB
    11                              <1> MAX_NAME_FCBZ   equ MAX_NAME_FCB + 1    ;Space for a null terminator
    12                              <1> ;Values below include the null terminator.
    13                              <1> MAX_FILE    equ 13  ;Maximum length of a filename (includes dot)
    14                              <1> MAX_DRIVE   equ 3   ;Maximum length of a drive string (X:<NUL>)
    15                              <1> MAX_FSPEC   equ 64  ;Maximum length of a path to a file (filespec)
    16                              <1> MAX_PATH    equ 67  ;Maximum length of a fully qualified pathspec
    17                              <1> ;MAX_PATH is X:\<string, maxlen 63 chars>,<null> so 67 chars total.
    18                              <1> ;Use this symbol to check the length of a filename after qualification.
    19                              <1> MAX_PSPEC   equ MAX_PATH - MAX_FILE - 1 ;54 bytes
    20                              <1> ;MAX_PSPEC is the max length of a path with space for a filename!
    21                              <1> ;Remember, filenames for us are just a string of, at most, 13 characters,
    22                              <1> ; which we always resolve into FCB format. Buffers need to make space for
    23                              <1> ; both the dot and terminating null
    24                              <1> ;------------------------------------------------------------------------;
    25                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    26                              <1> ; its file system structure. This is used to locate files and structures
    27                              <1> ; on the device itself and to translate file requests to cluster chains
    28                              <1> ; to LBAs to pass to the disk driver..
    29                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    30                              <1> ; drivers Initialise routine has been called.
    31                              <1> ;------------------------------------------------------------------------;
    32                              <1> struc dpb        ;Drive Parameter Block
    33                              <1> 
    34 00000000 ??                  <1>     .bDriveNumber           db ?  ;Drive number (0=A, 1=B ...)
    35 00000001 ??                  <1>     .bUnitNumber            db ?  ;Unit number in device
    36 00000002 ????                <1>     .wBytesPerSector        dw ?  ;min 512, max 4096
    37 00000004 ??                  <1>     .bMaxSectorInCluster    db ?  ;(Maximum sector in cluster) - 1
    38 00000005 ??                  <1>     .bSecPerClustShift      db ?  ;Sectors per cluster exponent
    39 00000006 ????                <1>     .wFAToffset             dw ?  ;Number of reserved sectors in partition
    40 00000008 ??                  <1>     .bNumberOfFATs          db ?  ;Number of FATs
    41 00000009 ????                <1>     .wNumberRootDirEntries  dw ?  ;In 32 byte units, this is 0 for FAT32
    42 0000000B ????????            <1>     .dClusterHeapOffset     dd ?  ;Start sector of data area
    43 0000000F ????????            <1>     .dMaxClusterAddr        dd ?  ;Max Cluster Addr = # of data clusters + 1
    44 00000013 ????????            <1>     .dFATlength             dd ?  ;FAT length, in sectors
    45 00000017 ????????            <1>     .dFirstUnitOfRootDir    dd ?  
    46                              <1>     ;Unit=Sector/Cluster of Root Directory (FAT12/16 = Sector, FAT32 = Cluster)
    47 0000001B ????????????????    <1>     .qDriverHeaderPtr       dq ?  ;Pointer to device driver header
    48 00000023 ??                  <1>     .bMediaDescriptor       db ?  ;Media descriptor
    49 00000024 ??                  <1>     .bAccessFlag            db ?  ;Access Flag (0 if accessed, else -1)
    50 00000025 ????????????????    <1>     .qNextDPBPtr            dq ?  ;Pointer to next DPB, -1 if at end
    51 0000002D ????????            <1>     .dNextFreeClst          dd ?  ;Starting cluster of free space search
    52 00000031 ????????            <1>     .dFreeClustCnt          dd ?  ;Number of free clusters, -1 unknown
    53                              <1> 
    54                              <1> endstruc
    55                              <1> 
    56                              <1> fat12MaxClustCnt    equ 4085    ;Cluster count less than this is FAT12
    57                              <1> fat16MaxClustCnt    equ 65525   ;Cluster count less than this is FAT16
    58                              <1> ;------------------------------------------------------------------------;
    59                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    60                              <1> ; All disk pathing requests go via the CDS for that drive.
    61                              <1> ; The default drive is the last accessed drive, this number is stored
    62                              <1> ; in the DOS data area.
    63                              <1> ; The CDS is stored as an array with the offset into the array being 
    64                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    65                              <1> ;
    66                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    67                              <1> ;------------------------------------------------------------------------;
    68                              <1> struc cds       ;Current Directory structure
    69 00000000 <res 43h>           <1>     .sCurrentPath        db MAX_PATH dup (?)    ;Current Directory Path String
    70 00000043 ????                <1>     .wFlags              dw ?   ;CDS Flags - 
    71 00000045 ????????????????    <1>     .qDPBPtr             dq ?   ;Ptr to the DPB of the dev using this CDS
    72 0000004D ????????            <1>     .dStartCluster       dd ?   ;Starting cluster of the directory on disk
    73 00000051 ????????????????    <1>     .qIFSPtr             dq ?   ;Reserved for IFS driver expansions
    74 00000059 ????????            <1>     .dNetStore           dd ?   ;For storing a owner dword for IFS (21h/5F03h)
    75 0000005D ????                <1>     .wBackslashOffset    dw ?   ;How many chars to skip for getting the path
    76                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    77                              <1> ; another, we save the number of chars to skip to that deep level).
    78                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    79                              <1> ; Only affects for SUBST drives, not JOIN
    80                              <1> ; Flags: Bit 15 set = Network drive
    81                              <1> ;        Bit 14 set = Physical drive
    82                              <1> ;        Bit 13 set = JOIN'ed drive
    83                              <1> ;        Bit 12 set = SUBST'ed drive
    84                              <1> ;        Bit 7  set = Redirected, not net. drive (This is how MSCDEX worked)
    85                              <1> endstruc
    86                              <1> ;CDS equates
    87                              <1> cdsRedirDrive   equ 8000h   ;All drives which use the Redirector interface
    88                              <1> cdsValidDrive   equ 4000h   ;CDS valid
    89                              <1> cdsJoinDrive    equ 2000h   ;CDS for joined drives
    90                              <1> cdsSubstDrive   equ 1000h   ;Drives formed by Subst
    91                              <1> cdsRdirLocDrive equ 0080h   ;Redirector but Local
    92                              <1> ;------------------------------------------------------------------------;
    93                              <1> ; The SFT is a way to allow applications to open file handles to files 
    94                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    95                              <1> ; under the first header, and then a second header will be linked to the 
    96                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    97                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    98                              <1> ; using the FCBS= command. Default FCBS=5.
    99                              <1> ;
   100                              <1> ; A file handle describes the file, and the location within the file that
   101                              <1> ; we are reading. The file handle can be manipulated without the file
   102                              <1> ; being in memory, thus allowing the user to access data without needing 
   103                              <1> ; to take up large portions of memory. Similarly, file handles allow for
   104                              <1> ; accessing devices, by treating them as files with their drivers 
   105                              <1> ; responding and translating the manipulations of the file handle itself.
   106                              <1> ; Neither the driver nor the application should see or use the SFT for
   107                              <1> ; the handle, as it is subject to change (and will change when file 
   108                              <1> ; sharing provisions are included). The DOS will make requests to the 
   109                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
   110                              <1> ; track of the information in the SFT entry for that handle. 
   111                              <1> ;
   112                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
   113                              <1> ; can point to the same file. It all depends on what the applications 
   114                              <1> ; want to do with the File.
   115                              <1> ;
   116                              <1> ; !!!!IMPORTANT!!!!
   117                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   118                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   119                              <1> ;
   120                              <1> ;Each SFT may look like this:
   121                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   122                              <1> ;            |                |
   123                              <1> ;       wNumFiles*sft    wNumFiles*sft
   124                              <1> ;
   125                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   126                              <1> ; System FCBs.
   127                              <1> ;
   128                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   129                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   130                              <1> ;
   131                              <1> ; DEFAULT FILES=8, MINIMUM FILES=5
   132                              <1> ; DEFAULT FCBS=5,  MINIMUM FCBS=5
   133                              <1> ;------------------------------------------------------------------------;
   134                              <1> struc sfth   ;System file table header
   135                              <1> ; This is the SFT header.
   136                              <1> ; This structure comes before the start of the first file in the array/table.
   137 00000000 ????????????????    <1>     .qNextSFTPtr dq ?    ;Pointer to the next SFT
   138 00000008 ????                <1>     .wNumFiles   dw ?    ;Number of files in this table
   139                              <1> endstruc
   140                              <1> 
   141                              <1> struc sft
   142                              <1> ;This is the file struc itself
   143 00000000 ????                <1>     .wNumHandles dw ?    ;Number of handles pointing to this file
   144 00000002 ????                <1>     .wOpenMode   dw ?    ;File access permissions and behaviours
   145 00000004 ??                  <1>     .bFileAttrib db ?    ;Regular File Attributes
   146 00000005 ????                <1>     .wDeviceInfo dw ?    ;Includes unit number if a block device
   147 00000007 ????????????????    <1>     .qPtr        dq ?    ;IF char, ptr to device driver header, ELSE DPBptr
   148 0000000F ????????            <1>     .dStartClust dd ?    ;Start cluster of file pointed to by SFT entry
   149                              <1> .dTimeDate:              ;Symbol to access time/date together
   150 00000013 ????                <1>     .wTime       dw ?    ;File Time, updated on open and writes
   151 00000015 ????                <1>     .wDate       dw ?    ;File Date, updated on open and writes
   152 00000017 ????????            <1>     .dFileSize   dd ?    ;File Size, in bytes
   153 0000001B ????????            <1>     .dCurntOff   dd ?    ;Current Offset pointed to by SFT entry, in bytes
   154 0000001F ????????            <1>     .dRelClust   dd ?    ;File relative cluster pointed to by SFT entry
   155 00000023 ????????            <1>     .dAbsClust   dd ?    ;Absolute disk cluster pointed to by SFT entry
   156 00000027 ????????????????    <1>     .qDirSect    dq ?    ;Abs number of sector containing directory entry 
   157 0000002F ??                  <1>     .bNumDirEnt  db ?    ;Directory entry within dir sector (byte offset/32)
   158 00000030 <res Bh>            <1>     .sFileName   db 11 dup (?)   ;8.3 Filename
   159                              <1> ;                       Share Vars
   160 0000003B ????????????????    <1>     .pNextSFT   dq ?    ;Ptr to the next SFT for this file in the chain
   161 00000043 ????????            <1>     .dMID       dd ?    ;Machine ID of the machine (VM) that opened this file
   162 00000047 ????????????????    <1>     .qPID       dq ?    ;Proc ID (PSP) of the program which opened this file
   163 0000004F ????????????????    <1>     .pMFT       dq ?    ;Pointer to the MFT for this file. 0 means no MFT
   164                              <1> endstruc
   165                              <1> ;Open Mode equates
   166                              <1> ;Access modes   Bits[2:0]
   167                              <1> openRdAcc   equ 0h
   168                              <1> openWrAcc   equ 1h
   169                              <1> openRWAcc   equ 2h
   170                              <1> ;Bit 3 reserved 0
   171                              <1> ;Sharing modes  Bits[6:4]
   172                              <1> openCompat      equ 0h  ;Deny all, compatibility mode
   173                              <1> openDenRWShr    equ 10h ;Deny all, explicity read/write
   174                              <1> openDenWrShr    equ 20h ;Deny writes
   175                              <1> openDenRdShr    equ 30h ;Deny reads
   176                              <1> openDenNoShr    equ 40h ;Don't deny anything!
   177                              <1> ;NetFCB is for files open by a local server, handling IO from a remote
   178                              <1> ; client by proxy opened by an FCB! Sets the Net bit to indicate this. 
   179                              <1> ;Thus, this is a handle with no JFT entry! Server handles its own JFT!
   180                              <1> openNetFCBShr   equ 70h
   181                              <1> openNoInherit   equ 80h
   182                              <1> 
   183                              <1> ;Bits 8-12 reserved 0
   184                              <1> ;The next two are extended open mode bits! 
   185                              <1> ;Can be set
   186                              <1> openFailOnI24   equ 2000h   ;If set, automatically FAIL all Int 24h
   187                              <1> openFlushWrites equ 4000h   ;If set, commit after each write call.
   188                              <1> ;SFT-FCBs mark that the SFT is indeed an FCB on the System FCB chain.
   189                              <1> ;These would only come into effect due to SHARE. We are yet to implement 
   190                              <1> ; them
   191                              <1> openSFTFCB      equ 8000h   ;If set, file is SFT-FCB.
   192                              <1> 
   193                              <1> ;Attribute Byte
   194                              <1> attrFileRO          equ 1h
   195                              <1> attrFileHidden      equ 2h
   196                              <1> attrFileSys         equ 4h
   197                              <1> attrFileVolLbl      equ 8h
   198                              <1> attrFileDir         equ 10h ;Directory entry
   199                              <1> attrFileArchive     equ 20h
   200                              <1> attrFileChar        equ 40h ;Reserved, never found in dir
   201                              <1> 
   202                              <1> ;Device Info word equates
   203                              <1> ;For a block device, bits [5:0] contain the drive number
   204                              <1> devCharConIn    equ 1h  ;If set, device is CON input
   205                              <1> devCharConOut   equ 2h  ;If set, device is CON output
   206                              <1> devCharNulDev   equ 4h  ;If set, device is NULL device
   207                              <1> devCharClkDev   equ 8h  ;If set, device is CLOCK device
   208                              <1> 
   209                              <1> devCharFastOut  equ 10h ;If set, device supports INT 29h
   210                              <1> devCharBinary   equ 20h ;If set, r/w char device in Binary mode
   211                              <1> devCharNotEOF   equ 40h ;If set, device not yet at end of file
   212                              <1> devDiskNoFlush  equ 40h ;Set if file is synchronised with hard store!
   213                              <1> devCharDev      equ 80h ;If set, it is a char device!
   214                              <1> 
   215                              <1> devDiskI24onFull    equ 100h    ;If set, Int 24h on disk full or disk EOF
   216                              <1> devCharNetSpool equ 800h    ;If set, device is a network spooler
   217                              <1> 
   218                              <1> devNoInherit    equ 1000h   ;If set, handle not inherited by child processes
   219                              <1> devCharNamePipe equ 2000h   ;If set, device is a named pipe
   220                              <1> devDiskNoDTonClose equ 4000h   ;If set, dont update date and time when closing
   221                              <1> devRedir        equ 8000h   ;If set, dev/file is redirected!
   222                              <1> 
   223                              <1> ;Extended open flags. For the var [wEOFlags]
   224                              <1> ;These are not related to the SFT but are used during an extended open
   225                              <1> ; call to keep track of whats going on and thus help build an SFT.
   226                              <1> eoInExtOpen     equ 0001h   ;Doing Extended Open
   227                              <1> eoFailI24       equ 0002h   ;If EO file hard fails, skip and fail Int 24h
   228                              <1> eoFileNoExist   equ 0004h   ;File doesnt exist
   229                              <1> 
   230                              <1> ;Can combine the third option with one of the first two options.
   231                              <1> ;The first two options cannot be combined.
   232                              <1> ; - If only create is selected, then we try to do a create new. If the 
   233                              <1> ;       file exists, this fails with a "File exists" error.
   234                              <1> ;       Acts like a normal create new call. (21/5Bh)
   235                              <1> ;
   236                              <1> ; - If only open is selected then we try to do an open. If the file doesn't
   237                              <1> ;       doesn't exist, this fails with a "File not found" error.
   238                              <1> ;       Acts like a normal open call. (21/3Dh)
   239                              <1> ;
   240                              <1> ; - If only truncate is selected then we try to do a create. If the file
   241                              <1> ;       doesn't exist, this fails a "File not found" error.
   242                              <1> ;       New behaviour.
   243                              <1> ;
   244                              <1> ; - If open and create are selected then we try and open the file. If 
   245                              <1> ;       the open fails due to the file not existing, we create a new file. 
   246                              <1> ;       New behaviour.
   247                              <1> ;
   248                              <1> ; - If truncate and create are selected then we try to truncate the file. 
   249                              <1> ;       If the file doesnt exist then we create a new file instead.
   250                              <1> ;       Acts like a normal create call. (21/3Ch)
   251                              <1> 
   252                              <1> eoActOpen       equ 01h ;Open the file. 
   253                              <1> eoActTruncate   equ 02h ;Truncate an existing file.
   254                              <1> eoActCreate     equ 10h ;Create a file if one doesnt exist.
   255                              <1> ;Extended Open Action Return 
   256                              <1> eoRetActOpen    equ 1   ;Open existing
   257                              <1> eoRetActCreate  equ 2   ;Create new and open
   258                              <1> eoRetActTruncate    equ 3    ;Recreate and open
   259                              <1> ;------------------------------------------------------------------------;
   260                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   261                              <1> ; to an internal buffer, and then copying it to the specified location
   262                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   263                              <1> ; another request for the same sector from the same device is made, so 
   264                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   265                              <1> ; size, selected according to the largest detected sector size during 
   266                              <1> ; the initial loadup.
   267                              <1> ;
   268                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   269                              <1> ;
   270                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   271                              <1> ;------------------------------------------------------------------------;
   272                              <1> 
   273                              <1> struc bufferHdr
   274 00000000 ????????????????    <1>     .nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
   275                              <1>     .wDrvNumFlg:         ;Read as a word to get the following two bytes!
   276 00000008 ??                  <1>     .driveNumber db  ?   ;Drive number the buffer is used for (or -1 for free)
   277 00000009 ??                  <1>     .bufferFlags db  ?   ;Standard Flags
   278 0000000A ????????????????    <1>     .bufferLBA   dq  ?   ;LBA the buffer contains
   279 00000012 ??                  <1>     .bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
   280 00000013 ????????            <1>     .bufFATsize  dd  ?   ;Number of sectors per FAT (or 0 if non-FAT)
   281 00000017 ????????????????    <1>     .driveDPBPtr dq  ?   ;Pointer to the device DPB block
   282 0000001F ??                  <1>     .reserved    db  ?   ;Alignment byte
   283                              <1>     .dataarea:             ;Points to the start of the data area
   284                              <1> endstruc
   285                              <1> ;Buffer Flag equates
   286                              <1> dosBuffer   equ 1h  ;Sector 0 (BPB/VPB) in buffer
   287                              <1> fatBuffer   equ 2h  ;FAT sector in buffer
   288                              <1> dirBuffer   equ 4h  ;Directory sector in buffer
   289                              <1> dataBuffer  equ 8h  ;File Data sector in buffer
   290                              <1> refBuffer   equ 20h ;Data in buffer has been referenced by an application
   291                              <1> dirtyBuffer equ 40h ;Data in buffer modified by an application
   292                              <1> freeBuffer  equ 00FFh   ;A word which goes into the drive number to clear both fields
   293                              <1> ;Note! A buffer is marked as referenced when the buffer is "obtained" by a syscall
   294                              <1> ;------------------------------------------------------------------------;
   295                              <1> ; Memory control block for each memory arena
   296                              <1> ;------------------------------------------------------------------------;
   297                              <1> struc mcb
   298 00000000 ??                  <1>     .marker     db ?  ;M = Member of the MCB chain. Z = Last member
   299 00000001 ????????????????    <1>     .owner      dq ?  ;Owning application PSP (para aligned) or 0 for free
   300 00000009 ????????            <1>     .blockSize  dd ?  ;Number of contiguous paragraphs owned by this block
   301                              <1>     ;The following byte is reserved outside of sysinit
   302 0000000D ??                  <1>     .subSysMark db ?  ;Marks the optional DOS subsystem of the MCB
   303 0000000E ????                <1>     .reserved   db 2 dup (?) 
   304                              <1>     .program:
   305                              <1> endstruc
   306                              <1> ;MCB equates
   307                              <1> mcbOwnerHole    equ 7   ;Owner = 7 => Memory hole, always fail free/realloc
   308                              <1> mcbOwnerFree    equ 0   ;Owner = 0 => Free and available space
   309                              <1> mcbOwnerDOS     equ 8   ;Owner = 8 => Owned by DOS
   310                              <1> mcbOwnerNewDOS  equ 9   ;Owner = 9 => New Kernel driver alloc. Needs setting to 8.
   311                              <1> mcbMarkCtn      equ "M"
   312                              <1> mcbMarkEnd      equ "Z"
   313                              <1> ;The following are used on MCB's that belong to DOS, that are not part of the
   314                              <1> ; main kernel (i.e. the CONFIG.SYS optional parts).
   315                              <1> mcbSubDriver    equ "D" ;Any memory allocated for a device driver's code.
   316                              <1> mcbSubDrvExtra  equ "L" ;Any memory allocated by a device driver.
   317                              <1> mcbSubDrvDPB    equ "P" ;Blocks used for DPB's are marked so.
   318                              <1> mcbSubIFS       equ "I" ;Unused for now
   319                              <1> mcbSubFiles     equ "F" ;Any memory allocated for Files.
   320                              <1> mcbSubFCBS      equ "X" ;Unused for now
   321                              <1> mcbSubBuffers   equ "B" ;Any memory allocated for Buffers.
   322                              <1> mcbSubCDS       equ "L" ;Any memory allocated to store a CDS.
   323                              <1> mcbSubStacks    equ "S" ;Unused for now
   324                              <1> 
   325                              <1> 
   326                              <1> memFirstFit     equ 0   ;First free block goes to application
   327                              <1> memBestFit      equ 1   ;Block whos size closest matches requirement
   328                              <1> memLastFit      equ 2   ;Last free block goes to application
   329                              <1> 
   330                              <1> ;Owner = Para aligned address => Owning application PSP
   331                              <1> ;...To consider...
   332                              <1> ;Owner = Non-para aligned address => Error? Should maybe lock up system?
   333                              <1> ;blockSize counts the number of paragraphs FROM .program TO THE NEXT MCB!
   334                              <1> ;------------------------------------------------------------------------;
   335                              <1> ; For Int 21h, the callers registers are saved on their stack in the 
   336                              <1> ; following order, thus allowing for return values to be placed in the 
   337                              <1> ; registers by accessing the caller register stack frame.
   338                              <1> ;------------------------------------------------------------------------;
   339                              <1> struc callerFrame
   340 00000000 ????????????????    <1>     .rax    dq ?  ;Bottom of frame, pointer to rax saved in oldRSP
   341 00000008 ????????????????    <1>     .rbx    dq ?    
   342 00000010 ????????????????    <1>     .rcx    dq ?
   343 00000018 ????????????????    <1>     .rdx    dq ?
   344 00000020 ????????????????    <1>     .rsi    dq ?
   345 00000028 ????????????????    <1>     .rdi    dq ?
   346 00000030 ????????????????    <1>     .rbp    dq ?
   347 00000038 ????????????????    <1>     .r8     dq ?  ;To be removed if truly not needed
   348 00000040 ????????????????    <1>     .r9     dq ?
   349                              <1> ;Pushed by Processor when invoked via Interrupt
   350 00000048 ????????????????    <1>     .rip    dq ?
   351 00000050 ????????????????    <1>     .cs     dq ?
   352 00000058 ????????????????    <1>     .flags  dq ?
   353                              <1> endstruc
   354                              <1> 
   355                              <1> struc dpl
   356                              <1> ;DOS parameter list, pointer to this stack is passed to DOS in rdx on
   357                              <1> ; server calls
   358 00000000 ????????????????    <1>     .rax    dq ?
   359 00000008 ????????????????    <1>     .rbx    dq ?
   360 00000010 ????????????????    <1>     .rcx    dq ?
   361 00000018 ????????????????    <1>     .rdx    dq ?
   362 00000020 ????????????????    <1>     .rsi    dq ?
   363 00000028 ????????????????    <1>     .rdi    dq ?
   364 00000030 ????????????????    <1>     .r8     dq ?
   365 00000038 ????????????????    <1>     .r9     dq ?
   366 00000040 ????????????????    <1>     .align  dq ?
   367 00000048 ????????????????    <1>     .dMID   dq ?  ;Machine id, low dword used only
   368 00000050 ????????????????    <1>     .qPID   dq ?  ;Process ID
   369                              <1> endstruc
   370                              <1> 
   371                              <1> struc cfgFrame  ;Frame used for config.sys parsing
   372 00000000 ????????????????    <1>     .oldRBP         dq ?    ;Ptr to DOSSEG
   373 00000008 ????????????????    <1>     .newBuffers     dq ?    ;New buffers value
   374 00000010 ????????????????    <1>     .newSFTVal      dq ?
   375 00000018 ????????????????    <1>     .newFCBSVal     dq ?
   376 00000020 ????????????????    <1>     .newProtFCBSVal dq ?    ;Number of protected FCBS
   377 00000028 ????????????????    <1>     .newLastdrive   dq ?
   378 00000030 ????????????????    <1>     .newStacks      dq ?    ;Ignored for now
   379 00000038 ????????????????    <1>     .newStackSize   dq ?    ;Ignored for now
   380 00000040 ????????????????    <1>     .cfgHandle      dq ?    ;CONFIG.SYS handle
   381 00000048 ????????????????    <1>     .lastLine       dq ?    ;Set if the last line is current
   382 00000050 ????????????????    <1>     .linePtr        dq ?    ;Ptr to line buffer of line being processed
   383 00000058 ????????????????    <1>     .driverBreak    dq ?    ;Ptr to the pathname terminator 
   384 00000060 ????????????????    <1>     .breakChar      dq ?    ;Char that was replaced by null for terminator
   385                              <1> endstruc
   386                              <1> 
   387                              <1> struc filename
   388                              <1> ;8.3 File name struct
   389 00000000 ????????????????    <1>     .fName  db 8 dup (?)
   390 00000008 ??????              <1>     .fExt   db 3 dup (?)
   391                              <1> endstruc
   392                              <1> 
   393                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
   394 00000000 ??                  <1>     .driveNum   db ?  ;Drive we are searching on, 1 based number
   395 00000001 <res Bh>            <1>     .template   db 11 dup (?) ;Search template (? meaning anything)
   396 0000000C ??                  <1>     .attrib     db ?  ;Search attribute
   397 0000000D ????????            <1>     .dirOffset  dd ?  ;32 byte entry within dir cluster
   398 00000011 ????????            <1>     .parDirClus dd ?  ;Parent Directory Cluster number
   399 00000015 ??                  <1>     .attribFnd  db ?  ;Attrib of file found
   400 00000016 ????                <1>     .fileTime   dw ?  ;File time
   401 00000018 ????                <1>     .fileDate   dw ?  ;File date
   402 0000001A ????????            <1>     .fileSize   dd ?  ;Number of bytes
   403 0000001E <res Dh>            <1>     .asciizName db 13 dup (?) ;ASCIIZ name with dot and terminating nul
   404                              <1> endstruc
   405                              <1> 
   406                              <1> dfltJFTsize equ 20  ;Default size of PSP JFT
   407                              <1> struc psp
   408 00000000 ????                <1>     .return     db 2 dup (?)  ;Should always be CDh 20h, same place as DOS
   409 00000002 ????????            <1>     .allocSize  dd ?  ;Number of paras in init alloc or when exiting as TSR.
   410 00000006 ????????            <1>                 dd ?  ;Reserved 4 bytes
   411 0000000A ????????????????    <1>     .oldInt22h  dq ?  ;Int 22h pointer on overlay load
   412 00000012 ????????????????    <1>     .oldInt23h  dq ?  ;Int 23h pointer on overlay load
   413 0000001A ????????????????    <1>     .oldInt24h  dq ?  ;Int 24h pointer on overlay load
   414 00000022 ????????????????    <1>     .parentPtr  dq ?  ;Pointer to parent process PSP
   415                              <1> ;If jftSize > 20, then the QWORD at .jobFileTbl becomes a pointer
   416                              <1> ; to the actual in use JFT and the other 12 bytes are left undefined.
   417                              <1> ;If jftSize < 20 (DOS will never set it so), then it is considered as 20
   418                              <1> ;If the user tries to reduce handle count to 20 or less, then the PSP JFT is 
   419                              <1> ; always used and jftSize.
   420                              <1>     .externalJFTPtr:    ;Ptr to external JFT array (first byte AFTER MCB)
   421 0000002A <res 14h>           <1>     .jobFileTbl db dfltJFTsize dup (?) ;Main File handle array, JFT
   422 0000003E ????????????????    <1>     .envPtr     dq ?  ;Pointer to the environment
   423 00000046 ????????????????    <1>     .rspPtr     dq ?  ;Pointer to rsp on entry to Int 21h
   424 0000004E ????                <1>     .jftSize    dw ?  ;JFT array size, 20 => PSP JFT in use
   425 00000050 ??????              <1>     .unixEntry  db 3 dup (?)  ;Must always be CDh 21h CBh, same place as DOS
   426 00000053 ????????????????    <1>     .prevPSP    dq ?  ;Pointer to the previous PSP in chain (used by SHARE)
   427 0000005B ??                  <1>                 db ?  ;Reserved byte
   428                              <1> ;The below are in the same place as in DOS.
   429                              <1>     .cmdLineArgPtr: ;Symbol for future use
   430 0000005C <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1 
   431 0000006C <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
   432                              <1>     .dta:   ;Pointer to the default DTA in the PSP
   433 00000080 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
   434 00000081 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
   435                              <1> endstruc
   436                              <1> 
   437                              <1> struc clkStruc
   438 00000000 ????                <1>     .dateWord   dw ?
   439 00000002 ??                  <1>     .minutes    db ?
   440 00000003 ??                  <1>     .hours      db ?
   441 00000004 ??                  <1>     .hseconds   db ?  ;Hundreths of seconds
   442 00000005 ??                  <1>     .seconds    db ?
   443                              <1> endstruc
   444                              <1> 
   445                              <1> 
   446                              <1> struc extCtryStruc
   447 00000000 ??                  <1>     .infoIDCode db ?    ;Information ID code (01h)
   448 00000001 ????                <1>     .strucSize  dw ?    ;Length of the structure  (42 or less)
   449 00000003 ????                <1>     .ctryID     dw ?    ;Country ID number
   450 00000005 ????                <1>     .cpNumber   dw ?    ;Code page number
   451 00000007 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   452                              <1>                         ;0 = month day year hh:mm:ss
   453                              <1>                         ;1 = day month year hh:mm:ss
   454                              <1>                         ;2 = year month day hh:mm:ss
   455 00000009 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   456 0000000E ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   457 00000010 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   458 00000012 ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   459 00000014 ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   460 00000016 ??                  <1>     .currFmt    db ?    ;Currency Format
   461                              <1>                         ;0 = Symbol leads, without space
   462                              <1>                         ;1 = Symbol follows, without space
   463                              <1>                         ;2 = Symbol leads, one space
   464                              <1>                         ;3 = Symbol follows, one space
   465                              <1>                         ;4 = Symbol replace decimal separator
   466 00000017 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   467 00000018 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   468 00000019 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   469 00000021 ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   470 00000023 <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   471                              <1> endstruc
   472                              <1> 
   473                              <1> struc countryStruc
   474 00000000 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   475                              <1>                         ;0 = month day year hh:mm:ss
   476                              <1>                         ;1 = day month year hh:mm:ss
   477                              <1>                         ;2 = year month day hh:mm:ss
   478 00000002 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   479 00000007 ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   480 00000009 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   481 0000000B ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   482 0000000D ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   483 0000000F ??                  <1>     .currFmt    db ?    ;Currency Format
   484                              <1>                         ;0 = Symbol leads, without space
   485                              <1>                         ;1 = Symbol follows, without space
   486                              <1>                         ;2 = Symbol leads, one space
   487                              <1>                         ;3 = Symbol follows, one space
   488                              <1>                         ;4 = Symbol replace decimal separator
   489 00000010 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   490 00000011 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   491 00000012 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   492 0000001A ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   493 0000001C <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   494                              <1> endstruc
   495                              <1> 
   496                              <1> ;Critical Error AH bitfield equates
   497                              <1> critRead    equ 0h
   498                              <1> critWrite   equ 1h
   499                              <1> critDOS     equ 0h
   500                              <1> critFAT     equ 2h
   501                              <1> critDir     equ 4h
   502                              <1> critData    equ 6h
   503                              <1> critFailOK  equ 8h
   504                              <1> critRetryOK equ 10h
   505                              <1> critIgnorOK equ 20h
   506                              <1> critCharDev equ 80h
   507                              <1> 
   508                              <1> critIgnore  equ 0
   509                              <1> critRetry   equ 1
   510                              <1> critAbort   equ 2
   511                              <1> critFail    equ 3
   512                              <1> 
   513                              <1> ;MISC ASCII control chars
   514                              <1> NUL equ 00h ;^@         | ASCII Null
   515                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text) 
   516                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
   517                              <1> BEL equ 07h ;^G         | ASCII Bell
   518                              <1> BSP equ 08h ;^H         | ASCII Backspace
   519                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
   520                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
   521                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
   522                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
   523                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
   524                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
   525                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
   526                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
   527                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
   528                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
   529                              <1> SPC equ 20h ;Printable  | ASCII Space
   530                              <1> ;This last one is NEVER printed with a caret as it is a console control char
   531                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
   532                              <1> 
   533                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
   534                              <1> ;Extended Ascii Codes
   535                              <1> eF1     equ 3Bh ;F1 second byte
   536                              <1> eF2     equ 3Ch ;F2 second byte
   537                              <1> eF3     equ 3Dh ;F3 second byte
   538                              <1> eF4     equ 3Eh ;F4 second byte
   539                              <1> eF5     equ 3Fh ;F5 second byte
   540                              <1> eF6     equ 40h ;F6 second byte
   541                              <1> eF7     equ 41h ;F7 second byte
   542                              <1> eCursL  equ 4Bh ;Cursor Left second byte
   543                              <1> eCursR  equ 4Dh ;Cursor Right second byte
   544                              <1> eIns    equ 52h ;Insert second byte
   545                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
   546                              <1> 
   547                              <1> ;Default Configuration for the system
   548                              <1> 
   549                              <1> buffersDefault  equ 30
   550                              <1> filesDefault    equ 20
   551                              <1> fcbsDefault     equ 4
   552                              <1> safeFcbsDeflt   equ 0
   553                              <1> lastDriveDeflt  equ 5   
   554                              <1> 
   555                              <1> ;ASCII char property table equates. If such a bit is clear in signature in table
   556                              <1> ; then the char has this property.
   557                              <1> badChar     equ 1   ;Bad ASCIIZ filename char
   558                              <1> termChar    equ 2   ;Terminator char type
   559                              <1> sepChar     equ 4   ;Separator char type
   560                              <1> badFCBChar  equ 8   ;FCB filename char
   561                              <1> 
   562                              <1> ;Nice STDIO equates
   563                              <1> STDIN   equ 0
   564                              <1> STDOUT  equ 1
   565                              <1> STDERR  equ 2
   566                              <1> STDAUX  equ 3
   567                              <1> STDPRN  equ 4
     9                                  %include "./inc/dosError.inc"
     1                              <1> ;DOS Error codes
     2                              <1> 
     3                              <1> ;Extended Error Codes
     4                              <1> errInvFnc   equ 1   ;Invalid function number
     5                              <1> errFnf      equ 2   ;File not found
     6                              <1> errPnf      equ 3   ;Path not found
     7                              <1> errNhl      equ 4   ;Too many open handles, no handles left
     8                              <1> errAccDen   equ 5   ;Access denied (to resource)
     9                              <1> errBadHdl   equ 6   ;Invalid handle
    10                              <1> errMCBbad   equ 7   ;MCB's destroyed
    11                              <1> errNoMem    equ 8   ;Insufficient memory
    12                              <1> errMemAddr  equ 9   ;Invalid Memory Block Address
    13                              <1> errBadEnv   equ 10  ;Invalid environment
    14                              <1> errBadFmt   equ 11  ;Invalid format (path etc)
    15                              <1> errAccCde   equ 12  ;Invalid Access Code    ?
    16                              <1> errInvDat   equ 13  ;Invalid data
    17                              <1> ;           equ 14  ;Reserved
    18                              <1> errBadDrv   equ 15  ;Invalid drive specified
    19                              <1> errDelCD    equ 16  ;Attempt to delete the current directory
    20                              <1> errDevUnk   equ 17  ;Not the same device (Device Unknown)
    21                              <1> errNoFil    equ 18  ;No more files, no match found
    22                              <1> ;The following are Driver error codes + 19
    23                              <1> drvErrShft  equ 19  ;Used to shift Driver error codes to extended error codes
    24                              <1> errWpd      equ 19  ;Attempt to write on write protected disk
    25                              <1> errUnkUnt   equ 20  ;Unknown Unit
    26                              <1> errDrvNR    equ 21  ;Drive not ready
    27                              <1> errUnkCmd   equ 22  ;Unknown Command
    28                              <1> errCRCerr   equ 23  ;Data (CRC) error
    29                              <1> errBadRLn   equ 24  ;Bad request structure length
    30                              <1> errSekErr   equ 25  ;Seek error
    31                              <1> errUnkMed   equ 26  ;Unknown media type
    32                              <1> errSecNF    equ 27  ;Sector not Found
    33                              <1> errNoPap    equ 28  ;Printer out of paper
    34                              <1> errWF       equ 29  ;Write fault
    35                              <1> errRF       equ 30  ;Read fault
    36                              <1> errGF       equ 31  ;General fault
    37                              <1> ;----------------------------------------------
    38                              <1> ;The following two go inbetween the Disk errors
    39                              <1> errShrVio   equ 32  ;Sharing violations
    40                              <1> errLokVio   equ 33  ;File Lock violation
    41                              <1> ;----------------------------------------------
    42                              <1> errIDC      equ 34  ;Driver code, Invalid Disk Change, settable by share
    43                              <1> errNoFCB    equ 35  ;FCB unavailable
    44                              <1> errShrFul   equ 36  ;Sharing buffer full
    45                              <1> ;The next two errors occur because an redir handle has the bit set to do this.
    46                              <1> ;We do not move the SFT in either case so that one can safely examine the
    47                              <1> ; state of the system before the call was made. In the second case,
    48                              <1> ; the user should do a 0 byte write at filesize before anything else to truncate
    49                              <1> ; any pre-allocated clusters.
    50                              <1> errHdlEOF   equ 38  ;Handle will EOF if read proceeds or at EOF. 
    51                              <1> errDskFul   equ 39  ;Disk will fill up if write proceeds or full. 
    52                              <1> 
    53                              <1> errNoNet    equ 50  ;Network request not supported, generic net fail
    54                              <1> errNLSAcDen equ 65  ;Network Access denied (NLS usage)
    55                              <1> 
    56                              <1> errFilExist equ 80  ;File already exists
    57                              <1> errDirExist equ 82  ;Directory already exists
    58                              <1> errFI24     equ 83  ;Fail on Int 24h
    59                              <1> errRedir    equ 84  ;Too many levels of redirection
    60                              <1> errDupRedir equ 85  ;Trying to redirect a redirection
    61                              <1> errBadPass  equ 86  ;Bad password
    62                              <1> errBadParam equ 87  ;Bad parameter passed to request
    63                              <1> errNetWrite equ 88  ;Network Write Fault
    64                              <1> ;-----------------------------------------------------------------------------
    65                              <1> ;Error Loci
    66                              <1> eLocUnk     equ 1   ;Unknown locus, nonspecific or not appropriate
    67                              <1> eLocDsk     equ 2   ;Disk, related to Random Access to a disk or block device
    68                              <1> eLocNet     equ 3   ;Network related issues
    69                              <1> eLocChr     equ 4   ;Serial/Character Device error
    70                              <1> eLocMem     equ 5   ;Related to RAM
    71                              <1> ;-----------------------------------------------------------------------------
    72                              <1> ;Error Actions
    73                              <1> eActRet     equ 1   ;Retry
    74                              <1> eActDRet    equ 2   ;Delay then retry (Try again later)
    75                              <1> eActUsr     equ 3   ;Ask user to re-input data, i.e. bad filename or something
    76                              <1> eActAbt     equ 4   ;Abort with cleanup
    77                              <1> eActKil     equ 5   ;Abort without cleanup
    78                              <1> eActIgn     equ 6   ;Ignore error
    79                              <1> eActRetUsr  equ 7   ;Retry after user intervention (i.e swap remdev)
    80                              <1> ;-----------------------------------------------------------------------------
    81                              <1> ;Error Classes
    82                              <1> eClsOoR     equ 1   ;Out of resources, no mem or handles
    83                              <1> eClsTS      equ 2   ;Temp sitch, should go away
    84                              <1> eClsAuth    equ 3   ;Authorisation, e.g. file permission error 
    85                              <1> eClsInt     equ 4   ;Internal DOS error or bug
    86                              <1> eClsHrdFlt  equ 5   ;Hardware Failure
    87                              <1> eClsSysFlt  equ 6   ;System Failure, i.e. missing or bad cfg files
    88                              <1> eClsAppFlt  equ 7   ;Application Program error, inconsistent requests etc...
    89                              <1> eClsNotFnd  equ 8   ;Resource not found (such as free SFT entry etc...)
    90                              <1> eClsBadFmt  equ 9   ;Bad format for resource
    91                              <1> eClsLocked  equ 10  ;Resource Locked
    92                              <1> eClsMedia   equ 11  ;Error is on medium, i.e. wrong or damaged remdev
    93                              <1> eClsClash   equ 12  ;Resource already exists!
    94                              <1> eClsUnk     equ 13  ;Unknown class
    10                                  %include "./inc/dosExec.inc"
     1                              <1> ;This include file contains structures related to the EXE format
     2                              <1> ; and the exec frame used when setting up the EXE in memory by 21h/4Bh
     3                              <1> 
     4                              <1> ;Int 21h/4Bh stack frame, used to store values whilst processing a EXE or COM
     5                              <1> ; file.
     6                              <1> execLoadGo  equ 0
     7                              <1> execLoad    equ 1
     8                              <1> execInvld   equ 2
     9                              <1> execOverlay equ 3
    10                              <1> execBkgrnd  equ 4
    11                              <1> 
    12                              <1> struc execFrame
    13 00000000 ????????????????    <1>     .oldRBP     resq 1  
    14 00000008 ????????????????    <1>     .bSubFunc   resq 1  ;Subfunction number
    15 00000010 ????????????????    <1>     .wProgHdl   resq 1  ;File handle number for executable file
    16 00000018 ????????????????    <1>     .wNameLen   resq 1  ;Needs to be less than 64 but welp
    17 00000020 ????????????????    <1>     .pParam     resq 1  ;Parameter list pointer
    18 00000028 ????????????????    <1>     .pProgname  resq 1  ;Ptr to ASCIIZ program name
    19                              <1> 
    20 00000030 ????????????????    <1>     .pEnvBase   resq 1  ;Ptr to new Environment block, NOT THE MCB FOR ENV BLK
    21 00000038 ????????????????    <1>     .pPSPBase   resq 1  ;Ptr to new PSP base address
    22 00000040 ????????????????    <1>     .pProgBase  resq 1  ;Ptr to Prog. Base addr., ALIGNED FOR FIRST EXE SECTION
    23 00000048 ????????????????    <1>     .dProgSize  resq 1  ;Program size is saved here, PSP included.
    24 00000050 ????????????????    <1>     .dCOFFhdr   resq 1  ;Offset in file to COFF header. Set to 0 for COM
    25 00000058 ????????????????    <1>     .bSegCount  resq 1  ;Count of segments loaded into memory
    26 00000060 ????????????????    <1>     .wCOFFChars resq 1  ;Save the COFF characteristics in here
    27                              <1> .pProgEP:   ;Program EP, recycle this qword
    28 00000068 ????????????????    <1>     .wNumSeg    resq 1  ;Number of segments, consider reusing NameLen
    29 00000070 ????????????????    <1>     .dFilePtr   resq 1  ;Keep of track of where in file we are
    30 00000078 ????????????????    <1>     .qRelocVal  resq 1  ;Used when computing relocations, Rebasing factor
    31                              <1> endstruc
    32                              <1> 
    33                              <1> ;Possible blocks to be pointed to by rbx
    34                              <1> 
    35                              <1> struc execProg 
    36 00000000 ????????????????    <1>     .pEnv       resq 1  ;Ptr to environment block (or 0 => copy parent env)
    37 00000008 ????????????????    <1>     .pCmdLine   resq 1  ;Ptr to the command line to be placed at PSP + 80h
    38 00000010 ????????????????    <1>     .pfcb1      resq 1  ;Ptr to the first FCB (parsed argument 1)
    39 00000018 ????????????????    <1>     .pfcb2      resq 1  ;Ptr to the second FCB  (parsed argument 2)
    40                              <1> endstruc
    41                              <1> 
    42                              <1> struc loadProg
    43 00000000 ????????????????    <1>     .pEnv       resq 1  ;Ptr to environment block (or 0 => copy parent env)
    44 00000008 ????????????????    <1>     .pCmdLine   resq 1  ;Ptr to the command line to be placed at PSP + 80h
    45 00000010 ????????????????    <1>     .pfcb1      resq 1  ;Ptr to the first FCB (parsed argument 1)
    46 00000018 ????????????????    <1>     .pfcb2      resq 1  ;Ptr to the second FCB  (parsed argument 2)
    47 00000020 ????????????????    <1>     .initRSP    resq 1  ;Return the start value for rsp
    48 00000028 ????????????????    <1>     .initRIP    resq 1  ;Return the entry point for the task
    49                              <1> endstruc
    50                              <1> 
    51                              <1> struc loadOvly
    52 00000000 ????????????????    <1>     .pLoadLoc   resq 1  ;Address in memory to load the overlay
    53 00000008 ????????????????    <1>     .qRelocFct  resq 1  ;Relocation address for relocatable items (0 for COM files)
    54                              <1> endstruc
    55                              <1> 
    56                              <1> ;----------------------------
    57                              <1> ;   EXE header structures   :
    58                              <1> ;----------------------------
    59                              <1> 
    60                              <1> ;DOS MZ .EXE header. Functionally useless except for e_magic and e_lfanew
    61                              <1> dosMagicSignature   equ "MZ"
    62                              <1> dosMagicSignature2  equ "ZM"
    63                              <1> struc imageDosHdr
    64 00000000 ????                <1>     .e_magic    resw 1  ;      // Magic number
    65 00000002 ????                <1>     .e_cblp     resw 1  ;      // Bytes on last page of file
    66 00000004 ????                <1>     .e_cp       resw 1  ;      // Pages in file
    67 00000006 ????                <1>     .e_crlc     resw 1  ;      // Relocations
    68 00000008 ????                <1>     .e_cparhdr  resw 1  ;      // Size of header in paragraphs
    69 0000000A ????                <1>     .e_minalloc resw 1  ;      // Minimum extra paragraphs needed
    70 0000000C ????                <1>     .e_maxalloc resw 1  ;      // Maximum extra paragraphs needed
    71 0000000E ????                <1>     .e_ss       resw 1  ;      // Initial (relative) SS value
    72 00000010 ????                <1>     .e_sp       resw 1  ;      // Initial SP value
    73 00000012 ????                <1>     .e_csum     resw 1  ;      // Checksum
    74 00000014 ????                <1>     .e_ip       resw 1  ;      // Initial IP value
    75 00000016 ????                <1>     .e_cs       resw 1  ;      // Initial (relative) CS value
    76 00000018 ????                <1>     .e_lfarlc   resw 1  ;      // File address of relocation table
    77 0000001A ????                <1>     .e_ovno     resw 1  ;      // Overlay number
    78 0000001C ????????????????    <1>     .e_res      resw 4  ;      // Reserved words
    79 00000024 ????                <1>     .e_oemid    resw 1  ;      // OEM identifier (for e_oeminfo)
    80 00000026 ????                <1>     .e_oeminfo  resw 1  ;      // OEM information; e_oemid specific
    81 00000028 <res 14h>           <1>     .e_res2     resw 10 ;      // Reserved words
    82 0000003C ????????            <1>     .e_lfanew   resd 1  ;      // File address of new exe header
    83                              <1> endstruc
    84                              <1> 
    85                              <1> ;Pssobile signatures pointed to by e_lfanew
    86                              <1> imageDosSignature   equ 05A4Dh      ; MZ, REJECT
    87                              <1> imageOS2Signature   equ 0454Eh      ; NE, REJECT
    88                              <1> imageOS2SignatureLE equ 0454Ch      ; LE, REJECT
    89                              <1> imagePESignature    equ 00004550h   ; PE00, ACCEPT
    90                              <1> 
    91                              <1> ;COFF File header @ [e_lfanew]
    92                              <1> 
    93                              <1> struc imageFileHeader
    94 00000000 ????????            <1>     .dPESignature        resd 1  ;PESignature, must be PE00
    95 00000004 ????                <1>     .wMachineType        resw 1  ;Machine Type, must be imageFileMachineAMD64
    96 00000006 ????                <1>     .wNumberOfSections   resw 1  ;Number of sections in file
    97 00000008 ????????            <1>     .dTimeDateStamp      resd 1  ;Unix datestamp
    98 0000000C ????????            <1>     .dPtrToSymbolTbl     resd 1  ;Pointer to the symbol table,      NOT USED
    99 00000010 ????????            <1>     .dNumberOfSymbols    resd 1  ;Number of symbols in the table,   NOT USED
   100 00000014 ????                <1>     .wSizeOfOptionalHdr  resw 1  ;Size of the optional header
   101 00000016 ????                <1>     .wCharacteristics    resw 1  ;Bitfield characteristics
   102                              <1> endstruc
   103                              <1> 
   104                              <1> ;The only valid values in the .machineType field
   105                              <1> 
   106                              <1> imageFileMachineUnknown equ 0
   107                              <1> imageFileMachineAMD64   equ 08664h 
   108                              <1> 
   109                              <1> ;Characteristics to check for
   110                              <1> imageFileRelocsStripped equ 0001h   ;If set, base addr MUST equal load addr
   111                              <1> imageFileExecutable     equ 0002h   ;Must always be set else badfmterr
   112                              <1> 
   113                              <1> ;Optional header, immediately follows COFF header
   114                              <1> 
   115                              <1> struc imageFileOptionalHeader
   116 00000000 ????                <1> 	.wMagic                     resw 1 ;0x010b - PE32, 0x020b - PE32+ (64 bit)
   117 00000002 ??                  <1> 	.bMajorLinkerVersion        resb 1
   118 00000003 ??                  <1> 	.bMinorLinkerVersion        resb 1
   119 00000004 ????????            <1> 	.dSizeOfCode                resd 1
   120 00000008 ????????            <1> 	.dSizeOfInitializedData     resd 1
   121 0000000C ????????            <1> 	.dSizeOfUninitializedData   resd 1
   122 00000010 ????????            <1> 	.dAddressOfEntryPoint       resd 1  ;RVA of the EP for program
   123 00000014 ????????            <1> 	.dBaseOfCode                resd 1
   124 00000018 ????????????????    <1>     .qImageBase                 resq 1  ;Preferred load address  
   125 00000020 ????????            <1> 	.dSectionAlignment          resd 1
   126 00000024 ????????            <1> 	.dFileAlignment             resd 1
   127 00000028 ????                <1> 	.wMajOSVer                  resw 1
   128 0000002A ????                <1> 	.wMinOSVer                  resw 1
   129 0000002C ????                <1> 	.wMajorImageVersion         resw 1
   130 0000002E ????                <1> 	.wMinorImageVersion         resw 1
   131 00000030 ????                <1> 	.wMajorSubsystemVersion     resw 1
   132 00000032 ????                <1> 	.wMinorSubsystemVersion     resw 1
   133 00000034 ????????            <1> 	.dWin32VersionValue         resd 1
   134 00000038 ????????            <1> 	.dSizeOfImage               resd 1  ;Size of ctg mem to hold program
   135 0000003C ????????            <1> 	.dSizeOfHeaders             resd 1
   136 00000040 ????????            <1> 	.dCheckSum                  resd 1
   137 00000044 ????                <1> 	.wSubsystem                 resw 1
   138 00000046 ????                <1> 	.wDllCharacteristics        resw 1
   139 00000048 ????????????????    <1> 	.qSizeOfStackReserve        resq 1
   140 00000050 ????????????????    <1> 	.qSizeOfStackCommit         resq 1  ;Default stack allocation is 256Kb
   141 00000058 ????????????????    <1> 	.qSizeOfHeapReserve         resq 1
   142 00000060 ????????????????    <1> 	.qSizeOfHeapCommit          resq 1
   143 00000068 ????????            <1> 	.dLoaderFlags               resd 1
   144 0000006C ????????            <1> 	.dNumberOfRvaAndSizes       resd 1  ;Number of data dirs entries in header
   145                              <1> endstruc
   146                              <1> 
   147                              <1> romMagicNum     equ 0107h
   148                              <1> pe32MagicNum    equ 010Bh
   149                              <1> pe64MagicNum    equ 020Bh
   150                              <1> 
   151                              <1> ;Data directory header structure
   152                              <1> 
   153                              <1> struc imageDataDirectory
   154 00000000 ????????            <1>     .virtualAddress  resd 1
   155 00000004 ????????            <1>     .size    resd 1
   156                              <1> endstruc
   157                              <1> 
   158                              <1> struc baseRelocBlock
   159 00000000 ????????            <1>     .pageRVA    resd 1  ;Offset from the load address
   160 00000004 ????????            <1>     .size       resd 1  ;Number of bytes in this block
   161                              <1>     ;Each entry is a word. High 4 bits are type of reloc (all must be 0Ah)
   162                              <1> endstruc
   163                              <1> ;Section headers that form the Section Table.
   164                              <1> ;There are wNumberOfSections many entries in this table.
   165                              <1> ;Each entry is one imageSectionHdr
   166                              <1> 
   167                              <1> struc imageSectionHdr       ;size 40 bytes
   168 00000000 ????????????????    <1>     .qName                  resb 8
   169 00000008 ????????            <1> 	.dVirtualSize           resd 1  ;If this is bigger than RawData, 0 pad
   170 0000000C ????????            <1> 	.dVirtualAddress        resd 1  ;Offset from ImageBase
   171 00000010 ????????            <1> 	.dSizeOfRawData         resd 1
   172 00000014 ????????            <1> 	.dPointerToRawData      resd 1  ;File pointer location
   173 00000018 ????????            <1> 	.dPointerToRelocations  resd 1
   174 0000001C ????????            <1> 	.dPointerToLinenumbers  resd 1
   175 00000020 ????                <1> 	.wNumberOfRelocations   resw 1
   176 00000022 ????                <1> 	.wNumberOfLinenumbers   resw 1
   177 00000024 ????????            <1> 	.dCharacteristics       resd 1
   178                              <1> endstruc
   179                              <1> 
   180                              <1> ;Section Hdr characteristics flags 
   181                              <1> imgScnCntCode   equ 20h   ;The section contains executable code.
   182                              <1> imgScnCntData   equ 40h   ;The section contains initialized data.
   183                              <1> imgScnCntBSS    equ 80h   ;The section contains uninitialized data. 
    11                                  
    12                                  ;=======================START OF SYSINIT MODULE======================
    13                                  %include "./src/dos/Sysinit/sys.inc"
     1                              <1> 
     2                              <1> ;Sysinit globals
     3                              <1> GLOBAL FINALDOSPTR
     4                              <1> GLOBAL FILES
     5                              <1> GLOBAL BUFFERS
     6                              <1> GLOBAL DFLTDRIVE
     7                              <1> GLOBAL LASTDRIVE
     8                              <1> GLOBAL OEMBIOS
     9                              <1> GLOBAL OEMDRVCHAIN
    10                              <1> GLOBAL OEMPTR
    11                              <1> GLOBAL OEMVERSION
    12                              <1> GLOBAL MCBANCHOR
    13                              <1> GLOBAL OEMMEMPTR
    14                              <1> GLOBAL SYSENTRY
    15                              <1> 
    16                              <1> ;OEM externs
    17                              <1> EXTERN OEMMCBINIT
    18                              <1> EXTERN OEMHALT
    19                              <1> EXTERN OEMCALLBK
    20                              <1> 
    21                              <1> ;Linker externs
    22                              <1> EXTERN dosEnd       ;Pointer from linker script
    23                              <1> EXTERN dosResLen    ;From linker script
    24                              <1> EXTERN dosResStart  ;From linker script
    25                              <1> EXTERN drv$_start   ;From linker script
    26                              <1> 
    27                              <1> ;DOS externs
    28                              <1> EXTERN dSegLen  ;From .bss of DOS
    29                              <1> 
    30                              <1> EXTERN nulDevHdr
    31                              <1> EXTERN anchorMcb
    32                              <1> EXTERN dayOfMonth
    33                              <1> EXTERN monthOfYear
    34                              <1> EXTERN vConPtr
    35                              <1> EXTERN clockPtr
    36                              <1> EXTERN currentPSP
    37                              <1> EXTERN editKeys
    38                              <1> EXTERN shareCount
    39                              <1> EXTERN shareDelay
    40                              <1> EXTERN caseMapFunc
    41                              <1> EXTERN charTableArray
    42                              <1> EXTERN charTableArray.ucTable
    43                              <1> EXTERN charTableArray.filenameUCTable
    44                              <1> EXTERN charTableArray.filenameTerminatingTable
    45                              <1> EXTERN charTableArray.collatingTable
    46                              <1> EXTERN charTableArray.dbcsTable
    47                              <1> EXTERN serverDispTbl
    48                              <1> EXTERN machineName
    49                              <1> EXTERN critPtchTbl
    50                              <1> EXTERN dosCrit1Enter
    51                              <1> EXTERN dosCrit1Exit
    52                              <1> EXTERN dosCrit2Enter
    53                              <1> EXTERN dosCrit2Exit
    54                              <1> EXTERN dosMgrHooks
    55                              <1> EXTERN dllHooks
    56                              <1> EXTERN shareHooks
    57                              <1> EXTERN goodDfltShareHook
    58                              <1> EXTERN badDfltShareHook
    59                              <1> EXTERN dosBIOSName
    60                              <1> EXTERN biosVers
    61                              <1> EXTERN biosPtr
    62                              <1> EXTERN dosPSP
    63                              <1> EXTERN bootDrive
    64                              <1> EXTERN numFiles
    65                              <1> EXTERN lastdrvNum
    66                              <1> EXTERN firstSftHeader
    67                              <1> EXTERN mcbChainPtr
    68                              <1> EXTERN vConPtr
    69                              <1> EXTERN clockPtr
    70                              <1> EXTERN extKeyFunc
    71                              <1> EXTERN errorDrv
    72                              <1> EXTERN currentNdx
    73                              <1> EXTERN switchChar
    74                              <1> EXTERN ctryTbl
    75                              <1> EXTERN serverDispTblPtr
    76                              <1> EXTERN currentDTA
    77                              <1> EXTERN cdsHeadPtr
    78                              <1> EXTERN dpbHeadPtr
    79                              <1> EXTERN maxBytesSec
    80                              <1> EXTERN bufHeadPtr
    81                              <1> EXTERN sftHeadPtr
    82                              <1> EXTERN numBuffers
    83                              <1> EXTERN fcbsHeadPtr
    84                              <1> EXTERN numPhysVol
    85                              <1> 
    86                              <1> 
    87                              <1> ;DOS Externs (SYSDATA)
    88                              <1> EXTERN i0
    89                              <1> EXTERN i1
    90                              <1> EXTERN i2
    91                              <1> EXTERN i3
    92                              <1> EXTERN i4
    93                              <1> EXTERN i5
    94                              <1> EXTERN i6
    95                              <1> EXTERN i7
    96                              <1> EXTERN i8
    97                              <1> EXTERN i9
    98                              <1> EXTERN i10
    99                              <1> EXTERN i11
   100                              <1> EXTERN i12
   101                              <1> EXTERN i13
   102                              <1> EXTERN i14
   103                              <1> EXTERN i15
   104                              <1> EXTERN i16
   105                              <1> EXTERN i17
   106                              <1> EXTERN i18
   107                              <1> EXTERN i19
   108                              <1> EXTERN i20
   109                              <1> EXTERN i21
   110                              <1> 
   111                              <1> EXTERN terminateProcess 
   112                              <1> EXTERN functionDispatch 
   113                              <1> EXTERN defaultIretq
   114                              <1> EXTERN dosDefCritErrHdlr    
   115                              <1> EXTERN absDiskRead      
   116                              <1> EXTERN absDiskWrite     
   117                              <1> EXTERN terminateRes     
   118                              <1> EXTERN multiplexHdlr
   119                              <1> EXTERN nulStrat
   120                              <1> EXTERN nulIntr
    14                                  
    15                                  ;Segment stext follows=odata align=1 vfollows=odata valign=1
    16                                  Segment stext code private align=1 use64
    17                                  ;---------------------------
    18                                  ;   SYSINIT code segment
    19                                  ;---------------------------
    20                                  %include "./src/dos/Sysinit/sysinit.asm"
     1                              <1> 
     2                              <1> SYSENTRY:    ;Control is passed here from OEMINIT module
     3                              <1> ;First move the load address into fs 
     4 00000000 B9000100C0          <1>     mov ecx, 0C0000100h ;Write FS MSR
     5 00000005 488B3D(BC010000)    <1>     mov rdi, qword [FINALDOSPTR] ;Pointer of the address we loaded at
     6 0000000C 89F8                <1>     mov eax, edi
     7 0000000E 4889FA              <1>     mov rdx, rdi
     8 00000011 48C1EA20            <1>     shr rdx, 20h
     9 00000015 0F30                <1>     wrmsr   ;Write the new value to FS MSR
    10 00000017 4889FD              <1>     mov rbp, rdi    ;Move the pointer into rbp as well
    11                              <1> ;------------------------------------------------;
    12                              <1> ;      Copy DOS to it's final resting ground     ;
    13                              <1> ;------------------------------------------------;  
    14                              <1> dosReloc:
    15 0000001A 488D35(00000000)    <1>     lea rsi, dosResStart    ;Get pointer to the start of dText
    16 00000021 488B3D(BC010000)    <1>     mov rdi, qword [FINALDOSPTR]    ;Get ptr to where dSeg goes
    17 00000028 4881C7[00000000]    <1>     add rdi, dSegLen                ;Make this a pointer to the start of dText
    18 0000002F 4839F7              <1>     cmp rdi, rsi 
    19 00000032 7411                <1>     je short skipDOSReloc   ;Skip relocating if DOS is at correct address
    20 00000034 B9[00000000]        <1>     mov ecx, dosResLen      ;Get length of file portion for copy
    21 00000039 81C107000000        <1>     add ecx, 7              ;Round up
    22 0000003F C1E903              <1>     shr ecx, 3              ;Divide by 8 to get number of QWORDS for copy
    23 00000042 F348A5              <1>     rep movsq
    24                              <1> skipDOSReloc:
    25                              <1> ;------------------------------------------------;
    26                              <1> ;           Sanitise the data area               ;
    27                              <1> ;------------------------------------------------;
    28                              <1> ; This call initialises ALL fields in the DOS    ;
    29                              <1> ; data area with 0's. Thus any fields, which     ;
    30                              <1> ; need to be initialised with a 0 value, are     ;
    31                              <1> ; initialised for free.                          ;
    32                              <1> ;------------------------------------------------;
    33 00000045 488B3D(BC010000)    <1>     mov rdi, qword [FINALDOSPTR]    ;Go back to the data area
    34 0000004C B9[00000000]        <1>     mov ecx, dSegLen
    35 00000051 30C0                <1>     xor al, al
    36 00000053 F3AA                <1>     rep stosb   ;and sanitise away!
    37                              <1> ;------------------------------------------------;
    38                              <1> ;          Kernel inits and adjustments          ;
    39                              <1> ;------------------------------------------------;
    40                              <1> ;Adjust Interrupt Entries Int 00h-15h
    41                              <1> ;Assumes rbp points to DOSSEG
    42 00000055 0F010D(B2010000)    <1>     sidt [localIDTpointer]   ;Get the idt pointer here
    43                              <1> adjExceptions:
    44 0000005C 488D3D(60000000)    <1>     lea rdi, exceptData
    45 00000063 31C0                <1>     xor eax, eax             ;Start with interrupt 0
    46 00000065 B915000000          <1>     mov ecx, 21
    47 0000006A E8370A0000          <1>     call setupInterruptBlock
    48                              <1> ;Adjust Interrupt Entries Int 20h-2Fh
    49                              <1> adjInts:
    50 0000006F 488D3D(10010000)    <1>     lea rdi, intData
    51 00000076 488D1D(00000000)    <1>     lea rbx, OEMHALT    ;Add base address of sysinit to the symbol
    52 0000007D 4829EB              <1>     sub rbx, rbp        ;Subtract so that the add in setupInterruptBlock is Ok
    53 00000080 48895F10            <1>     mov qword [rdi + 2*8], rbx  ;Store this address for Int 22h
    54 00000084 B820000000          <1>     mov eax, 20h            ;Start with interrupt 20h
    55 00000089 B930000000          <1>     mov ecx, 30h
    56 0000008E E8130A0000          <1>     call setupInterruptBlock
    57                              <1> ;------------------------------------------------;
    58                              <1> ;              Setup PSP for DOS                 ;
    59                              <1> ;------------------------------------------------;
    60 00000093 488D1D(1C020000)    <1>     lea rbx, qword [tempPSP]
    61 0000009A 48899D[00000000]    <1>     mov qword [rbp + currentPSP], rbx
    62                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++;
    63                              <1> ;    DOS INTERRUPTS CAN BE USED FROM HERE ON     ;
    64                              <1> ;++++++++++++++++++++++++++++++++++++++++++++++++;
    65                              <1> ;
    66                              <1> ;------------------------------------------------;
    67                              <1> ;          Driver Adjustments and inits          ;
    68                              <1> ;------------------------------------------------;
    69                              <1> ;Modify the pointers in nData before putting them in the data area
    70 000000A1 48012D(9A010000)    <1>     add qword [nData + drvHdr.strPtr], rbp
    71 000000A8 48012D(A2010000)    <1>     add qword [nData + drvHdr.intPtr], rbp
    72                              <1> ;Copy the Null driver header to its location in Sysvars
    73 000000AF B922000000          <1>     mov ecx, drvHdr_size
    74 000000B4 488D35(90010000)    <1>     lea rsi, qword [nData]
    75 000000BB 488DBD[00000000]    <1>     lea rdi, qword [rbp + nulDevHdr]
    76 000000C2 F3A4                <1>     rep movsb   
    77                              <1> 
    78                              <1> ;Adjust the addresses in the other driver headers 
    79 000000C4 48BE-               <1>     mov rsi, drv$_start
    79 000000C6 [0000000000000000]  <1>
    80 000000CE 480335(BC010000)    <1>     add rsi, qword [FINALDOSPTR]    ;Offset this correctly
    81 000000D5 4989F6              <1>     mov r14, rsi    ;Save this pointer in r14
    82 000000D8 4889B5[00000000]    <1>     mov qword [rbp + nulDevHdr + drvHdr.nxtPtr], rsi  ;Point NUL to the OEM driver chain
    83                              <1> adjDrivers:
    84                              <1> ;Input: rsi = Effective address of driver in DOS segment
    85                              <1> ;       rbp = Ptr to the start of the DOS segment
    86                              <1> ;Output: rsi = EA of next header in DOS segment
    87 000000DF 48016E0A            <1>     add qword [rsi + drvHdr.strPtr], rbp
    88 000000E3 48016E12            <1>     add qword [rsi + drvHdr.intPtr], rbp
    89 000000E7 48813EFFFFFFFF      <1>     cmp qword [rsi + drvHdr.nxtPtr], -1 ;End of chain?
    90 000000EE 7408                <1>     je short .exit
    91 000000F0 48012E              <1>     add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
    92 000000F3 488B36              <1>     mov rsi, qword [rsi + drvHdr.nxtPtr]    ;Dont "demand" ctguos headers... 
    93 000000F6 EBE7                <1>     jmp short adjDrivers
    94                              <1> .exit:
    95                              <1> ;------------------------------------------------;
    96                              <1> ;                   MCB inits                    ;
    97                              <1> ;------------------------------------------------;
    98                              <1> makeMCBChain:
    99                              <1> ;Fill in Anchor MCB first
   100 000000F8 488D85[10000000]    <1>     lea rax, qword [rbp + anchorMcb + mcb.program]    ;Get first allocated byte
   101 000000FF 488D9D[00000000]    <1>     lea rbx, qword [rbp + dosEnd] ;Get the end of the file
   102 00000106 4829C3              <1>     sub rbx, rax    ;Number of bytes in rbx (ebx bzw.)
   103 00000109 81C30F000000        <1>     add ebx, 0Fh    ;Round up if not para aligned
   104 0000010F C1EB04              <1>     shr ebx, 4      ;Get number of paragraphs
   105 00000112 899D[09000000]      <1>     mov dword [rbp + anchorMcb + mcb.blockSize], ebx
   106 00000118 48C785[01000000]08- <1>     mov qword [rbp + anchorMcb + mcb.owner], mcbOwnerDOS
   106 00000120 000000              <1>
   107 00000123 C685[00000000]5A    <1>     mov byte [rbp + anchorMcb + mcb.marker], mcbMarkEnd
   108                              <1> 
   109 0000012A 488D85[00000000]    <1>     lea rax, qword [rbp + anchorMcb]    ;Now store the anchor pointer in var
   110 00000131 488905(C4010000)    <1>     mov qword [MCBANCHOR], rax          ;Save in external var...
   111 00000138 6448890425-         <1>     mov qword fs:[mcbChainPtr], rax     ; and in internal DOS var 
   111 0000013D [00000000]          <1>
   112                              <1> 
   113 00000141 55                  <1>     push rbp    ;Save the pointer to DOSSEG on the stack temporarily
   114 00000142 E8(00000000)        <1>     call OEMMCBINIT ;Build MCB chain, kernel drvs can allocate... undoc :)
   115 00000147 5D                  <1>     pop rbp
   116 00000148 0F82(00000000)      <1>     jc OEMHALT
   117                              <1> ;------------------------------------------------;
   118                              <1> ;             Set Default Time/Date              ;
   119                              <1> ;------------------------------------------------;
   120 0000014E C685[00000000]01    <1>     mov byte [rbp + dayOfMonth], 01     ;Set 1st of Jan
   121 00000155 C685[00000000]01    <1>     mov byte [rbp + monthOfYear], 01
   122                              <1> ;------------------------------------------------;
   123                              <1> ;     Set OEM ID number and ptr for drivers      ;
   124                              <1> ;------------------------------------------------;
   125 0000015C 8B05(D9010000)      <1>     mov eax, dword [OEMVERSION]
   126 00000162 8985[00000000]      <1>     mov dword [rbp + biosVers], eax
   127                              <1> 
   128 00000168 488B05(D1010000)    <1>     mov rax, qword [OEMPTR]
   129 0000016F 488985[00000000]    <1>     mov qword [rbp + biosPtr], rax
   130                              <1> ;------------------------------------------------;
   131                              <1> ;              Kernel Driver inits               ;
   132                              <1> ;------------------------------------------------;
   133                              <1> kernDrvInit:
   134                              <1>     ;rbp and fs point to DOSSEG
   135                              <1>     ;Set the CON pointer and the CLOCK pointers.
   136                              <1>     ;The standard defines that kernel drivers are such that the 
   137                              <1>     ;first driver MUST be CON and the fourth MUST be CLOCK$.
   138                              <1>     ;This is done to allow the drivers to use DOS CHAR functions and 
   139                              <1>     ;GET/SET TIME and GET/SET DATE
   140 00000176 4C89F6              <1>     mov rsi, r14    ;Get back the pointer to the copied drivers
   141 00000179 4889F3              <1>     mov rbx, rsi
   142 0000017C 4889B5[00000000]    <1>     mov qword [rbp + vConPtr], rsi  ;Store default CON ptr
   143 00000183 488B36              <1>     mov rsi, qword [rsi + drvHdr.nxtPtr]    ;Goto AUX
   144 00000186 488B36              <1>     mov rsi, qword [rsi + drvHdr.nxtPtr]    ;Goto PRN
   145 00000189 488B36              <1>     mov rsi, qword [rsi + drvHdr.nxtPtr]    ;Goto CLOCK$
   146 0000018C 4889B5[00000000]    <1>     mov qword [rbp + clockPtr], rsi ;Store default CLOCK$ ptr
   147 00000193 4889DE              <1>     mov rsi, rbx     ;Point rsi back to head of device chain
   148 00000196 488D1D(DD010000)    <1>     lea rbx, initDrvBlk
   149                              <1> .init:
   150 0000019D E807080000          <1>     call initDriver         ;Importantly preserves rbp, rsi and rbx
   151 000001A2 0F82(00000000)      <1>     jc OEMHALT
   152 000001A8 E8E6060000          <1>     call addDriverMarkers   ;Preserves all registers
   153 000001AD 66F746080080        <1>     test word [rsi + drvHdr.attrib], devDrvChar
   154 000001B3 750B                <1>     jnz short .notMSD
   155 000001B5 E85E080000          <1>     call buildKernDPBs          ;Preserves rbp, rsi and rbx
   156 000001BA 0F82(00000000)      <1>     jc OEMHALT
   157                              <1> .notMSD:
   158 000001C0 488B36              <1>     mov rsi, qword [rsi + drvHdr.nxtPtr]    ;Now point rsi to that header
   159 000001C3 4881FEFFFFFFFF      <1>     cmp rsi, -1     ;We at the end of the chain?
   160 000001CA 75D1                <1>     jne short .init ;If not, goto next driver
   161                              <1> ;Finally, Eject the init routine if so desired by the implementers
   162 000001CC 488D9D[00000000]    <1>     lea rbx, qword [rbp + dosEnd]   ;Get the original alloc end pointer (para aligned)
   163 000001D3 4C8D85[00000000]    <1>     lea r8, qword [rbp + anchorMcb]   ;Get pointer to mcb
   164 000001DA E878070000          <1>     call ejectKernelInit
   165 000001DF 0F82(00000000)      <1>     jc OEMHALT
   166                              <1> ;----------------------------------------:
   167                              <1> ;           End of driver inits.         :
   168                              <1> ;----------------------------------------:
   169                              <1> ;
   170                              <1> ;----------------------------------------:
   171                              <1> ;END OF IMPLEMENTERS SYSINIT PORTION ^^^ :
   172                              <1> ;      So called the OEM BIOS INIT       :
   173                              <1> ;----------------------------------------:
   174                              <1> ;
   175                              <1> ;----------------------------------------:
   176                              <1> ;START OF COMMON DOS SYSINIT PORTION VVV :
   177                              <1> ;----------------------------------------:
   178                              <1> ;
   179                              <1> ;------------------------------------------------;
   180                              <1> ;     Set up general PSP areas and DOS vars      ;
   181                              <1> ;------------------------------------------------;
   182                              <1> ;Ensure to link the default DOS vCON edit key
   183                              <1> ; controller routines before proceeding
   184 000001E5 488D85[00000000]    <1>     lea rax, qword [rbp + editKeys]
   185 000001EC 6448890425-         <1>     mov qword fs:[extKeyFunc], rax
   185 000001F1 [00000000]          <1>
   186                              <1> 
   187                              <1> ;Additional DOS Vars init and fixups
   188 000001F5 64C60425[00000000]- <1>     mov byte fs:[errorDrv], -1   ;No error drive
   188 000001FD FF                  <1>
   189 000001FE 6466C70425-         <1>     mov word fs:[currentNdx], -1    ;Has to be -1 initially
   189 00000203 [00000000]FFFF      <1>
   190 00000209 66C785[00000000]03- <1>     mov word [rbp + shareCount], 3      ;Retry the repeat 3 times before failing
   190 00000211 00                  <1>
   191 00000212 66C785[00000000]01- <1>     mov word [rbp + shareDelay], 1      ;Go through one multiple of countdown loop
   191 0000021A 00                  <1>
   192 0000021B 64C60425[00000000]- <1>     mov byte fs:[switchChar], "/"  ;Default switch char
   192 00000223 2F                  <1>
   193 00000224 488DBD[00000000]    <1>     lea rdi, qword [rbp + caseMapFunc]  ;Get the function pointer
   194 0000022B 6448893C25-         <1>     mov qword fs:[ctryTbl + countryStruc.mapptr], rdi ;Store in country table
   194 00000230 [12000000]          <1>
   195 00000234 4801AD[01000000]    <1>     add qword [rbp + charTableArray.ucTable + 1], rbp ;Fixup stored address
   196 0000023B 4801AD[01000000]    <1>     add qword [rbp + charTableArray.filenameUCTable + 1], rbp 
   197 00000242 4801AD[01000000]    <1>     add qword [rbp + charTableArray.filenameTerminatingTable + 1], rbp 
   198 00000249 4801AD[01000000]    <1>     add qword [rbp + charTableArray.collatingTable + 1], rbp 
   199 00000250 4801AD[01000000]    <1>     add qword [rbp + charTableArray.dbcsTable + 1], rbp 
   200                              <1> 
   201                              <1> ;Server Table setup
   202 00000257 488DBD[00000000]    <1>     lea rdi, qword [rbp + serverDispTbl]  ;Get pointer to table
   203 0000025E 6448893C25-         <1>     mov qword fs:[serverDispTblPtr], rdi   ;Store to use
   203 00000263 [00000000]          <1>
   204                              <1> 
   205                              <1> ;Set network machine name to... nothing!
   206 00000267 488DBD[00000000]    <1>     lea rdi, qword [rbp + machineName]
   207 0000026E B910000000          <1>     mov ecx, 10h    ;16 chars long
   208 00000273 B020                <1>     mov al, SPC ;Space char
   209 00000275 F3AA                <1>     rep stosb   ;Fill with space chars
   210                              <1> 
   211                              <1> ;Patch Data Table init
   212 00000277 488DBD[00000000]    <1>     lea rdi, qword [rbp + critPtchTbl]
   213 0000027E 488D85[00000000]    <1>     lea rax, qword [rbp + dosCrit1Enter]
   214 00000285 48AB                <1>     stosq   ;Store this address and increment rdi by 8 to next tbl entry
   215 00000287 488D85[00000000]    <1>     lea rax, qword [rbp + dosCrit1Exit]
   216 0000028E 48AB                <1>     stosq
   217 00000290 488D85[00000000]    <1>     lea rax, qword [rbp + dosCrit2Enter]
   218 00000297 48AB                <1>     stosq
   219 00000299 488D85[00000000]    <1>     lea rax, qword [rbp + dosCrit2Exit]
   220 000002A0 48AB                <1>     stosq
   221                              <1> 
   222                              <1> ;Initial PSP pointer fields
   223 000002A2 488D1D(1C020000)    <1>     lea rbx, qword [tempPSP]
   224 000002A9 6448891C25-         <1>     mov qword fs:[currentPSP], rbx      ;Reset current PSP
   224 000002AE [00000000]          <1>
   225 000002B2 6448891C25-         <1>     mov qword fs:[dosPSP], rbx          ;Save the DOS PSP pointer
   225 000002B7 [00000000]          <1>
   226 000002BB 53                  <1>     push rbx
   227 000002BC 4881C380000000      <1>     add rbx, psp.dta
   228 000002C3 6448891C25-         <1>     mov qword fs:[currentDTA], rbx    ;Save current DTA
   228 000002C8 [00000000]          <1>
   229 000002CC 5B                  <1>     pop rbx
   230 000002CD 48895B22            <1>     mov qword [rbx + psp.parentPtr], rbx ;Save self as parent Process
   231 000002D1 48895B53            <1>     mov qword [rbx + psp.prevPSP], rbx  ;Save self as previous PSP
   232 000002D5 4889DA              <1>     mov rdx, rbx
   233 000002D8 B822350000          <1>     mov eax, 3522h  ;Get pointer for Int 22h in rbx
   234 000002DD CD21                <1>     int 21h
   235 000002DF 48895A0A            <1>     mov qword [rdx + psp.oldInt22h], rbx
   236 000002E3 B823350000          <1>     mov eax, 3523h
   237 000002E8 CD21                <1>     int 21h
   238 000002EA 48895A12            <1>     mov qword [rdx + psp.oldInt23h], rbx
   239 000002EE B824350000          <1>     mov eax, 3524h
   240 000002F3 CD21                <1>     int 21h
   241 000002F5 48895A1A            <1>     mov qword [rdx + psp.oldInt24h], rbx
   242                              <1> ;------------------------------------------------;
   243                              <1> ;              Setup DOSMGR Hooks                ;
   244                              <1> ;------------------------------------------------;   
   245 000002F9 488DBD[01000000]    <1>     lea rdi, qword [rbp + dosMgrHooks + 1]  ;Skip the present flag
   246 00000300 488D85[00000000]    <1>     lea rax, qword [rbp + goodDfltShareHook]    ;Return CF = NC
   247 00000307 48AB                <1>     stosq   ;Store ptr for LaunchTask
   248 00000309 48AB                <1>     stosq   ;Store ptr for TerminateTask
   249                              <1> ;------------------------------------------------;
   250                              <1> ;              Setup DLLMGR Hooks                ;
   251                              <1> ;------------------------------------------------;   
   252 0000030B 488DBD[00000000]    <1>     lea rdi, qword [rbp + dllHooks]
   253 00000312 488D85[00000000]    <1>     lea rax, qword [rbp + goodDfltShareHook]    ;Return CF = NC
   254 00000319 48AB                <1>     stosq   ;Store ptr for RegisterDLL
   255 0000031B 48AB                <1>     stosq   ;Store ptr for UnloadDLLHook
   256                              <1> ;------------------------------------------------;
   257                              <1> ;               Setup Share Hooks                ;
   258                              <1> ;------------------------------------------------;
   259 0000031D 488DBD[08000000]    <1>     lea rdi, qword [rbp + shareHooks + 8]   ;Start from openShare
   260 00000324 488D85[00000000]    <1>     lea rax, qword [rbp + goodDfltShareHook]
   261 0000032B 488D9D[00000000]    <1>     lea rbx, qword [rbp + badDfltShareHook]
   262 00000332 48AB                <1>     stosq   ;Store good for open
   263 00000334 48AB                <1>     stosq   ;Store good for close
   264 00000336 4893                <1>     xchg rax, rbx
   265                              <1> ;Store bad for close for machine, task, name, lock and unlock file
   266 00000338 B905000000          <1>     mov ecx, 5
   267 0000033D F348AB              <1>     rep stosq
   268 00000340 4893                <1>     xchg rax, rbx
   269 00000342 48AB                <1>     stosq   ;Store good for check file lock exists
   270 00000344 4893                <1>     xchg rax, rbx
   271                              <1> ;Store bad for open file, update fcb from sft and get fst cluster of fcb
   272 00000346 B903000000          <1>     mov ecx, 3
   273 0000034B F348AB              <1>     rep stosq
   274 0000034E 4893                <1>     xchg rax, rbx
   275 00000350 48AB                <1>     stosq   ;Store good for close dup file share
   276 00000352 4893                <1>     xchg rax, rbx
   277 00000354 48AB                <1>     stosq   ;Store bad for close handles for new file opened 
   278 00000356 48AB                <1>     stosq   ;Store bad for update dir information
   279                              <1> 
   280                              <1> ;Finish by setting up internal DOS vars from OEM passed arguments.
   281 00000358 0FB605(D0010000)    <1>     movzx eax, byte [OEMBIOS]
   282 0000035F 85C0                <1>     test eax, eax
   283 00000361 741B                <1>     jz short skipOEMName
   284 00000363 488DB5[00000000]    <1>     lea rsi, qword [rbp + dosBIOSName]
   285 0000036A 48B8494F2020202020- <1>     mov rax, "IO      "
   285 00000373 20                  <1>
   286 00000374 488906              <1>     mov qword [rsi], rax
   287 00000377 C746082E535953      <1>     mov dword [rsi + 8], ".SYS"
   288                              <1> skipOEMName:
   289 0000037E 0FB605(CE010000)    <1>     movzx eax, byte [DFLTDRIVE]
   290 00000385 31DB                <1>     xor ebx, ebx
   291 00000387 3D19000000          <1>     cmp eax, 25
   292 0000038C 0F47C3              <1>     cmova eax, ebx
   293 0000038F 8885[00000000]      <1>     mov byte [rbp + bootDrive], al
   294                              <1> 
   295 00000395 0FB605(CC010000)    <1>     movzx eax, byte [FILES]
   296 0000039C BB14000000          <1>     mov ebx, filesDefault
   297 000003A1 3D05000000          <1>     cmp eax, 5
   298 000003A6 0F42C3              <1>     cmovb eax, ebx
   299 000003A9 3DFE000000          <1>     cmp eax, 254
   300 000003AE 0F47C3              <1>     cmova eax, ebx
   301 000003B1 8885[00000000]      <1>     mov byte [rbp + numFiles], al
   302                              <1> 
   303 000003B7 0FB605(CD010000)    <1>     movzx eax, byte [BUFFERS]
   304 000003BE BB1E000000          <1>     mov ebx, buffersDefault
   305 000003C3 85C0                <1>     test eax, eax
   306 000003C5 0F44C3              <1>     cmovz eax, ebx
   307 000003C8 3D63000000          <1>     cmp eax, 99
   308 000003CD 0F47C3              <1>     cmova eax, ebx
   309 000003D0 8805(CD010000)      <1>     mov byte [BUFFERS], al
   310                              <1> 
   311 000003D6 0FB605(CF010000)    <1>     movzx eax, byte [LASTDRIVE]
   312 000003DD BB05000000          <1>     mov ebx, lastDriveDeflt
   313 000003E2 39D8                <1>     cmp eax, ebx
   314 000003E4 0F42C3              <1>     cmovb eax, ebx
   315 000003E7 3D19000000          <1>     cmp eax, 25
   316 000003EC 0F47C3              <1>     cmova eax, ebx
   317 000003EF 8805(CF010000)      <1>     mov byte [LASTDRIVE], al
   318 000003F5 8885[00000000]      <1>     mov byte [rbp + lastdrvNum], al     ;Set for DOS to be usable
   319                              <1> 
   320                              <1> ;------------------------------------------------;
   321                              <1> ;          Find largest sector size              ;
   322                              <1> ;------------------------------------------------;
   323 000003FB E806040000          <1>     call sectorSizeSet
   324                              <1> ;------------------------------------------------;
   325                              <1> ;                CDS array inits                 ;
   326                              <1> ;------------------------------------------------;
   327 00000400 0FB68D[00000000]    <1>     movzx ecx, byte [rbp + lastdrvNum]     ;Use as a counter
   328 00000407 E805000000          <1>     call makeCDSArray   ;Sets the CDS head pointer to rdi
   329 0000040C E995000000          <1>     jmp initialCDSWritten ;Go past the function
   330                              <1> makeCDSArray:
   331                              <1> ;Builds a new CDS array for ya and sets the sysvars var to point to it!
   332                              <1> ;Input: ecx = Size of array (number of CDS's in the array)
   333                              <1> ;Ouput: CF=CY: Abort operation. CF=NC: CDS Array allocated ok!
   334 00000411 B85F000000          <1>     mov eax, cds_size
   335 00000416 F7E1                <1>     mul ecx ;eax has the size of the CDS array to make
   336 00000418 050F000000          <1>     add eax, 0Fh    ;Round up if not on a para boundary
   337 0000041D C1E804              <1>     shr eax, 4      ;Convert to paragraphs
   338 00000420 31DB                <1>     xor ebx, ebx
   339 00000422 89C3                <1>     mov ebx, eax
   340 00000424 B800480000          <1>     mov eax, 4800h  ;ALLOC, set the owner below
   341 00000429 CD21                <1>     int 21h
   342                              <1>     retc    ;Return if Carry set
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000042B 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000042D C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   343 0000042E 4889C7              <1>     mov rdi, rax            ;Save pointer to MCB in rdi
   344 00000431 482D10000000        <1>     sub rax, mcb_size       ;Move rax to point to MCB
   345 00000437 C6400D4C            <1>     mov byte [rax + mcb.subSysMark], mcbSubCDS  ;Mark as a CDS array
   346 0000043B 48C7400108000000    <1>     mov qword [rax + mcb.owner], mcbOwnerDOS    ;Mark as owned by DOS
   347                              <1> 
   348 00000443 6448893C25-         <1>     mov qword fs:[cdsHeadPtr], rdi
   348 00000448 [00000000]          <1>
   349 0000044C 57                  <1>     push rdi
   350 0000044D 51                  <1>     push rcx
   351 0000044E 89C8                <1>     mov eax, ecx
   352 00000450 B95F000000          <1>     mov ecx, cds_size
   353 00000455 F7E1                <1>     mul ecx ;Multiply eax with ecx to get number of bytes to null out
   354 00000457 89C1                <1>     mov ecx, eax
   355 00000459 31C0                <1>     xor eax, eax
   356 0000045B F3AA                <1>     rep stosb
   357 0000045D 59                  <1>     pop rcx
   358 0000045E 5F                  <1>     pop rdi
   359 0000045F 64488B1C25-         <1>     mov rbx, qword fs:[dpbHeadPtr]
   359 00000464 [00000000]          <1>
   360 00000468 B8413A5C00          <1>     mov eax, 005C3A41h      ;"A:\"+NULL char
   361                              <1> .tempCDS:
   362 0000046D 8907                <1>     mov dword [rdi + cds.sCurrentPath], eax
   363 0000046F 48895F45            <1>     mov qword [rdi + cds.qDPBPtr], rbx
   364 00000473 C7474D00000000      <1>     mov dword [rdi + cds.dStartCluster], 0  ;Root dir for all!
   365 0000047A 66C7475D0200        <1>     mov word [rdi + cds.wBackslashOffset], 2    ;Skip the X:
   366 00000480 31D2                <1>     xor edx, edx    ;Use edx for flags
   367 00000482 4881FBFFFFFFFF      <1>     cmp rbx, -1 ;Is rbx an invalid DPB ptr?
   368 00000489 7409                <1>     je .skipValidCDS
   369 0000048B BA00400000          <1>     mov edx, cdsValidDrive  ;If not, set drive to valid and...
   370 00000490 488B5B25            <1>     mov rbx, qword [rbx + dpb.qNextDPBPtr]  ;... go to next DPB
   371                              <1> .skipValidCDS:
   372 00000494 66895743            <1>     mov word [rdi + cds.wFlags], dx ;Store the flags now
   373 00000498 FFC0                <1>     inc eax ;Increment the drive letter
   374 0000049A 4881C75F000000      <1>     add rdi, cds_size   ;Goto next array entry
   375 000004A1 FFC9                <1>     dec ecx
   376 000004A3 75C8                <1>     jnz .tempCDS
   377 000004A5 C3                  <1>     ret
   378                              <1> initialCDSWritten:
   379                              <1> ;------------------------------------------------;
   380                              <1> ;        Create a Default Temporary Buffer       ;
   381                              <1> ;------------------------------------------------;
   382 000004A6 640FB71C25-         <1>     movzx ebx, word fs:[maxBytesSec]    ;Get buffer size
   382 000004AB [00000000]          <1>
   383 000004AF 81C320000000        <1>     add ebx, bufferHdr_size             ;add header size for allocation size
   384 000004B5 81C30F000000        <1>     add ebx, 0Fh
   385 000004BB C1EB04              <1>     shr ebx, 4  ;Convert to number of paragraphs
   386 000004BE B800480000          <1>     mov eax, 4800h  ;ALLOC, set the owner below
   387 000004C3 CD21                <1>     int 21h
   388 000004C5 0F82(00000000)      <1>     jc OEMHALT
   389 000004CB 6448890425-         <1>     mov qword fs:[bufHeadPtr], rax      ;Save pointer to buffer
   389 000004D0 [00000000]          <1>
   390 000004D4 48C700FFFFFFFF      <1>     mov qword [rax + bufferHdr.nextBufPtr], -1 ;Point to no buffer
   391 000004DB 66C74008FF00        <1>     mov word [rax + bufferHdr.driveNumber], 00FFh  ;Free buffer and clear flags    
   392 000004E1 482D10000000        <1>     sub rax, mcb_size   ;Now go back to the mcb itself
   393 000004E7 48C7400108000000    <1>     mov qword [rax + mcb.owner], mcbOwnerDOS    ;Set DOS as owner of Buffer
   394 000004EF C6400D42            <1>     mov byte [rax + mcb.subSysMark], mcbSubBuffers  ;Set this arena as a buffer
   395                              <1> ;------------------------------------------------;
   396                              <1> ;          Default File Handle Creation          ;
   397                              <1> ;                                                ;
   398                              <1> ;   Note: Devices are opened AUX, CON then PRN   ;
   399                              <1> ;------------------------------------------------;
   400                              <1> defaultFileHandles:
   401 000004F3 488D95[00000000]    <1>     lea rdx, qword [rbp + firstSftHeader]
   402 000004FA 6448891425-         <1>     mov qword fs:[sftHeadPtr], rdx  ;Start from this SFT header
   402 000004FF [00000000]          <1>
   403 00000503 48C702FFFFFFFF      <1>     mov qword [rdx + sfth.qNextSFTPtr], -1
   404 0000050A 66C742080500        <1>     mov word [rdx + sfth.wNumFiles], 5  ;This SFTH has space for 5 SFTs
   405                              <1> ;Select default drive here so openStreams doesnt fail!
   406 00000510 0FB695[00000000]    <1>     movzx edx, byte [rbp + bootDrive]    ;Get the default drive
   407 00000517 B40E                <1>     mov ah, 0Eh ;Select drive
   408 00000519 CD21                <1>     int 21h
   409                              <1> 
   410 0000051B E811030000          <1>     call openStreams
   411 00000520 0F82(00000000)      <1>     jc OEMHALT
   412                              <1> ;------------------------------------------------;
   413                              <1> ;             Print Welcome Message              ;
   414                              <1> ;------------------------------------------------;
   415 00000526 488D15(00000000)    <1>     lea rdx, strtmsg
   416 0000052D B409                <1>     mov ah, 09h
   417 0000052F CD21                <1>     int 21h    
   418                              <1> ;------------------------------------------------;
   419                              <1> ;               Load CONFIG.SYS                  ;
   420                              <1> ;------------------------------------------------;
   421                              <1> ;Setup stackframe, workout base 
   422 00000531 55                  <1>     push rbp
   423 00000532 4889E5              <1>     mov rbp, rsp
   424 00000535 4881EC68000000      <1>     sub rsp, cfgFrame_size
   425 0000053C 0FB605(CD010000)    <1>     movzx eax, byte [BUFFERS]
   426 00000543 488945F8            <1>     mov qword [rbp - cfgFrame.newBuffers], rax
   427 00000547 0FB605(CC010000)    <1>     movzx eax, byte [FILES]
   428 0000054E 488945F0            <1>     mov qword [rbp - cfgFrame.newSFTVal], rax
   429 00000552 48C745E804000000    <1>     mov qword [rbp - cfgFrame.newFCBSVal], fcbsDefault
   430 0000055A 48C745E000000000    <1>     mov qword [rbp - cfgFrame.newProtFCBSVal], safeFcbsDeflt
   431 00000562 0FB605(CF010000)    <1>     movzx eax, byte [LASTDRIVE]
   432 00000569 488945D8            <1>     mov qword [rbp - cfgFrame.newLastdrive], rax
   433                              <1> 
   434 0000056D 488D15(49000000)    <1>     lea rdx, cfgspec    ;CONFIG.SYS, must be on bootdrive for now
   435 00000574 B43D                <1>     mov ah, 3Dh ;Open file for reading
   436 00000576 B000                <1>     mov al, openRdAcc
   437 00000578 CD21                <1>     int 21h
   438 0000057A 7216                <1>     jc noCfg  ;If no CONFIG.SYS found, just use defaults that are already setup
   439 0000057C E86B050000          <1>     call configParse ;Else, parse the config file
   440                              <1> ;Config.sys mightve made changes to files. Update DOS!
   441 00000581 0FB645F0            <1>     movzx eax, byte [rbp - cfgFrame.newSFTVal]
   442 00000585 64880425[00000000]  <1>     mov byte fs:[numFiles], al
   443                              <1> ;If a driver installed a new DPB device, check if it's sector size is bigger.
   444 0000058D E874020000          <1>     call sectorSizeSet  ;This is needed for setting the buffer sizes
   445                              <1> ;------------------------------------------------;
   446                              <1> ;   Setup Final Data Areas With Overrides from   ;
   447                              <1> ;                  CONFIG.SYS                    ;
   448                              <1> ;------------------------------------------------;
   449                              <1> ;Add additional buffers.
   450                              <1> ;Add additional SFT entries.
   451                              <1> ;Add additional FCBS.
   452                              <1> ;Create a larger CDS if needed.
   453                              <1> noCfg:
   454                              <1> ;Start with buffers:
   455 00000592 488B4DF8            <1>     mov rcx, qword [rbp - cfgFrame.newBuffers]    ;Get new number of buffers
   456 00000596 81F901000000        <1>     cmp ecx, 1   ;If its only one buffer, skip as we have one already
   457 0000059C 0F849D000000        <1>     je .skipBuffers
   458 000005A2 FFC9                <1>     dec ecx  ;Minus one now
   459 000005A4 64880C25[00000000]  <1>     mov byte fs:[numBuffers], cl    ;Store this value in var
   460                              <1>     ;Now do the allocation at rdi. Each buffer = maxSectorSize + bufferHdr_size
   461 000005AC 640FB70425-         <1>     movzx eax, word fs:[maxBytesSec]    ;Get buffer sector size
   461 000005B1 [00000000]          <1>
   462 000005B5 0520000000          <1>     add eax, bufferHdr_size ;eax has the size to add
   463 000005BA 50                  <1>     push rax    ;Save the total number of bytes for a buffer and its header
   464 000005BB F7E1                <1>     mul ecx ;Get total size to allocate in eax
   465 000005BD 5A                  <1>     pop rdx     ;and get the total value back in rdx
   466 000005BE 89C3                <1>     mov ebx, eax    ;Move the total number of bytes into ebx
   467 000005C0 81C30F000000        <1>     add ebx, 0Fh
   468 000005C6 C1EB04              <1>     shr ebx, 4      ;And convert it to paragraphs
   469 000005C9 B800480000          <1>     mov eax, 4800h  ;ALLOC, set the owner below
   470 000005CE CD21                <1>     int 21h
   471 000005D0 726D                <1>     jc short .skipBuffers   ;If it fails to allocate, default to one buffer
   472                              <1>     ;Each buffer has no flags, drive number must be -1
   473 000005D2 4889D3              <1>     mov rbx, rdx    ;Put the total number of bytes per buffer in rbx
   474 000005D5 4889C7              <1>     mov rdi, rax    ;Point rdi to the new area 
   475 000005D8 482D10000000        <1>     sub rax, mcb.program    ;Point rax to the head of the mcb
   476 000005DE 48C7400108000000    <1>     mov qword [rax + mcb.owner], mcbOwnerDOS    ;Mark as owned by DOS
   477 000005E6 C6400D42            <1>     mov byte [rax + mcb.subSysMark], mcbSubBuffers  ;Buffer buffer (funny)
   478 000005EA 64488B0425-         <1>     mov rax, qword fs:[bufHeadPtr]  ;Get the pointer to the first buffer
   478 000005EF [00000000]          <1>
   479 000005F3 488938              <1>     mov qword [rax + bufferHdr.nextBufPtr], rdi ;And set the new next buffer to point to it
   480 000005F6 4889FE              <1>     mov rsi, rdi    ;Points rsi to first new buffer space
   481 000005F9 31C0                <1>     xor eax, eax    ;Use for sanitising buffer headers
   482 000005FB FFC9                <1>     dec ecx         ;Reduce to convert from 1 based count to 0 based
   483 000005FD 67E321              <1>     jecxz .lastBuffer
   484                              <1> .bufferLoop:
   485 00000600 4801DF              <1>     add rdi, rbx    ;Goto next buffer space
   486 00000603 48893E              <1>     mov qword [rsi + bufferHdr.nextBufPtr], rdi ;Point to next buffer
   487 00000606 66C74608FF00        <1>     mov word [rsi + bufferHdr.driveNumber], 00FFh  ;Free buffer and clear flags
   488 0000060C 4889460A            <1>     mov qword [rsi + bufferHdr.bufferLBA], rax
   489 00000610 884612              <1>     mov byte [rsi + bufferHdr.bufFATcopy], al
   490 00000613 894613              <1>     mov dword [rsi + bufferHdr.bufFATsize], eax
   491 00000616 48894617            <1>     mov qword [rsi + bufferHdr.driveDPBPtr], rax
   492 0000061A 4889FE              <1>     mov rsi, rdi    ;Move rsi to next buffer position
   493 0000061D FFC9                <1>     dec ecx
   494 0000061F 75DF                <1>     jnz .bufferLoop
   495                              <1> .lastBuffer:
   496 00000621 4801DF              <1>     add rdi, rbx    ;Goto past the last buffer
   497 00000624 48C706FFFFFFFF      <1>     mov qword [rsi + bufferHdr.nextBufPtr], -1 ;Point to no buffer
   498 0000062B 66C74608FF00        <1>     mov word [rsi + bufferHdr.driveNumber], 00FFh  ;Free buffer and clear flags
   499 00000631 4889460A            <1>     mov qword [rsi + bufferHdr.bufferLBA], rax
   500 00000635 884612              <1>     mov byte [rsi + bufferHdr.bufFATcopy], al
   501 00000638 894613              <1>     mov dword [rsi + bufferHdr.bufFATsize], eax
   502 0000063B 48894617            <1>     mov qword [rsi + bufferHdr.driveDPBPtr], rax
   503                              <1> .skipBuffers:
   504                              <1> ;Now build a new SFT header for the number of files specified by user
   505 0000063F 488B4DF0            <1>     mov rcx, qword [rbp - cfgFrame.newSFTVal]
   506 00000643 81F905000000        <1>     cmp ecx, 5  ;If we are not adding anything, skip building SFT
   507 00000649 7663                <1>     jbe short .skipSFT
   508                              <1>     ;First compute how big this new arena needs to be
   509 0000064B 81E905000000        <1>     sub ecx, 5   ;Remove the default five files that are *always* present!
   510 00000651 B857000000          <1>     mov eax, sft_size
   511 00000656 F7E1                <1>     mul ecx ;Get number of files*size of file in bytes in eax
   512 00000658 050A000000          <1>     add eax, sfth_size  ;Add the size of one SFT header
   513 0000065D 89C3                <1>     mov ebx, eax        ;And move into ebx for the syscall
   514 0000065F 81C30F000000        <1>     add ebx, 0Fh        ;Round up to nearest paragraph...
   515 00000665 C1EB04              <1>     shr ebx, 4          ;And convert to paragraphs
   516 00000668 B800480000          <1>     mov eax, 4800h      ;ALLOC, set the owner below
   517 0000066D CD21                <1>     int 21h
   518 0000066F 723D                <1>     jc short .skipSFT   ;Skip adding files if this fails. Sorry end user!
   519 00000671 64488B3425-         <1>     mov rsi, qword fs:[sftHeadPtr]
   519 00000676 [00000000]          <1>
   520 0000067A 488906              <1>     mov qword [rsi + sfth.qNextSFTPtr], rax ;RAX points to the next sfth
   521 0000067D 66894808            <1>     mov word [rax + sfth.wNumFiles], cx ;Move remaining files here
   522 00000681 48C700FFFFFFFF      <1>     mov qword [rax + sfth.qNextSFTPtr], -1  ;Last table in chain    
   523 00000688 482D10000000        <1>     sub rax, mcb.program    ;Point to MCB now
   524 0000068E 48C7400108000000    <1>     mov qword [rax + mcb.owner], mcbOwnerDOS
   525 00000696 C6400D46            <1>     mov byte [rax + mcb.subSysMark], mcbSubFiles
   526                              <1>     ;Point rdi to first sft in this arena
   527 0000069A 488D781A            <1>     lea rdi, qword [rax + sfth_size + mcb_size]
   528                              <1> .initExtraSFTs:
   529 0000069E 66C7070000          <1>     mov word [rdi], 0
   530 000006A3 4881C757000000      <1>     add rdi, sft_size   ;Goto next SFT
   531 000006AA FFC9                <1>     dec ecx
   532 000006AC 75F0                <1>     jnz .initExtraSFTs  ;Remember uop hybridisation (don't use loop)
   533                              <1> .skipSFT:
   534                              <1> ;FCBS now
   535 000006AE 488B4DE8            <1>     mov rcx, qword [rbp - cfgFrame.newFCBSVal]
   536 000006B2 67E346              <1>     jecxz .skipFCBS ;Skip if no FCBS requested
   537 000006B5 B857000000          <1>     mov eax, sft_size
   538 000006BA F7E1                <1>     mul ecx ;Get number of files*size of file in bytes in eax
   539 000006BC 050A000000          <1>     add eax, sfth_size  ;Add the size of one SFT header
   540 000006C1 89C3                <1>     mov ebx, eax        ;And move into ebx for the syscall
   541 000006C3 81C30F000000        <1>     add ebx, 0Fh        ;Round up to nearest paragraph...
   542 000006C9 C1EB04              <1>     shr ebx, 4          ;And convert to paragraphs
   543 000006CC B800480000          <1>     mov eax, 4800h      ;ALLOC, set the owner below
   544 000006D1 CD21                <1>     int 21h
   545 000006D3 7226                <1>     jc short .skipFCBS   ;Skip adding files if this fails. Sorry end user!
   546 000006D5 6448890425-         <1>     mov qword fs:[fcbsHeadPtr], rax ;This is the FCBS head now
   546 000006DA [00000000]          <1>
   547 000006DE 66894808            <1>     mov word [rax + sfth.wNumFiles], cx ;Move FCBS here
   548 000006E2 48C700FFFFFFFF      <1>     mov qword [rax + sfth.qNextSFTPtr], -1  ;Last table in chain  
   549 000006E9 482D10000000        <1>     sub rax, mcb.program    ;Point to MCB now
   550 000006EF 48C7400108000000    <1>     mov qword [rax + mcb.owner], mcbOwnerDOS
   551 000006F7 C6400D58            <1>     mov byte [rax + mcb.subSysMark], mcbSubFCBS
   552                              <1> .skipFCBS:
   553                              <1> ;And CDS now
   554 000006FB 488B4DD8            <1>     mov rcx, qword [rbp - cfgFrame.newLastdrive]
   555                              <1>     ;First free the old CDS and then reallocate. If nothing changed, DOS
   556                              <1>     ; will reallocate this space. This is done to create CDS's for any newly
   557                              <1>     ; installed drives from CONFIG.SYS
   558 000006FF 644C8B0425-         <1>     mov r8, qword fs:[cdsHeadPtr]
   558 00000704 [00000000]          <1>
   559 00000708 B800490000          <1>     mov eax, 4900h  ;FREE the old allocation, owned by mcbOwnerDOS.
   560 0000070D CD21                <1>     int 21h
   561 0000070F 720D                <1>     jc short .skipCDS
   562 00000711 64880C25[00000000]  <1>     mov byte fs:[lastdrvNum], cl ;Save this value
   563 00000719 E8F3FCFFFF          <1>     call makeCDSArray
   564                              <1> .skipCDS:
   565 0000071E 4889EC              <1>     mov rsp, rbp    ;Return stack pointer to original position
   566 00000721 5D                  <1>     pop rbp ;Stack frame no longer needed
   567                              <1> ;Now we close all five default handles and open AUX, CON and PRN
   568                              <1> ; and reopen the handles as user may have loaded new CON/AUX/PRN etc drivers
   569 00000722 31DB                <1>     xor ebx, ebx
   570                              <1> closeHandlesLoop:
   571 00000724 B8003E0000          <1>     mov eax, 3e00h  ;Close
   572 00000729 CD21                <1>     int 21h
   573 0000072B FFC3                <1>     inc ebx ;Goto next handle
   574 0000072D 81FB06000000        <1>     cmp ebx, 6
   575 00000733 75EF                <1>     jne closeHandlesLoop
   576 00000735 E8F7000000          <1>     call openStreams
   577                              <1> l1:
   578 0000073A BB00100000          <1>     mov ebx, 1000h  ;Get a 64Kb block
   579 0000073F B800480000          <1>     mov eax, 4800h  ;Allocate the memory block
   580 00000744 CD21                <1>     int 21h         ;Malloc and get pointer in rbx
   581 00000746 0F8294000000        <1>     jc badMem
   582 0000074C 4889C3              <1>     mov rbx, rax    ;Get pointer to block header to set owner to DOS
   583 0000074F 4881EB10000000      <1>     sub rbx, mcb_size
   584 00000756 48C7430108000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerDOS
   585 0000075E 488905(D1010000)    <1>     mov qword [OEMMEMPTR], rax   ;Save the pointer here
   586 00000765 4C8D05(1C020000)    <1>     lea r8, tempPSP ;Get the DOS PSP pointer to r8
   587 0000076C 4989C1              <1>     mov r9, rax  ;Copy the Memory arena pointer to r9
   588                              <1>     ;Input: r8 = PSP
   589                              <1>     ;       r9 = Memory Arena Pointer
   590                              <1>     ;All regs must be preserved (including r9, even if you free. Dont free!)
   591 0000076F E8(00000000)        <1>     call OEMCALLBK  ;Return CF=CY if OEM wants to keep the memory block
   592 00000774 720E                <1>     jc short l2 
   593 00000776 4C8B05(D1010000)    <1>     mov r8, qword [OEMMEMPTR]
   594 0000077D B800490000          <1>     mov eax, 4900h  ;Free the memory block
   595 00000782 CD21                <1>     int 21h
   596                              <1> l2:
   597                              <1> ;Load Shell now
   598 00000784 488D1545000000      <1>     lea rdx, initBadRet
   599 0000078B B822250000          <1>     mov eax, 2522h  ;Setup the return address if the top level process dies
   600 00000790 CD21                <1>     int 21h
   601 00000792 488D1D(FC010000)    <1>     lea rbx, cmdBlock
   602 00000799 488D35(1C020000)    <1>     lea rsi, tempPSP
   603 000007A0 488D465C            <1>     lea rax, qword [rsi + psp.fcb1]
   604 000007A4 48894310            <1>     mov qword [rbx + execProg.pfcb1], rax
   605 000007A8 488D466C            <1>     lea rax, qword [rsi + psp.fcb2]
   606 000007AC 48894318            <1>     mov qword [rbx + execProg.pfcb2], rax
   607 000007B0 488D8680000000      <1>     lea rax, qword [rsi + psp.dta]  ;Get the dummy command line ptr
   608 000007B7 48894308            <1>     mov qword [rbx + execProg.pCmdLine], rax    ;Store dummy command line here
   609 000007BB 48C70300000000      <1>     mov qword [rbx + execProg.pEnv], 0  ;Pass a zero to indicate initial load!
   610 000007C2 488D15(54000000)    <1>     lea rdx, cmdSpec
   611 000007C9 B8004B0000          <1>     mov eax, 4B00h  ;Exec Prog
   612 000007CE CD21                <1>     int 21h
   613                              <1> initBadRet:
   614 000007D0 488D15(16000000)    <1>     lea rdx, badCom
   615 000007D7 B409                <1>     mov ah, 09h ;Print message
   616 000007D9 CD21                <1>     int 21h
   617                              <1> hltLbl:
   618 000007DB F4                  <1>     hlt
   619 000007DC F390                <1>     pause
   620 000007DE EBFB                <1>     jmp short hltLbl
   621                              <1> badMem:
   622 000007E0 488D1509000000      <1>     lea rdx, memErr
   623 000007E7 B800090000          <1>     mov eax, 0900h
   624 000007EC CD21                <1>     int 21h
   625 000007EE EBEB                <1>     jmp short hltLbl
   626 000007F0 53797374656D204D65- <1> memErr  db "System Memory Error",0Ah,0Dh,"$"
   626 000007F9 6D6F7279204572726F- <1>
   626 00000802 720A0D24            <1>
   627                              <1> 
   628                              <1> ;--------------------------------------------------------;
   629                              <1> ;--------------------------------------------------------;
   630                              <1> ;                Procedures for SYSINIT                  ;
   631                              <1> ;--------------------------------------------------------;
   632                              <1> ;--------------------------------------------------------;
   633                              <1> 
   634                              <1> sectorSizeSet:
   635                              <1> ;Done by reading DPB's for each drive
   636 00000806 31C0                <1>     xor eax, eax
   637 00000808 64488B1425-         <1>     mov rdx, qword fs:[dpbHeadPtr]  ;Get ptr to first DPB
   637 0000080D [00000000]          <1>
   638                              <1>     ;Go thru each block individually
   639                              <1> .findLargest:
   640 00000811 663B4202            <1>     cmp ax, word [rdx + dpb.wBytesPerSector]    ;Is current bigger than max?
   641 00000815 660F424202          <1>     cmovb ax, word [rdx + dpb.wBytesPerSector]  ;Move if so
   642 0000081A 488B5225            <1>     mov rdx, qword [rdx + dpb.qNextDPBPtr]  ;Goto next DPB
   643 0000081E 4881FAFFFFFFFF      <1>     cmp rdx, -1 ;We at the end?
   644 00000825 75EA                <1>     jne short .findLargest  ;If not, keep checking
   645 00000827 6466890425-         <1>     mov word fs:[maxBytesSec], ax
   645 0000082C [00000000]          <1>
   646                              <1>     return
    13                              <2> %%_ret:
    14 00000830 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   647                              <1> 
   648                              <1> openStreams:
   649                              <1> ;If this returns with CF=CY, an error occured.
   650 00000831 488D15(41000000)    <1>     lea rdx, auxName
   651 00000838 B8023D0000          <1>     mov eax, 3D02h   ;Open read/write
   652 0000083D CD21                <1>     int 21h
   653                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000083F 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000841 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   654 00000842 89C3                <1>     mov ebx, eax
   655 00000844 B903000000          <1>     mov ecx, 3  ;
   656 00000849 B800460000          <1>     mov eax, 4600h  ;DUP2
   657 0000084E CD21                <1>     int 21h
   658                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000850 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000852 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   659 00000853 B8003E0000          <1>     mov eax, 3e00h
   660 00000858 CD21                <1>     int 21h ;Close the original handle
   661                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000085A 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000085C C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   662 0000085D B8023D0000          <1>     mov eax, 3D02h  ;Open read/write
   663 00000862 488D15(3D000000)    <1>     lea rdx, conName
   664 00000869 CD21                <1>     int 21h
   665                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000086B 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000086D C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   666 0000086E 89C3                <1>     mov ebx, eax    ;Move file handle to ebx
   667 00000870 B800450000          <1>     mov eax, 4500h  ;DUP
   668 00000875 CD21                <1>     int 21h
   669                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000877 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000879 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   670 0000087A B800450000          <1>     mov eax, 4500h  ;DUP
   671 0000087F CD21                <1>     int 21h
   672                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000881 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000883 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   673 00000884 488D15(45000000)    <1>     lea rdx, prnName
   674 0000088B B8023D0000          <1>     mov eax, 3D02h
   675 00000890 CD21                <1>     int 21h       ;Open file
   676                              <1>     return
    13                              <2> %%_ret:
    14 00000892 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   677                              <1> 
   678                              <1> addDriverMarkers:
   679                              <1> ;Traverses the MCB chain after a driver init to add the correct subsytem 
   680                              <1> ; information and owner to each memory block. Used for drivers that allocate
   681                              <1> ; their own memory using ALLOC.
   682                              <1> ;All drivers (kernel and config) initialise using sysinit's own PSP. Thus
   683                              <1> ; any allocations made during this time result in arenas with owner 
   684                              <1> ; of qword [currentPSP]. We replace each such owner with mcbOwnerDOS and
   685                              <1> ; set the subsytem mark to driver extra. This works because in config.sys
   686                              <1> ; we load the driver into its own arena first and modify the MCB manually.
   687                              <1> ;Kernel drivers dont have a separate allocation so any allocation after 
   688                              <1> ; init must be an extra block.
   689                              <1> ;Input: Nothing
   690                              <1> ;Output: Sets all MCBs with currentPSP owner to mcbOwnerDOS and mcbSubDrvExtra
   691 00000893 50                  <1>     push rax
   692 00000894 56                  <1>     push rsi
   693 00000895 57                  <1>     push rdi
   694 00000896 488BBD[00000000]    <1>     mov rdi, qword [rbp + currentPSP]
   695 0000089D 488BB5[00000000]    <1>     mov rsi, qword [rbp + mcbChainPtr] ;Points to the kernel allocation
   696 000008A4 EB0E                <1>     jmp short .gotoNextBlock    ;Skip the first alloc (the kernel)
   697                              <1> .checkSubsystem:
   698 000008A6 48397E01            <1>     cmp qword [rsi + mcb.owner], rdi
   699 000008AA 7508                <1>     jne short .gotoNextBlock
   700                              <1> ;Twiddle this newly allocated block!
   701 000008AC C6460D4C            <1>     mov byte [rsi + mcb.subSysMark], mcbSubDrvExtra
   702 000008B0 C6460108            <1>     mov byte [rsi + mcb.owner], mcbOwnerDOS
   703                              <1> .gotoNextBlock:
   704 000008B4 803E5A              <1>     cmp byte [rsi + mcb.marker], mcbMarkEnd
   705 000008B7 7413                <1>     je short .exit
   706 000008B9 8B4609              <1>     mov eax, dword [rsi + mcb.blockSize]
   707 000008BC 48C1E004            <1>     shl rax, 4
   708 000008C0 4881C610000000      <1>     add rsi, mcb.program    
   709 000008C7 4801C6              <1>     add rsi, rax
   710 000008CA EBDA                <1>     jmp short .checkSubsystem
   711                              <1> .exit:
   712 000008CC 5F                  <1>     pop rdi
   713 000008CD 5E                  <1>     pop rsi
   714 000008CE 58                  <1>     pop rax
   715                              <1>     return
    13                              <2> %%_ret:
    14 000008CF C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   716                              <1> 
   717                              <1> convertBPBArray:
   718                              <1> ;rsi -> BPB array
   719                              <1> ;rbp -> Space for cl consecutive DPB's
   720                              <1> ;rdi -> Driver header
   721                              <1> ;cl = Number of BPBs to process
   722                              <1> ;If ZF=NZ on entry, link the end of the last DPB array 
   723 000008D0 E855000000          <1>     call .findLastDPB
   724 000008D5 0FB6C9              <1>     movzx ecx, cl   ;Use ch as the unit number counter
   725                              <1> .buildNext:
   726 000008D8 640FB60425-         <1>     movzx eax, byte fs:[numPhysVol] ;Get current # drives
   726 000008DD [00000000]          <1>
   727 000008E1 884500              <1>     mov byte [rbp + dpb.bDriveNumber], al   ;Set it as drvnum
   728 000008E4 64FE0425[00000000]  <1>     inc byte fs:[numPhysVol]    ;One more physical volume present!
   729 000008EC 886D01              <1>     mov byte [rbp + dpb.bUnitNumber], ch    ;Set unit number
   730 000008EF 48897D1B            <1>     mov qword [rbp + dpb.qDriverHeaderPtr], rdi ;Store ptr to driver
   731                              <1> 
   732 000008F3 56                  <1>     push rsi
   733 000008F4 488B36              <1>     mov rsi, qword [rsi]    ;Get the BPB pointer from the BPB array
   734 000008F7 B800530000          <1>     mov eax, 5300h ;Build DPB
   735 000008FC CD21                <1>     int 21h
   736 000008FE 5E                  <1>     pop rsi
   737                              <1> 
   738 000008FF FEC5                <1>     inc ch  ;Goto next unit number
   739 00000901 38E9                <1>     cmp cl, ch  ;When equal, exit!
   740 00000903 7414                <1>     jz short .exit
   741 00000905 488D4535            <1>     lea rax, qword [rbp + dpb_size]
   742 00000909 48894525            <1>     mov qword [rbp + dpb.qNextDPBPtr], rax
   743 0000090D 4889C5              <1>     mov rbp, rax    ;Advance rbp by that amount
   744 00000910 4881C608000000      <1>     add rsi, 8 ;Go to the next BPB in the BPB array
   745 00000917 EBBF                <1>     jmp short .buildNext
   746                              <1> .exit:
   747                              <1>     ;Now set next DPB as -1 i.e end of chain!
   748 00000919 31C0                <1>     xor eax, eax
   749 0000091B 48FFC8              <1>     dec rax
   750 0000091E 48894525            <1>     mov qword [rbp + dpb.qNextDPBPtr], rax
   751 00000922 4881C535000000      <1>     add rbp, dpb_size   ;Point rbp past the next DPB
   752 00000929 C3                  <1>     ret
   753                              <1> .findLastDPB:
   754                              <1> ;Finds the last DPB and links the next DPB to it
   755 0000092A 64488B0425-         <1>     mov rax, qword fs:[dpbHeadPtr]
   755 0000092F [00000000]          <1>
   756 00000933 4885C0              <1>     test rax, rax
   757 00000936 7415                <1>     jz short .first 
   758                              <1> .lp:
   759 00000938 48817825FFFFFFFF    <1>     cmp qword [rax + dpb.qNextDPBPtr], -1   ;End of chain?
   760 00000940 7406                <1>     je short .lastFound
   761 00000942 488B4025            <1>     mov rax, qword [rax + dpb.qNextDPBPtr]  ;Get this pointer in rax
   762 00000946 EBF0                <1>     jmp short .lp   ;And go again
   763                              <1> .lastFound:
   764 00000948 48896825            <1>     mov qword [rax + dpb.qNextDPBPtr], rbp  ;The next dpb will go here
   765 0000094C C3                  <1>     ret
   766                              <1> .first:
   767                              <1> ;If this is the first DPB array, set the dpbHeadPtr
   768 0000094D 6448892C25-         <1>     mov qword fs:[dpbHeadPtr], rbp
   768 00000952 [00000000]          <1>
   769 00000956 C3                  <1>     ret
   770                              <1> 
   771                              <1> ejectKernelInit:
   772                              <1> ;Reallocates the space allocated to the driver file after 
   773                              <1> ; init was called.
   774                              <1> ;Input: rbx -> Pointer to the original end of the allocation (para aligned)
   775                              <1> ;       r8 -> Points to the mcb header for reallocation
   776                              <1> ;Uses the sysinit init drive block. 
   777                              <1> ;rax, rbx, rflags trashed
   778                              <1> ;If returns CF=CY, error in reallocation.
   779 00000957 53                  <1>     push rbx
   780 00000958 488D1D(DD010000)    <1>     lea rbx, initDrvBlk
   781 0000095F 488B430E            <1>     mov rax, qword [rbx + initReqPkt.endptr]
   782 00000963 5B                  <1>     pop rbx
   783                              <1>     ;If this endptr is zero or -1 ignore it. 
   784                              <1>     ;If this endptr is greater than the end of alloc, ignore it.
   785 00000964 4885C0              <1>     test rax, rax
   786                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000967 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000969 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   787 0000096A 48FFC0              <1>     inc rax ;Carry over to 0 if this is -1
   788                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000096D 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000096F C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   789 00000970 48FFC8              <1>     dec rax ;Return to original value
   790 00000973 48050F000000        <1>     add rax, 0Fh    ;Paragraph align the endptr
   791 00000979 48C1E804            <1>     shr rax, 4
   792 0000097D 48C1E004            <1>     shl rax, 4
   793 00000981 4829C3              <1>     sub rbx, rax    ;If this is above zero then rbx > rax, which is valid
   794 00000984 7621                <1>     jbe short .exit   ;If equal or below zero, dont reallocate
   795 00000986 418B80[09000000]    <1>     mov eax, dword [r8 + anchorMcb + mcb.blockSize]    ;Get alloc size
   796 0000098D 4150                <1>     push r8 ;Save the pointer to the mcb before using syscall
   797 0000098F 4981C010000000      <1>     add r8, mcb.program ;Goto program
   798 00000996 C1EB04              <1>     shr ebx, 4  ;Now convert the difference into number of paragraphs
   799 00000999 29D8                <1>     sub eax, ebx
   800 0000099B 89C3                <1>     mov ebx, eax
   801 0000099D B8004A0000          <1>     mov eax, 4A00h  ;Reallocate space
   802 000009A2 CD21                <1>     int 21h
   803 000009A4 4158                <1>     pop r8
   804                              <1>     return
    13                              <2> %%_ret:
    14 000009A6 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   805                              <1> .exit:
   806 000009A7 F8                  <1>     clc ;Make sure to clear the CF flag before returning
   807                              <1>     return
    13                              <2> %%_ret:
    14 000009A8 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   808                              <1> 
   809                              <1> initDriver:
   810                              <1> ;Initialises one driver and adjusts the DOS data appropriately
   811                              <1> ;If on return CF=CY then the driver didnt want to be loaded
   812                              <1> ;Preserves rbx (initReqPkt), rbp (DOSSEG ptr), rsi (driver pointer)
   813                              <1> ;initReqPkt.optptr must be set before calling this function if cmdline
   814                              <1> ; arguments are to be passed to the driver
   815                              <1> ;Input: rsi -> driver pointer
   816                              <1> ;       rbx -> sysinit request pointer
   817                              <1> ;       rbp -> DOSSEG pointer
   818 000009A9 C6031F              <1>     mov byte [rbx + initReqPkt.hdrlen], initReqPkt_size
   819 000009AC C6430200            <1>     mov byte [rbx + initReqPkt.cmdcde], drvINIT
   820 000009B0 66C743030000        <1>     mov word [rbx + initReqPkt.status], 0
   821 000009B6 8A85[00000000]      <1>     mov al, byte [rbp + numPhysVol]    ;Get current num of physical volumes
   822 000009BC 88431E              <1>     mov byte [rbx + initReqPkt.drvnum], al
   823                              <1>     ;Protect the important registers. All others trashable
   824 000009BF 53                  <1>     push rbx
   825 000009C0 56                  <1>     push rsi
   826 000009C1 55                  <1>     push rbp
   827 000009C2 FF560A              <1>     call qword [rsi + drvHdr.strPtr]
   828 000009C5 FF5612              <1>     call qword [rsi + drvHdr.intPtr]
   829 000009C8 5D                  <1>     pop rbp
   830 000009C9 5E                  <1>     pop rsi
   831 000009CA 5B                  <1>     pop rbx
   832                              <1>     ;Check if a driver wants to not load.
   833                              <1>     ;If a kernel driver wants to stop, halt boot.
   834 000009CB 66F743030080        <1>     test word [rbx + initReqPkt.status], drvErrStatus
   835 000009D1 750C                <1>     jnz short .errExit
   836 000009D3 807B0D00            <1>     cmp byte [rbx + initReqPkt.numunt], 0
   837 000009D7 7508                <1>     jne short .notHalt
   838 000009D9 4839730E            <1>     cmp qword [rbx + initReqPkt.endptr], rsi    ;If endptr -> header, abort
   839 000009DD 7502                <1>     jne short .notHalt
   840                              <1> .errExit:
   841 000009DF F9                  <1>     stc
   842 000009E0 C3                  <1>     ret
   843                              <1> .notHalt:
   844                              <1>     ;Now check if the drivers were con/clock before exiting
   845 000009E1 668B4608            <1>     mov ax, word [rsi + drvHdr.attrib]
   846 000009E5 66250300            <1>     and ax, devDrvConIn | devDrvConOut
   847 000009E9 740D                <1>     jz short .checkClock    ;If neither one of these bits are set, jmp
   848 000009EB 663D0300            <1>     cmp ax, devDrvConIn | devDrvConOut
   849 000009EF 7507                <1>     jne short .checkClock
   850 000009F1 4889B5[00000000]    <1>     mov qword [rbp + vConPtr], rsi  ;Store the header ptr here
   851                              <1> .checkClock:
   852 000009F8 66F746080800        <1>     test word [rsi + drvHdr.attrib], devDrvClockDev
   853 000009FE 7407                <1>     jz short .notClock
   854 00000A00 4889B5[00000000]    <1>     mov qword [rbp + clockPtr], rsi
   855                              <1> .notClock:
   856                              <1> ;Now test if MSD driver. If so, store the number of units in the name field
   857 00000A07 66F746080080        <1>     test word [rsi + drvHdr.attrib], devDrvChar
   858                              <1>     retnz   ;Return if this is a char device
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000A0D 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000A0F C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   859                              <1>     ;Else, store the number of units as reported live by driver
   860 00000A10 0FB6430D            <1>     movzx eax, byte [rbx + initReqPkt.numunt] ;Get # units reported by driver
   861 00000A14 88461A              <1>     mov byte [rsi + drvHdr.drvUnt], al ;Store this byte permanently here
   862 00000A17 C3                  <1>     ret
   863                              <1> 
   864                              <1> buildKernDPBs:
   865                              <1> ;This is a wrapper for the below to be used ONLY FOR LOADING KERNEL DRIVERS. 
   866                              <1> ; If at boot time a FAT32 partition is detected, this otherwise would cause 
   867                              <1> ; the system to crash as build dpb requires at least one buffer in the buffer
   868                              <1> ; chain. So here we allocate one 4Kb buffer and place it in the chain. Once we 
   869                              <1> ; are done, we free this buffer.
   870 00000A18 50                  <1>     push rax
   871 00000A19 4150                <1>     push r8
   872 00000A1B B800480000          <1>     mov eax, 4800h  ;ALLOC, get ptr in rax
   873 00000A20 53                  <1>     push rbx
   874                              <1> ;100h for 4Kb + space for a buffer header!
   875 00000A21 BB02010000          <1>     mov ebx, 100h + ((bufferHdr_size + 0Fh) >> 4)
   876 00000A26 CD21                <1>     int 21h
   877 00000A28 5B                  <1>     pop rbx
   878 00000A29 7235                <1>     jc .exit
   879 00000A2B 4989C0              <1>     mov r8, rax
   880                              <1>     ;Setup MCB metadata
   881 00000A2E 41C640FD42          <1>     mov byte [r8 + mcb.subSysMark - mcb_size], mcbSubBuffers
   882                              <1>     ;Setup Buffer
   883 00000A33 49C700FFFFFFFF      <1>     mov qword [r8 + bufferHdr.nextBufPtr], -1
   884 00000A3A 49C74008FF000000    <1>     mov qword [r8 + bufferHdr.wDrvNumFlg], freeBuffer
   885 00000A42 4C8985[00000000]    <1>     mov qword [rbp + bufHeadPtr], r8
   886 00000A49 E816000000          <1>     call buildDPBs  ;Call function
   887 00000A4E 48C785[00000000]FF- <1>     mov qword [rbp + bufHeadPtr], -1    ;Now empty the buffer pointer
   887 00000A56 FFFFFF              <1>
   888 00000A59 B800490000          <1>     mov eax, 4900h  ;Free the ptr in r8
   889 00000A5E CD21                <1>     int 21h
   890                              <1> .exit:
   891 00000A60 4158                <1>     pop r8
   892 00000A62 58                  <1>     pop rax
   893                              <1>     return
    13                              <2> %%_ret:
    14 00000A63 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   894                              <1> buildDPBs:
   895                              <1>     ;Here we specially handle MSD drivers, building DPBs
   896                              <1>     ;If return with CF=CY, fail. Else, all done and setup
   897                              <1>     ;Input: rbx -> Points to sysinit request packet
   898                              <1>     ;       rsi -> Driver header
   899                              <1>     ;       rbp -> DOSSEG pointer
   900                              <1>     ;Preserves those registers
   901 00000A64 53                  <1>     push rbx
   902 00000A65 55                  <1>     push rbp
   903 00000A66 56                  <1>     push rsi
   904 00000A67 57                  <1>     push rdi
   905 00000A68 4889F7              <1>     mov rdi, rsi    ;SAVE THE DRIVER HEADER!
   906 00000A6B 0FB64E1A            <1>     movzx ecx, byte [rsi + drvHdr.drvUnt]  ;Get # of units reported by driver
   907 00000A6F 488B7316            <1>     mov rsi, qword [rbx + initReqPkt.optptr]
   908 00000A73 B835000000          <1>     mov eax, dpb_size
   909 00000A78 F7E1                <1>     mul ecx         ;Get the number of bytes for all the dpb's into eax
   910 00000A7A 050F000000          <1>     add eax, 0Fh    ;Round up if not precisely on para boundry
   911 00000A7F C1E804              <1>     shr eax, 4      ;Convert to paragraphs
   912 00000A82 89C3                <1>     mov ebx, eax
   913 00000A84 B800480000          <1>     mov eax, 4800h  ;ALLOC (marked as owned by DOS for now)
   914 00000A89 CD21                <1>     int 21h
   915 00000A8B 7214                <1>     jc short .exit
   916 00000A8D 4889C5              <1>     mov rbp, rax    
   917 00000A90 C640FD50            <1>     mov byte [rax + mcb.subSysMark - mcb_size], mcbSubDrvDPB  ;Set DPB marker
   918 00000A94 48C740F108000000    <1>     mov qword [rax + mcb.owner - mcb_size], mcbOwnerDOS    ;Set DOS owner
   919                              <1>     ;rsi -> Ptr to BPB array
   920                              <1> 	;rbp -> Ptr to buffer to hold first DPB
   921                              <1>     ;rdi -> Ptr to the driver header
   922 00000A9C E82FFEFFFF          <1>     call convertBPBArray    ;Returns rbp -> past last DPB
   923                              <1> .exit:
   924 00000AA1 5F                  <1>     pop rdi
   925 00000AA2 5E                  <1>     pop rsi
   926 00000AA3 5D                  <1>     pop rbp
   927 00000AA4 5B                  <1>     pop rbx
   928                              <1>     return
    13                              <2> %%_ret:
    14 00000AA5 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   929                              <1> 
   930                              <1> setupInterruptBlock:
   931                              <1> ;Sets up a block of interrupts with pointers provided in a table
   932                              <1> ;Input:
   933                              <1> ; al = Start interrupt
   934                              <1> ; rdi -> Start of pointer table
   935                              <1> ; cl = Last interrupt + 1
   936                              <1> ;Assumes rbp points to DOSSEG
   937 00000AA6 0FB6C0              <1>     movzx eax, al
   938 00000AA9 0FB6C9              <1>     movzx ecx, cl
   939                              <1> .lp:
   940 00000AAC 488B1F              <1>     mov rbx, qword [rdi]    ;Get address pointed to by rdi
   941 00000AAF 4801EB              <1>     add rbx, rbp            ;Add the relocated base to rbx
   942 00000AB2 E80E000000          <1>     call writeIDTEntry
   943 00000AB7 4881C708000000      <1>     add rdi, 8  ;Goto next interrupt handler
   944 00000ABE FFC0                <1>     inc eax     ;Goto next interrupt number
   945 00000AC0 39C8                <1>     cmp eax, ecx
   946 00000AC2 75E8                <1>     jne .lp
   947                              <1>     return
    13                              <2> %%_ret:
    14 00000AC4 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   948                              <1> 
   949                              <1> writeIDTEntry:
   950                              <1> ;Writes the interrupt in the right place in the table
   951                              <1>     ;al = Interrupt number
   952                              <1>     ;rbx -> Handler to install
   953 00000AC5 50                  <1>     push rax
   954 00000AC6 53                  <1>     push rbx
   955 00000AC7 0FB6C0              <1>     movzx eax, al
   956 00000ACA 4893                <1>     xchg rbx, rax
   957 00000ACC 48C1E304            <1>     shl rbx, 4h     ;Multiply IDT entry number by 16
   958 00000AD0 48031D(B4010000)    <1>     add rbx, qword [localIDTpointer.Base]    ;rsx points to IDT entry
   959 00000AD7 668903              <1>     mov word [rbx], ax  ;Get low word into offset 15...0
   960 00000ADA 48C1E810            <1>     shr rax, 10h    ;Bring next word low
   961 00000ADE 66894306            <1>     mov word [rbx + 6], ax  ;Get low word into offset 31...16
   962 00000AE2 48C1E810            <1>     shr rax, 10h    ;Bring last dword low
   963 00000AE6 894308              <1>     mov dword [rbx + 8], eax
   964 00000AE9 5B                  <1>     pop rbx
   965 00000AEA 58                  <1>     pop rax
   966 00000AEB C3                  <1>     ret
    21                                  %include "./src/dos/Sysinit/cfginit.asm"
     1                              <1> ;------------------------------------------------;
     2                              <1> ;              Process CONFIG.SYS                ;
     3                              <1> ;------------------------------------------------;
     4                              <1> ;Create a stack frame with the following order.
     5                              <1> ;Values greater than max are set to max. Values less than min are set to min.
     6                              <1> ; New Buffers value.        Default = 30, Min = 1, Max = 99
     7                              <1> ; New SFT value.            Default = 20, Min = 8, Max = 254
     8                              <1> ; New FCBS value.           Default = 4,  Min = 4, Max = 254
     9                              <1> ; New protected FCBS value. Default = 0,  Min = 0, Max = New FCBS value
    10                              <1> ; New CDS value.            Default = 5,  Min = 5, Max = 26
    11                              <1> ;
    12                              <1> ;Remember to maintain the base of occupied memory on stack (endPtr)
    13                              <1> ;-------------------------------------------------------------------------;
    14                              <1> ; CONFIG.SYS processing pseudocode:-
    15                              <1> ;
    16                              <1> ; _START:
    17                              <1> ; Read file one byte at a time a until a EOF or CR encountered.
    18                              <1> ; If (EOF encountered)
    19                              <1> ;   Insert a terminating ^Z to the end of the line. 
    20                              <1> ;   Close handle.
    21                              <1> ; Parse the line from beginning looking for a DOS terminating char.
    22                              <1> ;   If (CR or EOF encoutered before terminating char)
    23                              <1> ;       Bad line error msg. 
    24                              <1> ;       If (CR encountered)
    25                              <1> ;           Goto _START
    26                              <1> ;       Else
    27                              <1> ;           Goto _EXIT
    28                              <1> ;   Else 
    29                              <1> ;       If (Keyword AND not DEVICE) 
    30                              <1> ;           Store it's value on stack or change internal variable value
    31                              <1> ;       If (DEVICE)
    32                              <1> ;           Move endPtr after end of line and try load the driver.
    33                              <1> ;           If (driver doesn't exist or fails to init)
    34                              <1> ;               print bad driver error msg.
    35                              <1> ;       Else 
    36                              <1> ;           Bad line error msg
    37                              <1> ;       If (line terminated by CR)
    38                              <1> ;           Goto _START
    39                              <1> ; _EXIT:
    40                              <1> ;-------------------------------------------------------------------------;
    41                              <1> ; Note:
    42                              <1> ; If driver a Block Device Driver, build all the DPB's for it (up until max)
    43                              <1> ;   directly after the driver pointer as returned by the driver. Then, 
    44                              <1> ;   adjust the memory pointer and start loading next line.
    45                              <1> ; Once EOF has been reached, we jmp to noCfg which configures the other
    46                              <1> ;   data structures according to the values on the stack frame.
    47                              <1> ;-------------------------------------------------------------------------;
    48                              <1> ;Start CONFIG.SYS parsing here
    49                              <1> configParse:
    50 00000AEC 488945C0            <1>     mov qword [rbp - cfgFrame.cfgHandle], rax
    51 00000AF0 48C745B800000000    <1>     mov qword [rbp - cfgFrame.lastLine], 0
    52 00000AF8 48C745B0FFFFFFFF    <1>     mov qword [rbp - cfgFrame.linePtr], -1   ;Default buffer
    53 00000B00 B800480000          <1>     mov eax, 4800h
    54 00000B05 BB10000000          <1>     mov ebx, 10h    ;Request 16 paragraphs (256 bytes)
    55 00000B0A CD21                <1>     int 21h
    56 00000B0C 0F825D010000        <1>     jc .stopProcessError
    57 00000B12 488945B0            <1>     mov qword [rbp - cfgFrame.linePtr], rax
    58 00000B16 4889C2              <1>     mov rdx, rax    ;Move the pointer to rdx
    59 00000B19 482D10000000        <1>     sub rax, mcb_size 
    60 00000B1F 48C7400108000000    <1>     mov qword [rax + mcb.owner], mcbOwnerDOS    ;Set owner to DOS
    61 00000B27 31C0                <1>     xor eax, eax
    62                              <1> .nextChar:
    63 00000B29 488B5DC0            <1>     mov rbx, qword [rbp - cfgFrame.cfgHandle]   ;Move the handle into ebx
    64 00000B2D 6681FBFFFF          <1>     cmp bx, -1
    65 00000B32 0F8437010000        <1>     je .stopProcessError
    66 00000B38 B8003F0000          <1>     mov eax, 3F00h  ;Read handle
    67 00000B3D B901000000          <1>     mov ecx, 1  ;Read one byte
    68 00000B42 CD21                <1>     int 21h
    69 00000B44 0F8225010000        <1>     jc .stopProcessError
    70 00000B4A 85C0                <1>     test eax, eax	;If this is zero, EOF reached, take command
    71 00000B4C 741B                <1>     jz .endOfFile
    72                              <1> .notEOF:
    73 00000B4E 0FB602              <1>     movzx eax, byte [rdx]
    74 00000B51 3C0D                <1>     cmp al, CR
    75 00000B53 741F                <1>     je short .endOfLine
    76 00000B55 3C0A                <1>     cmp al, LF
    77 00000B57 7418                <1>     je short .endOfLineChange   ;Continue, but replace with standard EOL char (CR)
    78 00000B59 3C1A                <1>     cmp al, EOF
    79 00000B5B 740C                <1>     je short .endOfFile
    80 00000B5D E873070000          <1>     call .ucChar    ;Uppercase the char
    81 00000B62 8802                <1>     mov byte [rdx], al  ;Replace the char with the capitalised form
    82                              <1> .notChar:
    83 00000B64 48FFC2              <1>     inc rdx ;Now move our local pointer to the next byte
    84 00000B67 EBC0                <1>     jmp short .nextChar
    85                              <1> .endOfFile:
    86 00000B69 48C745B8FFFFFFFF    <1>     mov qword [rbp - cfgFrame.lastLine], -1	;Mark EOF and End of line
    87                              <1> .endOfLineChange:
    88 00000B71 C6020D              <1>     mov byte [rdx], CR  ;Store a terminating char at the end of the command
    89                              <1> .endOfLine:
    90                              <1> ;rdx points to terminating char
    91                              <1> ;First find the length of the instruction word
    92 00000B74 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
    93                              <1> ;If this is a 1 char line, skip processing (as it is CR), and goto next line
    94 00000B78 4839F2              <1>     cmp rdx, rsi
    95 00000B7B 7473                <1>     je .cmdPrepNew
    96 00000B7D E8D5000000          <1>     call .skipSeparators  ;Skip any standard leading separators
    97 00000B82 31C9                <1>     xor ecx, ecx
    98                              <1> .cmdNameLenGet:
    99 00000B84 AC                  <1>     lodsb
   100 00000B85 E8B6000000          <1>     call .isCharSeparator
   101 00000B8A 740A                <1>     jz short .endOfCommandFound
   102 00000B8C FFC1                <1>     inc ecx
   103 00000B8E 81F90A000000        <1>     cmp ecx, 10 ;If shorter than longest command, keep looping
   104 00000B94 72EE                <1>     jb short .cmdNameLenGet
   105                              <1> ;Else, fall through in error
   106                              <1> .endOfCommandFound:
   107                              <1> ;ecx has the length of the command
   108 00000B96 81F90A000000        <1>     cmp ecx, 10
   109 00000B9C 0F84C3000000        <1>     je .badLineHandle
   110 00000BA2 488D3D69010000      <1>     lea rdi, .keyTbl ;Put rdi at the table to search for
   111                              <1> .cmdSearch:
   112 00000BA9 803FFF              <1>     cmp byte [rdi], -1
   113 00000BAC 0F84B3000000        <1>     je .badLineHandle
   114 00000BB2 380F                <1>     cmp byte [rdi], cl
   115 00000BB4 757A                <1>     jne short .gotoNextCmd
   116                              <1>     ;Candidate command found, check said command is the command we want
   117 00000BB6 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
   118 00000BBA 4881FEFFFFFFFF      <1>     cmp rsi, -1 ;Error?
   119 00000BC1 0F84A8000000        <1>     je .stopProcessError
   120 00000BC7 57                  <1>     push rdi
   121 00000BC8 51                  <1>     push rcx
   122 00000BC9 48FFC7              <1>     inc rdi ;Go to next char
   123 00000BCC F3A6                <1>     repe cmpsb  ;Compare whilst the strings are equal
   124 00000BCE 59                  <1>     pop rcx
   125 00000BCF 5F                  <1>     pop rdi
   126 00000BD0 755E                <1>     jne short .gotoNextCmd    ;If not equal, just goto next command
   127                              <1>     ;Else, rdi points to the table entry from the head of the table
   128                              <1>     ;      rcx has the length of the name field
   129                              <1>     ;rdx points to the terminating char of the line 
   130 00000BD2 488D3539010000      <1>     lea rsi, .keyTbl
   131 00000BD9 4889F0              <1>     mov rax, rsi    ;Keep a copy in rax
   132 00000BDC 480FB7740F01        <1>     movzx rsi, word [rdi + rcx + 1]
   133 00000BE2 4801C6              <1>     add rsi, rax    ;So add the EA of the head of the tbl before calling
   134 00000BE5 F8                  <1>     clc ;Ensure flags are happy before entering
   135 00000BE6 55                  <1>     push rbp
   136 00000BE7 FFD6                <1>     call rsi    ;Call this function
   137 00000BE9 5D                  <1>     pop rbp
   138 00000BEA 0F8284000000        <1>     jc .stopProcessErrorNoPrint    ;If the function returns CF=CY, error exit
   139                              <1> .cmdPrepNew:
   140 00000BF0 48F745B8FFFFFFFF    <1>     test qword [rbp - cfgFrame.lastLine], -1 ;If we concluded at EOF, exit
   141 00000BF8 0F85C0060000        <1>     jnz .cfgExit
   142 00000BFE 488B55B0            <1>     mov rdx, qword [rbp - cfgFrame.linePtr] ;Start reading afresh
   143                              <1>     ;Read the next char. 
   144                              <1>     ;If EOF, exit.
   145                              <1>     ;Else if, LF, proceed to read line routine.
   146                              <1>     ;Else, advance ptr by one and proceed to process char
   147                              <1> .endCommandClear:
   148 00000C02 488B5DC0            <1>     mov rbx, qword [rbp - cfgFrame.cfgHandle]   ;Move the handle into rbx
   149 00000C06 B8003F0000          <1>     mov eax, 3F00h  ;Read handle
   150 00000C0B B901000000          <1>     mov ecx, 1  ;Read one byte to clear the LF from the file
   151 00000C10 CD21                <1>     int 21h
   152 00000C12 725B                <1>     jc .stopProcessError
   153 00000C14 85C0                <1>     test eax, eax   ;If no chars were read, exit!
   154 00000C16 0F84A2060000        <1>     jz .cfgExit
   155                              <1>     ;Do a trash check
   156 00000C1C 8A02                <1>     mov al, byte [rdx]
   157 00000C1E 3C1A                <1>     cmp al, EOF
   158 00000C20 0F8498060000        <1>     je .cfgExit
   159 00000C26 3C0A                <1>     cmp al, LF
   160 00000C28 0F84FBFEFFFF        <1>     je .nextChar
   161 00000C2E EBD2                <1>     jmp short .endCommandClear  ;Loop out trailing spaces, crap chars and CR
   162                              <1> ;CONFIG.SYS utility functions
   163                              <1> .gotoNextCmd:
   164 00000C30 0FB607              <1>     movzx eax, byte [rdi]
   165 00000C33 0503000000          <1>     add eax, 3
   166 00000C38 4801C7              <1>     add rdi, rax
   167 00000C3B E969FFFFFF          <1>     jmp .cmdSearch
   168                              <1> .isCharSeparator:
   169                              <1> ;Input: AL = Char to check
   170                              <1> ;Output: ZF=ZE -> Char terminal
   171                              <1> ;        ZF=NZ -> Char not terminal
   172 00000C40 3C3D                <1>     cmp al, "="
   173                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000C42 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000C44 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   174 00000C45 3C20                <1>     cmp al, SPC
   175                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000C47 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000C49 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   176 00000C4A 3C09                <1>     cmp al, TAB
   177                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000C4C 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000C4E C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   178 00000C4F 3C3B                <1>     cmp al, ";"
   179                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000C51 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000C53 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   180 00000C54 3C2C                <1>     cmp al, ","
   181                              <1>     return
    13                              <2> %%_ret:
    14 00000C56 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   182                              <1> .skipSeparators:
   183                              <1> ;Input: rsi -> Start of string
   184                              <1> ;Output: rsi -> First non-terminator char after string of terminators
   185 00000C57 50                  <1>     push rax
   186                              <1> .stl1:
   187 00000C58 AC                  <1>     lodsb   ;Get char
   188 00000C59 E8E2FFFFFF          <1>     call .isCharSeparator    ;Is it terminal?
   189 00000C5E 74F8                <1>     jz .stl1    ;Yes, keep going
   190 00000C60 58                  <1>     pop rax
   191 00000C61 48FFCE              <1>     dec rsi
   192                              <1>     return
    13                              <2> %%_ret:
    14 00000C64 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   193                              <1> 
   194                              <1> .badLineHandle:
   195                              <1> ;If the command was unrecognised, goto next line! Do not halt!
   196 00000C65 E84B000000          <1>     call .badLineErrorMsg
   197 00000C6A E981FFFFFF          <1>     jmp  .cmdPrepNew
   198                              <1> 
   199                              <1> .stopProcessError:
   200                              <1> ;Print the hard error message and reset the system values
   201 00000C6F E836000000          <1>     call .hardErrorMsg
   202                              <1> .stopProcessErrorNoPrint:
   203                              <1> ;Reset all values to OEM defaults
   204 00000C74 0FB605(CD010000)    <1>     movzx eax, byte [BUFFERS]
   205 00000C7B 488945F8            <1>     mov qword [rbp - cfgFrame.newBuffers], rax
   206 00000C7F 0FB605(CC010000)    <1>     movzx eax, byte [FILES]
   207 00000C86 488945F0            <1>     mov qword [rbp - cfgFrame.newSFTVal], rax
   208 00000C8A 48C745E804000000    <1>     mov qword [rbp - cfgFrame.newFCBSVal], fcbsDefault
   209 00000C92 48C745E000000000    <1>     mov qword [rbp - cfgFrame.newProtFCBSVal], safeFcbsDeflt
   210 00000C9A 0FB605(CF010000)    <1>     movzx eax, byte [LASTDRIVE]
   211 00000CA1 488945D8            <1>     mov qword [rbp - cfgFrame.newLastdrive], rax
   212 00000CA5 E914060000          <1>     jmp .cfgExit
   213                              <1> .hardErrorMsg:
   214                              <1> ;Prints an error message and TERMINATE parsing
   215 00000CAA 50                  <1>     push rax
   216 00000CAB 52                  <1>     push rdx
   217 00000CAC 488D1515000000      <1>     lea rdx, .hdLine
   218 00000CB3 EB09                <1>     jmp short .errorCmn
   219                              <1> .badLineErrorMsg:
   220                              <1> ;Prints an error message BUT DOES NOT TERMINATE PARSING
   221 00000CB5 50                  <1>     push rax
   222 00000CB6 52                  <1>     push rdx
   223 00000CB7 488D152D000000      <1>     lea rdx, .speLine
   224                              <1> .errorCmn:
   225 00000CBE B800090000          <1>     mov eax, 0900h
   226 00000CC3 CD21                <1>     int 21h
   227 00000CC5 5A                  <1>     pop rdx
   228 00000CC6 58                  <1>     pop rax
   229                              <1>     return
    13                              <2> %%_ret:
    14 00000CC7 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   230 00000CC8 0D0A4572726F722069- <1> .hdLine:    db CR,LF,"Error in processing CONFIG.SYS",CR,LF,"$"
   230 00000CD1 6E2070726F63657373- <1>
   230 00000CDA 696E6720434F4E4649- <1>
   230 00000CE3 472E5359530D0A24    <1>
   231 00000CEB 0D0A556E7265636F67- <1> .speLine:   db CR,LF,"Unrecognised command in CONFIG.SYS",CR,LF,"$"
   231 00000CF4 6E6973656420636F6D- <1>
   231 00000CFD 6D616E6420696E2043- <1>
   231 00000D06 4F4E4649472E535953- <1>
   231 00000D0F 0D0A24              <1>
   232                              <1> .keyTbl: 
   233 00000D12 05425245414B        <1>     db 5, "BREAK"           ;DONE
   234 00000D18 6300                <1> 	dw .breakHandler - .keyTbl
   235 00000D1A 0742554646455253    <1>     db 7, "BUFFERS"         ;DONE
   236 00000D22 9900                <1> 	dw .bufHandler - .keyTbl
   237 00000D24 07434F554E545259    <1> 	db 7, "COUNTRY"         ;Ignored for now
   238 00000D2C AA05                <1> 	dw .countryScan - .keyTbl
   239 00000D2E 06444556494345      <1> 	db 6, "DEVICE"          ;DONE
   240 00000D35 0F01                <1> 	dw .drvLoader - .keyTbl
   241 00000D37 0446434253          <1> 	db 4, "FCBS"            ;Ignored for now
   242 00000D3C AA05                <1> 	dw .fcbHandler - .keyTbl
   243 00000D3E 0546494C4553        <1> 	db 5, "FILES"           ;DONE
   244 00000D44 3804                <1> 	dw .sftHandler - .keyTbl
   245 00000D46 094C41535444524956- <1> 	db 9, "LASTDRIVE"       ;DONE
   245 00000D4F 45                  <1>
   246 00000D50 EA04                <1> 	dw .lastdriveHandler - .keyTbl
   247 00000D52 055348454C4C        <1> 	db 5, "SHELL"           ;Ignored for now
   248 00000D58 3605                <1> 	dw .shellHandler - .keyTbl
   249 00000D5A 06535441434B53      <1> 	db 6, "STACKS"          ;Ignored for now
   250 00000D61 AA05                <1> 	dw .stacksHandler - .keyTbl
   251 00000D63 08445249565041524D  <1>     db 8, "DRIVPARM"
   252 00000D6C AA05                <1>     dw .drivParm - .keyTbl  ;Ignored for now
   253                              <1>     ;The following three are to not cause issues with empty lines/EOF chars
   254 00000D6E 0352454D            <1>     db 3, "REM"
   255 00000D72 AA05                <1>     dw .comment - .keyTbl
   256 00000D74 FF                  <1> 	db -1	;End of table marker
   257                              <1> 
   258                              <1> .breakHandler:
   259 00000D75 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
   260 00000D79 4881C605000000      <1>     add rsi, 5  ;Go past BREAK
   261                              <1>     ;This must be the word ON or OFF 
   262 00000D80 E8D2FEFFFF          <1>     call .skipSeparators
   263 00000D85 31D2                <1>     xor edx, edx    ;Clear CF and default to OFF
   264 00000D87 66813E4F4E          <1>     cmp word [rsi], "ON"
   265 00000D8C 7413                <1>     je .breakOn
   266 00000D8E 66813E4F46          <1>     cmp word [rsi], "OF"
   267 00000D93 7506                <1>     jne .breakBad
   268 00000D95 807E0246            <1>     cmp byte [rsi + 2], "F"
   269 00000D99 7408                <1>     je .breakCommon
   270                              <1> .breakBad:
   271 00000D9B E815FFFFFF          <1>     call .badLineErrorMsg
   272                              <1>     return
    13                              <2> %%_ret:
    14 00000DA0 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   273                              <1> .breakOn:
   274 00000DA1 FFC2                <1>     inc edx ;Go from OFF to ON  (keeps CF=NC)
   275                              <1> .breakCommon:
   276 00000DA3 B801330000          <1>     mov eax, 3301h  ;Set break to value in dl
   277 00000DA8 CD21                <1>     int 21h
   278                              <1>     return
    13                              <2> %%_ret:
    14 00000DAA C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   279                              <1> 
   280                              <1> .bufHandler:
   281 00000DAB 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
   282 00000DAF 4881C607000000      <1>     add rsi, 7  ;Go past BUFFERS=
   283                              <1>     ;This must be at most three digits, anything else is a failure
   284 00000DB6 E89CFEFFFF          <1>     call .skipSeparators
   285 00000DBB 4889F7              <1>     mov rdi, rsi    ;Save the start in rdi
   286 00000DBE 31C9                <1>     xor ecx, ecx
   287 00000DC0 AC                  <1>     lodsb   ;Get the first char. Must be between ASCII '0' and '9'
   288 00000DC1 3C30                <1>     cmp al, "0"
   289 00000DC3 7256                <1>     jb .bufHandlerErr
   290 00000DC5 3C39                <1>     cmp al, "9"
   291 00000DC7 7752                <1>     ja .bufHandlerErr
   292 00000DC9 FFC1                <1>     inc ecx ;Increment char counter
   293 00000DCB AC                  <1>     lodsb   ;Get second char
   294 00000DCC E810050000          <1>     call .termCheck
   295 00000DD1 7410                <1>     je .bufHandlerProcess   ;If it is a terminating char, exit
   296 00000DD3 3C30                <1>     cmp al, "0"
   297 00000DD5 7244                <1>     jb .bufHandlerErr
   298 00000DD7 3C39                <1>     cmp al, "9"
   299 00000DD9 7740                <1>     ja .bufHandlerErr
   300 00000DDB AC                  <1>     lodsb   ;Check no more chars!
   301 00000DDC E800050000          <1>     call .termCheck
   302 00000DE1 7538                <1>     jne .bufHandlerErr
   303                              <1> .bufHandlerProcess:
   304 00000DE3 31D2                <1>     xor edx, edx    ;Accumulate value in edx
   305 00000DE5 4889FE              <1>     mov rsi, rdi    ;Go back to the first number
   306                              <1> .bufHandlerLp:
   307 00000DE8 AC                  <1>     lodsb   ;Get the digit
   308 00000DE9 2C30                <1>     sub al, "0" ;Convert to ASCII
   309 00000DEB 0FB6C0              <1>     movzx eax, al
   310 00000DEE 67E30E              <1>     jecxz .bufHandlerPrepExit   ;Exit if this is the only digit
   311 00000DF1 D1E0                <1>     shl eax, 1  ;Multiply by 2
   312 00000DF3 678D1480            <1>     lea edx, dword [4*eax + eax]    ;Multiply (2*eax) by 5
   313 00000DF7 AC                  <1>     lodsb   ;Get the next digit
   314 00000DF8 2C30                <1>     sub al, "0"
   315 00000DFA 0FB6C0              <1>     movzx eax, al
   316 00000DFD 01D0                <1>     add eax, edx    ;Add the tens to the unit
   317                              <1> .bufHandlerPrepExit:
   318 00000DFF 0FB60D(CD010000)    <1>     movzx ecx, byte [BUFFERS]
   319 00000E06 85C0                <1>     test eax, eax
   320 00000E08 0F44C1              <1>     cmovz eax, ecx  ;Replace zero with default if the user specified 0 buffers
   321 00000E0B 488945F8            <1>     mov qword [rbp - cfgFrame.newBuffers], rax
   322 00000E0F F8                  <1>     clc
   323                              <1>     return
    13                              <2> %%_ret:
    14 00000E10 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   324                              <1> .bufHandlerMul:
   325 00000E11 2C30                <1>     sub al, "0" ;Convert to a binary value
   326 00000E13 F6E1                <1>     mul cl  ;Multiply al by cl, answer in ax
   327 00000E15 0FB7C0              <1>     movzx eax, ax
   328 00000E18 01C2                <1>     add edx, eax
   329                              <1>     return
    13                              <2> %%_ret:
    14 00000E1A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   330                              <1> .bufHandlerErr:
   331 00000E1B E895FEFFFF          <1>     call .badLineErrorMsg
   332                              <1>     return
    13                              <2> %%_ret:
    14 00000E20 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   333                              <1> ;===============================
   334                              <1> ;   Device Driver Loader here  :
   335                              <1> ;===============================
   336                              <1> .drvLoader:
   337 00000E21 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
   338 00000E25 4881C606000000      <1>     add rsi, 6  ;Go past DEVICE= to the pathname
   339 00000E2C E826FEFFFF          <1>     call .skipSeparators
   340 00000E31 4889F7              <1>     mov rdi, rsi
   341 00000E34 4889FA              <1>     mov rdx, rdi    ;Prepare rdx for the open
   342                              <1> ;Now search for the first char after pathname. 
   343                              <1> .drvFindEndOfFileName:
   344 00000E37 AC                  <1>     lodsb ;Get char from string name
   345                              <1>     ;Was the char a primitive string terminator?
   346 00000E38 3C20                <1>     cmp al, SPC
   347 00000E3A 740C                <1>     je short .fileNameFound
   348 00000E3C 3C1A                <1>     cmp al, EOF
   349 00000E3E 7408                <1>     je short .fileNameFound
   350 00000E40 3C0D                <1>     cmp al, CR
   351 00000E42 7404                <1>     je short .fileNameFound
   352 00000E44 3C0A                <1>     cmp al, LF
   353 00000E46 75EF                <1>     jne short .drvFindEndOfFileName
   354                              <1> .fileNameFound:
   355 00000E48 48FFCE              <1>     dec rsi ;Point rsi to the space itself
   356 00000E4B 488975A8            <1>     mov qword [rbp - cfgFrame.driverBreak], rsi
   357 00000E4F 0FB606              <1>     movzx eax, byte [rsi]   ;Get the original breakchar
   358 00000E52 488945A0            <1>     mov qword [rbp - cfgFrame.breakChar], rax  ;And save it
   359 00000E56 C60600              <1>     mov byte [rsi], 0   ;Null terminate the path to the file
   360                              <1>     ;rdx -> Filename
   361                              <1>     ;Here open the file to attempt to see how much space to 
   362                              <1>     ; allocate to the file for loading. 
   363                              <1>     ;Consider using the 4B01h loading mode instead and swapping back
   364                              <1>     ; the current DTA and PSP to DOS default? This gives each driver a PSP
   365                              <1>     ; which would allow for opening of files independently of calling programs'
   366                              <1>     ; file table... maybe try it after getting 4B03h load to work first!
   367 00000E59 B8003D0000          <1>     mov eax, 3D00h  ;Read only file
   368 00000E5E CD21                <1>     int 21h
   369 00000E60 0F82A8020000        <1>     jc .drvBad
   370 00000E66 0FB7D8              <1>     movzx ebx, ax   ;Get the handle in ebx
   371 00000E69 31D2                <1>     xor edx, edx    ;Move the handle to the end of the file
   372 00000E6B B802420000          <1>     mov eax, 4202h  ;LSEEK to SEEK_END
   373 00000E70 CD21                <1>     int 21h
   374 00000E72 89C6                <1>     mov esi, eax    ;Save the file size in esi
   375 00000E74 31D2                <1>     xor edx, edx    ;Move the handle to the start of the file
   376 00000E76 B800420000          <1>     mov eax, 4200h  ;LSEEK to SEEK_SET (start of the file)
   377 00000E7B CD21                <1>     int 21h
   378 00000E7D 53                  <1>     push rbx        ;Push the file handle on the stack
   379 00000E7E BB06000000          <1>     mov ebx, 6      ;6 paragraphs (96 bytes)
   380 00000E83 B800480000          <1>     mov eax, 4800h  ;Allocate this block of memory
   381 00000E88 CD21                <1>     int 21h
   382 00000E8A 5B                  <1>     pop rbx         ;Get the handle back in rbx
   383 00000E8B 0F828D020000        <1>     jc .drvMemClose
   384 00000E91 4889C2              <1>     mov rdx, rax    ;Get pointer to memory in rdx
   385 00000E94 B940000000          <1>     mov ecx, imageDosHdr_size
   386 00000E99 B8003F0000          <1>     mov eax, 3F00h  ;READ
   387 00000E9E CD21                <1>     int 21h
   388 00000EA0 4989D0              <1>     mov r8, rdx     ;Store the pointer to the memory block in r8 if need to free
   389 00000EA3 4889D7              <1>     mov rdi, rdx    ;Get pointer to the EXE header
   390 00000EA6 730C                <1>     jnc short .headerReadOK
   391                              <1> .drvFreeMemAndHdl: ;Frees the block and then handle
   392                              <1>     ;r8 must point to the block to free
   393 00000EA8 B800490000          <1>     mov eax, 4900h  ;Free the block first!
   394 00000EAD CD21                <1>     int 21h
   395 00000EAF E953020000          <1>     jmp .drvBadClose
   396                              <1> .headerReadOK:
   397                              <1> ;Use register r10 as the indicator for .COM or .EXE. Set if COM.
   398 00000EB4 4889D7              <1>     mov rdi, rdx    ;Save the pointer in rdi
   399                              <1>     ;First check this file is MZ/ZM. If this is not, we assume its a .COM driver
   400 00000EB7 66813F4D5A          <1>     cmp word [rdi], dosMagicSignature
   401 00000EBC 742C                <1>     je short .exeDrivers
   402 00000EBE 66813F5A4D          <1>     cmp word [rdi], dosMagicSignature2
   403 00000EC3 7425                <1>     je short .exeDrivers
   404                              <1> ;.COM drivers come down here
   405                              <1>     ;Get File Image Allocation Size in ecx here.
   406                              <1>     ;Must be leq than 64Kb, rounded to nearest paragraph if .COM
   407 00000EC5 31C9                <1>     xor ecx, ecx
   408 00000EC7 31D2                <1>     xor edx, edx
   409 00000EC9 B802420000          <1>     mov eax, 4202h  ;LSEEK from the end of the file
   410 00000ECE CD21                <1>     int 21h
   411                              <1>     ;eax now has the filesize. 
   412 00000ED0 89C1                <1>     mov ecx, eax
   413 00000ED2 81E1F0FFFFFF        <1>     and ecx, ~0Fh   ;Clear lower byte
   414 00000ED8 C1E904              <1>     shr ecx, 4      ;Convert to paragraphs
   415 00000EDB FFC1                <1>     inc ecx         ;... and round up!
   416 00000EDD 81F900100000        <1>     cmp ecx, 1000h ;Is it geq 64k (in paragraphs)?
   417 00000EE3 73C3                <1>     jae .drvFreeMemAndHdl
   418 00000EE5 E978000000          <1>     jmp .loadCont
   419                              <1> .exeDrivers:
   420                              <1>     ;Get the file pointer for file header
   421 00000EEA 8B573C              <1>     mov edx, dword [rdi + imageDosHdr.e_lfanew] ;Get this file offset
   422 00000EED 31C9                <1>     xor ecx, ecx
   423 00000EEF B800420000          <1>     mov eax, 4200h  ;LSEEK from the start of the file
   424 00000EF4 CD21                <1>     int 21h
   425                              <1>     ;Now read in imageFileHeader here
   426 00000EF6 4889FA              <1>     mov rdx, rdi    ;Overwrite the 16-bit header
   427 00000EF9 B918000000          <1>     mov ecx, imageFileHeader_size   ;Read the header
   428 00000EFE B8003F0000          <1>     mov eax, 3F00h  ;READ
   429 00000F03 CD21                <1>     int 21h
   430 00000F05 72A1                <1>     jc short .drvFreeMemAndHdl
   431 00000F07 3D18000000          <1>     cmp eax, imageFileHeader_size   ;If fewer bytes were read, fail
   432 00000F0C 729A                <1>     jb short .drvFreeMemAndHdl
   433 00000F0E 813F50450000        <1>     cmp dword [rdi + imageFileHeader.dPESignature], imagePESignature
   434 00000F14 7592                <1>     jne .drvFreeMemAndHdl
   435 00000F16 66817F046486        <1>     cmp word [rdi + imageFileHeader.wMachineType], imageFileMachineAMD64
   436 00000F1C 758A                <1>     jne .drvFreeMemAndHdl
   437 00000F1E 66817F143C00        <1>     cmp word [rdi + imageFileHeader.wSizeOfOptionalHdr], 60
   438 00000F24 7282                <1>     jb .drvFreeMemAndHdl ;We need section alignment info if a .EXE!
   439                              <1>     ;Now read the first 60 bytes of the optional header here. rdx points to buffer
   440 00000F26 B93C000000          <1>     mov ecx, 60     ;Read only 60 bytes
   441 00000F2B B8003F0000          <1>     mov eax, 3F00h  ;READ
   442 00000F30 CD21                <1>     int 21h
   443 00000F32 0F8270FFFFFF        <1>     jc .drvFreeMemAndHdl   ;If something goes wrong, skip
   444 00000F38 3D38000000          <1>     cmp eax, 56
   445 00000F3D 0F8265FFFFFF        <1>     jb .drvFreeMemAndHdl   ;If fewer than 60 bytes read, skip
   446                              <1>     ;Round up size requirement.
   447                              <1>     ;If .EXE, round up to nearest section alignment
   448 00000F43 8B4F38              <1>     mov ecx, dword [rdi + imageFileOptionalHeader.dSizeOfImage] ;Get mem alloc size
   449 00000F46 8B4720              <1>     mov eax, dword [rdi + imageFileOptionalHeader.dSectionAlignment]
   450 00000F49 89C6                <1>     mov esi, eax    ;Save in esi the alignment requirement
   451 00000F4B FFC8                <1>     dec eax         ;Set bits to strip, clear all other bits
   452 00000F4D F7D0                <1>     not eax         ;Flip the set and clear bits
   453 00000F4F 21C1                <1>     and ecx, eax    ;Now clear the bits to clear from size, aligning downwards
   454 00000F51 01F1                <1>     add ecx, esi    ;Now round upwards!
   455 00000F53 C1E904              <1>     shr ecx, 4      ;Convert to number of paragraphs.
   456 00000F56 81F900000002        <1>     cmp ecx, 2000000h  ;Drivers cannot be more than 2Gb in size.
   457 00000F5C 0F8346FFFFFF        <1>     jae .drvFreeMemAndHdl
   458                              <1> .loadCont:
   459 00000F62 B800490000          <1>     mov eax, 4900h  ;FREE -> Free the 6 paragraph header buffer.
   460 00000F67 CD21                <1>     int 21h ;r8 has the pointer to the block for freeing
   461                              <1>     ;Now close the file
   462 00000F69 B8003E0000          <1>     mov eax, 3E00h  ;Close handle in ebx
   463 00000F6E CD21                <1>     int 21h
   464 00000F70 89CB                <1>     mov ebx, ecx    ;Put the number of paragraphs in ebx
   465 00000F72 B800480000          <1>     mov eax, 4800h  ;Allocate this block of memory
   466 00000F77 CD21                <1>     int 21h         ;rax gets the pointer to load the program into
   467 00000F79 0F829F010000        <1>     jc .drvMemClose
   468                              <1>     ;Now set the subsystem marker and the owner to DOS
   469 00000F7F C640FD44            <1>     mov byte [rax - mcb_size + mcb.subSysMark], mcbSubDriver  ;Mark as occupied by driver
   470 00000F83 48C740F108000000    <1>     mov qword [rax - mcb_size + mcb.owner], mcbOwnerDOS
   471                              <1>     ;Build the overlay command block
   472 00000F8B 488D1D(FC010000)    <1>     lea rbx, cmdBlock
   473 00000F92 488903              <1>     mov qword [rbx + loadOvly.pLoadLoc], rax
   474 00000F95 48894308            <1>     mov qword [rbx + loadOvly.qRelocFct], rax
   475 00000F99 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr] ;Get the pointer to the 
   476 00000F9D 4881C606000000      <1>     add rsi, 6  ;Go past DEVICE= to the null terminated pathname
   477 00000FA4 E8AEFCFFFF          <1>     call .skipSeparators
   478 00000FA9 4889F2              <1>     mov rdx, rsi
   479 00000FAC B8034B0000          <1>     mov eax, 4B03h  ;Load overlay!
   480 00000FB1 CD21                <1>     int 21h
   481 00000FB3 733E                <1>     jnc short .loadOk   ;Driver loaded and unpacked. Now we get going...
   482                              <1> .badDriverLoad:
   483 00000FB5 4C8B05(FC010000)    <1>     mov r8, qword [cmdBlock + loadOvly.pLoadLoc] ;Get the address of this 
   484 00000FBC B800490000          <1>     mov eax, 4900h  ;FREE -> Free the space where the program shouldve gone
   485 00000FC1 CD21                <1>     int 21h
   486 00000FC3 488D1508000000      <1>     lea rdx, .drvMemMsg
   487 00000FCA B800090000          <1>     mov eax, 0900h
   488 00000FCF CD21                <1>     int 21h
   489                              <1>     return
    13                              <2> %%_ret:
    14 00000FD1 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   490 00000FD2 0D0A4E6F7420656E6F- <1> .drvMemMsg: db CR,LF,"Not enough memory for driver",CR,LF,"$" 
   490 00000FDB 756768206D656D6F72- <1>
   490 00000FE4 7920666F7220647269- <1>
   490 00000FED 7665720D0A24        <1>
   491                              <1> .loadOk:
   492                              <1>     ;Use driver load routines. Get the first byte of the MCB (where prog is loaded).
   493 00000FF3 488B33              <1>     mov rsi, qword [rbx + loadOvly.pLoadLoc]
   494 00000FF6 4989F0              <1>     mov r8, rsi  ;Get the pointer to the MCB arena in r8 for later!
   495                              <1>     ;Reset the command line to have a space at the null terminator
   496 00000FF9 488B45A8            <1>     mov rax, qword [rbp - cfgFrame.driverBreak]
   497 00000FFD 53                  <1>     push rbx
   498 00000FFE 8A5DA0              <1>     mov bl, byte [rbp - cfgFrame.breakChar] ;Get the original breakchar
   499 00001001 8818                <1>     mov byte [rax], bl  ;and replace the null terminator
   500 00001003 5B                  <1>     pop rbx
   501                              <1>     ;Remember, the first byte of the overlay is the driver header. 
   502                              <1>     ;Hence, rsi points to that byte!
   503                              <1>     ;Pointers of each header need adjustment relative to their load address,
   504                              <1>     ; and linking into the main driver chain after NUL.
   505                              <1>     ;r11 = Local var, if no drivers in file passed init, free allocation.
   506                              <1>     ;                 Else, free using kernel eject routine.
   507 00001004 56                  <1>     push rsi    ;Save the pointer to the first pointer to adjust
   508                              <1> .driverPtrAdjustment:
   509 00001005 4801760A            <1>     add qword [rsi + drvHdr.strPtr], rsi
   510 00001009 48017612            <1>     add qword [rsi + drvHdr.intPtr], rsi
   511 0000100D 48813EFFFFFFFF      <1>     cmp qword [rsi + drvHdr.nxtPtr], -1
   512 00001014 7408                <1>     je short .driverPtrAdjustmentDone
   513 00001016 480136              <1>     add qword [rsi + drvHdr.nxtPtr], rsi
   514 00001019 488B36              <1>     mov rsi, qword [rsi + drvHdr.nxtPtr]
   515 0000101C EBE7                <1>     jmp short .driverPtrAdjustment
   516                              <1> .driverPtrAdjustmentDone:
   517 0000101E 5E                  <1>     pop rsi     ;Get back the pointer to the first driver header
   518                              <1>     ;Prepare for initialising the drivers in the arena
   519                              <1>     ;EXPERIMENT: USING R9 and R12 UNTIL THE END OF THE FUNCTION
   520 0000101F 4989F1              <1>     mov r9, rsi     ;Save a copy of the driver pointer in r9
   521 00001022 488D1D(DD010000)    <1>     lea rbx, initDrvBlk
   522 00001029 56                  <1>     push rsi
   523 0000102A 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr] ;Get the line pointer
   524 0000102E 4881C606000000      <1>     add rsi, 6  ;Go past DEVICE
   525 00001035 E81DFCFFFF          <1>     call .skipSeparators    ;Go past equals and any following spaces
   526 0000103A 48897316            <1>     mov qword [rbx + initReqPkt.optptr], rsi ;and pass to driver!
   527 0000103E 5E                  <1>     pop rsi
   528 0000103F 4C8B6500            <1>     mov r12, qword [rbp - cfgFrame.oldRBP]  ;Get DOSSEG in r12
   529                              <1> .driverInit:
   530 00001043 4C87E5              <1>     xchg r12, rbp
   531                              <1> ;----------------------------------------------------------------
   532                              <1> ;In this region, rbp points back to dosseg
   533                              <1> ;vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
   534 00001046 E85EF9FFFF          <1>     call initDriver
   535 0000104B 7255                <1>     jc short .driverBadRbpAdjust
   536                              <1> ;If we swap drivers to be their own tasks (i.e. with 4B01h)
   537                              <1> ; this routine will still work like so!
   538 0000104D E841F8FFFF          <1>     call addDriverMarkers
   539                              <1> ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   540 00001052 4C87E5              <1>     xchg r12, rbp
   541 00001055 66F746080080        <1>     test word [rsi + drvHdr.attrib], devDrvChar
   542 0000105B 7507                <1>     jnz short .driverInitialised
   543 0000105D E802FAFFFF          <1>     call buildDPBs          ;Preserves rbp, rsi and rbx
   544 00001062 7241                <1>     jc short .driverBad
   545                              <1> .driverInitialised:
   546 00001064 48813EFFFFFFFF      <1>     cmp qword [rsi + drvHdr.nxtPtr], -1     ;We at the end of the chain?
   547 0000106B 480F4536            <1>     cmovne rsi, qword [rsi + drvHdr.nxtPtr]    ;Walk rsi if not
   548 0000106F 75D2                <1>     jne short .driverInit ;If not, goto next driver
   549                              <1> ;Now we eject the init routines for the driver
   550                              <1> ;r8 points to the MCB data area already
   551 00001071 31DB                <1>     xor ebx, ebx
   552 00001073 418B58F9            <1>     mov ebx, dword [r8 - mcb_size + mcb.blockSize] ;Get the size of the arena in paragraphs
   553 00001077 48C1E304            <1>     shl rbx, 4  ;Turn into number of bytes
   554 0000107B 4981E810000000      <1>     sub r8, mcb_size    ;Point to the mcb header proper
   555 00001082 498D5C1810          <1>     lea rbx, qword [r8 + rbx + mcb.program] ;Get pointer to the end of the arena
   556 00001087 E8CBF8FFFF          <1>     call ejectKernelInit    ;Ignore any errors in ejection.
   557                              <1>     ;Link into main driver chain, 
   558                              <1>     ;r9 points to first driver in block
   559                              <1>     ;rsi points to last driver in block
   560 0000108C 488B7D00            <1>     mov rdi, qword [rbp - cfgFrame.oldRBP]  ;Get DOSSEG ptr
   561 00001090 488DBF[00000000]    <1>     lea rdi, qword [rdi + nulDevHdr] ;Get ptr to first driver
   562 00001097 488B07              <1>     mov rax, qword [rdi + drvHdr.nxtPtr]    ;Get the link
   563 0000109A 4C890F              <1>     mov qword [rdi + drvHdr.nxtPtr], r9     ;Link new drivers in
   564 0000109D 488906              <1>     mov qword [rsi + drvHdr.nxtPtr], rax    ;Link end to old chain
   565                              <1> .driverExit:
   566                              <1> ;Exit the init routine if it all works out, WOO!
   567                              <1> ;Return values to original registers/memory locations
   568                              <1> ;    mov qword fs:[currentPSP], r11
   569 000010A0 F8                  <1>     clc
   570                              <1>     return
    13                              <2> %%_ret:
    14 000010A1 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   571                              <1> .driverBadRbpAdjust:
   572 000010A2 4C89E5              <1>     mov rbp, r12
   573                              <1> .driverBad:
   574                              <1>     ;Form the string to print
   575 000010A5 488D3D50000000      <1>     lea rdi, .driverBad2    ;Store the name here
   576 000010AC 66F746080080        <1>     test word [rsi + drvHdr.attrib], devDrvChar ;Are we a char dev?
   577 000010B2 750E                <1>     jnz short .driverCharBad    ;If not, exit
   578                              <1>     ;MSD devices need to have something placed in there
   579 000010B4 48B84D534420646576- <1>     mov rax, "MSD dev "
   579 000010BD 20                  <1>
   580 000010BE 48AB                <1>     stosq   ;Store the 8 chars here
   581 000010C0 EB06                <1>     jmp short .driverBadPrint
   582                              <1> .driverCharBad:
   583 000010C2 488D761A            <1>     lea rsi, qword [rsi + drvHdr.drvNam]    ;Copy the device driver name over
   584 000010C6 48A5                <1>     movsq   ;Move all 8 chars over from device driver name
   585                              <1> .driverBadPrint:
   586 000010C8 488D1510000000      <1>     lea rdx, .driverBad1
   587 000010CF B800090000          <1>     mov eax, 0900h  ;Print the string!
   588 000010D4 CD21                <1>     int 21h
   589 000010D6 B800490000          <1>     mov eax, 4900h  ;Attempt to deallocate the driver now
   590 000010DB CD21                <1>     int 21h
   591 000010DD EBC1                <1>     jmp short .driverExit
   592 000010DF 0D0A4572726F722069- <1> .driverBad1 db CR,LF,"Error initialising driver: "
   592 000010E8 6E697469616C697369- <1>
   592 000010F1 6E6720647269766572- <1>
   592 000010FA 3A20                <1>
   593 000010FC 20202020202020200D- <1> .driverBad2 db "        ",CR,LF,"$"
   593 00001105 0A24                <1>
   594                              <1> ;------------------
   595                              <1> ;Bad exit cases
   596                              <1> ;------------------
   597                              <1> .drvBadClose:
   598 00001107 B8003E0000          <1>     mov eax, 3E00h  ;Close handle in ebx
   599 0000110C CD21                <1>     int 21h
   600                              <1> .drvBad:
   601 0000110E 488D1519000000      <1>     lea rdx, .drvBadMsg
   602                              <1> .drvBad2:
   603 00001115 B800090000          <1>     mov eax, 0900h
   604 0000111A CD21                <1>     int 21h
   605 0000111C F8                  <1>     clc ;Never return with CF=CY
   606                              <1>     return
    13                              <2> %%_ret:
    14 0000111D C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   607                              <1> .drvMemClose:
   608 0000111E B8003E0000          <1>     mov eax, 3E00h  ;Close handle in ebx
   609 00001123 CD21                <1>     int 21h
   610 00001125 488D15A6FEFFFF      <1>     lea rdx, .drvMemMsg
   611 0000112C EBE7                <1>     jmp short .drvBad2
   612                              <1> 
   613 0000112E 0D0A426164206F7220- <1> .drvBadMsg: db CR,LF,"Bad or missing filename",CR,LF,"$"
   613 00001137 6D697373696E672066- <1>
   613 00001140 696C656E616D650D0A- <1>
   613 00001149 24                  <1>
   614                              <1> 
   615                              <1> 
   616                              <1> .sftHandler:
   617                              <1> ;This reads the line to set the number of FILE to between 1 and 254
   618 0000114A 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
   619 0000114E 4881C605000000      <1>     add rsi, 5  ;Go past FILES=
   620 00001155 E8FDFAFFFF          <1>     call .skipSeparators
   621                              <1>     ;This must be at most three digits, anything else is a failure
   622 0000115A 4889F7              <1>     mov rdi, rsi    ;Save the start in rdi
   623 0000115D 31C9                <1>     xor ecx, ecx
   624 0000115F AC                  <1>     lodsb   ;Get the first char. Must be between ASCII '0' and '9'
   625 00001160 3C30                <1>     cmp al, "0"
   626 00001162 0F828E000000        <1>     jb .sftHandlerErr
   627 00001168 3C39                <1>     cmp al, "9"
   628 0000116A 0F8786000000        <1>     ja .sftHandlerErr
   629 00001170 FFC1                <1>     inc ecx ;Increment char counter
   630 00001172 AC                  <1>     lodsb   ;Get second char
   631 00001173 E869010000          <1>     call .termCheck
   632 00001178 7424                <1>     je .sftHandlerProcess   ;If it is a terminating char, exit
   633 0000117A 3C30                <1>     cmp al, "0"
   634 0000117C 7278                <1>     jb .sftHandlerErr
   635 0000117E 3C39                <1>     cmp al, "9"
   636 00001180 7774                <1>     ja .sftHandlerErr
   637 00001182 FFC1                <1>     inc ecx ;Increment char counter
   638 00001184 AC                  <1>     lodsb   ;Get third char
   639 00001185 E857010000          <1>     call .termCheck
   640 0000118A 7412                <1>     je .sftHandlerProcess   ;If it is a terminating char, exit
   641 0000118C 3C30                <1>     cmp al, "0"
   642 0000118E 7266                <1>     jb .sftHandlerErr
   643 00001190 3C39                <1>     cmp al, "9"
   644 00001192 7762                <1>     ja .sftHandlerErr
   645 00001194 AC                  <1>     lodsb   ;Check no more chars!
   646 00001195 E847010000          <1>     call .termCheck
   647 0000119A 755A                <1>     jne .sftHandlerErr
   648 0000119C FFC1                <1>     inc ecx ;Increment char counter
   649                              <1> .sftHandlerProcess:
   650 0000119E 31D2                <1>     xor edx, edx    ;Accumulate value in edx
   651 000011A0 4889FE              <1>     mov rsi, rdi    ;Go back to the first number
   652                              <1> .sftHandlerLp:
   653 000011A3 FFC9                <1>     dec ecx
   654 000011A5 AC                  <1>     lodsb   ;Get the digit
   655 000011A6 E823000000          <1>     call .sftHandlerMul
   656 000011AB 67E302              <1>     jecxz .sftHandlerPrepExit
   657 000011AE EBF3                <1>     jmp short .sftHandlerLp 
   658                              <1> .sftHandlerPrepExit:
   659                              <1> ;edx has the value now, so place it in stack
   660 000011B0 81FAFE000000        <1>     cmp edx, 254
   661 000011B6 773E                <1>     ja .sftHandlerErr       ;DOS maximum number of files
   662 000011B8 0FB60D(CC010000)    <1>     movzx ecx, byte [FILES] ;Get default if the user specifies less than min
   663 000011BF 81FA08000000        <1>     cmp edx, 8              ;DOS minimum number of files
   664 000011C5 0F42D1              <1>     cmovb edx, ecx
   665 000011C8 488955F0            <1>     mov qword [rbp - cfgFrame.newSFTVal], rdx
   666 000011CC F8                  <1>     clc
   667                              <1>     return
    13                              <2> %%_ret:
    14 000011CD C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   668                              <1> .sftHandlerMul:
   669                              <1> ;Input:
   670                              <1> ;al = digit to add to result (ASCII digit)
   671                              <1> ;ecx = whether al is a unit (0), ten (1) or hundred (2)
   672                              <1> ;rdx = Accumulated sum
   673                              <1> ;Output:
   674                              <1> ;rdx = Accumulated sum with al added
   675                              <1> ;eax is destroyed
   676                              <1> ;All other registers preserved
   677 000011CE 51                  <1>     push rcx
   678 000011CF 52                  <1>     push rdx
   679 000011D0 0FB6C0              <1>     movzx eax, al
   680 000011D3 2D30000000          <1>     sub eax, '0' ;Convert to a binary digit
   681 000011D8 BA01000000          <1>     mov edx, 1    ;Get 1 in edx (multiplicative unit)
   682 000011DD 39D1                <1>     cmp ecx, edx  ;Was cl a ten?
   683 000011DF BB0A000000          <1>     mov ebx, 10     ;Default base offset to 10
   684 000011E4 B964000000          <1>     mov ecx, 100
   685 000011E9 0F42DA              <1>     cmovb ebx, edx  ;If below, it was a unit
   686 000011EC 0F47D9              <1>     cmova ebx, ecx  ;If above, it was a hundred
   687 000011EF F7E3                <1>     mul ebx    ;Multiply the base offset to eax
   688 000011F1 5A                  <1>     pop rdx ;Get the accumulated value back
   689 000011F2 01C2                <1>     add edx, eax    ;Add this result over
   690 000011F4 59                  <1>     pop rcx
   691                              <1>     return
    13                              <2> %%_ret:
    14 000011F5 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   692                              <1> .sftHandlerErr:
   693 000011F6 E8BAFAFFFF          <1>     call .badLineErrorMsg
   694                              <1>     return
    13                              <2> %%_ret:
    14 000011FB C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   695                              <1> 
   696                              <1> .lastdriveHandler:
   697 000011FC 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
   698 00001200 4881C609000000      <1>     add rsi, 9  ;Go past LASTDRIVE
   699 00001207 E84BFAFFFF          <1>     call .skipSeparators
   700 0000120C AC                  <1>     lodsb   ;Get this char
   701 0000120D 0FB6C0              <1>     movzx eax, al   ;Zero extend to eax
   702 00001210 E8C0000000          <1>     call .ucChar
   703 00001215 3C5A                <1>     cmp al, "Z"
   704 00001217 77DD                <1>     ja .sftHandlerErr
   705 00001219 3C41                <1>     cmp al, "A"
   706 0000121B 72D9                <1>     jb .sftHandlerErr
   707 0000121D 803E0D              <1>     cmp byte [rsi], CR
   708 00001220 740F                <1>     je .ldProceed
   709 00001222 803E0A              <1>     cmp byte [rsi], LF
   710 00001225 740A                <1>     je .ldProceed
   711 00001227 803E09              <1>     cmp byte [rsi], TAB
   712 0000122A 7405                <1>     je .ldProceed
   713 0000122C 803E20              <1>     cmp byte [rsi], SPC
   714 0000122F 75C5                <1>     jne .sftHandlerErr
   715                              <1> .ldProceed:
   716 00001231 2C40                <1>     sub al, "@"     ;Convert into a number 1-26 
   717 00001233 0FB6C0              <1>     movzx eax, al   ;Zero extend in case DOS rets something dumb in upper bits
   718 00001236 0FB615(CF010000)    <1>     movzx edx, byte [LASTDRIVE]
   719 0000123D 39D0                <1>     cmp eax, edx
   720 0000123F 0F42C2              <1>     cmovb eax, edx
   721 00001242 488945D8            <1>     mov qword [rbp - cfgFrame.newLastdrive], rax
   722 00001246 F8                  <1>     clc
   723                              <1>     return
    13                              <2> %%_ret:
    14 00001247 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   724                              <1> 
   725                              <1> .shellHandler:
   726 00001248 488B75B0            <1>     mov rsi, qword [rbp - cfgFrame.linePtr]
   727 0000124C 4889F3              <1>     mov rbx, rsi
   728 0000124F 4881C605000000      <1>     add rsi, 5  ;Go past SHELL
   729 00001256 E8FCF9FFFF          <1>     call .skipSeparators    ;Spaces, equals sign etc
   730 0000125B 4889F7              <1>     mov rdi, rsi
   731 0000125E 4829DF              <1>     sub rdi, rbx    ;Get the depth into the string we are at
   732 00001261 B980000000          <1>     mov ecx, 128
   733 00001266 29F9                <1>     sub ecx, edi    ;Get remaining valid char count for the string
   734 00001268 4889F7              <1>     mov rdi, rsi
   735 0000126B B80D000000          <1>     mov eax, CR
   736 00001270 F2AE                <1>     repne scasb     ;Scan for the terminator
   737 00001272 0F853DFAFFFF        <1>     jne .badLineErrorMsg    ;If we didn't find it, complain!
   738                              <1>     ;Now we know we are safe, proceed with copy.
   739 00001278 488D3D(54000000)    <1>     lea rdi, cmdSpec
   740 0000127F B800370000          <1>     mov eax, 3700h  ;Get switchchar in dl
   741 00001284 CD21                <1>     int 21h
   742                              <1> .shLp:
   743 00001286 AC                  <1>     lodsb
   744                              <1>     ;If a sep, a CR or a default switchchar, we are done!
   745 00001287 3C0D                <1>     cmp al, CR
   746 00001289 740E                <1>     je .shSpecDone   
   747 0000128B E8B0F9FFFF          <1>     call .isCharSeparator
   748 00001290 7407                <1>     je .shSpecDone
   749 00001292 38D0                <1>     cmp al, dl
   750 00001294 7403                <1>     je .shSpecDone
   751 00001296 AA                  <1>     stosb   ;Else store the char!
   752 00001297 EBED                <1>     jmp short .shLp
   753                              <1> .shSpecDone:
   754 00001299 C60700              <1>     mov byte [rdi], 0   ;Now store the null terminator :)
   755 0000129C C605(9C020000)00    <1>     mov byte [tempPSP + psp.dta], 0 ;Reset the count of chars in the tail
   756 000012A3 488D3D(9D020000)    <1>     lea rdi, tempPSP + psp.dta + 1  ;Now store the tail here
   757 000012AA 48FFCE              <1>     dec rsi     ;Go back to get the char again
   758                              <1>     ;This will work with CR especially well
   759                              <1> .shTailLp:
   760 000012AD AC                  <1>     lodsb
   761 000012AE 3C0D                <1>     cmp al, CR
   762 000012B0 7409                <1>     je .shAllDone
   763 000012B2 AA                  <1>     stosb
   764 000012B3 FE05(9C020000)      <1>     inc byte [tempPSP + psp.dta]    ;Inc the char count!
   765 000012B9 EBF2                <1>     jmp short .shTailLp
   766                              <1> .shAllDone: ;Only possible to get here is al=CR
   767 000012BB AA                  <1>     stosb   ;Store the terminating CR
   768                              <1> .countryScan:
   769                              <1> .fcbHandler:
   770                              <1> .stacksHandler:
   771                              <1> .drivParm:
   772                              <1> .comment:
   773 000012BC F8                  <1>     clc
   774                              <1>     return
    13                              <2> %%_ret:
    14 000012BD C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   775                              <1> 
   776                              <1> .cfgExit:
   777 000012BE 488B5DC0            <1>     mov rbx, qword [rbp - cfgFrame.cfgHandle] ;Get the handle back
   778 000012C2 B8003E0000          <1>     mov eax, 3E00h    ;Close the handle
   779 000012C7 CD21                <1>     int 21h ;bx already has the handle
   780 000012C9 4C8B45B0            <1>     mov r8, qword [rbp - cfgFrame.linePtr]   ;Get the line buffer ptr back
   781 000012CD B800490000          <1>     mov eax, 4900h  ;FREE
   782 000012D2 CD21                <1>     int 21h
   783                              <1>     return
    13                              <2> %%_ret:
    14 000012D4 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   784                              <1> .ucChar:
   785                              <1> ;Input: al = Char to UC
   786                              <1> ;Output: al = UC'd char
   787 000012D5 53                  <1>     push rbx    ;Save on original stack
   788 000012D6 50                  <1>     push rax    ;Put the word on the stack
   789 000012D7 B813120000          <1>     mov eax, 1213h  ;Uppercase the char in al
   790 000012DC CD2F                <1>     int 2fh
   791 000012DE 5B                  <1>     pop rbx     ;Pop off the word we placed on the stack
   792 000012DF 5B                  <1>     pop rbx     ;Get back original rbx
   793                              <1>     return
    13                              <2> %%_ret:
    14 000012E0 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   794                              <1> 
   795                              <1> .termCheck:
   796                              <1> ;Input: al = Char to check if it is a command line terminator
   797                              <1> ;Output: ZF=ZE if terminator. ZF=NZ if not.
   798 000012E1 3C20                <1>     cmp al, SPC
   799 000012E3 7210                <1>     jb .bhtcspecial
   800                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000012E5 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000012E7 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   801 000012E8 3C09                <1>     cmp al, TAB
   802                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000012EA 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000012EC C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   803 000012ED 3C0D                <1>     cmp al, CR
   804                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000012EF 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000012F1 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   805 000012F2 3C0A                <1>     cmp al, LF
   806                              <1>     return
    13                              <2> %%_ret:
    14 000012F4 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   807                              <1> .bhtcspecial:
   808 000012F5 38C0                <1>     cmp al, al  ;Set ZF=ZE
   809                              <1>     return
    13                              <2> %%_ret:
    14 000012F7 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    22                                  
    23                                  Segment sdata data private align=1
    24                                  ;---------------------------
    25                                  ;   SYSINIT data segment
    26                                  ;---------------------------
    27                                  %include "./src/dos/Sysinit/sysdat.asm"
     1                              <1> ;--------------------------------
     2                              <1> ;       DATA FOR SYSINIT        :
     3                              <1> ;--------------------------------
     4 00000000 5374617274696E6720- <1> strtmsg db "Starting SCP/DOS...",0Ah,0Dh,"$"
     4 00000009 5343502F444F532E2E- <1>
     4 00000012 2E0A0D24            <1>
     5 00000016 0A0D426164206F7220- <1> badCom  db 0Ah,0Dh,"Bad or missing Command interpreter",0Ah,0Dh,"$"
     5 0000001F 6D697373696E672043- <1>
     5 00000028 6F6D6D616E6420696E- <1>
     5 00000031 746572707265746572- <1>
     5 0000003A 0A0D24              <1>
     6 0000003D 434F4E00            <1> conName db "CON",0
     7 00000041 41555800            <1> auxName db "AUX",0
     8 00000045 50524E00            <1> prnName db "PRN",0
     9                              <1> 
    10 00000049 434F4E4649472E5359- <1> cfgspec db "CONFIG.SYS",0   ;ASCIIZ for CONFIG
    10 00000052 5300                <1>
    11 00000054 434F4D4D414E442E43- <1> cmdSpec db "COMMAND.COM",0  ;ASCIIZ FOR COMMAND.COM. Overwrite in SHELL
    11 0000005D 4F4D00              <1>
    12                              <1> exceptData:
    13 00000060 [0000000000000000]  <1>     dq i0
    14 00000068 [0000000000000000]  <1>     dq i1
    15 00000070 [0000000000000000]  <1>     dq i2
    16 00000078 [0000000000000000]  <1>     dq i3
    17 00000080 [0000000000000000]  <1>     dq i4
    18 00000088 [0000000000000000]  <1>     dq i5
    19 00000090 [0000000000000000]  <1>     dq i6
    20 00000098 [0000000000000000]  <1>     dq i7
    21 000000A0 [0000000000000000]  <1>     dq i8
    22 000000A8 [0000000000000000]  <1>     dq i9
    23 000000B0 [0000000000000000]  <1>     dq i10
    24 000000B8 [0000000000000000]  <1>     dq i11
    25 000000C0 [0000000000000000]  <1>     dq i12
    26 000000C8 [0000000000000000]  <1>     dq i13
    27 000000D0 [0000000000000000]  <1>     dq i14
    28 000000D8 [0000000000000000]  <1>     dq i15
    29 000000E0 [0000000000000000]  <1>     dq i16
    30 000000E8 [0000000000000000]  <1>     dq i17
    31 000000F0 [0000000000000000]  <1>     dq i18
    32 000000F8 [0000000000000000]  <1>     dq i19
    33 00000100 [0000000000000000]  <1>     dq i20
    34 00000108 [0000000000000000]  <1>     dq i21
    35                              <1> 
    36                              <1> intData:
    37 00000110 [0000000000000000]  <1>     dq terminateProcess ;Int 20h
    38 00000118 [0000000000000000]  <1>     dq functionDispatch ;Int 21h
    39 00000120 [0000000000000000]  <1>     dq defaultIretq     ;Int 22h, Adjusted during interrupt setup to OEMHALT
    40 00000128 [0000000000000000]  <1>     dq defaultIretq     ;Int 23h, ignore any CTRL+C during init
    41 00000130 [0000000000000000]  <1>     dq dosDefCritErrHdlr    ;Int 24h, return fail, CF=CY, leading to OEMHALT
    42 00000138 [0000000000000000]  <1>     dq absDiskRead      ;Int 25h
    43 00000140 [0000000000000000]  <1>     dq absDiskWrite     ;Int 26h
    44 00000148 [0000000000000000]  <1>     dq terminateRes     ;Int 27h
    45 00000150 [0000000000000000]  <1>     dq defaultIretq     ;Int 28h
    46 00000158 [0000000000000000]  <1>     dq defaultIretq     ;Int 29h
    47 00000160 [0000000000000000]  <1>     dq defaultIretq     ;Int 2Ah
    48 00000168 [0000000000000000]  <1>     dq defaultIretq     ;Int 2Bh
    49 00000170 [0000000000000000]  <1>     dq defaultIretq     ;Int 2Ch
    50 00000178 [0000000000000000]  <1>     dq defaultIretq     ;Int 2Dh
    51 00000180 [0000000000000000]  <1>     dq defaultIretq     ;Int 2Eh
    52 00000188 [0000000000000000]  <1>     dq multiplexHdlr    ;Int 2Fh, multiplex default handler
    53                              <1> nData:
    54 00000190 0000000000000000    <1>     dq 0    ;We link here to the head of the OEM driver chain
    55 00000198 0480                <1>     dw 08004h
    56 0000019A [0000000000000000]  <1>     dq nulStrat
    57 000001A2 [0000000000000000]  <1>     dq nulIntr
    58 000001AA 4E554C2020202020    <1>     db "NUL     " ;Default NUL data
    59                              <1> 
    60                              <1> localIDTpointer: ;Local IDT pointer
    61 000001B2 0000                <1>     .Limit  dw 0
    62 000001B4 0000000000000000    <1>     .Base   dq 0
    63                              <1> 
    64                              <1> ;DOS Data given by OEM
    65 000001BC 0000000000000000    <1> FINALDOSPTR dq 0    ;Pointer to where dSeg should be loaded
    66 000001C4 0000000000000000    <1> MCBANCHOR   dq 0    ;Pointer to the Anchor MCB
    67 000001CC 00                  <1> FILES       db 0    ;Default number of FILES
    68 000001CD 00                  <1> BUFFERS     db 0    ;Default number of BUFFERS
    69 000001CE 00                  <1> DFLTDRIVE   db 0    ;Default drive number (0-25), this is the boot drive
    70 000001CF 00                  <1> LASTDRIVE   db 0    ;Default last drive number (0-25)
    71 000001D0 00                  <1> OEMBIOS     db 0    ;Set if to use IO.SYS or clear if to use SCPBIOS.SYS
    72                              <1> OEMMEMPTR:  ;Used to save the allocated 64k block for OEMCALLBK
    73 000001D1 0000000000000000    <1> OEMPTR      dq 0    ;Pointer to store at biosPtr
    74 000001D9 00000000            <1> OEMVERSION  dd 0    ;BIOS number, to be used by drivers for id-ing
    75                              <1> 
    76 000001DD 000000000000000000- <1> initDrvBlk  db initReqPkt_size dup (0)  ;Used for making driver init reqs
    76 000001E6 000000000000000000- <1>
    76 000001EF 000000000000000000- <1>
    76 000001F8 00000000            <1>
    77                              <1> cmdBlock:   ;Used also for overlay block for driver loads
    78                              <1>     istruc execProg
    79 000001FC 0000000000000000    <1>     at execProg.pEnv,       dq 0    ;Is set to point at the above line
    80 00000204 0000000000000000    <1>     at execProg.pCmdLine,   dq 0    ;Points to just a 0Dh
    81 0000020C 0000000000000000    <1>     at execProg.pfcb1,      dq 0    ;Set to DOS's fcb 1 and 2
    82 00000214 0000000000000000    <1>     at execProg.pfcb2,      dq 0
    83                              <1>     iend
    84                              <1> tempPSP: ;Points to a 256 byte space that is set up appropriately
    85                              <1>     istruc psp
    86 0000021C CD20                <1>     at psp.return,      db 0CDh, 20h
    87 0000021E 0000000000000000    <1>     at psp.allocSize,   dd 0, 0 ;Second 0 is for the reserved dword
    88 00000226 0000000000000000    <1>     at psp.oldInt22h,   dq 0
    89 0000022E 0000000000000000    <1>     at psp.oldInt23h,   dq 0
    90 00000236 0000000000000000    <1>     at psp.oldInt24h,   dq 0
    91 0000023E 0000000000000000    <1>     at psp.parentPtr,   dq 0
    92 00000246 FFFFFFFFFFFFFFFFFF- <1>     at psp.jobFileTbl,  db 20 dup (0FFh)
    92 0000024F FFFFFFFFFFFFFFFFFF- <1>
    92 00000258 FFFF                <1>
    93 0000025A 0000000000000000    <1>     at psp.envPtr,      dq 0
    94 00000262 0000000000000000    <1>     at psp.rspPtr,      dq 0
    95 0000026A 1400                <1>     at psp.jftSize,     dw 20 
    96 0000026C CD21C3              <1>     at psp.unixEntry,   db 0CDh, 21h, 0C3h
    97 0000026F 0000000000000000    <1>     at psp.prevPSP,     dq 0
    98 00000277 000000000000000000- <1>     at psp.fcb1,        db 16 dup (0)
    98 00000280 0000000000000000    <1>
    99 00000288 000000000000000000- <1>     at psp.fcb2,        db 20 dup (0)
    99 00000291 000000000000000000- <1>
    99 0000029A 0000                <1>
   100                              <1>     ;Dummy cmd line for COMMAND.COM
   101 0000029C 022F500D0000000000- <1>     at psp.dta,         db 2, "/P",CR,123 dup (0)   
   101 000002A5 000000000000000000- <1>
   101 000002AE 000000000000000000- <1>
   101 000002B7 000000000000000000- <1>
   101 000002C0 000000000000000000- <1>
   101 000002C9 000000000000000000- <1>
   101 000002D2 000000000000000000- <1>
   101 000002DB 000000000000000000- <1>
   101 000002E4 000000000000000000- <1>
   101 000002ED 000000000000000000- <1>
   101 000002F6 000000000000000000- <1>
   101 000002FF 000000000000000000- <1>
   101 00000308 000000000000000000- <1>
   101 00000311 000000000000000000- <1>
   101 0000031A 00                  <1>
   102 0000031B 00                  <1>     iend
    28                                  ;========================END OF SYSINIT MODULE=======================
    28          ------------------       info: assembly required 1+2+2 passes

