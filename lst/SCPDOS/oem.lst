     1                                  [DEFAULT REL]
     2                                  BITS 64
     3                                  
     4                                  %include "./src/Include/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1> ;    %ifdef retOff
    22                              <1> ;    %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1> ;    %ifdef currSegVBase
    24                              <1> ;    j%+1 short (retOff+currSegVBase)
    25                              <1> ;    %else
    26                              <1> ;    j%+1 short retOff
    27                              <1> ;    %endif  ;End ifdef currSegVBase
    28                              <1> ;    %else 
    29                              <1> ;    j%-1 short %%a
    30                              <1> ;    return
    31                              <1> ;%%a:
    32                              <1> ;    %endif  ;End the distance measurement if
    33                              <1> ;    %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1> ;    %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro rets 0
    81                              <1> cret s
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %macro retns 0
    85                              <1> cret ns
    86                              <1> %endmacro
    87                              <1> 
    88                              <1> %macro breakpoint 0
    89                              <1> xchg bx, bx
    90                              <1> %endmacro
     5                                  %include "./src/Include/dosStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous internal     ;
     4                              <1> ; SCP/DOS structures.                                   ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> ;File/path length equates.
     8                              <1> MAX_FNAME_FCB   equ 8
     9                              <1> MAX_EXT_FCB     equ 3
    10                              <1> MAX_NAME_FCB    equ MAX_FNAME_FCB + MAX_EXT_FCB
    11                              <1> MAX_NAME_FCBZ   equ MAX_NAME_FCB + 1    ;Space for a null terminator
    12                              <1> ;Values below include the null terminator.
    13                              <1> MAX_FILE    equ 13  ;Maximum length of a filename (includes dot)
    14                              <1> MAX_DRIVE   equ 3   ;Maximum length of a drive string (X:<NUL>)
    15                              <1> MAX_FSPEC   equ 64  ;Maximum length of a path to a file (filespec)
    16                              <1> MAX_PATH    equ 67  ;Maximum length of a fully qualified pathspec
    17                              <1> ;MAX_PATH is X:\<string, maxlen 63 chars>,<null> so 67 chars total.
    18                              <1> ;Use this symbol to check the length of a filename after qualification.
    19                              <1> MAX_PSPEC   equ MAX_PATH - MAX_FILE - 1 ;54 bytes
    20                              <1> ;MAX_PSPEC is the max length of a path with space for a filename!
    21                              <1> ;Remember, filenames for us are just a string of, at most, 13 characters,
    22                              <1> ; which we always resolve into FCB format. Buffers need to make space for
    23                              <1> ; both the dot and terminating null
    24                              <1> ;------------------------------------------------------------------------;
    25                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    26                              <1> ; its file system structure. This is used to locate files and structures
    27                              <1> ; on the device itself and to translate file requests to cluster chains
    28                              <1> ; to LBAs to pass to the disk driver..
    29                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    30                              <1> ; drivers Initialise routine has been called.
    31                              <1> ;------------------------------------------------------------------------;
    32                              <1> struc dpb        ;Drive Parameter Block
    33                              <1> 
    34 00000000 ??                  <1>     .bDriveNumber           db ?  ;Drive number (0=A, 1=B ...)
    35 00000001 ??                  <1>     .bUnitNumber            db ?  ;Unit number in device
    36 00000002 ????                <1>     .wBytesPerSector        dw ?  ;min 512, max 4096
    37 00000004 ??                  <1>     .bMaxSectorInCluster    db ?  ;(Maximum sector in cluster) - 1
    38 00000005 ??                  <1>     .bSecPerClustShift      db ?  ;Sectors per cluster exponent
    39 00000006 ????                <1>     .wFAToffset             dw ?  ;Number of reserved sectors in partition
    40 00000008 ??                  <1>     .bNumberOfFATs          db ?  ;Number of FATs
    41 00000009 ????                <1>     .wNumberRootDirEntries  dw ?  ;In 32 byte units, this is 0 for FAT32
    42 0000000B ????????            <1>     .dClusterHeapOffset     dd ?  ;Start sector of data area
    43 0000000F ????????            <1>     .dMaxClusterAddr        dd ?  ;Max Cluster Addr = # of data clusters + 1
    44 00000013 ????????            <1>     .dFATlength             dd ?  ;FAT length, in sectors
    45 00000017 ????????            <1>     .dFirstUnitOfRootDir    dd ?  
    46                              <1>     ;Unit=Sector/Cluster of Root Directory (FAT12/16 = Sector, FAT32 = Cluster)
    47 0000001B ????????????????    <1>     .qDriverHeaderPtr       dq ?  ;Pointer to device driver header
    48 00000023 ??                  <1>     .bMediaDescriptor       db ?  ;Media descriptor
    49 00000024 ??                  <1>     .bAccessFlag            db ?  ;Access Flag (0 if accessed, else -1)
    50 00000025 ????????????????    <1>     .qNextDPBPtr            dq ?  ;Pointer to next DPB, -1 if at end
    51 0000002D ????????            <1>     .dNextFreeClst          dd ?  ;Starting cluster of free space search
    52 00000031 ????????            <1>     .dFreeClustCnt          dd ?  ;Number of free clusters, -1 unknown
    53                              <1> 
    54                              <1> endstruc
    55                              <1> 
    56                              <1> fat12MaxClustCnt    equ 4085    ;Cluster count less than this is FAT12
    57                              <1> fat16MaxClustCnt    equ 65525   ;Cluster count less than this is FAT16
    58                              <1> ;------------------------------------------------------------------------;
    59                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    60                              <1> ; All disk pathing requests go via the CDS for that drive.
    61                              <1> ; The default drive is the last accessed drive, this number is stored
    62                              <1> ; in the DOS data area.
    63                              <1> ; The CDS is stored as an array with the offset into the array being 
    64                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    65                              <1> ;
    66                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    67                              <1> ;------------------------------------------------------------------------;
    68                              <1> struc cds       ;Current Directory structure
    69 00000000 <res 43h>           <1>     .sCurrentPath        db MAX_PATH dup (?)    ;Current Directory Path String
    70 00000043 ????                <1>     .wFlags              dw ?   ;CDS Flags - 
    71 00000045 ????????????????    <1>     .qDPBPtr             dq ?   ;Ptr to the DPB of the dev using this CDS
    72 0000004D ????????            <1>     .dStartCluster       dd ?   ;Starting cluster of the directory on disk
    73 00000051 ????????????????    <1>     .qIFSPtr             dq ?   ;Reserved for IFS driver expansions
    74 00000059 ????????            <1>     .dNetStore           dd ?   ;For storing a owner dword for IFS (21h/5F03h)
    75 0000005D ????                <1>     .wBackslashOffset    dw ?   ;How many chars to skip for getting the path
    76                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    77                              <1> ; another, we save the number of chars to skip to that deep level).
    78                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    79                              <1> ; Only affects for SUBST drives, not JOIN
    80                              <1> ; Flags: Bit 15 set = Network drive
    81                              <1> ;        Bit 14 set = Physical drive
    82                              <1> ;        Bit 13 set = JOIN'ed drive
    83                              <1> ;        Bit 12 set = SUBST'ed drive
    84                              <1> ;        Bit 7  set = Redirected, not net. drive (This is how MSCDEX worked)
    85                              <1> endstruc
    86                              <1> ;CDS equates
    87                              <1> cdsRedirDrive   equ 8000h   ;All drives which use the Redirector interface
    88                              <1> cdsValidDrive   equ 4000h   ;CDS valid
    89                              <1> cdsJoinDrive    equ 2000h   ;CDS for joined drives
    90                              <1> cdsSubstDrive   equ 1000h   ;Drives formed by Subst
    91                              <1> cdsRdirLocDrive equ 0080h   ;Redirector but Local
    92                              <1> ;------------------------------------------------------------------------;
    93                              <1> ; The SFT is a way to allow applications to open file handles to files 
    94                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    95                              <1> ; under the first header, and then a second header will be linked to the 
    96                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    97                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    98                              <1> ; using the FCBS= command. Default FCBS=5.
    99                              <1> ;
   100                              <1> ; A file handle describes the file, and the location within the file that
   101                              <1> ; we are reading. The file handle can be manipulated without the file
   102                              <1> ; being in memory, thus allowing the user to access data without needing 
   103                              <1> ; to take up large portions of memory. Similarly, file handles allow for
   104                              <1> ; accessing devices, by treating them as files with their drivers 
   105                              <1> ; responding and translating the manipulations of the file handle itself.
   106                              <1> ; Neither the driver nor the application should see or use the SFT for
   107                              <1> ; the handle, as it is subject to change (and will change when file 
   108                              <1> ; sharing provisions are included). The DOS will make requests to the 
   109                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
   110                              <1> ; track of the information in the SFT entry for that handle. 
   111                              <1> ;
   112                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
   113                              <1> ; can point to the same file. It all depends on what the applications 
   114                              <1> ; want to do with the File.
   115                              <1> ;
   116                              <1> ; !!!!IMPORTANT!!!!
   117                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   118                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   119                              <1> ;
   120                              <1> ;Each SFT may look like this:
   121                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   122                              <1> ;            |                |
   123                              <1> ;       wNumFiles*sft    wNumFiles*sft
   124                              <1> ;
   125                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   126                              <1> ; System FCBs.
   127                              <1> ;
   128                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   129                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   130                              <1> ;
   131                              <1> ; DEFAULT FILES=8, MINIMUM FILES=5
   132                              <1> ; DEFAULT FCBS=5,  MINIMUM FCBS=5
   133                              <1> ;------------------------------------------------------------------------;
   134                              <1> struc sfth   ;System file table header
   135                              <1> ; This is the SFT header.
   136                              <1> ; This structure comes before the start of the first file in the array/table.
   137 00000000 ????????????????    <1>     .qNextSFTPtr dq ?    ;Pointer to the next SFT
   138 00000008 ????                <1>     .wNumFiles   dw ?    ;Number of files in this table
   139                              <1> endstruc
   140                              <1> 
   141                              <1> struc sft
   142                              <1> ;This is the file struc itself
   143 00000000 ????                <1>     .wNumHandles dw ?    ;Number of handles pointing to this file
   144 00000002 ????                <1>     .wOpenMode   dw ?    ;File access permissions and behvaiours
   145 00000004 ??                  <1>     .bFileAttrib db ?    ;Regular File Attributes
   146 00000005 ????                <1>     .wDeviceInfo dw ?    ;Includes unit number if a block device
   147 00000007 ????????????????    <1>     .qPtr        dq ?    ;IF char, ptr to device driver header, ELSE DPBptr
   148 0000000F ????????            <1>     .dStartClust dd ?    ;Start cluster of file pointed to by SFT entry
   149 00000013 ????                <1>     .wTime       dw ?    ;File Time, updated on open and writes
   150 00000015 ????                <1>     .wDate       dw ?    ;File Date, updated on open and writes
   151 00000017 ????????            <1>     .dFileSize   dd ?    ;File Size, in bytes
   152 0000001B ????????            <1>     .dCurntOff   dd ?    ;Current Offset pointed to by SFT entry, in bytes
   153 0000001F ????????            <1>     .dRelClust   dd ?    ;Rel cluster pointed to by SFT entry
   154 00000023 ????????            <1>     .dAbsClusr   dd ?    ;Absolute cluster pointed to by SFT entry
   155 00000027 ????????????????    <1>     .qDirSect    dq ?    ;Abs number of sector containing directory entry 
   156 0000002F ??                  <1>     .bNumDirEnt  db ?    ;Directory entry within dir sector (byte offset/32)
   157 00000030 <res Bh>            <1>     .sFileName   db 11 dup (?)   ;8.3 Filename
   158                              <1> ;                       Share Vars
   159 0000003B ????????????????    <1>     .pNextSFT   dq ?    ;Ptr to the next SFT for this file in the chain
   160 00000043 ????????            <1>     .dNetID     dd ?    ;Network ID of the machine (VM) that opened this file
   161 00000047 ????????????????    <1>     .qPID       dq ?    ;Proc ID (PSP) of the program which opened this file
   162 0000004F ????                <1>     .wMFTOffset dw ?    ;Offset to the MFT for this file. 0 means no MFT
   163                              <1> endstruc
   164                              <1> ;Open Mode equates
   165                              <1> ;Access modes   Bits[2:0]
   166                              <1> openRdAcc   equ 0h
   167                              <1> openWrAcc   equ 1h
   168                              <1> openRWAcc   equ 2h
   169                              <1> ;Bit 3 reserved 0
   170                              <1> ;Sharing modes  Bits[6:4]
   171                              <1> openCompat      equ 0h  ;Deny all, compatibility mode
   172                              <1> openDenRWShr    equ 10h ;Deny all, explicity read/write
   173                              <1> openDenWrShr    equ 20h ;Deny writes
   174                              <1> openDenRdShr    equ 30h ;Deny reads
   175                              <1> openDenNoShr    equ 40h ;Don't deny anything!
   176                              <1> ;NetFCB is for files open by a local server, handling IO from a remote
   177                              <1> ; client by proxy opened by an FCB! Sets the Net bit to indicate this. 
   178                              <1> ;Thus, this is a handle with no JFT entry! Server handles its own JFT!
   179                              <1> openNetFCBShr   equ 70h
   180                              <1> openNoInherit   equ 80h
   181                              <1> 
   182                              <1> ;Bits 8-12 reserved 0
   183                              <1> ;The next two are extended open mode bits! 
   184                              <1> ;Can be set
   185                              <1> openFailOnI24   equ 2000h   ;If set, automatically FAIL all Int 24h
   186                              <1> openFlushWrites equ 4000h   ;If set, commit after each write call.
   187                              <1> ;Once share is loaded, if a local FCB open occurs, mark the sft as so.
   188                              <1> openSFTFCB      equ 8000h   ;If set, file is SFT-FCB.
   189                              <1> 
   190                              <1> ;Attribute Byte
   191                              <1> attrFileRO          equ 1h
   192                              <1> attrFileHidden      equ 2h
   193                              <1> attrFileSys         equ 4h
   194                              <1> attrFileVolLbl      equ 8h
   195                              <1> attrFileDir         equ 10h ;Directory entry
   196                              <1> attrFileArchive     equ 20h
   197                              <1> attrFileChar        equ 40h ;Reserved, never found in dir
   198                              <1> 
   199                              <1> ;Device Info word equates
   200                              <1> ;For a block device, bits [5:0] contain the drive number
   201                              <1> devCharConIn    equ 1h  ;If set, device is CON input
   202                              <1> devCharConOut   equ 2h  ;If set, device is CON output
   203                              <1> devCharNulDev   equ 4h  ;If set, device is NULL device
   204                              <1> devCharClkDev   equ 8h  ;If set, device is CLOCK device
   205                              <1> 
   206                              <1> devCharFastOut  equ 10h ;If set, device supports INT 29h
   207                              <1> devCharBinary   equ 20h ;If set, r/w char device in Binary mode
   208                              <1> devCharNotEOF   equ 40h ;If set, device not yet at end of file
   209                              <1> devDiskNoFlush  equ 40h ;Set if file is synchronised with hard store!
   210                              <1> devCharDev      equ 80h ;If set, it is a char device!
   211                              <1> 
   212                              <1> devDiskI24onFull    equ 100h    ;If set, Int 24h on disk full or disk EOF
   213                              <1> devCharNetSpool equ 800h    ;If set, device is a network spooler
   214                              <1> 
   215                              <1> devNoInherit    equ 1000h   ;If set, handle not inherited by child processes
   216                              <1> devCharNamePipe equ 2000h   ;If set, device is a named pipe
   217                              <1> devDiskNoDTonClose equ 4000h   ;If set, dont update date and time when closing
   218                              <1> devRedir        equ 8000h   ;If set, dev/file is redirected!
   219                              <1> 
   220                              <1> ;Extended open flags. For the var [wEOFlags]
   221                              <1> ;These are not related to the SFT but are used during an extended open
   222                              <1> ; call to keep track of whats going on and thus help build an SFT.
   223                              <1> eoInExtOpen     equ 0001h   ;Doing Extended Open
   224                              <1> eoFailI24       equ 0002h   ;If EO file hard fails, skip and fail Int 24h
   225                              <1> eoFileNoExist   equ 0004h   ;File doesnt exist
   226                              <1> 
   227                              <1> ;Can combine the third option with one of the first two options.
   228                              <1> ;The first two options cannot be combined.
   229                              <1> ; - If only create is selected, then we try to do a create new. If the 
   230                              <1> ;       file exists, this fails with a "File exists" error.
   231                              <1> ;       Acts like a normal create new call. (21/5Bh)
   232                              <1> ;
   233                              <1> ; - If only open is selected then we try to do an open. If the file doesn't
   234                              <1> ;       doesn't exist, this fails with a "File not found" error.
   235                              <1> ;       Acts like a normal open call. (21/3Dh)
   236                              <1> ;
   237                              <1> ; - If only truncate is selected then we try to do a create. If the file
   238                              <1> ;       doesn't exist, this fails a "File not found" error.
   239                              <1> ;       New behaviour.
   240                              <1> ;
   241                              <1> ; - If open and create are selected then we try and open the file. If 
   242                              <1> ;       the open fails due to the file not existing, we create a new file. 
   243                              <1> ;       New behaviour.
   244                              <1> ;
   245                              <1> ; - If truncate and create are selected then we try to truncate the file. 
   246                              <1> ;       If the file doesnt exist then we create a new file instead.
   247                              <1> ;       Acts like a normal create call. (21/3Ch)
   248                              <1> 
   249                              <1> eoActOpen       equ 01h ;Open the file. 
   250                              <1> eoActTruncate   equ 02h ;Truncate an existing file.
   251                              <1> eoActCreate     equ 10h ;Create a file if one doesnt exist.
   252                              <1> ;Extended Open Action Return 
   253                              <1> eoRetActOpen    equ 1   ;Open existing
   254                              <1> eoRetActCreate  equ 2   ;Create new and open
   255                              <1> eoRetActTruncate    equ 3    ;Recreate and open
   256                              <1> ;------------------------------------------------------------------------;
   257                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   258                              <1> ; to an internal buffer, and then copying it to the specified location
   259                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   260                              <1> ; another request for the same sector from the same device is made, so 
   261                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   262                              <1> ; size, selected according to the largest detected sector size during 
   263                              <1> ; the initial loadup.
   264                              <1> ;
   265                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   266                              <1> ;
   267                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   268                              <1> ;------------------------------------------------------------------------;
   269                              <1> 
   270                              <1> struc bufferHdr
   271 00000000 ????????????????    <1>     .nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
   272                              <1>     .wDrvNumFlg:         ;Read as a word to get the following two bytes!
   273 00000008 ??                  <1>     .driveNumber db  ?   ;Drive number the buffer is used for (or -1 for free)
   274 00000009 ??                  <1>     .bufferFlags db  ?   ;Standard Flags
   275 0000000A ????????????????    <1>     .bufferLBA   dq  ?   ;LBA the buffer contains
   276 00000012 ??                  <1>     .bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
   277 00000013 ????????            <1>     .bufFATsize  dd  ?   ;Number of sectors per FAT (or 0 if non-FAT)
   278 00000017 ????????????????    <1>     .driveDPBPtr dq  ?   ;Pointer to the device DPB block
   279 0000001F ??                  <1>     .reserved    db  ?   ;Alignment byte
   280                              <1>     .dataarea:             ;Points to the start of the data area
   281                              <1> endstruc
   282                              <1> ;Buffer Flag equates
   283                              <1> dosBuffer   equ 1h  ;Sector 0 (BPB/VPB) in buffer
   284                              <1> fatBuffer   equ 2h  ;FAT sector in buffer
   285                              <1> dirBuffer   equ 4h  ;Directory sector in buffer
   286                              <1> dataBuffer  equ 8h  ;File Data sector in buffer
   287                              <1> refBuffer   equ 20h ;Data in buffer has been referenced by an application
   288                              <1> dirtyBuffer equ 40h ;Data in buffer modified by an application
   289                              <1> freeBuffer  equ 00FFh   ;A word which goes into the drive number to clear both fields
   290                              <1> ;Note! A buffer is marked as referenced when the buffer is "obtained" by a syscall
   291                              <1> ;------------------------------------------------------------------------;
   292                              <1> ; Memory control block for each memory arena
   293                              <1> ;------------------------------------------------------------------------;
   294                              <1> struc mcb
   295 00000000 ??                  <1>     .marker     db ?  ;M = Member of the MCB chain. Z = Last member
   296 00000001 ????????????????    <1>     .owner      dq ?  ;Owning application PSP (para aligned) or 0 for free
   297 00000009 ????????            <1>     .blockSize  dd ?  ;Number of contiguous paragraphs owned by this block
   298                              <1>     ;The following byte is reserved outside of sysinit
   299 0000000D ??                  <1>     .subSysMark db ?  ;Marks the optional DOS subsystem of the MCB
   300 0000000E ????                <1>     .reserved   db 2 dup (?) 
   301                              <1>     .program:
   302                              <1> endstruc
   303                              <1> ;MCB equates
   304                              <1> mcbOwnerHole    equ 7   ;Owner = 7 => Memory hole, always fail free/realloc
   305                              <1> mcbOwnerFree    equ 0   ;Owner = 0 => Free and available space
   306                              <1> mcbOwnerDOS     equ 8   ;Owner = 8 => Owned by DOS
   307                              <1> mcbOwnerNewDOS  equ 9   ;Owner = 9 => New Kernel driver alloc. Needs setting to 8.
   308                              <1> mcbMarkCtn      equ "M"
   309                              <1> mcbMarkEnd      equ "Z"
   310                              <1> ;The following are used on MCB's that belong to DOS, that are not part of the
   311                              <1> ; main kernel (i.e. the CONFIG.SYS optional parts).
   312                              <1> mcbSubDriver    equ "D" ;Any memory allocated for a device driver's code.
   313                              <1> mcbSubDrvExtra  equ "L" ;Any memory allocated by a device driver.
   314                              <1> mcbSubDrvDPB    equ "P" ;Blocks used for DPB's are marked so.
   315                              <1> mcbSubIFS       equ "I" ;Unused for now
   316                              <1> mcbSubFiles     equ "F" ;Any memory allocated for Files.
   317                              <1> mcbSubFCBS      equ "X" ;Unused for now
   318                              <1> mcbSubBuffers   equ "B" ;Any memory allocated for Buffers.
   319                              <1> mcbSubCDS       equ "L" ;Any memory allocated to store a CDS.
   320                              <1> mcbSubStacks    equ "S" ;Unused for now
   321                              <1> 
   322                              <1> 
   323                              <1> memFirstFit     equ 0   ;First free block goes to application
   324                              <1> memBestFit      equ 1   ;Block whos size closest matches requirement
   325                              <1> memLastFit      equ 2   ;Last free block goes to application
   326                              <1> 
   327                              <1> ;Owner = Para aligned address => Owning application PSP
   328                              <1> ;...To consider...
   329                              <1> ;Owner = Non-para aligned address => Error? Should maybe lock up system?
   330                              <1> ;blockSize counts the number of paragraphs FROM .program TO THE NEXT MCB!
   331                              <1> ;------------------------------------------------------------------------;
   332                              <1> ; For Int 21h, the callers registers are saved on their stack in the 
   333                              <1> ; following order, thus allowing for return values to be placed in the 
   334                              <1> ; registers by accessing the caller register stack frame.
   335                              <1> ;------------------------------------------------------------------------;
   336                              <1> struc callerFrame
   337 00000000 ????????????????    <1>     .rax    dq ?  ;Bottom of frame, pointer to rax saved in oldRSP
   338 00000008 ????????????????    <1>     .rbx    dq ?    
   339 00000010 ????????????????    <1>     .rcx    dq ?
   340 00000018 ????????????????    <1>     .rdx    dq ?
   341 00000020 ????????????????    <1>     .rsi    dq ?
   342 00000028 ????????????????    <1>     .rdi    dq ?
   343 00000030 ????????????????    <1>     .rbp    dq ?
   344 00000038 ????????????????    <1>     .r8     dq ?  ;To be removed if truly not needed
   345 00000040 ????????????????    <1>     .r9     dq ?
   346                              <1> ;Pushed by Processor when invoked via Interrupt
   347 00000048 ????????????????    <1>     .rip    dq ?
   348 00000050 ????????????????    <1>     .cs     dq ?
   349 00000058 ????????????????    <1>     .flags  dq ?
   350                              <1> endstruc
   351                              <1> 
   352                              <1> struc dpl
   353                              <1> ;DOS parameter list, pointer to this stack is passed to DOS in rdx on
   354                              <1> ; server calls
   355 00000000 ????????????????    <1>     .rax    dq ?
   356 00000008 ????????????????    <1>     .rbx    dq ?
   357 00000010 ????????????????    <1>     .rcx    dq ?
   358 00000018 ????????????????    <1>     .rdx    dq ?
   359 00000020 ????????????????    <1>     .rsi    dq ?
   360 00000028 ????????????????    <1>     .rdi    dq ?
   361 00000030 ????????????????    <1>     .r8     dq ?
   362 00000038 ????????????????    <1>     .r9     dq ?
   363 00000040 ????????????????    <1>     .align  dq ?
   364 00000048 ????????????????    <1>     .compID dq ?  ;Computer id, low word used only
   365 00000050 ????????????????    <1>     .procID dq ?  ;Process ID
   366                              <1> endstruc
   367                              <1> 
   368                              <1> struc cfgFrame  ;Frame used for config.sys parsing
   369 00000000 ????????????????    <1>     .oldRBP         dq ?    ;Ptr to DOSSEG
   370 00000008 ????????????????    <1>     .newBuffers     dq ?    ;New buffers value
   371 00000010 ????????????????    <1>     .newSFTVal      dq ?
   372 00000018 ????????????????    <1>     .newFCBSVal     dq ?
   373 00000020 ????????????????    <1>     .newProtFCBSVal dq ?    ;Number of protected FCBS
   374 00000028 ????????????????    <1>     .newLastdrive   dq ?
   375 00000030 ????????????????    <1>     .newStacks      dq ?    ;Ignored for now
   376 00000038 ????????????????    <1>     .newStackSize   dq ?    ;Ignored for now
   377 00000040 ????????????????    <1>     .cfgHandle      dq ?    ;CONFIG.SYS handle
   378 00000048 ????????????????    <1>     .lastLine       dq ?    ;Set if the last line is current
   379 00000050 ????????????????    <1>     .linePtr        dq ?    ;Ptr to line buffer of line being processed
   380 00000058 ????????????????    <1>     .driverBreak    dq ?    ;Ptr to the pathname terminator 
   381 00000060 ????????????????    <1>     .breakChar      dq ?    ;Char that was replaced by null for terminator
   382                              <1> endstruc
   383                              <1> 
   384                              <1> struc filename
   385                              <1> ;8.3 File name struct
   386 00000000 ????????????????    <1>     .fName  db 8 dup (?)
   387 00000008 ??????              <1>     .fExt   db 3 dup (?)
   388                              <1> endstruc
   389                              <1> 
   390                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
   391 00000000 ??                  <1>     .driveNum   db ?  ;Drive we are searching on, 1 based number
   392 00000001 <res Bh>            <1>     .template   db 11 dup (?) ;Search template (? meaning anything)
   393 0000000C ??                  <1>     .attrib     db ?  ;Search attribute
   394 0000000D ????????            <1>     .dirOffset  dd ?  ;32 byte entry within dir cluster
   395 00000011 ????????            <1>     .parDirClus dd ?  ;Parent Directory Cluster number
   396 00000015 ??                  <1>     .attribFnd  db ?  ;Attrib of file found
   397 00000016 ????                <1>     .fileTime   dw ?  ;File time
   398 00000018 ????                <1>     .fileDate   dw ?  ;File date
   399 0000001A ????????            <1>     .fileSize   dd ?  ;Number of bytes
   400 0000001E <res Dh>            <1>     .asciizName db 13 dup (?) ;ASCIIZ name with dot and terminating nul
   401                              <1> endstruc
   402                              <1> 
   403                              <1> dfltJFTsize equ 20  ;Default size of PSP JFT
   404                              <1> struc psp
   405 00000000 ????                <1>     .return     db 2 dup (?)  ;Should always be CDh 20h, same place as DOS
   406 00000002 ????????            <1>     .allocSize  dd ?  ;Number of paras in init alloc or when exiting as TSR.
   407 00000006 ????????            <1>                 dd ?  ;Reserved 4 bytes
   408 0000000A ????????????????    <1>     .oldInt22h  dq ?  ;Int 22h pointer on overlay load
   409 00000012 ????????????????    <1>     .oldInt23h  dq ?  ;Int 23h pointer on overlay load
   410 0000001A ????????????????    <1>     .oldInt24h  dq ?  ;Int 24h pointer on overlay load
   411 00000022 ????????????????    <1>     .parentPtr  dq ?  ;Pointer to parent process PSP
   412                              <1> ;If jftSize > 20, then the QWORD at .jobFileTbl becomes a pointer
   413                              <1> ; to the actual in use JFT and the other 12 bytes are left undefined.
   414                              <1> ;If jftSize < 20 (DOS will never set it so), then it is considered as 20
   415                              <1> ;If the user tries to reduce handle count to 20 or less, then the PSP JFT is 
   416                              <1> ; always used and jftSize.
   417                              <1>     .externalJFTPtr:    ;Ptr to external JFT array (first byte AFTER MCB)
   418 0000002A <res 14h>           <1>     .jobFileTbl db dfltJFTsize dup (?) ;Main File handle array, JFT
   419 0000003E ????????????????    <1>     .envPtr     dq ?  ;Pointer to the environment
   420 00000046 ????????????????    <1>     .rspPtr     dq ?  ;Pointer to rsp on entry to Int 21h
   421 0000004E ????                <1>     .jftSize    dw ?  ;JFT array size, 20 => PSP JFT in use
   422 00000050 ??????              <1>     .unixEntry  db 3 dup (?)  ;Must always be CDh 21h CBh, same place as DOS
   423 00000053 ????????????????    <1>     .prevPSP    dq ?  ;Pointer to the previous PSP in chain (used by SHARE)
   424 0000005B ??                  <1>                 db ?  ;Reserved byte
   425                              <1> ;The below are in the same place as in DOS.
   426                              <1>     .cmdLineArgPtr: ;Symbol for future use
   427 0000005C <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1 
   428 0000006C <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
   429                              <1>     .dta:   ;Pointer to the default DTA in the PSP
   430 00000080 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
   431 00000081 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
   432                              <1> endstruc
   433                              <1> 
   434                              <1> struc clkStruc
   435 00000000 ????                <1>     .dateWord   dw ?
   436 00000002 ??                  <1>     .minutes    db ?
   437 00000003 ??                  <1>     .hours      db ?
   438 00000004 ??                  <1>     .hseconds   db ?  ;Hundreths of seconds
   439 00000005 ??                  <1>     .seconds    db ?
   440                              <1> endstruc
   441                              <1> 
   442                              <1> 
   443                              <1> struc extCtryStruc
   444 00000000 ??                  <1>     .infoIDCode db ?    ;Information ID code (01h)
   445 00000001 ????                <1>     .strucSize  dw ?    ;Length of the structure  (42 or less)
   446 00000003 ????                <1>     .ctryID     dw ?    ;Country ID number
   447 00000005 ????                <1>     .cpNumber   dw ?    ;Code page number
   448 00000007 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   449                              <1>                         ;0 = month day year hh:mm:ss
   450                              <1>                         ;1 = day month year hh:mm:ss
   451                              <1>                         ;2 = year month day hh:mm:ss
   452 00000009 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   453 0000000E ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   454 00000010 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   455 00000012 ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   456 00000014 ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   457 00000016 ??                  <1>     .currFmt    db ?    ;Currency Format
   458                              <1>                         ;0 = Symbol leads, without space
   459                              <1>                         ;1 = Symbol follows, without space
   460                              <1>                         ;2 = Symbol leads, one space
   461                              <1>                         ;3 = Symbol follows, one space
   462                              <1>                         ;4 = Symbol replace decimal separator
   463 00000017 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   464 00000018 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   465 00000019 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   466 00000021 ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   467 00000023 <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   468                              <1> endstruc
   469                              <1> 
   470                              <1> struc countryStruc
   471 00000000 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   472                              <1>                         ;0 = month day year hh:mm:ss
   473                              <1>                         ;1 = day month year hh:mm:ss
   474                              <1>                         ;2 = year month day hh:mm:ss
   475 00000002 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   476 00000007 ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   477 00000009 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   478 0000000B ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   479 0000000D ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   480 0000000F ??                  <1>     .currFmt    db ?    ;Currency Format
   481                              <1>                         ;0 = Symbol leads, without space
   482                              <1>                         ;1 = Symbol follows, without space
   483                              <1>                         ;2 = Symbol leads, one space
   484                              <1>                         ;3 = Symbol follows, one space
   485                              <1>                         ;4 = Symbol replace decimal separator
   486 00000010 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   487 00000011 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   488 00000012 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   489 0000001A ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   490 0000001C <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   491                              <1> endstruc
   492                              <1> 
   493                              <1> ;Critical Error AH bitfield equates
   494                              <1> critRead    equ 0h
   495                              <1> critWrite   equ 1h
   496                              <1> critDOS     equ 0h
   497                              <1> critFAT     equ 2h
   498                              <1> critDir     equ 4h
   499                              <1> critData    equ 6h
   500                              <1> critFailOK  equ 8h
   501                              <1> critRetryOK equ 10h
   502                              <1> critIgnorOK equ 20h
   503                              <1> critCharDev equ 80h
   504                              <1> 
   505                              <1> critIgnore  equ 0
   506                              <1> critRetry   equ 1
   507                              <1> critAbort   equ 2
   508                              <1> critFail    equ 3
   509                              <1> 
   510                              <1> ;MISC ASCII control chars
   511                              <1> NUL equ 00h ;^@         | ASCII Null
   512                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text) 
   513                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
   514                              <1> BEL equ 07h ;^G         | ASCII Bell
   515                              <1> BSP equ 08h ;^H         | ASCII Backspace
   516                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
   517                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
   518                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
   519                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
   520                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
   521                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
   522                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
   523                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
   524                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
   525                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
   526                              <1> SPC equ 20h ;Printable  | ASCII Space
   527                              <1> ;This last one is NEVER printed with a caret as it is a console control char
   528                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
   529                              <1> 
   530                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
   531                              <1> ;Extended Ascii Codes
   532                              <1> eF1     equ 3Bh ;F1 second byte
   533                              <1> eF2     equ 3Ch ;F2 second byte
   534                              <1> eF3     equ 3Dh ;F3 second byte
   535                              <1> eF4     equ 3Eh ;F4 second byte
   536                              <1> eF5     equ 3Fh ;F5 second byte
   537                              <1> eF6     equ 40h ;F6 second byte
   538                              <1> eF7     equ 41h ;F7 second byte
   539                              <1> eCursL  equ 4Bh ;Cursor Left second byte
   540                              <1> eCursR  equ 4Dh ;Cursor Right second byte
   541                              <1> eIns    equ 52h ;Insert second byte
   542                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
   543                              <1> 
   544                              <1> ;Default Configuration for the system
   545                              <1> 
   546                              <1> buffersDefault  equ 30
   547                              <1> filesDefault    equ 20
   548                              <1> fcbsDefault     equ 4
   549                              <1> safeFcbsDeflt   equ 0
   550                              <1> lastDriveDeflt  equ 5   
   551                              <1> 
   552                              <1> ;ASCII char property table equates. If such a bit is clear in signature in table
   553                              <1> ; then the char has this property.
   554                              <1> badChar     equ 1   ;Bad ASCIIZ filename char
   555                              <1> termChar    equ 2   ;Terminator char type
   556                              <1> sepChar     equ 4   ;Separator char type
   557                              <1> badFCBChar  equ 8   ;FCB filename char
     6                                  
     7                                  ;=======================START OF OEMINIT MODULE======================
     8                                  %include "./src/Oeminit/oem.inc"
     1                              <1> 
     2                              <1> ;OEM globals
     3                              <1> GLOBAL OEMMCBINIT
     4                              <1> GLOBAL OEMHALT
     5                              <1> GLOBAL OEMCALLBK
     6                              <1> 
     7                              <1> ;Sysinit externs
     8                              <1> EXTERN FINALDOSPTR
     9                              <1> EXTERN FILES
    10                              <1> EXTERN BUFFERS
    11                              <1> EXTERN DFLTDRIVE
    12                              <1> EXTERN LASTDRIVE
    13                              <1> EXTERN OEMBIOS
    14                              <1> EXTERN OEMDRVCHAIN
    15                              <1> EXTERN OEMPTR
    16                              <1> EXTERN OEMVERSION
    17                              <1> EXTERN MCBANCHOR
    18                              <1> EXTERN OEMMEMPTR
    19                              <1> EXTERN SYSENTRY
     9                                  
    10                                  Segment otext code private align=1 use64
    11                                  ;---------------------------
    12                                  ;   OEMINIT code segment
    13                                  ;---------------------------
    14                                  %include "./src/Oeminit/oeminit.asm"
     1                              <1> %use masm
     2                              <1> ;SYSINIT doesnt care about the internal structure of the OEMINIT module.
     3                              <1> ;Thus, an OEM is free to arrange code and data within the OEMINIT module,
     4                              <1> ; as they please. OEMINIT is always the first module linked to in the DOS
     5                              <1> ; binary blob file and therefore an OEM can guarantee that the first byte 
     6                              <1> ; of the OEMINIT module will be the first byte executed by the machine.
     7                              <1> ;SYSINIT starts being invoked only once OEMINIT jumps to the symbol SYSENTRY.
     8                              <1> ;OEMINIT can even be an .EXE or .ELF executable if the firmware allows it, 
     9                              <1> ; as long as it can link with SYSINIT by EXPORTING and IMPORTING the right
    10                              <1> ; symbols, its ok! Also, the DOS linker script requires that the OEMINIT 
    11                              <1> ; module be the first thing in the executable file, with the default
    12                              <1> ; kernel drivers being the at the end, after the DOS, in the segment
    13                              <1> ; kDrvText, kDrvData and kDrvBSS.
    14                              <1> ;OEMINIT has no BSS segment, but has otext and odata where it can link 
    15                              <1> ; itself into.
    16                              <1> ;---------------------------------------------------------------------------;
    17                              <1> ;PUBLIC PROCEDURES needed to link with SYSINIT:                             ;
    18                              <1> ;---------------------------------------------------------------------------;
    19                              <1> ; OEMMCBINIT -> Does MCB chain building as SYSINIT doesn't know how to read ;
    20                              <1> ;   any memory maps. Thats on the OEM to parse and build for us.            ;
    21                              <1> ; OEMHALT -> If anything goes wrong during the initial phase of SYSINIT,    ;
    22                              <1> ;   it will use this routine to print a message and halt the machine.       ;
    23                              <1> ; OEMCALLBK -> Used to finalise any setup before xfring control to SHELL=   ;
    24                              <1> ;   At this point, DOS is ready to be used.                                 ;
    25                              <1> ;---------------------------------------------------------------------------;
    26                              <1> ;EXTERN VARS needed to link with SYSINIT:                                   ;
    27                              <1> ;---------------------------------------------------------------------------;
    28                              <1> ; These vars need to be initialised before jumping to SYSENTRY              ;
    29                              <1> ;---------------------------------------------------------------------------;
    30                              <1> ;FINALDOSPTR dq ?    ;Pointer to where dSeg should be loaded                ;
    31                              <1> ;FILES       db ?    ;Default number of FILES                               ;
    32                              <1> ;BUFFERS     db ?    ;Default number of BUFFERS                             ;
    33                              <1> ;DFLTDRIVE   db ?    ;Default drive number (0-25), this is the boot drive   ;
    34                              <1> ;LASTDRIVE   db ?    ;Default last drive number (0-25)                      ;
    35                              <1> ;OEMBIOS     db ?    ;Set if to use IO.SYS or clear if to use SCPBIOS.SYS   ;
    36                              <1> ;OEMPTR      dq ?    ;Pointer to store at biosPtr                           ;
    37                              <1> ;OEMVERSION  dd ?    ;BIOS number, to be used by drivers for id-ing         ;
    38                              <1> ;---------------------------------------------------------------------------;
    39                              <1> ; These vars are initialised by SYSINIT, to be used in OEMMCBINIT           ;
    40                              <1> ; These vars are undefined outside of OEMMCBINIT                            ;
    41                              <1> ;---------------------------------------------------------------------------;
    42                              <1> ;MCBANCHOR   dq ?    ;Pointer to the Anchor MCB, part of dSEg               ;
    43                              <1> ;---------------------------------------------------------------------------;
    44                              <1> ; These vars are initialised by SYSINIT, to be used in OEMCALLBK            ;
    45                              <1> ; These vars are undefined outside of OEMCALLBK                             ;
    46                              <1> ;---------------------------------------------------------------------------;
    47                              <1> ;OEMMEMPTR   dq ?    ;Var to save ptr to the 64Kb block passed to OEMCALLBK ;
    48                              <1> ;---------------------------------------------------------------------------;
    49                              <1> ;
    50                              <1> 
    51                              <1> OEMRELOC PROC NEAR  ;OEMINIT Entry point from SCP/BIOS
    52                              <1> ; We arrive here with the following values in the registers.
    53                              <1> ; rbx =  LBA of first Logical Block after SCP/BIOS
    54                              <1> ; dx  = Int 33h boot device number
    55                              <1> ; fs  = userbase pointer (pointer to first usable block of RAM)
    56                              <1> ; rsp = 7C00h
    57                              <1> 
    58 00000000 55AA                <1>     dw 0AA55h           ;Initial signature
    59 00000002 4C0FB6FA            <1>     movzx r15, dl       ;Save the drive letter in r15
    60 00000006 4989DE              <1>     mov r14, rbx        ;Save next sector number
    61 00000009 488D3514000000      <1>     lea rsi, sysInitldr
    62 00000010 BF00060000          <1>     mov edi, 600h   ;Hardcoded address, 600h
    63 00000015 B940000000          <1>     mov ecx, 512/8      ;TMP: DOS boot device MUST HAVE 512 byte sectors.
    64 0000001A F348A5              <1>     rep movsq   ;Copy over
    65 0000001D B800060000          <1>     mov eax, 600h   ;Push the new address to go to
    66 00000022 50                  <1>     push rax
    67 00000023 C3                  <1>     ret ;Jump to this value (600h + whatever the size here is)
    68                              <1> sysInitldr:
    69 00000024 48BC00060000000000- <1>     mov rsp, 600h   ;400h-600h is the stack. This is large enough for boot!
    69 0000002D 00                  <1>
    70                              <1> ;Now the tough part, load DOS to 800
    71 0000002E BE10000000          <1>     mov esi, 10h    ;Use as a loop counter
    72                              <1> .read:
    73 00000033 4488FA              <1>     mov dl, r15b    ;Get Drive number
    74 00000036 48BB00080000000000- <1>     mov rbx, 800h   ;Load at next 512 byte marker
    74 0000003F 00                  <1>
    75 00000040 4489F1              <1>     mov ecx, r14d   ;Get this sector LBA (first sector after BIOS)
    76 00000043 FFC1                <1>     inc ecx         ;and want the next sector (DOS AND BIOS MUST BE CONTIGUOUS)
    77 00000045 B080                <1>     mov al, 80h     ;Load a large number of sectors (about 64k)
    78 00000047 B482                <1>     mov ah, 82h     ;Read LBA
    79 00000049 CD33                <1>     int 33h
    80 0000004B 7206                <1>     jc .readFail
    81 0000004D 6800080000          <1>     push qword 800h
    82 00000052 C3                  <1>     ret   ;No error? Yay, DOS loaded.
    83                              <1> .readFail:
    84 00000053 FFCE                <1>     dec esi
    85 00000055 75DC                <1>     jnz .read
    86 00000057 488D2D09000000      <1>     lea rbp, .msg   ;Print error message
    87 0000005E B804130000          <1>     mov eax, 1304h
    88 00000063 CD30                <1>     int 30h
    89 00000065 CD38                <1>     int 38h ;If an error, fall into SYSDEBUG
    90 00000067 5343502F444F53204C- <1> .msg db "SCP/DOS Load Error",0Ah,0Dh,0
    90 00000070 6F6164204572726F72- <1>
    90 00000079 0A0D00              <1>
    91 0000007C 909090909090909090- <1>     db 200h-($-$$) dup 90h ;Fill rest of the sector with NOPs
    91 00000085 909090909090909090- <1>
    91 0000008E 909090909090909090- <1>
    91 00000097 909090909090909090- <1>
    91 000000A0 909090909090909090- <1>
    91 000000A9 909090909090909090- <1>
    91 000000B2 909090909090909090- <1>
    91 000000BB 909090909090909090- <1>
    91 000000C4 909090909090909090- <1>
    91 000000CD 909090909090909090- <1>
    91 000000D6 909090909090909090- <1>
    91 000000DF 909090909090909090- <1>
    91 000000E8 909090909090909090- <1>
    91 000000F1 909090909090909090- <1>
    91 000000FA 909090909090909090- <1>
    91 00000103 909090909090909090- <1>
    91 0000010C 909090909090909090- <1>
    91 00000115 909090909090909090- <1>
    91 0000011E 909090909090909090- <1>
    91 00000127 909090909090909090- <1>
    91 00000130 909090909090909090- <1>
    91 00000139 909090909090909090- <1>
    91 00000142 909090909090909090- <1>
    91 0000014B 909090909090909090- <1>
    91 00000154 909090909090909090- <1>
    91 0000015D 909090909090909090- <1>
    91 00000166 909090909090909090- <1>
    91 0000016F 909090909090909090- <1>
    91 00000178 909090909090909090- <1>
    91 00000181 909090909090909090- <1>
    91 0000018A 909090909090909090- <1>
    91 00000193 909090909090909090- <1>
    91 0000019C 909090909090909090- <1>
    91 000001A5 909090909090909090- <1>
    91 000001AE 909090909090909090- <1>
    91 000001B7 909090909090909090- <1>
    91 000001C0 909090909090909090- <1>
    91 000001C9 909090909090909090- <1>
    91 000001D2 909090909090909090- <1>
    91 000001DB 909090909090909090- <1>
    91 000001E4 909090909090909090- <1>
    91 000001ED 909090909090909090- <1>
    91 000001F6 909090909090909090- <1>
    91 000001FF 90                  <1>
    92                              <1> ;END OF FIRST SECTOR!!
    93                              <1> ;Now move the alignment of the DOSSEG to 4Kb boundary
    94                              <1> initBegin:
    95 00000200 FC                  <1>     cld ;Ensure all writes are done the right way firstly!
    96 00000201 B9000100C0          <1>     mov ecx, 0C0000100h ;Read FS MSR
    97 00000206 0F32                <1>     rdmsr
    98 00000208 89D7                <1>     mov edi, edx        ;Get the hi dword, and clear the upper bytes
    99 0000020A 48C1E720            <1>     shl rdi, 20h        ;Shift high
   100 0000020E 89C7                <1>     mov edi, eax        ;Get the low dword in
   101 00000210 4889FE              <1>     mov rsi, rdi        ;Save userbase in rsi temporarily
   102 00000213 4881E700F0FFFF      <1>     and rdi, ~0FFFh
   103 0000021A 4881C700100000      <1>     add rdi, 1000h      ;Make this pointer 4Kb aligned!
   104                              <1> ;Now sets the Statistical data and adds any page tables that are needed
   105                              <1> ;------------------------------------------------;
   106                              <1> ;      Start saving basic DOS data to the        ; 
   107                              <1> ;                OEM Variables                   ;
   108                              <1> ;------------------------------------------------;
   109 00000221 31C0                <1>     xor eax, eax    ;Drive A:
   110 00000223 BB02000000          <1>     mov ebx, 2      ;Drive C:
   111 00000228 41F6C780            <1>     test r15b, 80h  ;Is the hard drive bit set?
   112 0000022C 0F45C3              <1>     cmovnz eax, ebx
   113 0000022F 8805(00000000)      <1>     mov byte [DFLTDRIVE], al    ;Set default drive
   114                              <1> ;Copy DOS to its final resting place
   115 00000235 48893508040000      <1>     mov qword [biosUBase], rsi  ;Local OEM variable
   116 0000023C C605(00000000)08    <1>     mov byte [FILES], 8         ;Default 8 files, initially 5 only
   117 00000243 C605(00000000)1E    <1>     mov byte [BUFFERS], 30      ;Default 30 buffers, at start 1
   118 0000024A C605(00000000)05    <1>     mov byte [LASTDRIVE], 5     ;Default Last drive value
   119 00000251 C705(00000000)0000- <1>     mov dword [OEMVERSION], 0   ;CSM BIOS
   119 00000259 0000                <1>
   120 0000025B 48C705(00000000)00- <1>     mov qword [OEMPTR], 0       ;No pointer
   120 00000263 000000              <1>
   121 00000266 C605(00000000)00    <1>     mov byte [OEMBIOS], 0       ;Use SCPBIOS/SCPDOS kernel names
   122                              <1>    ;If no detected Int 33h devices, halt 
   123 0000026D CD31                <1>     int 31h ;Get number of Int 33h devices in r8b
   124 0000026F 49C1E818            <1>     shr r8, 3*8
   125 00000273 4584C0              <1>     test r8b, r8b
   126 00000276 0F8483030000        <1>     jz OEMHALT
   127 0000027C 4889F7              <1>     mov rdi, rsi
   128 0000027F 4881E700F0FFFF      <1>     and rdi, ~0FFFh ;round up to next 4Kb page after biosUBase
   129 00000286 4881C700100000      <1>     add rdi, 1000h
   130                              <1> ;------------------------------------------------;
   131                              <1> ;      Add additional page tables before the     ;
   132                              <1> ;                   data area.                   ;
   133                              <1> ;------------------------------------------------;
   134                              <1> ;This will allow for up to 64Gb of addressible space
   135                              <1>     ;Each entry is a 2Mb (200000h) multiple from 4Gb (100000000h)
   136 0000028D B900780000          <1>     mov ecx, aptSize/8   ;This many entries as qwords
   137 00000292 57                  <1>     push rdi        ;rdi points to the APT space
   138 00000293 48B883000000010000- <1>     mov rax, 100000000h | 83h ;Make each pde 2Mb, present and r/w
   138 0000029C 00                  <1>
   139                              <1> pdtLoop:
   140 0000029D 48AB                <1>     stosq
   141 0000029F 480500002000        <1>     add rax, 200000h
   142 000002A5 FFC9                <1>     dec ecx
   143 000002A7 75F4                <1>     jnz pdtLoop
   144 000002A9 58                  <1>     pop rax ;Get the pointer back to the top of the memory area in rax
   145                              <1> ;Now we add every 4kb page to the page directory pointer table
   146                              <1> ;15 4kb pages to consider
   147 000002AA 48893D(00000000)    <1>     mov qword [FINALDOSPTR], rdi ;rdi now points to where dSeg will go
   148 000002B1 0F20DF              <1>     mov rdi, cr3    ;Get Page level 4 table pointer
   149 000002B4 488B3F              <1>     mov rdi, qword [rdi] ;Go to next level
   150 000002B7 4881E700FFFFFF      <1>     and rdi, ~0FFh  ;Strip bottom two nybbles
   151 000002BE 4881C720000000      <1>     add rdi, 4*8    ;Go to 4th entry
   152 000002C5 B93C000000          <1>     mov ecx, 60
   153 000002CA 480D03000000        <1>     or rax, 3h      ;present and r/w
   154                              <1> pdptLoop:
   155 000002D0 48AB                <1>     stosq
   156 000002D2 480500100000        <1>     add rax, 1000h  ;Goto next 4kb page
   157 000002D8 FFC9                <1>     dec ecx
   158 000002DA 75F4                <1>     jnz pdptLoop
   159                              <1> 
   160 000002DC 0F20DF              <1>     mov rdi, cr3    ;Reload cr3 to make the system aware of new table entries
   161 000002DF 0F22DF              <1>     mov cr3, rdi    ;(is this strictly necessary?)
   162                              <1> 
   163                              <1> ;----------------------------------------------------------------
   164                              <1> ;                       PIC Remap procedure                     :
   165                              <1> ;----------------------------------------------------------------
   166                              <1> ;Remapping the IRQ lines to Interrupts 0F0h - 0FFh
   167 000002E2 FA                  <1>     cli
   168 000002E3 B0FF                <1>     mov al, 0FFh    ;Mask all interrupts 
   169 000002E5 E621                <1>     out 021h, al
   170 000002E7 E6A1                <1>     out 0A1h, al
   171 000002E9 0F010D6C030000      <1>     sidt [oemIDTptr]    ;Get the idt here
   172 000002F0 488B3567030000      <1>     mov rsi, qword [oemIDTptr.Base] ;Get the base ptr
   173 000002F7 4889F7              <1>     mov rdi, rsi
   174 000002FA 4881C600020000      <1>     add rsi, 020h*10h
   175 00000301 4881C7000F0000      <1>     add rdi, 0F0h*10h
   176 00000308 B920000000          <1>     mov ecx, 2*10h    ;Copy the hardware IRQ pointers high!
   177 0000030D F348A5              <1>     rep movsq
   178                              <1> 
   179 00000310 B011                <1>     mov al, 11h        ;bit 10h and 1h = Start initialisation
   180 00000312 E620                <1>     out 020h, al
   181 00000314 E680                <1>     out 080h, al    
   182 00000316 E6A0                <1>     out 0A0h, al
   183 00000318 E680                <1>     out 080h, al    
   184 0000031A B0F0                <1>     mov al, 0F0h       ;PIC1 to take Int 0F0h - F7h
   185 0000031C E621                <1>     out 021h, al
   186 0000031E E680                <1>     out 080h, al    
   187 00000320 0408                <1>     add al, 8        ;PIC2 to take Int  F8h - FFh
   188 00000322 E6A1                <1>     out 0A1h, al 
   189 00000324 E680                <1>     out 080h, al    
   190 00000326 B004                <1>     mov al, 4
   191 00000328 E621                <1>     out 021h, al    ;Tell PIC 1 that there is a PIC 2 at IRQ2 (00000100)
   192 0000032A E680                <1>     out 080h, al    
   193 0000032C FEC8                <1>     dec al
   194 0000032E FEC8                <1>     dec al
   195 00000330 E6A1                <1>     out 0A1h, al    ;Tell PIC 2 its cascade identity (00000010)
   196 00000332 E680                <1>     out 080h, al
   197 00000334 B001                <1>     mov al, 01h        ;Initialise in 8086 mode
   198 00000336 E621                <1>     out 021h, al
   199 00000338 E680                <1>     out 080h, al    
   200 0000033A E6A1                <1>     out 0A1h, al
   201 0000033C E680                <1>     out 080h, al    
   202 0000033E 0F011D17030000      <1>     lidt [oemIDTptr] 
   203 00000345 31C0                <1>     xor eax, eax    ;Unmask all interrupts 
   204 00000347 E621                <1>     out 021h, al
   205 00000349 E6A1                <1>     out 0A1h, al
   206 0000034B FB                  <1>     sti
   207                              <1> 
   208 0000034C E9(00000000)        <1>     jmp SYSENTRY    ;Now all vars setup, we can proceed!
   209                              <1> OEMSYSINIT ENDP
   210                              <1> aptSize equ 60*4096 ;(APT = Additional Page Tables)
   211                              <1> 
   212                              <1> OEMMCBINIT PROC NEAR
   213 00000351 B820E80000          <1>     mov eax, 0E820h ;Get memory map
   214 00000356 CD35                <1>     int 35h ; rsi has pointer to memory map
   215 00000358 488B05E5020000      <1>     mov rax, qword [biosUBase]
   216 0000035F E8F6000000          <1>     call .mcbFindAddress
   217 00000364 7341                <1>     jnc .mcbi1  ;If found, proceed
   218                              <1>     ;Here, we try use E801h
   219 00000366 B801E80000          <1>     mov eax, 0E801h
   220 0000036B CD35                <1>     int 35h
   221 0000036D 0FB7C0              <1>     movzx eax, ax   ;ax has 1Kb blocks from userbase to ISA hole (if pres)
   222 00000370 0FB7DB              <1>     movzx ebx, bx   ;cx has 64Kb blocks from 16Mb to PCI hole
   223 00000373 85C0                <1>     test eax, eax
   224 00000375 7417                <1>     jz .worst
   225 00000377 C1E009              <1>     shl eax, 9      ;Multiply by 9 to get number of bytes
   226 0000037A C1E310              <1>     shl ebx, 16     ;Multiply by 16 to get number of bytes
   227 0000037D 8905C9020000        <1>     mov dword [loProtMem], eax
   228 00000383 891DC7020000        <1>     mov dword [hiProtMem], ebx
   229 00000389 E919010000          <1>     jmp mcbBuild
   230                              <1> .worst:
   231                              <1>     ;Get USERBASE pointer and subtract it from 2Mb
   232 0000038E B800002000          <1>     mov eax, 200000h
   233 00000393 488B1DAA020000      <1>     mov rbx, qword [biosUBase]   ;Get userbase
   234 0000039A 29D8                <1>     sub eax, ebx
   235 0000039C 8905AA020000        <1>     mov dword [loProtMem], eax  ;The leftover goes here
   236 000003A2 E900010000          <1>     jmp mcbBuild 
   237                              <1> .mcbi1:
   238 000003A7 488B10              <1>     mov rdx, qword [rax]    ;Save the userbase in rdx
   239 000003AA 48BB01000000010000- <1>     mov rbx, 100000001h ;Valid entry signature
   239 000003B3 00                  <1>
   240 000003B4 48395810            <1>     cmp qword [rax + 16], rbx ;If entry is marked as invalid, fail boot
   241 000003B8 0F85BC000000        <1>     jne .mcbFail
   242 000003BE 488B4008            <1>     mov rax, qword [rax + 8]    ;Get arena size in rax
   243                              <1>     ;PCI hole always exists so this value will always be a dword
   244 000003C2 890584020000        <1>     mov dword [loProtMem], eax
   245 000003C8 4889D3              <1>     mov rbx, rdx    ;Get userbase into rbx
   246 000003CB 4801C3              <1>     add rbx, rax    ;Check if it goes above 16Mb?
   247 000003CE 4881FB00000001      <1>     cmp rbx, 1000000h  
   248 000003D5 773A                <1>     ja .skipISA
   249                              <1> ;Here we deal with ISA hole issues
   250 000003D7 B820E80000          <1>     mov eax, 0E820h
   251 000003DC CD35                <1>     int 35h
   252 000003DE 48B800000001000000- <1>     mov rax, 1000000h
   252 000003E7 00                  <1>
   253 000003E8 E86D000000          <1>     call .mcbFindAddress
   254 000003ED 0F82B4000000        <1>     jc mcbBuild  ;If address doesnt exist, must not be any memory above 16MB
   255 000003F3 48BB01000000010000- <1>     mov rbx, 100000001h ;Valid entry signature
   255 000003FC 00                  <1>
   256 000003FD 48395810            <1>     cmp qword [rax + 16], rbx ;If entry is marked as invalid, ignore domain
   257 00000401 0F85A0000000        <1>     jne mcbBuild  
   258 00000407 488B5808            <1>     mov rbx, qword [rax + 8]
   259 0000040B 891D3F020000        <1>     mov dword [hiProtMem], ebx   ;Save data 
   260                              <1> .skipISA:
   261 00000411 B820E80000          <1>     mov eax, 0E820h
   262 00000416 CD35                <1>     int 35h
   263 00000418 48B800000000010000- <1>     mov rax, 100000000h ;4Gb boundary
   263 00000421 00                  <1>
   264 00000422 E833000000          <1>     call .mcbFindAddress
   265 00000427 727E                <1>     jc mcbBuild    ;If no memory above 4Gb, proceed as normal
   266 00000429 48BB01000000010000- <1>     mov rbx, 100000001h ;Valid entry signature
   266 00000432 00                  <1>
   267 00000433 48395810            <1>     cmp qword [rax + 16], rbx ;If entry is marked as invalid, ignore domain
   268 00000437 756E                <1>     jne mcbBuild   
   269 00000439 488B5808            <1>     mov rbx, qword [rax + 8]
   270                              <1>     ;If this size is above 60Gb, store 60Gb as this is max long arena size!
   271 0000043D 48B9000000000F0000- <1>     mov rcx, 0F00000000h    ;60Gb value
   271 00000446 00                  <1>
   272 00000447 4839CB              <1>     cmp rbx, rcx
   273 0000044A 480F47D9            <1>     cmova rbx, rcx  ;Move the value of rcx into rbx IF it is above
   274 0000044E 48891DFF010000      <1>     mov qword [longMem], rbx   ;Save data 
   275 00000455 E94D000000          <1>     jmp mcbBuild
   276                              <1> .mcbFindAddress:
   277                              <1> ;Takes an address in rax and tries to find the 24 byte entry in the memory map
   278                              <1> ;Entry: rax = Address of arena to search for
   279                              <1> ;       rsi = Pointer to memory map
   280                              <1> ;       ecx = Number of 24 byte entries
   281                              <1> ;Exit:  CF=NC : rax = Pointer to 24 byte entry 
   282                              <1> ;       CF=CY : value in rax not found
   283 0000045A 56                  <1>     push rsi
   284 0000045B 51                  <1>     push rcx
   285 0000045C 50                  <1>     push rax
   286                              <1> .mfa0:
   287 0000045D 483B06              <1>     cmp rax, qword [rsi]
   288 00000460 7410                <1>     je .mcbAddressFound
   289 00000462 4881C618000000      <1>     add rsi, 24 ;Goto next entry
   290 00000469 FFC9                <1>     dec ecx
   291 0000046B 79F0                <1>     jns .mfa0
   292                              <1> .mcbNoAddressFound: ;If ecx changes sign, we have used up all entries
   293 0000046D 58                  <1>     pop rax
   294 0000046E 59                  <1>     pop rcx
   295 0000046F 5E                  <1>     pop rsi
   296 00000470 F9                  <1>     stc
   297 00000471 C3                  <1>     ret
   298                              <1> .mcbAddressFound:
   299 00000472 4889F0              <1>     mov rax, rsi    ;Save pointer to entry in rax
   300 00000475 59                  <1>     pop rcx ;Pop old rax value off
   301 00000476 59                  <1>     pop rcx
   302 00000477 5E                  <1>     pop rsi
   303 00000478 F8                  <1>     clc
   304 00000479 C3                  <1>     ret
   305                              <1> .mcbFail:
   306 0000047A 488D2D0C000000      <1>     lea rbp, mcbFailmsg
   307 00000481 B804130000          <1>     mov eax, 1304h
   308 00000486 CD30                <1>     int 30h
   309 00000488 E972010000          <1>     jmp OEMHALT
   310 0000048D 4D656D6F727920416C- <1> mcbFailmsg db "Memory Allocation Error",0Ah,0Dh,0
   310 00000496 6C6F636174696F6E20- <1>
   310 0000049F 4572726F720A0D00    <1>
   311                              <1> 
   312                              <1> mcbBuild:
   313                              <1> ;Actually build the MCB chain here
   314                              <1> ;Start by computing the difference between userbase and DOS area
   315 000004A7 488B1D96010000      <1>     mov rbx, qword [biosUBase]
   316 000004AE 488B35(00000000)    <1>     mov rsi, qword [MCBANCHOR]  
   317 000004B5 8B4609              <1>     mov eax, dword [rsi + mcb.blockSize]    ;Get the size of the block
   318 000004B8 48C1E004            <1>     shl rax, 4      ;Convert to number of allocated bytes
   319 000004BC 480510000000        <1>     add rax, mcb_size   ;Add the mcb itself to the count
   320 000004C2 4801F0              <1>     add rax, rsi    ;Add the pointer to the mcb to get pointer to free space
   321 000004C5 4889C7              <1>     mov rdi, rax    ;Save this value as the pointer to the next MCB
   322 000004C8 4829D8              <1>     sub rax, rbx    ;Get difference from userbase and first byte after DOS
   323 000004CB 29057B010000        <1>     sub dword [loProtMem], eax  ;Remove difference from the free bytes count
   324 000004D1 0F8228010000        <1>     jc OEMHALT                  ;If this carries, fail
   325 000004D7 813D6B010000008000- <1>     cmp dword [loProtMem], 8000h   ;Need a minimum of 32Kb free space.
   325 000004E0 00                  <1>
   326 000004E1 0F8218010000        <1>     jb OEMHALT
   327 000004E7 C6064D              <1>     mov byte [rsi + mcb.marker], mcbMarkCtn ;Now mark anchor as not end
   328 000004EA 4889FB              <1>     mov rbx, rdi    ;Get the pointer to the free space back
   329 000004ED C6035A              <1>     mov byte [rbx + mcb.marker], mcbMarkEnd  ;Mark as end of chain
   330 000004F0 48C7430100000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerFree
   331 000004F8 31F6                <1>     xor esi, esi
   332 000004FA 8B354C010000        <1>     mov esi, dword [loProtMem]
   333 00000500 81EE10000000        <1>     sub esi, mcb_size   ;Now remove one mcb's worth of space
   334 00000506 C1EE04              <1>     shr esi, 4  ;Shift down by a nybble to get paragraphs
   335 00000509 897309              <1>     mov dword [rbx + mcb.blockSize], esi
   336                              <1> 
   337                              <1>     ;Now check the hiProtMem count. If it is 0, skip ISA hole computations.
   338 0000050C 813D3A010000000000- <1>     cmp dword [hiProtMem], 0
   338 00000515 00                  <1>
   339 00000516 746C                <1>     jz .skipISA
   340                              <1>     ;Here if an ISA hole exists, place a MCB around it
   341 00000518 816B0901000000      <1>     sub dword [rbx + mcb.blockSize], (mcb_size>>4)    
   342                              <1>     ;Remove one MCB worth of space from alloc
   343 0000051F 31C9                <1>     xor ecx, ecx
   344 00000521 8B4B09              <1>     mov ecx, dword [rbx + mcb.blockSize]
   345 00000524 81C101000000        <1>     add ecx, (mcb_size >> 4)    ;Add one as the block starts AFTER the MCB
   346 0000052A C1E104              <1>     shl ecx, 4  ;Convert from paragraphs
   347 0000052D C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn  ;Change marker in anchor
   348 00000530 4801CB              <1>     add rbx, rcx   ;Point rbx to next space
   349 00000533 C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn
   350 00000536 48C7430107000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerHole
   351 0000053E 48B900000001000000- <1>     mov rcx, 1000000h   ;Move 16Mb in rcx
   351 00000547 00                  <1>
   352 00000548 4889D8              <1>     mov rax, rbx    ;Get mcb pointer in rax
   353 0000054B 480510000000        <1>     add rax, mcb_size
   354 00000551 4829C1              <1>     sub rcx, rax    ;Take their difference
   355 00000554 C1E904              <1>     shr ecx, 4
   356 00000557 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx    ;Save the difference
   357 0000055A C1E104              <1>     shl ecx, 4  ;Get bytes again
   358 0000055D 4881C310000000      <1>     add rbx, mcb_size
   359 00000564 4801CB              <1>     add rbx, rcx
   360                              <1>     ;RBX should now be at 16Mb
   361 00000567 C6035A              <1>     mov byte [rbx + mcb.marker], mcbMarkEnd
   362 0000056A 48C7430100000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerFree
   363 00000572 8B0DD8000000        <1>     mov ecx, dword [hiProtMem]
   364 00000578 C1E904              <1>     shr ecx, 4  ;Get paragraphs
   365 0000057B 81E901000000        <1>     sub ecx, (mcb_size>>4)  ;Reserve space for one mcb
   366 00000581 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx
   367                              <1> .skipISA:
   368                              <1>     ;Now check the longMem count. If it is 0, skip PCI hole computations.
   369                              <1>     ;rbx points to a block with "Z" marker
   370 00000584 813DC6000000000000- <1>     cmp dword [longMem], 0
   370 0000058D 00                  <1>
   371 0000058E 746E                <1>     jz .exit
   372                              <1>     ;Add PCI hole MCB
   373 00000590 816B0901000000      <1>     sub dword [rbx + mcb.blockSize], (mcb_size>>4)
   374                              <1>     ;Remove one MCB worth of space from alloc
   375 00000597 31C9                <1>     xor ecx, ecx
   376 00000599 8B4B09              <1>     mov ecx, dword [rbx + mcb.blockSize]
   377 0000059C 81C101000000        <1>     add ecx, (mcb_size >> 4)    ;Add one as the block starts AFTER the MCB
   378 000005A2 C1E104              <1>     shl ecx, 4  ;Get bytes
   379 000005A5 C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn ;Change marker in prev MCB
   380 000005A8 4801CB              <1>     add rbx, rcx   ;Point rbx to next space
   381 000005AB C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn
   382 000005AE 48C7430107000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerHole
   383 000005B6 48B900000000010000- <1>     mov rcx, 100000000h   ;Move 4Gb in rcx
   383 000005BF 00                  <1>
   384 000005C0 4889D8              <1>     mov rax, rbx    ;Get mcb pointer in rax
   385 000005C3 480510000000        <1>     add rax, mcb_size
   386 000005C9 4829C1              <1>     sub rcx, rax    ;Take their difference
   387 000005CC C1E904              <1>     shr ecx, 4
   388 000005CF 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx    ;Save the difference
   389 000005D2 C1E104              <1>     shl ecx, 4  ;Get bytes again
   390 000005D5 4881C310000000      <1>     add rbx, mcb_size
   391 000005DC 4801CB              <1>     add rbx, rcx
   392                              <1>     ;RBX should now be at 4Gb
   393 000005DF C6035A              <1>     mov byte [rbx + mcb.marker], mcbMarkEnd
   394 000005E2 48C7430100000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerFree
   395 000005EA 488B0D63000000      <1>     mov rcx, qword [longMem]
   396 000005F1 48C1E904            <1>     shr rcx, 4
   397 000005F5 81E901000000        <1>     sub ecx, (mcb_size>>4)  ;Reserve space for one mcb
   398 000005FB 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx
   399                              <1> .exit:
   400 000005FE C3                  <1>     ret
   401                              <1> OEMMCBINIT ENDP
   402                              <1> 
   403                              <1> OEMHALT PROC    NEAR
   404                              <1> ;If a critical error occurs during sysinit, fail through here
   405                              <1> ;Int 22h, 23h and 24h point here during sysinit
   406 000005FF 488D2D0C000000      <1>     lea rbp, hltmsg
   407 00000606 B804130000          <1>     mov eax, 1304h
   408 0000060B CD30                <1>     int 30h
   409                              <1> .ei0:
   410 0000060D F4                  <1>     hlt
   411 0000060E F390                <1>     pause
   412 00000610 EBFB                <1>     jmp short .ei0
   413 00000612 4572726F7220696E69- <1> hltmsg  db "Error initialising SCPDOS.SYS. System halting...",0
   413 0000061B 7469616C6973696E67- <1>
   413 00000624 20534350444F532E53- <1>
   413 0000062D 59532E205379737465- <1>
   413 00000636 6D2068616C74696E67- <1>
   413 0000063F 2E2E2E00            <1>
   414                              <1> OEMHALT ENDP
   415                              <1> 
   416                              <1> OEMCALLBK PROC NEAR
   417 00000643 C3                  <1>     ret
   418                              <1> OEMCALLBK ENDP
   419                              <1> 
   420                              <1> ;OEM Only variables are permitted in this file. They are not 
   421                              <1> ; visible to SYSINIT
   422 00000644 0000000000000000    <1> biosUBase   dq 0
   423 0000064C 00000000            <1> loProtMem   dd 0
   424 00000650 00000000            <1> hiProtMem   dd 0
   425 00000654 0000000000000000    <1> longMem     dq 0
   426                              <1> oemIDTptr:      ;Local IDT pointer
   427 0000065C 0000                <1>     .Limit  dw 0
   428 0000065E 0000000000000000    <1>     .Base   dq 0
    15                                  
    16                                  Segment odata data private align=1
    17                                  ;---------------------------
    18                                  ;   OEMINIT data segment
    19                                  ;---------------------------
    20                                  ;No OEM DATA
    21                                  ;========================END OF OEMINIT MODULE=======================
    21          ------------------       info: assembly required 1+2+2 passes

