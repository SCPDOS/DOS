     1                                  [DEFAULT REL]
     2                                  BITS 64
     3                                  
     4                                  %include "./src/Include/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1>     %ifdef retOff
    22                              <1>     %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1>     %ifdef currSegVBase
    24                              <1>     j%+1 short (retOff+currSegVBase)
    25                              <1>     %else
    26                              <1>     j%+1 short retOff
    27                              <1>     %endif  ;End ifdef currSegVBase
    28                              <1>     %else 
    29                              <1>     j%-1 short %%a
    30                              <1>     return
    31                              <1> %%a:
    32                              <1>     %endif  ;End the distance measurement if
    33                              <1>     %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1>     %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro breakpoint 0
    81                              <1> xchg bx, bx
    82                              <1> %endmacro
     5                                  %include "./src/Include/dosStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous internal     ;
     4                              <1> ; SCP/DOS structures.                                   ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> ;------------------------------------------------------------------------;
     8                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
     9                              <1> ; its file system structure. This is used to locate files and structures
    10                              <1> ; on the device itself and to translate file requests to cluster chains
    11                              <1> ; to LBAs to pass to the disk driver..
    12                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    13                              <1> ; drivers Initialise routine has been called.
    14                              <1> ;------------------------------------------------------------------------;
    15                              <1> struc dpb        ;Drive Parameter Block
    16                              <1> 
    17 00000000 ??                  <1>     .bDriveNumber           db ?  ;Drive number (0=A, 1=B ...)
    18 00000001 ??                  <1>     .bUnitNumber            db ?  ;Unit number in device
    19 00000002 ????                <1>     .wBytesPerSector        dw ?  ;min 512, max 4096
    20 00000004 ??                  <1>     .bMaxSectorInCluster    db ?  ;(Maximum sector in cluster) - 1
    21 00000005 ??                  <1>     .bSecPerClustShift      db ?  ;Sectors per cluster exponent
    22 00000006 ????                <1>     .wFAToffset             dw ?  ;Number of reserved sectors in partition
    23 00000008 ??                  <1>     .bNumberOfFATs          db ?  ;Number of FATs
    24 00000009 ????                <1>     .wNumberRootDirEntries  dw ?  ;In 32 byte units, this is 0 for FAT32
    25 0000000B ????????            <1>     .dClusterHeapOffset     dd ?  ;Start sector of data area
    26 0000000F ????????            <1>     .dMaxClusterAddr        dd ?  ;Max Cluster Addr = # of data clusters + 1
    27 00000013 ????????            <1>     .dFATlength             dd ?  ;FAT length, in sectors
    28 00000017 ????????            <1>     .dFirstUnitOfRootDir    dd ?  
    29                              <1>     ;Unit=Sector/Cluster of Root Directory (FAT12/16 = Sector, FAT32 = Cluster)
    30 0000001B ????????????????    <1>     .qDriverHeaderPtr       dq ?  ;Pointer to device driver header
    31 00000023 ??                  <1>     .bMediaDescriptor       db ?  ;Media descriptor
    32 00000024 ??                  <1>     .bAccessFlag            db ?  ;Access Flag (0 if accessed, else -1)
    33 00000025 ????????????????    <1>     .qNextDPBPtr            dq ?  ;Pointer to next DPB, -1 if at end
    34 0000002D ????????            <1>     .dNextFreeClst          dd ?  ;Starting cluster of free space search
    35 00000031 ????????            <1>     .dFreeClustCnt          dd ?  ;Number of free clusters, -1 unknown
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> fat12MaxClustCnt    equ 4085    ;Cluster count less than this is FAT12
    40                              <1> fat16MaxClustCnt    equ 65525   ;Cluster count less than this is FAT16
    41                              <1> ;------------------------------------------------------------------------;
    42                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    43                              <1> ; All disk pathing requests go via the CDS for that drive.
    44                              <1> ; The default drive is the last accessed drive, this number is stored
    45                              <1> ; in the DOS data area.
    46                              <1> ; The CDS is stored as an array with the offset into the array being 
    47                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    48                              <1> ;
    49                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    50                              <1> ;------------------------------------------------------------------------;
    51                              <1> struc cds       ;Current Directory structure
    52 00000000 <res 43h>           <1>     .sCurrentPath        db 67 dup (?)    ;Current Directory Path String
    53 00000043 ????                <1>     .wFlags              dw ?   ;CDS Flags - 
    54 00000045 ????????????????    <1>     .qDPBPtr             dq ?   ;Ptr to the DPB of the dev using this CDS
    55 0000004D ????????            <1>     .dStartCluster       dd ?   ;Starting cluster of the directory on disk
    56 00000051 ????????????????    <1>     .qIFSPtr             dq ?   ;Reserved for IFS driver expansions
    57 00000059 ????????            <1>     .dNetStore           dd ?   ;For storing a owner dword for IFS (21h/5F03h)
    58 0000005D ????                <1>     .wBackslashOffset    dw ?   ;How many chars to skip for getting the path
    59                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    60                              <1> ; another, we save the number of chars to skip to that deep level).
    61                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    62                              <1> ; Only affects for SUBST drives, not JOIN
    63                              <1> ; Flags: Bit 15 set = Network drive
    64                              <1> ;        Bit 14 set = Physical drive
    65                              <1> ;        Bit 13 set = JOIN'ed drive
    66                              <1> ;        Bit 12 set = SUBST'ed drive
    67                              <1> ;        Bit 7  set = Redirected, not net. drive (This is how MSCDEX worked)
    68                              <1> endstruc
    69                              <1> ;CDS equates
    70                              <1> cdsRedirDrive   equ 8000h   ;All drives which use the Redirector interface
    71                              <1> cdsValidDrive   equ 4000h   ;CDS valid
    72                              <1> cdsJoinDrive    equ 2000h   ;CDS for joined drives
    73                              <1> cdsSubstDrive   equ 1000h   ;Drives formed by Subst
    74                              <1> cdsRdirLocDrive equ 0080h   ;Redirector but Local
    75                              <1> ;------------------------------------------------------------------------;
    76                              <1> ; The SFT is a way to allow applications to open file handles to files 
    77                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    78                              <1> ; under the first header, and then a second header will be linked to the 
    79                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    80                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    81                              <1> ; using the FCBS= command. Default FCBS=5.
    82                              <1> ;
    83                              <1> ; A file handle describes the file, and the location within the file that
    84                              <1> ; we are reading. The file handle can be manipulated without the file
    85                              <1> ; being in memory, thus allowing the user to access data without needing 
    86                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    87                              <1> ; accessing devices, by treating them as files with their drivers 
    88                              <1> ; responding and translating the manipulations of the file handle itself.
    89                              <1> ; Neither the driver nor the application should see or use the SFT for
    90                              <1> ; the handle, as it is subject to change (and will change when file 
    91                              <1> ; sharing provisions are included). The DOS will make requests to the 
    92                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    93                              <1> ; track of the information in the SFT entry for that handle. 
    94                              <1> ;
    95                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    96                              <1> ; can point to the same file. It all depends on what the applications 
    97                              <1> ; want to do with the File.
    98                              <1> ;
    99                              <1> ; !!!!IMPORTANT!!!!
   100                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   101                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   102                              <1> ;
   103                              <1> ;Each SFT may look like this:
   104                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   105                              <1> ;            |                |
   106                              <1> ;       wNumFiles*sft    wNumFiles*sft
   107                              <1> ;
   108                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   109                              <1> ; System FCBs.
   110                              <1> ;
   111                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   112                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   113                              <1> ;
   114                              <1> ; DEFAULT FILES=8, MINIMUM FILES=5
   115                              <1> ; DEFAULT FCBS=5,  MINIMUM FCBS=5
   116                              <1> ;------------------------------------------------------------------------;
   117                              <1> struc sfth   ;System file table header
   118                              <1> ; This is the SFT header.
   119                              <1> ; This structure comes before the start of the first file in the array/table.
   120 00000000 ????????????????    <1>     .qNextSFTPtr dq ?    ;Pointer to the next SFT
   121 00000008 ????                <1>     .wNumFiles   dw ?    ;Number of files in this table
   122                              <1> endstruc
   123                              <1> 
   124                              <1> struc sft
   125                              <1> ;This is the file struc itself
   126 00000000 ????                <1>     .wNumHandles dw ?    ;Number of handles pointing to this file
   127 00000002 ????                <1>     .wOpenMode   dw ?    ;File access permissions and behvaiours
   128 00000004 ??                  <1>     .bFileAttrib db ?    ;Regular File Attributes
   129 00000005 ????                <1>     .wDeviceInfo dw ?    ;Includes unit number if a block device
   130 00000007 ????????????????    <1>     .qPtr        dq ?    ;IF char, ptr to device driver header, ELSE DPBptr
   131 0000000F ????????            <1>     .dStartClust dd ?    ;Start cluster of file pointed to by SFT entry
   132 00000013 ????                <1>     .wTime       dw ?    ;File Time, updated on open and writes
   133 00000015 ????                <1>     .wDate       dw ?    ;File Date, updated on open and writes
   134 00000017 ????????            <1>     .dFileSize   dd ?    ;File Size, in bytes
   135 0000001B ????????            <1>     .dCurntOff   dd ?    ;Current Offset pointed to by SFT entry, in bytes
   136 0000001F ????????            <1>     .dRelClust   dd ?    ;Rel cluster pointed to by SFT entry
   137 00000023 ????????            <1>     .dAbsClusr   dd ?    ;Absolute cluster pointed to by SFT entry
   138 00000027 ????????????????    <1>     .qDirSect    dq ?    ;Abs number of sector containing directory entry 
   139 0000002F ??                  <1>     .bNumDirEnt  db ?    ;Directory entry within dir sector (byte offset/32)
   140 00000030 <res Bh>            <1>     .sFileName   db 11 dup (?)   ;8.3 Filename
   141 0000003B ????????????????    <1>     .qSharePtr   dq ?    ;SHARE pointer to previous SFT sharing same file
   142 00000043 ????                <1>     .wMachNum    dw ?    ;SHARE number of network machine opening file
   143 00000045 ????????????????    <1>     .qPSPOwner   dq ?    ;Addr of PSP of program which first opened this file
   144 0000004D ????                <1>     .wShareRec   dw ?    ;offset within SHARE code segment of sharing record
   145                              <1> ;                           0 means no record
   146                              <1> endstruc
   147                              <1> ;Open Mode equates
   148                              <1> ;Access modes   Bits[2:0]
   149                              <1> ReadAccess      equ 0h
   150                              <1> WriteAccess     equ 1h
   151                              <1> RWAccess        equ 2h
   152                              <1> ;Bit 3 reserved 0
   153                              <1> ;Sharing modes  Bits[6:4]
   154                              <1> CompatShare     equ 0h
   155                              <1> denyRWShare     equ 10h
   156                              <1> denyWriteShare  equ 20h
   157                              <1> denyReadShare   equ 30h
   158                              <1> denyNoneShare   equ 40h
   159                              <1> ;NetFCB is for files open by a local server, handling IO from a remote
   160                              <1> ; client by proxy opened by an FCB! Sets the Net bit to indicate this. 
   161                              <1> ;Thus, this is a handle with no JFT entry! Server handles its own JFT!
   162                              <1> netFCBShare     equ 70h     
   163                              <1> noInherit       equ 80h
   164                              <1> ;Bits 8-12 reserved 0
   165                              <1> ;Fancy open mode bits
   166                              <1> diskFullFail    equ 2000h   ;Reserved: If set, trigger Int 24h on disk full.
   167                              <1> noBufferWrites  equ 4000h   ;Reserved: If set, flush after each buffer write.
   168                              <1> ;Once share is loaded, if a local FCB open occurs, mark the sft as so.
   169                              <1> FCBopenedFile   equ 8000h   ;If set, file is opened by FCB, else handle based.
   170                              <1> 
   171                              <1> ;Attribute Byte
   172                              <1> readOnlyFile    equ 1h
   173                              <1> hiddenFile      equ 2h
   174                              <1> systemFile      equ 4h
   175                              <1> volLabelFile    equ 8h
   176                              <1> directoryFile   equ 10h ;Directory entry
   177                              <1> archiveFile     equ 20h
   178                              <1> charFile        equ 40h ;Reserved, never found in dir
   179                              <1> ;Device Info equates
   180                              <1> ;For a block device, bits [5:0] contain the drive number
   181                              <1> charDevConIn    equ 1h  ;If set, device is CON input
   182                              <1> charDevConOut   equ 2h  ;If set, device is CON output
   183                              <1> charDevNulDev   equ 4h  ;If set, device is NULL device
   184                              <1> charDevClockDev equ 8h  ;If set, device is CLOCK device
   185                              <1> charDevFastOut  equ 10h ;If set, device supports INT 29h
   186                              <1> charDevBinary   equ 20h ;If set, r/w char device in Binary mode!!!
   187                              <1> charDevNoEOF    equ 40h ;If set, no EOF when reading from device!!
   188                              <1> blokFileNoFlush equ 40h ;Set if file is synchronised with hard store!
   189                              <1> devCharDev      equ 80h ;If set, it is a char device!
   190                              <1> charDevNetSpool equ 800h    ;If set, device is a network spooler
   191                              <1> devNoInherit    equ 1000h   ;If set, handle not inherited by child processes
   192                              <1> charDevNamePipe equ 2000h   ;If set, device is a named pipe
   193                              <1> blokNoDTonClose equ 4000h   ;If set, dont update date and time when closing
   194                              <1> devRedirDev     equ 8000h   ;If set, dev/file is redirected!
   195                              <1>  
   196                              <1> ;------------------------------------------------------------------------;
   197                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   198                              <1> ; to an internal buffer, and then copying it to the specified location
   199                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   200                              <1> ; another request for the same sector from the same device is made, so 
   201                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   202                              <1> ; size, selected according to the largest detected sector size during 
   203                              <1> ; the initial loadup.
   204                              <1> ;
   205                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   206                              <1> ;
   207                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   208                              <1> ;------------------------------------------------------------------------;
   209                              <1> 
   210                              <1> struc bufferHdr
   211 00000000 ????????????????    <1>     .nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
   212                              <1>     .wDrvNumFlg:         ;Read as a word to get the following two bytes!
   213 00000008 ??                  <1>     .driveNumber db  ?   ;Drive number the buffer is used for (or -1 for free)
   214 00000009 ??                  <1>     .bufferFlags db  ?   ;Standard Flags
   215 0000000A ????????????????    <1>     .bufferLBA   dq  ?   ;LBA the buffer contains
   216 00000012 ??                  <1>     .bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
   217 00000013 ????????            <1>     .bufFATsize  dd  ?   ;Number of sectors per FAT (or 0 if non-FAT)
   218 00000017 ????????????????    <1>     .driveDPBPtr dq  ?   ;Pointer to the device DPB block
   219 0000001F ??                  <1>     .reserved    db  ?   ;Alignment byte
   220                              <1>     .dataarea:             ;Points to the start of the data area
   221                              <1> endstruc
   222                              <1> ;Buffer Flag equates
   223                              <1> dosBuffer   equ 1h  ;Sector 0 (BPB/VPB) in buffer
   224                              <1> fatBuffer   equ 2h  ;FAT sector in buffer
   225                              <1> dirBuffer   equ 4h  ;Directory sector in buffer
   226                              <1> dataBuffer  equ 8h  ;File Data sector in buffer
   227                              <1> refBuffer   equ 20h ;Data in buffer has been referenced by an application
   228                              <1> dirtyBuffer equ 40h ;Data in buffer modified by an application
   229                              <1> freeBuffer  equ 00FFh   ;A word which goes into the drive number to clear both fields
   230                              <1> ;Note! A buffer is marked as referenced when the buffer is "obtained" by a syscall
   231                              <1> ;------------------------------------------------------------------------;
   232                              <1> ; Memory control block for each memory arena
   233                              <1> ;------------------------------------------------------------------------;
   234                              <1> struc mcb
   235 00000000 ??                  <1>     .marker     db ?  ;M = Member of the MCB chain. Z = Last member
   236 00000001 ????????????????    <1>     .owner      dq ?  ;Owning application PSP (para aligned) or 0 for free
   237 00000009 ????????            <1>     .blockSize  dd ?  ;Number of contiguous paragraphs owned by this block
   238                              <1>     ;The following byte is reserved outside of sysinit
   239 0000000D ??                  <1>     .subSysMark db ?  ;Marks the optional DOS subsystem of the MCB
   240 0000000E ????                <1>     .reserved   db 2 dup (?) 
   241                              <1>     .program:
   242                              <1> endstruc
   243                              <1> ;MCB equates
   244                              <1> mcbOwnerHole    equ 7   ;Owner = 7 => Memory hole, always fail free/realloc
   245                              <1> mcbOwnerFree    equ 0   ;Owner = 0 => Free and available space
   246                              <1> mcbOwnerDOS     equ 8   ;Owner = 8 => Owned by DOS
   247                              <1> mcbOwnerNewDOS  equ 9   ;Owner = 9 => New Kernel driver alloc. Needs setting to 8.
   248                              <1> mcbMarkCtn      equ "M"
   249                              <1> mcbMarkEnd      equ "Z"
   250                              <1> ;The following are used on MCB's that belong to DOS, that are not part of the
   251                              <1> ; main kernel (i.e. the CONFIG.SYS optional parts).
   252                              <1> mcbSubDriver    equ "D" ;Any memory allocated for a device driver's code.
   253                              <1> mcbSubDrvExtra  equ "L" ;Any memory allocated by a device driver.
   254                              <1> mcbSubDrvDPB    equ "P" ;Blocks used for DPB's are marked so.
   255                              <1> mcbSubIFS       equ "I" ;Unused for now
   256                              <1> mcbSubFiles     equ "F" ;Any memory allocated for Files.
   257                              <1> mcbSubFCBS      equ "X" ;Unused for now
   258                              <1> mcbSubBuffers   equ "B" ;Any memory allocated for Buffers.
   259                              <1> mcbSubCDS       equ "L" ;Any memory allocated to store a CDS.
   260                              <1> mcbSubStacks    equ "S" ;Unused for now
   261                              <1> 
   262                              <1> 
   263                              <1> memFirstFit     equ 0   ;First free block goes to application
   264                              <1> memBestFit      equ 1   ;Block whos size closest matches requirement
   265                              <1> memLastFit      equ 2   ;Last free block goes to application
   266                              <1> 
   267                              <1> ;Owner = Para aligned address => Owning application PSP
   268                              <1> ;...To consider...
   269                              <1> ;Owner = Non-para aligned address => Error? Should maybe lock up system?
   270                              <1> ;blockSize counts the number of paragraphs FROM .program TO THE NEXT MCB!
   271                              <1> ;------------------------------------------------------------------------;
   272                              <1> ; For Int 21h, the callers registers are saved on their stack in the 
   273                              <1> ; following order, thus allowing for return values to be placed in the 
   274                              <1> ; registers by accessing the caller register stack frame.
   275                              <1> ;------------------------------------------------------------------------;
   276                              <1> struc callerFrame
   277 00000000 ????????????????    <1>     .rax    dq ?  ;Bottom of frame, pointer to rax saved in oldRSP
   278 00000008 ????????????????    <1>     .rbx    dq ?    
   279 00000010 ????????????????    <1>     .rcx    dq ?
   280 00000018 ????????????????    <1>     .rdx    dq ?
   281 00000020 ????????????????    <1>     .rsi    dq ?
   282 00000028 ????????????????    <1>     .rdi    dq ?
   283 00000030 ????????????????    <1>     .rbp    dq ?
   284 00000038 ????????????????    <1>     .r8     dq ?  ;To be removed if truly not needed
   285 00000040 ????????????????    <1>     .r9     dq ?
   286                              <1> ;Pushed by Processor when invoked via Interrupt
   287 00000048 ????????????????    <1>     .rip    dq ?
   288 00000050 ????????????????    <1>     .cs     dq ?
   289 00000058 ????????????????    <1>     .flags  dq ?
   290                              <1> endstruc
   291                              <1> 
   292                              <1> struc dpl
   293                              <1> ;DOS parameter list, pointer to this stack is passed to DOS in rdx on
   294                              <1> ; server calls
   295 00000000 ????????????????    <1>     .rax    dq ?
   296 00000008 ????????????????    <1>     .rbx    dq ?
   297 00000010 ????????????????    <1>     .rcx    dq ?
   298 00000018 ????????????????    <1>     .rdx    dq ?
   299 00000020 ????????????????    <1>     .rsi    dq ?
   300 00000028 ????????????????    <1>     .rdi    dq ?
   301 00000030 ????????????????    <1>     .r8     dq ?
   302 00000038 ????????????????    <1>     .r9     dq ?
   303 00000040 ????????????????    <1>     .align  dq ?
   304 00000048 ????????????????    <1>     .compID dq ?  ;Computer id, low word used only
   305 00000050 ????????????????    <1>     .procID dq ?  ;Process ID
   306                              <1> endstruc
   307                              <1> 
   308                              <1> struc cfgFrame  ;Frame used for config.sys parsing
   309 00000000 ????????????????    <1>     .oldRBP         dq ?    ;Ptr to DOSSEG
   310 00000008 ????????????????    <1>     .newBuffers     dq ?    ;New buffers value
   311 00000010 ????????????????    <1>     .newSFTVal      dq ?
   312 00000018 ????????????????    <1>     .newFCBSVal     dq ?
   313 00000020 ????????????????    <1>     .newProtFCBSVal dq ?    ;Number of protected FCBS
   314 00000028 ????????????????    <1>     .newLastdrive   dq ?
   315 00000030 ????????????????    <1>     .newStacks      dq ?    ;Ignored for now
   316 00000038 ????????????????    <1>     .newStackSize   dq ?    ;Ignored for now
   317 00000040 ????????????????    <1>     .cfgHandle      dq ?    ;CONFIG.SYS handle
   318 00000048 ????????????????    <1>     .lastLine       dq ?    ;Set if the last line is current
   319 00000050 ????????????????    <1>     .linePtr        dq ?    ;Ptr to line buffer of line being processed
   320 00000058 ????????????????    <1>     .driverBreak    dq ?    ;Ptr to the pathname terminator 
   321 00000060 ????????????????    <1>     .breakChar      dq ?    ;Char that was replaced by null for terminator
   322                              <1> endstruc
   323                              <1> 
   324                              <1> struc filename
   325                              <1> ;8.3 File name struct
   326 00000000 ????????????????    <1>     .fName  db 8 dup (?)
   327 00000008 ??????              <1>     .fExt   db 3 dup (?)
   328                              <1> endstruc
   329                              <1> 
   330                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
   331 00000000 ??                  <1>     .driveNum   db ?  ;Drive we are searching on, 1 based number
   332 00000001 <res Bh>            <1>     .template   db 11 dup (?) ;Search template (? meaning anything)
   333 0000000C ??                  <1>     .attrib     db ?  ;Search attribute
   334 0000000D ????????            <1>     .dirOffset  dd ?  ;32 byte entry within dir cluster
   335 00000011 ????????            <1>     .parDirClus dd ?  ;Parent Directory Cluster number
   336 00000015 ??                  <1>     .attribFnd  db ?  ;Attrib of file found
   337 00000016 ????                <1>     .fileTime   dw ?  ;File time
   338 00000018 ????                <1>     .fileDate   dw ?  ;File date
   339 0000001A ????????            <1>     .fileSize   dd ?  ;Number of bytes
   340 0000001E <res Dh>            <1>     .asciizName db 13 dup (?) ;ASCIIZ name with dot and terminating nul
   341                              <1> endstruc
   342                              <1> 
   343                              <1> dfltJFTsize equ 20  ;Default size of PSP JFT
   344                              <1> struc psp
   345 00000000 ????                <1>     .return     db 2 dup (?)  ;Should always be CDh 20h, same place as DOS
   346 00000002 ????????            <1>     .allocSize  dd ?  ;Number of paras in init alloc or when exiting as TSR.
   347 00000006 ????????            <1>                 dd ?  ;Reserved 4 bytes
   348 0000000A ????????????????    <1>     .oldInt22h  dq ?  ;Int 22h pointer on overlay load
   349 00000012 ????????????????    <1>     .oldInt23h  dq ?  ;Int 23h pointer on overlay load
   350 0000001A ????????????????    <1>     .oldInt24h  dq ?  ;Int 24h pointer on overlay load
   351 00000022 ????????????????    <1>     .parentPtr  dq ?  ;Pointer to parent process PSP
   352                              <1> ;If jftSize > 20, then the QWORD at .jobFileTbl becomes a pointer
   353                              <1> ; to the actual in use JFT and the other 12 bytes are left undefined.
   354                              <1> ;If jftSize < 20 (DOS will never set it so), then it is considered as 20
   355                              <1> ;If the user tries to reduce handle count to 20 or less, then the PSP JFT is 
   356                              <1> ; always used and jftSize.
   357                              <1>     .externalJFTPtr:    ;Ptr to external JFT array (first byte AFTER MCB)
   358 0000002A <res 14h>           <1>     .jobFileTbl db dfltJFTsize dup (?) ;Main File handle array, JFT
   359 0000003E ????????????????    <1>     .envPtr     dq ?  ;Pointer to the environment
   360 00000046 ????????????????    <1>     .rspPtr     dq ?  ;Pointer to rsp on entry to Int 21h
   361 0000004E ????                <1>     .jftSize    dw ?  ;JFT array size, 20 => PSP JFT in use
   362 00000050 ??????              <1>     .unixEntry  db 3 dup (?)  ;Must always be CDh 21h CBh, same place as DOS
   363 00000053 ????????????????    <1>     .prevPSP    dq ?  ;Pointer to the previous PSP in chain (used by SHARE)
   364 0000005B ??                  <1>                 db ?  ;Reserved byte
   365                              <1> ;The below are in the same place as in DOS.
   366                              <1>     .cmdLineArgPtr: ;Symbol for future use
   367 0000005C <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1 
   368 0000006C <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
   369                              <1>     .dta:   ;Pointer to the default DTA in the PSP
   370 00000080 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
   371 00000081 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
   372                              <1> endstruc
   373                              <1> 
   374                              <1> struc clkStruc
   375 00000000 ????                <1>     .dateWord   dw ?
   376 00000002 ??                  <1>     .minutes    db ?
   377 00000003 ??                  <1>     .hours      db ?
   378 00000004 ??                  <1>     .hseconds   db ?  ;Hundreths of seconds
   379 00000005 ??                  <1>     .seconds    db ?
   380                              <1> endstruc
   381                              <1> 
   382                              <1> 
   383                              <1> struc extCtryStruc
   384 00000000 ??                  <1>     .infoIDCode db ?    ;Information ID code (01h)
   385 00000001 ????                <1>     .strucSize  dw ?    ;Length of the structure  (42 or less)
   386 00000003 ????                <1>     .ctryID     dw ?    ;Country ID number
   387 00000005 ????                <1>     .cpNumber   dw ?    ;Code page number
   388 00000007 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   389                              <1>                         ;0 = month day year hh:mm:ss
   390                              <1>                         ;1 = day month year hh:mm:ss
   391                              <1>                         ;2 = year month day hh:mm:ss
   392 00000009 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   393 0000000E ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   394 00000010 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   395 00000012 ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   396 00000014 ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   397 00000016 ??                  <1>     .currFmt    db ?    ;Currency Format
   398                              <1>                         ;0 = Symbol leads, without space
   399                              <1>                         ;1 = Symbol follows, without space
   400                              <1>                         ;2 = Symbol leads, one space
   401                              <1>                         ;3 = Symbol follows, one space
   402                              <1>                         ;4 = Symbol replace decimal separator
   403 00000017 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   404 00000018 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   405 00000019 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   406 00000021 ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   407 00000023 <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   408                              <1> endstruc
   409                              <1> 
   410                              <1> struc countryStruc
   411 00000000 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   412                              <1>                         ;0 = month day year hh:mm:ss
   413                              <1>                         ;1 = day month year hh:mm:ss
   414                              <1>                         ;2 = year month day hh:mm:ss
   415 00000002 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   416 00000007 ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   417 00000009 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   418 0000000B ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   419 0000000D ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   420 0000000F ??                  <1>     .currFmt    db ?    ;Currency Format
   421                              <1>                         ;0 = Symbol leads, without space
   422                              <1>                         ;1 = Symbol follows, without space
   423                              <1>                         ;2 = Symbol leads, one space
   424                              <1>                         ;3 = Symbol follows, one space
   425                              <1>                         ;4 = Symbol replace decimal separator
   426 00000010 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   427 00000011 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   428 00000012 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   429 0000001A ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   430 0000001C <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   431                              <1> endstruc
   432                              <1> 
   433                              <1> ;Critical Error AH bitfield equates
   434                              <1> critRead    equ 0h
   435                              <1> critWrite   equ 1h
   436                              <1> critDOS     equ 0h
   437                              <1> critFAT     equ 2h
   438                              <1> critDir     equ 4h
   439                              <1> critData    equ 6h
   440                              <1> critFailOK  equ 8h
   441                              <1> critRetryOK equ 10h
   442                              <1> critIgnorOK equ 20h
   443                              <1> critCharDev equ 80h
   444                              <1> 
   445                              <1> critIgnore  equ 0
   446                              <1> critRetry   equ 1
   447                              <1> critAbort   equ 2
   448                              <1> critFail    equ 3
   449                              <1> 
   450                              <1> ;MISC ASCII control chars
   451                              <1> NUL equ 00h ;^@         | ASCII Null
   452                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text) 
   453                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
   454                              <1> BEL equ 07h ;^G         | ASCII Bell
   455                              <1> BSP equ 08h ;^H         | ASCII Backspace
   456                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
   457                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
   458                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
   459                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
   460                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
   461                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
   462                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
   463                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
   464                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
   465                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
   466                              <1> SPC equ 20h ;Printable  | ASCII Space
   467                              <1> ;This last one is NEVER printed with a caret as it is a console control char
   468                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
   469                              <1> 
   470                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
   471                              <1> ;Extended Ascii Codes
   472                              <1> eF1     equ 3Bh ;F1 second byte
   473                              <1> eF2     equ 3Ch ;F2 second byte
   474                              <1> eF3     equ 3Dh ;F3 second byte
   475                              <1> eF4     equ 3Eh ;F4 second byte
   476                              <1> eF5     equ 3Fh ;F5 second byte
   477                              <1> eF6     equ 40h ;F6 second byte
   478                              <1> eF7     equ 41h ;F7 second byte
   479                              <1> eCursL  equ 4Bh ;Cursor Left second byte
   480                              <1> eCursR  equ 4Dh ;Cursor Right second byte
   481                              <1> eIns    equ 52h ;Insert second byte
   482                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
   483                              <1> 
   484                              <1> ;Default Configuration for the system
   485                              <1> 
   486                              <1> buffersDefault  equ 30
   487                              <1> filesDefault    equ 20
   488                              <1> fcbsDefault     equ 4
   489                              <1> safeFcbsDeflt   equ 0
   490                              <1> lastDriveDeflt  equ 5   
   491                              <1> 
   492                              <1> ;ASCII char property table equates. If such a bit is clear in signature in table
   493                              <1> ; then the char has this property.
   494                              <1> badChar     equ 1   ;Bad ASCIIZ filename char
   495                              <1> termChar    equ 2   ;Terminator char type
   496                              <1> sepChar     equ 4   ;Separator char type
   497                              <1> badFCBChar  equ 8   ;FCB filename char
     6                                  
     7                                  ;=======================START OF OEMINIT MODULE======================
     8                                  %include "./src/Oeminit/oem.inc"
     1                              <1> 
     2                              <1> ;OEM globals
     3                              <1> GLOBAL OEMMCBINIT
     4                              <1> GLOBAL OEMHALT
     5                              <1> GLOBAL OEMCALLBK
     6                              <1> 
     7                              <1> ;Driver extern
     8                              <1> EXTERN driverChain
     9                              <1> 
    10                              <1> ;Sysinit externs
    11                              <1> EXTERN FINALDOSPTR
    12                              <1> EXTERN FILES
    13                              <1> EXTERN BUFFERS
    14                              <1> EXTERN DFLTDRIVE
    15                              <1> EXTERN LASTDRIVE
    16                              <1> EXTERN OEMBIOS
    17                              <1> EXTERN OEMDRVCHAIN
    18                              <1> EXTERN OEMPTR
    19                              <1> EXTERN OEMVERSION
    20                              <1> EXTERN MCBANCHOR
    21                              <1> EXTERN OEMMEMPTR
    22                              <1> EXTERN SYSENTRY
     9                                  
    10                                  Segment otext align=1 valign=1
    11                                  ;---------------------------
    12                                  ;   OEMINIT code segment
    13                                  ;---------------------------
    14                                  
    15                                  %include "./src/Oeminit/oeminit.asm"
     1                              <1> %use masm
     2                              <1> ;SYSINIT doesnt care about the internal structure of the OEMINIT module.
     3                              <1> ;Thus, an OEM is free to arrange code and data within the OEMINIT module,
     4                              <1> ; as they please. OEMINIT is always the first module linked to in the DOS
     5                              <1> ; binary blob file and therefore an OEM can guarantee that the first byte 
     6                              <1> ; of the OEMINIT module will be the first byte executed by the machine.
     7                              <1> ;SYSINIT starts being invoked only once OEMINIT jumps to the symbol SYSENTRY.
     8                              <1> ;OEMINIT can even be an .EXE or .ELF executable if the firmware allows it, 
     9                              <1> ; as long as it can link with SYSINIT by EXPORTING and IMPORTING the right
    10                              <1> ; symbols, its ok! Also, the DOS linker script requires that the OEMINIT 
    11                              <1> ; module be the first thing in the executable file, with the default
    12                              <1> ; kernel drivers being the at the end, after the DOS, in the segment
    13                              <1> ; kDrvText, kDrvData and kDrvBSS.
    14                              <1> ;OEMINIT has no BSS segment, but has otext and odata where it can link 
    15                              <1> ; itself into.
    16                              <1> ;---------------------------------------------------------------------------;
    17                              <1> ;PUBLIC PROCEDURES needed to link with SYSINIT:                             ;
    18                              <1> ;---------------------------------------------------------------------------;
    19                              <1> ; OEMMCBINIT -> Does MCB chain building as SYSINIT doesn't know how to read ;
    20                              <1> ;   any memory maps. Thats on the OEM to parse and build for us.            ;
    21                              <1> ; OEMHALT -> If anything goes wrong during the initial phase of SYSINIT,    ;
    22                              <1> ;   it will use this routine to print a message and halt the machine.       ;
    23                              <1> ; OEMCALLBK -> Used to finalise any setup before xfring control to SHELL=   ;
    24                              <1> ;   At this point, DOS is ready to be used.                                 ;
    25                              <1> ;---------------------------------------------------------------------------;
    26                              <1> ;EXTERN VARS needed to link with SYSINIT:                                   ;
    27                              <1> ;---------------------------------------------------------------------------;
    28                              <1> ; These vars need to be initialised before jumping to SYSENTRY              ;
    29                              <1> ;---------------------------------------------------------------------------;
    30                              <1> ;FINALDOSPTR dq ?    ;Pointer to where dSeg should be loaded                ;
    31                              <1> ;FILES       db ?    ;Default number of FILES                               ;
    32                              <1> ;BUFFERS     db ?    ;Default number of BUFFERS                             ;
    33                              <1> ;DFLTDRIVE   db ?    ;Default drive number (0-25), this is the boot drive   ;
    34                              <1> ;LASTDRIVE   db ?    ;Default last drive number (0-25)                      ;
    35                              <1> ;OEMBIOS     db ?    ;Set if to use IO.SYS or clear if to use SCPBIOS.SYS   ;
    36                              <1> ;OEMDRVCHAIN dq ?    ;Pointer to the uninitialised device drivers           ;
    37                              <1> ;OEMPTR      dq ?    ;Pointer to store at biosPtr                           ;
    38                              <1> ;OEMVERSION  dd ?    ;BIOS number, to be used by drivers for id-ing         ;
    39                              <1> ;---------------------------------------------------------------------------;
    40                              <1> ; These vars are initialised by SYSINIT, to be used in OEMMCBINIT           ;
    41                              <1> ; These vars are undefined outside of OEMMCBINIT                            ;
    42                              <1> ;---------------------------------------------------------------------------;
    43                              <1> ;MCBANCHOR   dq ?    ;Pointer to the Anchor MCB, part of dSEg               ;
    44                              <1> ;---------------------------------------------------------------------------;
    45                              <1> ; These vars are initialised by SYSINIT, to be used in OEMCALLBK            ;
    46                              <1> ; These vars are undefined outside of OEMCALLBK                             ;
    47                              <1> ;---------------------------------------------------------------------------;
    48                              <1> ;OEMMEMPTR   dq ?    ;Var to save ptr to the 64Kb block passed to OEMCALLBK ;
    49                              <1> ;---------------------------------------------------------------------------;
    50                              <1> ;
    51                              <1> 
    52                              <1> OEMRELOC PROC NEAR  ;OEMINIT Entry point from SCP/BIOS
    53                              <1> ; We arrive here with the following values in the registers.
    54                              <1> ; rbx =  LBA of first Logical Block after SCP/BIOS
    55                              <1> ; dx  = Int 33h boot device number
    56                              <1> ; fs  = userbase pointer (pointer to first usable block of RAM)
    57                              <1> 
    58 00000000 55AA                <1>     dw 0AA55h           ;Initial signature
    59 00000002 4C0FB6FA            <1>     movzx r15, dl       ;Save the drive letter in r15
    60 00000006 4989DE              <1>     mov r14, rbx        ;Save next sector number
    61 00000009 488D3514000000      <1>     lea rsi, sysInitldr
    62 00000010 BF00060000          <1>     mov edi, 600h   ;Hardcoded address, 600h
    63 00000015 B940000000          <1>     mov ecx, 512/8      ;TMP: DOS boot device MUST HAVE 512 byte sectors.
    64 0000001A F348A5              <1>     rep movsq   ;Copy over
    65 0000001D B800060000          <1>     mov eax, 600h   ;Push the new address to go to
    66 00000022 50                  <1>     push rax
    67 00000023 C3                  <1>     ret ;Jump to this value (600h + whatever the size here is)
    68                              <1> sysInitldr:
    69                              <1> ;Now the tough part, load DOS to 800
    70 00000024 BE10000000          <1>     mov esi, 10h    ;Use as a loop counter
    71                              <1> .read:
    72 00000029 4488FA              <1>     mov dl, r15b    ;Get Drive number
    73 0000002C BB00080000          <1>     mov rbx, 800h   ;Load at next 512 byte marker
    74 00000031 4489F1              <1>     mov ecx, r14d   ;Get this sector LBA (first sector after BIOS)
    75 00000034 FFC1                <1>     inc ecx         ;and want the next sector (DOS AND BIOS MUST BE CONTIGUOUS)
    76 00000036 B065                <1>     mov al, 65h     ;Load a large number of sectors (about 51.7k)
    77 00000038 B482                <1>     mov ah, 82h     ;Read LBA
    78 0000003A CD33                <1>     int 33h
    79 0000003C 7206                <1>     jc .readFail
    80 0000003E 6800080000          <1>     push qword 800h
    81 00000043 C3                  <1>     ret   ;No error? Yay, DOS loaded.
    82                              <1> .readFail:
    83 00000044 FFCE                <1>     dec esi
    84 00000046 75E1                <1>     jnz .read
    85 00000048 488D2D09000000      <1>     lea rbp, .msg   ;Print error message
    86 0000004F B804130000          <1>     mov eax, 1304h
    87 00000054 CD30                <1>     int 30h
    88 00000056 CD38                <1>     int 38h ;If an error, fall into SYSDEBUG
    89 00000058 5343502F444F53204C- <1> .msg db "SCP/DOS Load Error",0Ah,0Dh,0
    89 00000061 6F6164204572726F72- <1>
    89 0000006A 0A0D00              <1>
    90 0000006D 909090909090909090- <1>     db 200h-($-$$) dup 90h ;Fill rest of the sector with NOPs
    90 00000076 909090909090909090- <1>
    90 0000007F 909090909090909090- <1>
    90 00000088 909090909090909090- <1>
    90 00000091 909090909090909090- <1>
    90 0000009A 909090909090909090- <1>
    90 000000A3 909090909090909090- <1>
    90 000000AC 909090909090909090- <1>
    90 000000B5 909090909090909090- <1>
    90 000000BE 909090909090909090- <1>
    90 000000C7 909090909090909090- <1>
    90 000000D0 909090909090909090- <1>
    90 000000D9 909090909090909090- <1>
    90 000000E2 909090909090909090- <1>
    90 000000EB 909090909090909090- <1>
    90 000000F4 909090909090909090- <1>
    90 000000FD 909090909090909090- <1>
    90 00000106 909090909090909090- <1>
    90 0000010F 909090909090909090- <1>
    90 00000118 909090909090909090- <1>
    90 00000121 909090909090909090- <1>
    90 0000012A 909090909090909090- <1>
    90 00000133 909090909090909090- <1>
    90 0000013C 909090909090909090- <1>
    90 00000145 909090909090909090- <1>
    90 0000014E 909090909090909090- <1>
    90 00000157 909090909090909090- <1>
    90 00000160 909090909090909090- <1>
    90 00000169 909090909090909090- <1>
    90 00000172 909090909090909090- <1>
    90 0000017B 909090909090909090- <1>
    90 00000184 909090909090909090- <1>
    90 0000018D 909090909090909090- <1>
    90 00000196 909090909090909090- <1>
    90 0000019F 909090909090909090- <1>
    90 000001A8 909090909090909090- <1>
    90 000001B1 909090909090909090- <1>
    90 000001BA 909090909090909090- <1>
    90 000001C3 909090909090909090- <1>
    90 000001CC 909090909090909090- <1>
    90 000001D5 909090909090909090- <1>
    90 000001DE 909090909090909090- <1>
    90 000001E7 909090909090909090- <1>
    90 000001F0 909090909090909090- <1>
    90 000001F9 90909090909090      <1>
    91                              <1> ;END OF FIRST SECTOR!!
    92                              <1> ;Now move the alignment of the DOSSEG to 4Kb boundary
    93                              <1> initBegin:
    94 00000200 FC                  <1>     cld ;Ensure all writes are done the right way firstly!
    95 00000201 B9000100C0          <1>     mov ecx, 0C0000100h ;Read FS MSR
    96 00000206 0F32                <1>     rdmsr
    97 00000208 89D7                <1>     mov edi, edx        ;Get the hi dword, and clear the upper bytes
    98 0000020A 48C1E720            <1>     shl rdi, 20h        ;Shift high
    99 0000020E 89C7                <1>     mov edi, eax        ;Get the low dword in
   100 00000210 4889FE              <1>     mov rsi, rdi        ;Save userbase in rsi temporarily
   101 00000213 4881E700F0FFFF      <1>     and rdi, ~0FFFh
   102 0000021A 4881C700100000      <1>     add rdi, 1000h      ;Make this pointer 4Kb aligned!
   103                              <1> ;Now sets the Statistical data and adds any page tables that are needed
   104                              <1> ;------------------------------------------------;
   105                              <1> ;      Start saving basic DOS data to the        ; 
   106                              <1> ;                OEM Variables                   ;
   107                              <1> ;------------------------------------------------;
   108 00000221 31C0                <1>     xor eax, eax    ;Drive A:
   109 00000223 BB02000000          <1>     mov ebx, 2      ;Drive C:
   110 00000228 41F6C780            <1>     test r15b, 80h  ;Is the hard drive bit set?
   111 0000022C 0F45C3              <1>     cmovnz eax, ebx
   112 0000022F 8805(00000000)      <1>     mov byte [DFLTDRIVE], al    ;Set default drive
   113                              <1> ;Copy DOS to its final resting place
   114 00000235 488935E2030000      <1>     mov qword [biosUBase], rsi  ;Local OEM variable
   115 0000023C C605(00000000)08    <1>     mov byte [FILES], 8         ;Default 8 files, initially 5 only
   116 00000243 C605(00000000)1E    <1>     mov byte [BUFFERS], 30      ;Default 30 buffers, at start 1
   117 0000024A C605(00000000)05    <1>     mov byte [LASTDRIVE], 5     ;Default Last drive value
   118 00000251 C705(00000000)0000- <1>     mov dword [OEMVERSION], 0   ;CSM BIOS
   118 00000259 0000                <1>
   119 0000025B 48C705(00000000)00- <1>     mov qword [OEMPTR], 0       ;No pointer
   119 00000263 000000              <1>
   120 00000266 C605(00000000)00    <1>     mov byte [OEMBIOS], 0       ;Use SCPBIOS/SCPDOS kernel names
   121                              <1>    ;If no detected Int 33h devices, halt 
   122 0000026D CD31                <1>     int 31h ;Get number of Int 33h devices in r8b
   123 0000026F 49C1E818            <1>     shr r8, 3*8
   124 00000273 4584C0              <1>     test r8b, r8b
   125 00000276 0F845D030000        <1>     jz OEMHALT
   126 0000027C 4889F7              <1>     mov rdi, rsi
   127 0000027F 4881E700F0FFFF      <1>     and rdi, ~0FFFh ;round up to next 4Kb page after biosUBase
   128 00000286 4881C700100000      <1>     add rdi, 1000h
   129                              <1> ;------------------------------------------------;
   130                              <1> ;      Add additional page tables before the     ;
   131                              <1> ;                   data area.                   ;
   132                              <1> ;------------------------------------------------;
   133                              <1> ;This will allow for up to 64Gb of addressible space
   134                              <1>     ;Each entry is a 2Mb (200000h) multiple from 4Gb (100000000h)
   135 0000028D B900780000          <1>     mov ecx, aptSize/8   ;This many entries as qwords
   136 00000292 57                  <1>     push rdi        ;rdi points to the APT space
   137 00000293 48B883000000010000- <1>     mov rax, 100000000h | 83h ;Make each pde 2Mb, present and r/w
   137 0000029C 00                  <1>
   138                              <1> pdtLoop:
   139 0000029D 48AB                <1>     stosq
   140 0000029F 480500002000        <1>     add rax, 200000h
   141 000002A5 FFC9                <1>     dec ecx
   142 000002A7 75F4                <1>     jnz pdtLoop
   143 000002A9 58                  <1>     pop rax ;Get the pointer back to the top of the memory area in rax
   144                              <1> ;Now we add every 4kb page to the page directory pointer table
   145                              <1> ;15 4kb pages to consider
   146 000002AA 48893D(00000000)    <1>     mov qword [FINALDOSPTR], rdi ;rdi now points to where dSeg will go
   147 000002B1 57                  <1>     push rdi
   148 000002B2 0F20DF              <1>     mov rdi, cr3    ;Get Page level 4 table pointer
   149 000002B5 488B3F              <1>     mov rdi, qword [rdi] ;Go to next level
   150 000002B8 4881E700FFFFFF      <1>     and rdi, ~0FFh  ;Strip bottom two nybbles
   151 000002BF 4883C720            <1>     add rdi, 4*8    ;Go to 4th entry
   152 000002C3 B93C000000          <1>     mov ecx, 60
   153 000002C8 4883C803            <1>     or rax, 3h      ;present and r/w
   154                              <1> pdptLoop:
   155 000002CC 48AB                <1>     stosq
   156 000002CE 480500100000        <1>     add rax, 1000h  ;Goto next 4kb page
   157 000002D4 FFC9                <1>     dec ecx
   158 000002D6 75F4                <1>     jnz pdptLoop
   159                              <1> 
   160 000002D8 0F20DF              <1>     mov rdi, cr3    ;Reload cr3 to make the system aware of new table entries
   161 000002DB 0F22DF              <1>     mov cr3, rdi    ;(is this strictly necessary?)
   162                              <1> ;------------------------------------------------;
   163                              <1> ;       Set Device Driver Chain and Exit         ;
   164                              <1> ;------------------------------------------------;  
   165                              <1> ;Before we exit, set the device driver chain
   166 000002DE 48B8-               <1>     mov rax, driverChain
   166 000002E0 [0000000000000000]  <1>
   167 000002E8 5F                  <1>     pop rdi
   168 000002E9 4801F8              <1>     add rax, rdi    ;Add the DOSSEG base address
   169 000002EC 488905(00000000)    <1>     mov qword [OEMDRVCHAIN], rax  ;Store this value here
   170                              <1> 
   171                              <1> ;----------------------------------------------------------------
   172                              <1> ;                       PIC Remap procedure                     :
   173                              <1> ;----------------------------------------------------------------
   174                              <1> ;Remapping the IRQ lines to Interrupts 0F0h - 0FFh
   175 000002F3 FA                  <1>     cli
   176 000002F4 B0FF                <1>     mov al, 0FFh    ;Mask all interrupts 
   177 000002F6 E621                <1>     out 021h, al
   178 000002F8 E6A1                <1>     out 0A1h, al
   179 000002FA 0F010D35030000      <1>     sidt [oemIDTptr]    ;Get the idt here
   180 00000301 488B3530030000      <1>     mov rsi, qword [oemIDTptr.Base] ;Get the base ptr
   181 00000308 4889F7              <1>     mov rdi, rsi
   182 0000030B 4881C600020000      <1>     add rsi, 020h*10h
   183 00000312 4881C7000F0000      <1>     add rdi, 0F0h*10h
   184 00000319 B920000000          <1>     mov ecx, 2*10h    ;Copy the hardware IRQ pointers high!
   185 0000031E F348A5              <1>     rep movsq
   186                              <1> 
   187 00000321 B011                <1>     mov al, 11h        ;bit 10h and 1h = Start initialisation
   188 00000323 E620                <1>     out 020h, al
   189 00000325 E680                <1>     out 080h, al    
   190 00000327 E6A0                <1>     out 0A0h, al
   191 00000329 E680                <1>     out 080h, al    
   192 0000032B B0F0                <1>     mov al, 0F0h       ;PIC1 to take Int 0F0h - F7h
   193 0000032D E621                <1>     out 021h, al
   194 0000032F E680                <1>     out 080h, al    
   195 00000331 0408                <1>     add al, 8        ;PIC2 to take Int  F8h - FFh
   196 00000333 E6A1                <1>     out 0A1h, al 
   197 00000335 E680                <1>     out 080h, al    
   198 00000337 B004                <1>     mov al, 4
   199 00000339 E621                <1>     out 021h, al    ;Tell PIC 1 that there is a PIC 2 at IRQ2 (00000100)
   200 0000033B E680                <1>     out 080h, al    
   201 0000033D FEC8                <1>     dec al
   202 0000033F FEC8                <1>     dec al
   203 00000341 E6A1                <1>     out 0A1h, al    ;Tell PIC 2 its cascade identity (00000010)
   204 00000343 E680                <1>     out 080h, al
   205 00000345 B001                <1>     mov al, 01h        ;Initialise in 8086 mode
   206 00000347 E621                <1>     out 021h, al
   207 00000349 E680                <1>     out 080h, al    
   208 0000034B E6A1                <1>     out 0A1h, al
   209 0000034D E680                <1>     out 080h, al    
   210 0000034F 0F011DE0020000      <1>     lidt [oemIDTptr] 
   211 00000356 31C0                <1>     xor eax, eax    ;Unmask all interrupts 
   212 00000358 E621                <1>     out 021h, al
   213 0000035A E6A1                <1>     out 0A1h, al
   214 0000035C FB                  <1>     sti
   215                              <1> 
   216 0000035D E9(00000000)        <1>     jmp SYSENTRY    ;Now all vars setup, we can proceed!
   217                              <1> OEMSYSINIT ENDP
   218                              <1> aptSize equ 60*4096 ;(APT = Additional Page Tables)
   219                              <1> 
   220                              <1> OEMMCBINIT PROC NEAR
   221 00000362 B820E80000          <1>     mov eax, 0E820h ;Get memory map
   222 00000367 CD35                <1>     int 35h ; rsi has pointer to memory map
   223 00000369 488B05AE020000      <1>     mov rax, qword [biosUBase]
   224 00000370 E8EE000000          <1>     call .mcbFindAddress
   225 00000375 7341                <1>     jnc .mcbi1  ;If found, proceed
   226                              <1>     ;Here, we try use E801h
   227 00000377 B801E80000          <1>     mov eax, 0E801h
   228 0000037C CD35                <1>     int 35h
   229 0000037E 0FB7C0              <1>     movzx eax, ax   ;ax has 1Kb blocks from userbase to ISA hole (if pres)
   230 00000381 0FB7DB              <1>     movzx ebx, bx   ;cx has 64Kb blocks from 16Mb to PCI hole
   231 00000384 85C0                <1>     test eax, eax
   232 00000386 7417                <1>     jz .worst
   233 00000388 C1E009              <1>     shl eax, 9      ;Multiply by 9 to get number of bytes
   234 0000038B C1E310              <1>     shl ebx, 16     ;Multiply by 16 to get number of bytes
   235 0000038E 890592020000        <1>     mov dword [loProtMem], eax
   236 00000394 891D90020000        <1>     mov dword [hiProtMem], ebx
   237 0000039A E90E010000          <1>     jmp mcbBuild
   238                              <1> .worst:
   239                              <1>     ;Get USERBASE pointer and subtract it from 2Mb
   240 0000039F B800002000          <1>     mov eax, 200000h
   241 000003A4 488B1D73020000      <1>     mov rbx, qword [biosUBase]   ;Get userbase
   242 000003AB 29D8                <1>     sub eax, ebx
   243 000003AD 890573020000        <1>     mov dword [loProtMem], eax  ;The leftover goes here
   244 000003B3 E9F5000000          <1>     jmp mcbBuild 
   245                              <1> .mcbi1:
   246 000003B8 488B10              <1>     mov rdx, qword [rax]    ;Save the userbase in rdx
   247 000003BB 48BB01000000010000- <1>     mov rbx, 100000001h ;Valid entry signature
   247 000003C4 00                  <1>
   248 000003C5 48395810            <1>     cmp qword [rax + 16], rbx ;If entry is marked as invalid, fail boot
   249 000003C9 0F85B1000000        <1>     jne .mcbFail
   250 000003CF 488B4008            <1>     mov rax, qword [rax + 8]    ;Get arena size in rax
   251                              <1>     ;PCI hole always exists so this value will always be a dword
   252 000003D3 89054D020000        <1>     mov dword [loProtMem], eax
   253 000003D9 4889D3              <1>     mov rbx, rdx    ;Get userbase into rbx
   254 000003DC 4801C3              <1>     add rbx, rax    ;Check if it goes above 16Mb?
   255 000003DF 4881FB00000001      <1>     cmp rbx, 1000000h  
   256 000003E6 7735                <1>     ja .skipISA
   257                              <1> ;Here we deal with ISA hole issues
   258 000003E8 B820E80000          <1>     mov eax, 0E820h
   259 000003ED CD35                <1>     int 35h
   260 000003EF B800000001          <1>     mov rax, 1000000h
   261 000003F4 E86A000000          <1>     call .mcbFindAddress
   262 000003F9 0F82AE000000        <1>     jc mcbBuild  ;If address doesnt exist, must not be any memory above 16MB
   263 000003FF 48BB01000000010000- <1>     mov rbx, 100000001h ;Valid entry signature
   263 00000408 00                  <1>
   264 00000409 48395810            <1>     cmp qword [rax + 16], rbx ;If entry is marked as invalid, ignore domain
   265 0000040D 0F859A000000        <1>     jne mcbBuild  
   266 00000413 488B5808            <1>     mov rbx, qword [rax + 8]
   267 00000417 891D0D020000        <1>     mov dword [hiProtMem], ebx   ;Save data 
   268                              <1> .skipISA:
   269 0000041D B820E80000          <1>     mov eax, 0E820h
   270 00000422 CD35                <1>     int 35h
   271 00000424 48B800000000010000- <1>     mov rax, 100000000h ;4Gb boundary
   271 0000042D 00                  <1>
   272 0000042E E830000000          <1>     call .mcbFindAddress
   273 00000433 7278                <1>     jc mcbBuild    ;If no memory above 4Gb, proceed as normal
   274 00000435 48BB01000000010000- <1>     mov rbx, 100000001h ;Valid entry signature
   274 0000043E 00                  <1>
   275 0000043F 48395810            <1>     cmp qword [rax + 16], rbx ;If entry is marked as invalid, ignore domain
   276 00000443 7568                <1>     jne mcbBuild   
   277 00000445 488B5808            <1>     mov rbx, qword [rax + 8]
   278                              <1>     ;If this size is above 60Gb, store 60Gb as this is max long arena size!
   279 00000449 48B9000000000F0000- <1>     mov rcx, 0F00000000h    ;60Gb value
   279 00000452 00                  <1>
   280 00000453 4839CB              <1>     cmp rbx, rcx
   281 00000456 480F47D9            <1>     cmova rbx, rcx  ;Move the value of rcx into rbx IF it is above
   282 0000045A 48891DCD010000      <1>     mov qword [longMem], rbx   ;Save data 
   283 00000461 EB4A                <1>     jmp mcbBuild
   284                              <1> .mcbFindAddress:
   285                              <1> ;Takes an address in rax and tries to find the 24 byte entry in the memory map
   286                              <1> ;Entry: rax = Address of arena to search for
   287                              <1> ;       rsi = Pointer to memory map
   288                              <1> ;       ecx = Number of 24 byte entries
   289                              <1> ;Exit:  CF=NC : rax = Pointer to 24 byte entry 
   290                              <1> ;       CF=CY : value in rax not found
   291 00000463 56                  <1>     push rsi
   292 00000464 51                  <1>     push rcx
   293 00000465 50                  <1>     push rax
   294                              <1> .mfa0:
   295 00000466 483B06              <1>     cmp rax, qword [rsi]
   296 00000469 740D                <1>     je .mcbAddressFound
   297 0000046B 4883C618            <1>     add rsi, 24 ;Goto next entry
   298 0000046F FFC9                <1>     dec ecx
   299 00000471 79F3                <1>     jns .mfa0
   300                              <1> .mcbNoAddressFound: ;If ecx changes sign, we have used up all entries
   301 00000473 58                  <1>     pop rax
   302 00000474 59                  <1>     pop rcx
   303 00000475 5E                  <1>     pop rsi
   304 00000476 F9                  <1>     stc
   305 00000477 C3                  <1>     ret
   306                              <1> .mcbAddressFound:
   307 00000478 4889F0              <1>     mov rax, rsi    ;Save pointer to entry in rax
   308 0000047B 59                  <1>     pop rcx ;Pop old rax value off
   309 0000047C 59                  <1>     pop rcx
   310 0000047D 5E                  <1>     pop rsi
   311 0000047E F8                  <1>     clc
   312 0000047F C3                  <1>     ret
   313                              <1> .mcbFail:
   314 00000480 488D2D0C000000      <1>     lea rbp, mcbFailmsg
   315 00000487 B804130000          <1>     mov eax, 1304h
   316 0000048C CD30                <1>     int 30h
   317 0000048E E946010000          <1>     jmp OEMHALT
   318 00000493 4D656D6F727920416C- <1> mcbFailmsg db "Memory Allocation Error",0Ah,0Dh,0
   318 0000049C 6C6F636174696F6E20- <1>
   318 000004A5 4572726F720A0D00    <1>
   319                              <1> 
   320                              <1> mcbBuild:
   321                              <1> ;Actually build the MCB chain here
   322                              <1> ;Start by computing the difference between userbase and DOS area
   323 000004AD 488B1D6A010000      <1>     mov rbx, qword [biosUBase]
   324 000004B4 488B35(00000000)    <1>     mov rsi, qword [MCBANCHOR]  
   325 000004BB 8B4609              <1>     mov eax, dword [rsi + mcb.blockSize]    ;Get the size of the block
   326 000004BE 48C1E004            <1>     shl rax, 4      ;Convert to number of allocated bytes
   327 000004C2 4883C010            <1>     add rax, mcb_size   ;Add the mcb itself to the count
   328 000004C6 4801F0              <1>     add rax, rsi    ;Add the pointer to the mcb to get pointer to free space
   329 000004C9 4889C7              <1>     mov rdi, rax    ;Save this value as the pointer to the next MCB
   330 000004CC 4829D8              <1>     sub rax, rbx    ;Get difference from userbase and first byte after DOS
   331 000004CF 290551010000        <1>     sub dword [loProtMem], eax  ;Remove difference from the free bytes count
   332 000004D5 0F82FE000000        <1>     jc OEMHALT                  ;If this carries, fail
   333 000004DB 813D41010000008000- <1>     cmp dword [loProtMem], 8000h   ;Need a minimum of 32Kb free space.
   333 000004E4 00                  <1>
   334 000004E5 0F82EE000000        <1>     jb OEMHALT
   335 000004EB C6064D              <1>     mov byte [rsi + mcb.marker], mcbMarkCtn ;Now mark anchor as not end
   336 000004EE 4889FB              <1>     mov rbx, rdi    ;Get the pointer to the free space back
   337 000004F1 C6035A              <1>     mov byte [rbx + mcb.marker], mcbMarkEnd  ;Mark as end of chain
   338 000004F4 48C7430100000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerFree
   339 000004FC 31F6                <1>     xor esi, esi
   340 000004FE 8B3522010000        <1>     mov esi, dword [loProtMem]
   341 00000504 83EE10              <1>     sub esi, mcb_size   ;Now remove one mcb's worth of space
   342 00000507 C1EE04              <1>     shr esi, 4  ;Shift down by a nybble to get paragraphs
   343 0000050A 897309              <1>     mov dword [rbx + mcb.blockSize], esi
   344                              <1> 
   345                              <1>     ;Now check the hiProtMem count. If it is 0, skip ISA hole computations.
   346 0000050D 833D1601000000      <1>     cmp dword [hiProtMem], 0
   347 00000514 7459                <1>     jz .skipISA
   348                              <1>     ;Here if an ISA hole exists, place a MCB around it
   349 00000516 836B0901            <1>     sub dword [rbx + mcb.blockSize], (mcb_size>>4)    
   350                              <1>     ;Remove one MCB worth of space from alloc
   351 0000051A 31C9                <1>     xor ecx, ecx
   352 0000051C 8B4B09              <1>     mov ecx, dword [rbx + mcb.blockSize]
   353 0000051F 83C101              <1>     add ecx, (mcb_size >> 4)    ;Add one as the block starts AFTER the MCB
   354 00000522 C1E104              <1>     shl ecx, 4  ;Convert from paragraphs
   355 00000525 C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn  ;Change marker in anchor
   356 00000528 4801CB              <1>     add rbx, rcx   ;Point rbx to next space
   357 0000052B C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn
   358 0000052E 48C7430107000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerHole
   359 00000536 B900000001          <1>     mov rcx, 1000000h   ;Move 16Mb in rcx
   360 0000053B 4889D8              <1>     mov rax, rbx    ;Get mcb pointer in rax
   361 0000053E 4883C010            <1>     add rax, mcb_size
   362 00000542 4829C1              <1>     sub rcx, rax    ;Take their difference
   363 00000545 C1E904              <1>     shr ecx, 4
   364 00000548 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx    ;Save the difference
   365 0000054B C1E104              <1>     shl ecx, 4  ;Get bytes again
   366 0000054E 4883C310            <1>     add rbx, mcb_size
   367 00000552 4801CB              <1>     add rbx, rcx
   368                              <1>     ;RBX should now be at 16Mb
   369 00000555 C6035A              <1>     mov byte [rbx + mcb.marker], mcbMarkEnd
   370 00000558 48C7430100000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerFree
   371 00000560 8B0DC4000000        <1>     mov ecx, dword [hiProtMem]
   372 00000566 C1E904              <1>     shr ecx, 4  ;Get paragraphs
   373 00000569 83E901              <1>     sub ecx, (mcb_size>>4)  ;Reserve space for one mcb
   374 0000056C 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx
   375                              <1> .skipISA:
   376                              <1>     ;Now check the longMem count. If it is 0, skip PCI hole computations.
   377                              <1>     ;rbx points to a block with "Z" marker
   378 0000056F 833DB800000000      <1>     cmp dword [longMem], 0
   379 00000576 7460                <1>     jz .exit
   380                              <1>     ;Add PCI hole MCB
   381 00000578 836B0901            <1>     sub dword [rbx + mcb.blockSize], (mcb_size>>4)
   382                              <1>     ;Remove one MCB worth of space from alloc
   383 0000057C 31C9                <1>     xor ecx, ecx
   384 0000057E 8B4B09              <1>     mov ecx, dword [rbx + mcb.blockSize]
   385 00000581 83C101              <1>     add ecx, (mcb_size >> 4)    ;Add one as the block starts AFTER the MCB
   386 00000584 C1E104              <1>     shl ecx, 4  ;Get bytes
   387 00000587 C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn ;Change marker in prev MCB
   388 0000058A 4801CB              <1>     add rbx, rcx   ;Point rbx to next space
   389 0000058D C6034D              <1>     mov byte [rbx + mcb.marker], mcbMarkCtn
   390 00000590 48C7430107000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerHole
   391 00000598 48B900000000010000- <1>     mov rcx, 100000000h   ;Move 4Gb in rcx
   391 000005A1 00                  <1>
   392 000005A2 4889D8              <1>     mov rax, rbx    ;Get mcb pointer in rax
   393 000005A5 4883C010            <1>     add rax, mcb_size
   394 000005A9 4829C1              <1>     sub rcx, rax    ;Take their difference
   395 000005AC C1E904              <1>     shr ecx, 4
   396 000005AF 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx    ;Save the difference
   397 000005B2 C1E104              <1>     shl ecx, 4  ;Get bytes again
   398 000005B5 4883C310            <1>     add rbx, mcb_size
   399 000005B9 4801CB              <1>     add rbx, rcx
   400                              <1>     ;RBX should now be at 4Gb
   401 000005BC C6035A              <1>     mov byte [rbx + mcb.marker], mcbMarkEnd
   402 000005BF 48C7430100000000    <1>     mov qword [rbx + mcb.owner], mcbOwnerFree
   403 000005C7 488B0D60000000      <1>     mov rcx, qword [longMem]
   404 000005CE 48C1E904            <1>     shr rcx, 4
   405 000005D2 83E901              <1>     sub ecx, (mcb_size>>4)  ;Reserve space for one mcb
   406 000005D5 894B09              <1>     mov dword [rbx + mcb.blockSize], ecx
   407                              <1> .exit:
   408 000005D8 C3                  <1>     ret
   409                              <1> OEMMCBINIT ENDP
   410                              <1> 
   411                              <1> OEMHALT PROC    NEAR
   412                              <1> ;If a critical error occurs during sysinit, fail through here
   413                              <1> ;Int 22h, 23h and 24h point here during sysinit
   414 000005D9 488D2D0C000000      <1>     lea rbp, hltmsg
   415 000005E0 B804130000          <1>     mov eax, 1304h
   416 000005E5 CD30                <1>     int 30h
   417                              <1> .ei0:
   418 000005E7 F4                  <1>     hlt
   419 000005E8 F390                <1>     pause
   420 000005EA EBFB                <1>     jmp short .ei0
   421 000005EC 4572726F7220696E69- <1> hltmsg  db "Error initialising SCPDOS.SYS. System halting...",0
   421 000005F5 7469616C6973696E67- <1>
   421 000005FE 20534350444F532E53- <1>
   421 00000607 59532E205379737465- <1>
   421 00000610 6D2068616C74696E67- <1>
   421 00000619 2E2E2E00            <1>
   422                              <1> OEMHALT ENDP
   423                              <1> 
   424                              <1> OEMCALLBK PROC NEAR
   425 0000061D C3                  <1>     ret
   426                              <1> OEMCALLBK ENDP
   427                              <1> 
   428                              <1> ;OEM Only variables are permitted in this file. They are not 
   429                              <1> ; visible to SYSINIT
   430 0000061E 0000000000000000    <1> biosUBase   dq 0
   431 00000626 00000000            <1> loProtMem   dd 0
   432 0000062A 00000000            <1> hiProtMem   dd 0
   433 0000062E 0000000000000000    <1> longMem     dq 0
   434                              <1> oemIDTptr:      ;Local IDT pointer
   435 00000636 0000                <1>     .Limit  dw 0
   436 00000638 0000000000000000    <1>     .Base   dq 0
    16                                  
    17                                  Segment odata follows=otext align=1 vfollows=otext valign=1
    18                                  ;---------------------------
    19                                  ;   OEMINIT data segment
    20                                  ;---------------------------
    21                                  ;No OEM DATA
    22                                  ;========================END OF OEMINIT MODULE=======================
