     1                                  ;Share! Handle file sharing in this module here.
     2                                  ;This is a kernel module with the key difference that it is not linked 
     3                                  ; into the main kernel image. Instead, we produce a standalone .EXE file
     4                                  ; which hooks itself into DOS if the user runs the program.
     5                                  ;We run as a TSR with two switches:
     6                                  ;/F:xxxxxxx specifies the amount of bytes to allocate for MFT space in bytes.
     7                                  ; Max value: 1048576 bytes (1Mb).
     8                                  ; Default: 2048 bytes (2Kb).
     9                                  ;/L:xxxx specifies the number of concurrent file locks allowed.
    10                                  ; Max value: 9999
    11                                  ; Default: 20
    12                                  
    13                                  [DEFAULT REL]
    14                                  BITS 64
    15                                  
    16                                  [LIST -]
    25                                  ;========================START OF SHARE MODULE=========================
    26                                  EXTERN resLenParas
    27                                  GLOBAL ep
    28                                  ;---------------------------
    29                                  ;   DOS data segment here
    30                                  ;---------------------------
    31                                  ;Included as an absolute 
    32                                  ;segment at address 0 to
    33                                  ;allow using the dos data 
    34                                  ;segment as a struc
    35                                  ;---------------------------
    36                                  absolute 0x0
    37                                  %include "./src/dos/Kernel/BSS/dosSeg.asm"
     1                              <1> ;This file contains the main DOS data segment
     2 00000000 <res 10h>           <1>     anchorMcb   db mcb_size dup (?) ;This is space for the anchor MCB
     3                              <1> dosDataArea:    ;The returned pointer points to the variables w/o anchor MCB
     4 00000010 ??                  <1>     bootDrive   db ?    ;The logical drive we booted from
     5 00000011 ????????            <1>     biosVers    dd ?    ;Indicates BIOS type. Each OEM picks a number
     6 00000015 ????????????????    <1>     biosPtr     dq ?    ;For saving a data ptr to be used by BIOS/drivers
     7                              <1> ;Above is the system stats
     8                              <1> ;Below is the DOS vars, DO NOT TOUCH FROM validNetNam TO NUMJOINDRV
     9                              <1> ;Both below variables can be edited with Int 21h AX=440Bh
    10 0000001D ????                <1>     validNetNam dw ?    ;Flag if machinename valid, deflt no=0
    11 0000001F ????                <1>     shareCount  dw ?    ;Share Retry Count, number of repeats before fail.
    12 00000021 ????                <1>     shareDelay  dw ?    ;Share Delay, in multiples of ms. (TEMP, just loop)
    13 00000023 ????????????????    <1>                 dq ?    ;Unused ptr for future, current disk buffer
    14 0000002B ????????????????    <1>     vConHdlOff  dq ?    ;Ptr into buff to the next char to process in hdl req
    15                              <1>     ;   A value of 0 means no chars buffered.
    16 00000033 ????????????????    <1>     mcbChainPtr dq ?    ;Pointer to the MCB chain x
    17                              <1> sysVarsPtr:
    18 0000003B ????????????????    <1>     dpbHeadPtr  dq ?    ;Pointer to the first DPB in the DPB chain x
    19 00000043 ????????????????    <1>     sftHeadPtr  dq ?    ;Pointer to the first SFT header in SFT chain
    20 0000004B ????????????????    <1>     clockPtr    dq ?    ;Pointer to the current active CLOCK$ device header x
    21                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
    22 00000053 ????????????????    <1>     vConPtr     dq ?    ;Ptr to the devdrv of the char dev controlling vCon x
    23                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
    24 0000005B ????                <1>     maxBytesSec dw ?    ;Maximum number of bytes per sector (size of buffers)x
    25 0000005D ????????????????    <1>     bufHeadPtr  dq ?    ;Pointer to the head of the disk buffer chain x
    26 00000065 ????????????????    <1>     cdsHeadPtr  dq ?    ;Pointer to the head of the CDS array x
    27 0000006D ????????????????    <1>     fcbsHeadPtr dq ?    ;Pointer to the head of the System FCB chain
    28 00000075 ????                <1>     numSafeSFCB dw ?    ;Number of protected FCBs (y in FCBS=x,y)
    29 00000077 ??                  <1>     numPhysVol  db ?    ;Number of physical volumes in the system x
    30 00000078 ??                  <1>     lastdrvNum  db ?    ;Value of LASTDRIVE (default = 5) [Size of CDS array]x
    31 00000079 ??                  <1>     numBuffers  db ?    ;Buffers=30 default
    32 0000007A <res 22h>           <1>     nulDevHdr   db drvHdr_size dup (?)
    33 0000009C ??                  <1>     numJoinDrv  db ?    ;Number of Joined Drives
    34                              <1> ;Additional internal variables
    35 0000009D ??                  <1>     numFiles    db ?    ;FILES=5 default, max 255
    36                              <1>     ;DOSMGR hook functions and variable here
    37                              <1>     ;All DOSMGR hooks are 8 byte pointers and have been introduced to allow
    38                              <1>     ; an external application to install itself as a multitasker into the
    39                              <1>     ; DOS kernel. DOS's behaviour changes accordingly when a multitasker 
    40                              <1>     ; is installed. It is recommended that a multitasker NOT be installed
    41                              <1>     ; when a file sharing broker is not installed but that is up to the 
    42                              <1>     ; implementer to decide.  
    43                              <1>     ;Three function hooks are provided. NOTE, all functions must preserve
    44                              <1>     ; ALL registers used.
    45                              <1>     ;
    46                              <1>     ;launchTask:
    47                              <1>     ;This allows for a multitasker to install its handling routine for 
    48                              <1>     ; launching tasks. Note this is called after all setup
    49                              <1>     ; for the EXE has been done except for setting the PSP.
    50                              <1>     ; If the mode bSuFunc = 4, then we have we have the following:
    51                              <1>     ;       ecx = mode of termination
    52                              <1>     ;           = 00 -> Upon terminating, leave task in Zombie mode
    53                              <1>     ;                   awaiting for a task to read it's return code
    54                              <1>     ;           = 01 -> Upon terminating, discard all resources allocated
    55                              <1>     ;                   to the task.
    56                              <1>     ;           > 01 -> Error code, unknown function (01h).
    57                              <1>     ;This function must return to the caller via DOS with CF=CY if an error 
    58                              <1>     ;   and eax = Error code or CF=NC if all ok. DOS will then return to
    59                              <1>     ;   the parent task, with the background task hopefully scheduled to run
    60                              <1>     ;   in the DOSMGR.
    61                              <1>     ;Either before or on initial run, DOSMGR must set currentDTA in a bgTasks'
    62                              <1>     ; SDA to psp+80h. This can be done in launchBgTask.
    63                              <1>     ;
    64                              <1>     ;terminateTask:
    65                              <1>     ;This allows for a multitasker to install its handling routine for
    66                              <1>     ; cleaning up resources allocated to a task. 
    67                              <1>     ;
    68                              <1>     ;Specific function definitions:
    69                              <1>     ;
    70                              <1>     ;If we enter
    71                              <1>     ;   Input:  bx = FCB drive statuses
    72                              <1>     ;           ecx = Termination mode setting
    73                              <1>     ;           rsi = RSP value to start with
    74                              <1>     ;           rbp = execFrame. Use this to get parentPSP data et al.
    75                              <1>     ;           qword [rbp - execFrame.pProgEP] = RIP value to launch from
    76                              <1>     ;   Output: CF=NC -> Proceed with launch of bg task
    77                              <1>     ;           CF=CY -> Error exit, errorcode in eax
    78                              <1> dosMgrHooks:
    79 0000009E ??                  <1>     dosMgrPresent   db ?    ;Clear if no mgr, else set to -1
    80 0000009F ????????????????    <1>     launchTask      dq ?    ;Registers a new task, with specifics based on bSubfunc
    81 000000A7 ????????????????    <1>     terminateTask   dq ?    ;Called to tell the MGR that this task is ending
    82                              <1> 
    83                              <1>     ;DLL Manager hook functions here
    84                              <1>     ;All DLLMGR hooks are 8 byte pointers and are new to the DOS kernel.
    85                              <1>     ;They allow for the installation of a DLL manager program, which hooks
    86                              <1>     ; these pointers, to point to their own subroutines in the DLLMGR prog.
    87                              <1>     ;These hooks are called from within EXEC, only for PE type executables
    88                              <1>     ; and from within EXIT. 
    89                              <1>     ;
    90                              <1>     ;In EXEC mode, modes 0 and 1 create a PSP for the task and thus the 
    91                              <1>     ; task is self standing and has a PSP as a Unique ID. 
    92                              <1>     ;If mode 3, this is an overlay EXE. This means it is not it's own task and 
    93                              <1>     ; is an extension of the parent task. In such a case, the DLL Manager must 
    94                              <1>     ; look at where the overlay is to be loaded (execFrame.pProgBase), and if 
    95                              <1>     ; there is already an overlay there, to remove it's functions from the 
    96                              <1>     ; registery, replacing them with the new overlay's functions. All overlay
    97                              <1>     ; exports must be flagged as belonging to the parent task PSP so that
    98                              <1>     ; on EXIT, they can be removed from the registry. 
    99                              <1>     ;
   100                              <1>     ;In EXIT, the PSP of the ending task must be taken
   101                              <1>     ; into consideration, as if the PSP isn't registered then the task ending
   102                              <1>     ; is a .COM file or an .EXE with no exports.
   103                              <1>     ;Furthermore, if register fails (due to memory or namespace constraints),
   104                              <1>     ; it must return CF=CY.
   105                              <1> dllHooks:
   106 000000AF ????????????????    <1>     registerDLL     dq ?  ;Entered with rbp = execFrame
   107 000000B7 ????????????????    <1>     unloadDLLHook   dq ?  ;
   108                              <1> 
   109                              <1>     ;Share hook functions here
   110                              <1>     ;All share hooks now take 8 bytes rather than 4 bytes as before
   111                              <1>     ;Thus ALL offsets from SFT header increase by 4 bytes and each entry
   112                              <1>     ; is a QWORD entry. Please adjust SHARE.EXE access as necessary.
   113                              <1> shareHooks:
   114 000000BF ????????????????    <1>     markerShare         dq ?  ;Marker Share hook
   115 000000C7 ????????????????    <1>     openShare           dq ?  ;Share called on open. 
   116 000000CF ????????????????    <1>     closeShare          dq ?  ;Share called on close.
   117 000000D7 ????????????????    <1>     closeCompShare      dq ?  ;Share to close all files for a machine.
   118 000000DF ????????????????    <1>     closeTaskShare      dq ?  ;Share to close all files for a task.
   119 000000E7 ????????????????    <1>     closeNameShare      dq ?  ;Share to close file by name.
   120 000000EF ????????????????    <1>     lockFileShare       dq ?  ;Share to lock file region.
   121 000000F7 ????????????????    <1>     unlockFileShare     dq ?  ;Share to unlock file region.
   122 000000FF ????????????????    <1>     checkFileLockShare  dq ?  ;Share to check file region locked.
   123 00000107 ????????????????    <1>     openFileListShare   dq ?  ;Share to get open file list entry.
   124 0000010F ????????????????    <1>     updateFCBfromSFTShr dq ?  ;Share to update FCB from the SFT.    UNUSED
   125 00000117 ????????????????    <1>     fstClstOfFCBShare   dq ?  ;Share to get first cluster of FCB.   UNUSED
   126 0000011F ????????????????    <1>     closeDupNetShare    dq ?  ;Share to close file if dup for proc.
   127 00000127 ????????????????    <1>     renDelCloseShare    dq ?  ;Share to handle rename/delete correctly.
   128 0000012F ????????????????    <1>     updateDirShare      dq ?  ;Share to update dir info in SFT. 
   129                              <1> 
   130                              <1> ;Create SFT header and corresponding array of five default sft entries
   131 00000137 <res Ah>            <1>     firstSftHeader  db sfth_size dup (?)
   132 00000141 <res 57h>           <1>     firstSft        db sft_size dup (?)
   133 00000198 <res 57h>           <1>     secondSft       db sft_size dup (?)
   134 000001EF <res 57h>           <1>     thirdSft        db sft_size dup (?)
   135 00000246 <res 57h>           <1>     fourthSft       db sft_size dup (?)
   136 0000029D <res 57h>           <1>     fifthSft        db sft_size dup (?)
   137                              <1> 
   138                              <1> ;Virtual CONsole Buffers
   139 000002F4 ??                  <1>     vConCursPos db ?     ;Keeps track for tabs stops (and var with 7)
   140                              <1>     ;Only incremented when CON device runs vCon
   141                              <1> vConBuf:    ;Proper buffer symbol
   142 000002F5 ??                  <1>     vConCurCnt  db ?     ;Current count of chars in vConBuffer
   143 000002F6 <res 80h>           <1>     vConBuffer  db 128 dup (?)   ;General Buffer for vCon 256 bytes. 
   144                              <1>     ;Only 128 bytes at a time if doing CON IO via handle
   145 00000376 <res 80h>           <1>     vConInBuf   db 128 dup (?)   ;vConsole buffer for reads ONLY
   146 000003F6 ??                  <1>                 db ?     ;Padding Buffer!
   147                              <1> 
   148 000003F7 ??                  <1>     printEcho   db ?  ;If 0, no echo. Non-zero => Echo to PRN
   149 000003F8 ??                  <1>     verifyFlag  db ?  ;If set, writes are replaces with write/verify x
   150 000003F9 ??                  <1>     switchChar  db ?  ;Editable by 21h/37h. Set to / by default
   151 000003FA ??                  <1>     vConErr     db ?  ;Inc on each char output call
   152                              <1>     ;Is and-ed with 03h, checks for ^C on every fourth char output
   153                              <1> 
   154 000003FB ??                  <1>     allocStrat  db ?  ;Allocation strategy. First, Best or Last fit
   155                              <1> ;Server stuff. Default to all zeros (blank)
   156 000003FC ??                  <1>     shareFlag   db ?  ;SHARE loaded flag. -1 means loaded, 0 means not.
   157 000003FD ??                  <1>     serverCnt   db ?  ;Increments on each 21h/5E01h call
   158 000003FE <res 10h>           <1>     machineName db 16 dup (?) ;Machine name (Set via 21h/5E01h) (set to SPC)    
   159                              <1> ;Swappable Data Area
   160 0000040E <res 20h>           <1>     critPtchTbl dq 4 dup (?)  ;Offsets from DosDataArea addr to the 4 funcs
   161 0000042E ??                  <1>                 db ?  ;Alignment byte
   162                              <1> sda:    ;Start of Swappable Data Area, this bit can remain static
   163 0000042F ??                  <1>     critErrFlag db ?  ;Critical error flag, set on entry to Int 24h x
   164 00000430 ??                  <1>     inDOS       db ?  ;Inc on each DOS call, dec when leaving x
   165 00000431 ??                  <1>     errorDrv    db ?  ;Drive on which error occured or FFh x
   166 00000432 ??                  <1>     errorLocus  db ?  ;Where the error took place  
   167 00000433 ????                <1>     errorExCde  dw ?  ;Extended Error Code
   168 00000435 ??                  <1>     errorAction db ?  ;Suggested action for error  
   169 00000436 ??                  <1>     errorClass  db ?  ;Error Class
   170 00000437 ????????????????    <1>     errorVolLbl dq ?    ;Sets a ptr to the volume label of the error disk
   171 0000043F ????????????????    <1>     currentDTA  dq ?  ;Address of the current DTA x
   172 00000447 ????????????????    <1>     currentPSP  dq ?  ;Address of current PSP x
   173                              <1> 
   174 0000044F ????????????????    <1>     xInt23hRSP  dq ?  ;Saves RSP across an Int 23h call
   175 00000457 ????                <1>     errorLevel  dw ?  ;Last return code returned by Int 21h/4Ch x
   176                              <1>     ;Upper byte: 0=Normal, 1=Abort Occured, 2=CtrlC, 3=TSR 21h/31h
   177                              <1>     ;Lower byte: User Specified
   178 00000459 ??                  <1>     currentDrv  db ?  ;Default drive x
   179 0000045A ??                  <1>     breakFlag   db ?  ;If set, check for CTRL+C on all DOS calls x
   180                              <1> ;SDA, needs to be replaced between processes
   181                              <1> sdaDOSSwap:
   182 0000045B ????????????????    <1>     oldRAX      dq ?  ;Store rax on entering Int21h or returning Int 23h
   183                              <1> ;Next two vars contain info for networking and sharing software to identify
   184                              <1> ; the requester of the call.
   185 00000463 ????????????????    <1>     qPID        dq ?  ;PSP of process making server request. 0 = current psp
   186 0000046B ????????            <1>     dMID        dd ?  ;Requesters' (VM) Network ID. 0 = local machine
   187 0000046F ????????????????    <1>     firstMCB    dq ?  ;First fit MCB for request
   188 00000477 ????????????????    <1>     bestMCB     dq ?  ;Best fit MCB for request
   189 0000047F ????????????????    <1>     lastMCB     dq ?  ;Last fit MCB for request
   190 00000487 ????                <1>     dirEntryNum dw ?  ;Offset into directory of entry we are looking for
   191 00000489 ??                  <1>     volIdFlag   db ?  ;If set, we are searching for a volume ID
   192 0000048A ????????????????    <1>     xInt24hRSP  dq ?  ;RSP across an Int 24h call
   193 00000492 ??                  <1>     Int24bitfld db ?  ;Copies the bit field given to the Int 24h handler
   194 00000493 ??                  <1>     fileDirFlag db ?  ;File/Directory flag. 0 = Dir, ¬0 = File
   195 00000494 ??                  <1>     Int24Fail   db ?  ;Set if Int 24h returned fail
   196                              <1> 
   197 00000495 ????????????????    <1>     oldoldRSP   dq ?  ;RSP at prev Int 21h entry if called from within Int 21h
   198 0000049D ????????????????    <1>     dosReturn   dq ?  ;Used as a var to return when juggling stack
   199 000004A5 ????????????????    <1>     oldRSP      dq ?  ;RSP when entering Int 21h
   200 000004AD ????????????????    <1>     oldRBX      dq ?  ;Temp var to save value of rbx during an Int 21 call
   201 000004B5 ??                  <1>     dirFlag     db ?  ;Directory Flag. 0 => Search for Dir, 1 => for File
   202                              <1> ;The below flag tells DOS to print ^C in the termination function
   203 000004B6 ??                  <1>     ctrlCExit   db ?  ;-1 => CTRL+BREAK termination, 0 otherwise
   204 000004B7 ??                  <1>     fcbSpaceOk  db ?  ;If set, we allow embedded spaces in the filenames
   205                              <1> ;Time stuff
   206                              <1> ;Read the below two as a word
   207 000004B8 ??                  <1>     dayOfMonth  db ?  ;01h - 1Fh (1 - 31)
   208 000004B9 ??                  <1>     monthOfYear db ?  ;01h - 0Ch (1 - 12)
   209 000004BA ??                  <1>     years       db ?  ;00h - 7Fh (00 = 1980 - 127 = 2107)
   210 000004BB ????                <1>     daysOffset  dw ?  ;Days since 1-1-1980
   211 000004BD ??                  <1>     dayOfWeek   db ?  ;0 = Sunday <-> 6 = Saturday
   212                              <1> 
   213 000004BE ??                  <1>     vConDrvSwp  db ?  ;Set if vCon controlled by a different driver to vConPtr
   214 000004BF ??                  <1>     int28Flag   db ?  ;If set, Int 28h should be called, if clear no
   215 000004C0 ??                  <1>     procExiting db ?  ;Set to -1 if in process termination
   216                              <1> ;A request routed through the FCB or handle uses primReqPkt for its main IO.
   217                              <1> ;A secondary header is present to allow simultaneous echoing to console 
   218                              <1> ; without forcing to re-build the whole primary request block.
   219                              <1> ;Thus all disk io uses the primary and CharIO goes through the primary
   220                              <1> ; with secondary char output going through the secondary header
   221                              <1> ;(i.e the char input functions use the primary for main input and secondary 
   222                              <1> ; for output)
   223                              <1> ;ioReqPkt is the largest possible packet
   224 000004C1 <res 2Ah>           <1>     secdReqPkt  db ioReqPkt_size dup (?) ;Secondary, Char IO Reqhdr
   225 000004EB <res 2Ah>           <1>     primReqPkt  db ioReqPkt_size dup (?) ;Main Drv Reqhdr 
   226                              <1> altRet: ;Accessed as a qword
   227 00000515 <res 2Ah>           <1>     critReqPkt  db ioReqPkt_size dup (?)  ;Used for ^C detection!
   228 0000053F ??                  <1>     pspCopyFlg  db ?  ;Set to -1 for child process PSP, 0 for simple PSP copy
   229                              <1> ;Swappable Buffers
   230 00000540 ????????????        <1>     CLOCKrecrd  db 6 dup (?)  ;Clock driver record
   231                              <1>     ;We add an additional byte to save ah too
   232 00000546 ????                <1>     singleIObyt dw ?  ;For single IO byte buffers
   233                              <1> extErrByteBuf:  ;Used by DOS execpt hdlr to build strings. Immediate abort!
   234                              <1> exeHdrSpace:    ;This needs 112 bytes in EXEC only, buffer is free for use!
   235 00000548 <res 80h>           <1>     buffer1     db 2*MAX_FSPEC dup (?)  ;Space for max expanded MAX_FSPEC
   236                              <1> sectHdr:        ;This needs 20 bytes in EXEC only
   237 000005C8 <res 80h>           <1>     buffer2     db 2*MAX_FSPEC dup (?) ;Space for a second path
   238 00000648 ????????????????    <1>     fname1Ptr   dq ?  ;Ptr to first filename argument
   239 00000650 ????????????????    <1>     fname2Ptr   dq ?  ;Ptr to second filename argument
   240 00000658 ??                  <1>     skipDisk    db ?  ;Set => Read Disk, Clear => Skip checking on disk
   241                              <1> ;Misc bookkeeping flags and vars
   242 00000659 <res 2Bh>           <1>     dosffblock  db ffBlock_size dup (?)  ;FF block (fullsize unlike DOS)
   243 00000684 <res 20h>           <1>     curDirCopy  db fatDirEntry_size dup (?)  ;Dir copy
   244 000006A4 <res 5Fh>           <1>     tmpCDS      db cds_size dup (?)  ;For server calls that need a tmp CDS
   245                              <1> ;These two are used to expand filenames into FCB format. The extra char 
   246                              <1> ; is used to store the terminator of the portion (either a pathsep or null)
   247 00000703 <res Ch>            <1>     fcbName     db MAX_NAME_FCBZ dup (?)
   248 0000070F <res Ch>            <1>     wcdFcbName  db MAX_NAME_FCBZ dup (?)  ;Expands wildcards for rename
   249 0000071B ????????????????    <1>     fileDirSect dq ?  ;File/Directory starting sector, for each level
   250 00000723 ??                  <1>     volIncmpFCB db ?  ;Set to -1 if the volume uses FAT32 (or all incompat FS)
   251 00000724 ??                  <1>     extFCBAttr  db ?  ;Extended FCB file attribute
   252 00000725 ??                  <1>     extFCBFlag  db ?  ;Set to -1 if Extended FCB
   253 00000726 ??                  <1>     searchAttr  db ?  ;Directory Search attributes
   254                              <1> ;    fileOpenMd  db ?  ;Open mode (compat, r/w/rw?) 
   255 00000727 ??                  <1>     renFlags    db ?  ;01h = Rename in same dir, 02h = Wildcard in destination
   256 00000728 ??                  <1>     badNameRen  db ?  ;Device name or File not found for rename
   257 00000729 ??                  <1>     rwFlag      db ?  ;00h=Read, 1=Write, read/write/share error reporting
   258 0000072A ??                  <1>     spliceFlag  db ?  ;00 = Relative path, !0 = Full path
   259 0000072B ??                  <1>     dosInvoke   db ?  ;0 = Invoked via Int 21h, -1 = Invoked via 21h/5D01h
   260                              <1> 
   261 0000072C ??                  <1>     vConInsert  db ?  ;Insert mode on 21/0ah (0 = not insert, !0 = insert)
   262 0000072D ??                  <1>     fileExist   db ?  ;-1 if file in pathspec exists (create/open)
   263 0000072E ??                  <1>     parDirExist db ?  ;-1 if parent directory for file exists (create/open)
   264 0000072F ??                  <1>     exitType    db ?  ;Forms the upper byte of the errorlvl
   265 00000730 ??                  <1>     openCreate  db ?  ;If open, set to 0, if Create set to -1
   266                              <1> ;Set to E5h for renaming and deletion. Can be set to 0 if *.* chosen
   267                              <1> ; to speed up the deletion but we don't use this (yet).
   268 00000731 ??                  <1>     delChar     db ?
   269 00000732 ??                  <1>     workingDrv  db ?  ;Working drive number, 0 based, from DPB
   270                              <1> qPtr:       ;Stores working DPB and/or device driver (if r/w a char device)
   271                              <1> workingDD:  ;Create a symbol for the working device driver too
   272 00000733 ????????????????    <1>     workingDPB  dq ?  ;Ptr to the DPB of the drive being accessed
   273 0000073B ????????????????    <1>     workingCDS  dq ?  ;Ptr to the CDS of the drive being accessed
   274 00000743 ????????????????    <1>     workingFCB  dq ?  ;Ptr to the caller FCB for FCB function
   275                              <1> ;Below is the symbol for saving the oldSFTptr during a char func
   276                              <1> vConAltSFTPtr: ;Alternate symbol for working SFT (used when CON is swapped)
   277 0000074B ????????????????    <1>     workingSFT  dq ?  ;Temporary SFT (may not be not current) ptr being used
   278 00000753 ????????????????    <1>     curHdlPtr   dq ?  ;Ptr to JFT handle entry in current PSP
   279 0000075B ????????????????    <1>     currentSFT  dq ?  ;Ptr to the SFT of the file being accessed
   280 00000763 ????                <1>     currentNdx  dw ?  ;Used to access the current SFTNdx being opened/created
   281 00000765 ????                <1>     currentHdl  dw ?  ;The current file handle is saved here
   282 00000767 ????????????????    <1>     currBuff    dq ?  ;Ptr to the Current Buffer (hdr) being accessed
   283                              <1> ;Temp vars, used when walking FAT or changing sectors, or reporting sector num
   284                              <1> ; and 32 byte offset into the sector for directory
   285 0000076F ????????????????    <1>     tempSect    dq ?  ;A scratch sector number
   286                              <1> pathLen:    ;Used to store the length of a path string for removal strcmp
   287 00000777 ????                <1>     entry       dw ?  ;32 byte offset into a sector or #fats sectors/fat
   288                              <1> ;***************************************************|
   289                              <1> ; Needs to be set up before any file access         |
   290                              <1> ; These vars keep track of file access properties   |
   291                              <1> ;   and must be used only for such purposes.        |
   292                              <1> ;***************************************************|
   293 00000779 ????????            <1>     currClustF  dd ?  ;Relative cluster in file being r/w to/from
   294 0000077D ????????            <1>     currClustD  dd ?  ;Current Disk Cluster being r/w to/from
   295                              <1> 
   296 00000781 ????????            <1>     currSectF   dd ?  ;Current Sector in File being r/w to/from
   297 00000785 ??                  <1>     currSectC   db ?  ;Current Sector in Cluster being r/w to/from
   298 00000786 ????????????????    <1>     currSectD   dq ?  ;Current absolute Sector number on Disk
   299                              <1> 
   300 0000078E ????                <1>     currByteS   dw ?  ;Current Byte in sector being r/w to/from
   301 00000790 ????????            <1>     currByteF   dd ?  ;Current Byte in file being r/w to/from
   302                              <1> ;***************************************************|
   303 00000794 ????????            <1>     lastClust   dd ?  ;Number of the last (rel) cluster of the file
   304 00000798 ????????            <1>     lastClustA  dd ?  ;Number of the last (abs) cluster of file on disk
   305 0000079C ????????            <1>     tfrLen      dd ?  ;Number of bytes to transfer
   306 000007A0 ????????            <1>     tfrCntr     dd ?  ;Number of bytes left to transfer
   307                              <1> ;Directory stuff
   308 000007A4 ????????            <1>     dirClustPar dd ?  ;Absolute disk cluster of the start of the parent dir
   309 000007A8 ????????            <1>     dirClustA   dd ?  ;Absolute cluster number of current directory
   310 000007AC ????                <1>     dirSect     dw ?  ;Sector of current directory cluster
   311 000007AE ????????            <1>     dirEntry    dd ?  ;32 byte offset in dir for file being searched for
   312                              <1> ;Extended Open vars
   313 000007B2 ????                <1>     wEOFlags    dw ?  ;Set if we are doing an extended open with various flags
   314 000007B4 ????                <1>     wEOActions  dw ?  ;Extended open actions (user DX)
   315 000007B6 ????                <1>     wEOOpenMode dw ?  ;Symbol to the next two bytes. (USER BX)
   316 000007B8 ????                <1>     wEOAttribs  dw ?  ;Symbol to the next two bytes (USER CX)
   317 000007BA ????????????????    <1>     pszEOfile   dq ?  ;Ptr to null terminated string to file name (USER RSI)
   318                              <1> ;Error DPB 
   319 000007C2 ????????????????    <1>     tmpDPBPtr   dq ?  ;A DPB for error/temporary situations
   320                              <1> ;No clash recycling below var as the vars in SDA are invalid if in CPU 
   321                              <1> ; exception hdlr. This var gets cleared on entry to the exception handler. 
   322                              <1> ;If it remains clear, the task will Abort. If it gets set, DOS or COMMAND.COM 
   323                              <1> ; caused CPU exception or we have an NMI. Then we freeze as we cant guarantee 
   324                              <1> ; anything anymore.
   325                              <1> haltDOS:
   326 000007CA ??                  <1>     mediaByte   db ?  ;Calls 1Bh and 1Ch return ptr to here
   327                              <1>     
   328 000007CB <res 2Bh>           <1>     renameFFBlk db ffBlock_size dup (?)  ;Source file "find first" block
   329 000007F6 <res 20h>           <1>     renameDir   db fatDirEntry_size dup (?)  ;Build new file dir entry here
   330                              <1> ;Stacks and scratch SFT
   331 00000816 ????                <1>     alignb  8
   332 00000818 <res 528h>          <1>     critStack   dq 165 dup (?)
   333 00000D40 ????????????????    <1>     critStakTop dq ?
   334                              <1> 
   335 00000D48 <res 57h>           <1>     scratchSFT  db sft_size dup (?)  ;Used in FCB calls to emulate a SFT
   336                              <1>     
   337 00000D9F ??                  <1>     alignb  8
   338 00000DA0 <res 638h>          <1>     AuxStack    dq 199 dup (?)
   339 000013D8 ????????????????    <1>     AuxStakTop  dq ?  ;Auxilliary stack (Char IO, Int 25h/46h etc)
   340 000013E0 <res 638h>          <1>     DiskStack   dq 199 dup (?)
   341 00001A18 ????????????????    <1>     DiskStakTop dq ?
   342                              <1> 
   343 00001A20 ??                  <1>     lookahead   db ?  ;-1 => Lookahead on select Char function calls!
   344                              <1> ;Below is used in create and delete for vol lbl only. Else is -1.
   345 00001A21 ??                  <1>     rebuildDrv  db ?  ;Stores the drive letter of the dpb to reset.
   346                              <1>     sdaLen      equ     $ - sda 
   347                              <1>     sdaDOSLen   equ     $ - sdaDOSSwap
   348                              <1> 
   349                              <1> ;Additional variables NOT in the SDA
   350 00001A22 ????????????????    <1>     serverDispTblPtr    dq ?  ;DO NOT MOVE! Used to find server dispatch tbl
   351                              <1> ;A backup header to allow copying to for saving the current header when 
   352                              <1> ; quickly doing a second request
   353 00001A2A <res 2Ah>           <1>     bkupReqHdr          db ioReqPkt_size dup (?)  
   354                              <1> ;Prevent toggling print if in the middle of reading an extended ASCII char
   355                              <1> inExtASCII:
   356 00001A54 ??                  <1>     noPrintTog  db ?  ;00 = Toggle as usual, 01 = Prevent toggle
   357 00001A55 ????                <1>     keybTicks   dw ?  ;Counts the number of cycles spent in a kb loop.
   358                              <1> ;Every time this overflows, we read the clock and update the DOS internal
   359                              <1> ; copy of the date/time record
   360                              <1> ;The idt doesnt need to be in the SDA as we will halt interrupts
   361                              <1> ; until we get/set the address. Thus the IDT entry returned is the 
   362                              <1> ; correct one AT the time of calling up to "the time it takes to get
   363                              <1> ; to the read IDT routine".
   364                              <1> dosIdtPtr:          ;21h/25h will always read a new copy of IDT here
   365 00001A57 ????                <1>     .limit  dw ?    ;Overlap this with stack below as no call overlap
   366 00001A59 ????????????????    <1>     .base   dq ?
   367                              <1> ;Lseek and IOCTL return data in registers as well as on the caller's 
   368                              <1> ; stack. In Int 2Fh, this could overwrite user data if the functions
   369                              <1> ; were allowed to write to original callers register stack. 
   370                              <1> ; So we have this structure below that is used by these functions to 
   371                              <1> ; write their "return" data onto a "stack", even though when accessed 
   372                              <1> ; through the multiplexer we never will read this structure. 
   373                              <1> ; Really only 4 qwords are needed (rax-rdx) but yaknow... safety
   374                              <1> labelPkt:   ;Whilst this is here, keep the thing below kinda big :)
   375 00001A61 <res 60h>           <1>     mplxRegStack    db callerFrame_size dup (?) 
    38                                  
    39                                  ;---------------------------
    40                                  ;       Share data seg
    41                                  ;---------------------------
    42                                  segment bss$r bss private align=16
    43                                  %include "./src/share/data/shbss.asm"
     1                              <1> ;All BSS variables go here
     2                              <1> 
     3 00000000 ????????????????    <1> pMftArena   dq ?
     4 00000008 ????????            <1> dMftArenaSz dd ?    ;Size of MFT arena in bytes (max 1048576 bytes i.e. 1 Mb)
     5 0000000C ????????????????    <1> pLockArena  dq ?
     6 00000014 ????????????????    <1> pFreeLock   dq ?    ;Ptr to head of Free lock chain. 0 means no free locks left
     7 0000001C ????                <1> wNumLocks   dw ?    ;Store number of locks here (max 9999)
     8 0000001E ????????????????    <1> pOldI2Fh    dq ?    ;Ptr to old Int 2Fh for chaining
     9 00000026 ????????????????    <1> pDosseg     dq ?    ;Ptr to the DOSSEG
    10 0000002E ????????????????    <1> pPSP        dq ?    ;Ptr to share psp. Used as scratch space once resident.
    44                                  
    45                                  ;---------------------------
    46                                  ;       Share code seg
    47                                  ;---------------------------
    48                                  segment .text code private align=16 use64
    49                                  ;Place this explicit .text section to calm nasm down
    50                                  segment code$r code private align=16 use64
    51                                  %include "./src/share/text/shmain.asm"
     1                              <1> ;-------------------------------------------------------------------------
     2                              <1> ;This file contains the all the functions that have external linkage.
     3                              <1> ;
     4                              <1> ; Int 2Fh handler
     5                              <1> ; open           
     6                              <1> ; close          
     7                              <1> ; closeAllByMachine      
     8                              <1> ; closeAllByProcess      
     9                              <1> ; closeAllByName    
    10                              <1> ; lockFile       
    11                              <1> ; unlockFile     
    12                              <1> ; checkRegionLock  
    13                              <1> ; getMFTInfo   
    14                              <1> ; updateFCB 
    15                              <1> ; getFirstClusterFCB   
    16                              <1> ; closeNetworkFiles   
    17                              <1> ; closeRenDel
    18                              <1> ; dirUpdate      
    19                              <1> ;-------------------------------------------------------------------------
    20                              <1> 
    21                              <1> i2fHandler:
    22 00000000 80FC10              <1>     cmp ah, 10h ;Is this call for us?
    23 00000003 7508                <1>     jne .gotoNext
    24 00000005 84C0                <1>     test al, al ;Do we test presence of share?
    25 00000007 7502                <1>     jnz .exit   ;If not, probably badly behaved code. Let it return silently
    26 00000009 B0FF                <1>     mov al, -1  ;Else, indicate we are already installed
    27                              <1> .exit:
    28 0000000B 48CF                <1>     iretq
    29                              <1> .gotoNext:
    30 0000000D FF25(1E000000)      <1>     jmp qword [pOldI2Fh]
    31                              <1> 
    32                              <1> open:           
    33                              <1> ;Called on file create/open. Creates/Finds an MFT entry for the file
    34                              <1> ; being opened and adds the new SFT to the MFT chain.
    35                              <1> ;----------------------------------------------------------------------------
    36                              <1> ;Input: qword [fname1Ptr] -> Fully qualified pathname to open
    37                              <1> ;       qword [currentSFT] -> SFT that was just created/opened
    38                              <1> ;           This SFT needs the following fields filled in:
    39                              <1> ;               .wOpenMode
    40                              <1> ;               .bFileAttrib
    41                              <1> ;               .dMID
    42                              <1> ;               .qPID
    43                              <1> ;               .pMFT
    44                              <1> ;       qword [qPID] -> Process ID of the requesting task
    45                              <1> ;       dword [dMID] -> Machine ID of the requesting task
    46                              <1> ;Output: CF=NC: Proceed happily with SFT linked into the MFT for the file.
    47                              <1> ;        CF=CY: eax = Error code for request. Abort, free SFT.
    48                              <1> ;Use r8 as DOSSEG base
    49                              <1> ;----------------------------------------------------------------------------
    50 00000013 E810010000          <1>     call critEnter
    51 00000018 4150                <1>     push r8
    52 0000001A 4C8B05(26000000)    <1>     mov r8, qword [pDosseg]
    53 00000021 498BB048060000      <1>     mov rsi, qword [r8 + fname1Ptr] ;Get the filename pointer
    54 00000028 E82E030000          <1>     call getMFT
    55 0000002D 720C                <1>     jc .exit
    56                              <1> ;rbx -> MFT for this file here.
    57 0000002F 498BB05B070000      <1>     mov rsi, qword [r8 + currentSFT]    ;Get the current SFT now
    58 00000036 E8E2010000          <1>     call addSFTtoMFT    ;Bubble CF
    59                              <1> .exit:
    60 0000003B 4158                <1>     pop r8
    61 0000003D E8F0000000          <1>     call critExit
    62                              <1>     return
    13                              <2> %%_ret:
    14 00000042 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    63                              <1> 
    64                              <1> close:          
    65                              <1> ;Called on file close. Frees all sharing information associated with
    66                              <1> ; a file.
    67                              <1> ;Input: rdi -> SFT we are closing.
    68 00000043 E8E0000000          <1>     call critEnter
    69 00000048 488B5F4F            <1>     mov rbx, qword [rdi + sft.pMFT]
    70 0000004C 4885DB              <1>     test rbx, rbx   ;If this is an SFT from before Share loaded, do nothing!
    71 0000004F 741C                <1>     jz .exit
    72 00000051 0FBF07              <1>     movsx eax, word [rdi + sft.wNumHandles] ;Get the count
    73 00000054 85C0                <1>     test eax, eax   ;If count is zero, free all sharing data
    74 00000056 7404                <1>     jz .goClose
    75 00000058 FFC0                <1>     inc eax         ;If this handle is -1, also free any sharing data.
    76 0000005A 7511                <1>     jnz .exit       ;If not -1 or 0, then inc eax > 0 and so we just exit
    77                              <1> .goClose:
    78 0000005C E863010000          <1>     call freeLocks  ;Free all locks associated to this SFT
    79 00000061 E811010000          <1>     call removeSFTfromMFT ;Delink this SFT from the SFT link
    80 00000066 7505                <1>     jnz .exit       ;If not last SFT in MFT chain, dont free MFT
    81 00000068 E8CF000000          <1>     call freeMFT    ;If no more SFTs, free the MFT. Do small GC.
    82                              <1> .exit:
    83 0000006D E8C0000000          <1>     call critExit
    84                              <1>     return
    13                              <2> %%_ret:
    14 00000072 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    85                              <1> 
    86                              <1> closeAllByMachine:      
    87                              <1> ;Close all files for a machine
    88 00000073 F9                  <1>     stc
    89                              <1>     return
    13                              <2> %%_ret:
    14 00000074 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    90                              <1> closeAllByProcess:      
    91                              <1> ;Close all files for a task
    92 00000075 F9                  <1>     stc
    93                              <1>     return
    13                              <2> %%_ret:
    14 00000076 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    94                              <1> closeAllByName:      
    95                              <1> ;Close file by name
    96 00000077 F9                  <1>     stc
    97                              <1>     return
    13                              <2> %%_ret:
    14 00000078 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    98                              <1> lockFile:       
    99                              <1> ;Lock a file region
   100 00000079 F9                  <1>     stc
   101                              <1>     return
    13                              <2> %%_ret:
    14 0000007A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   102                              <1> unlockFile:     
   103                              <1> ;Unlock file region
   104 0000007B F9                  <1>     stc
   105                              <1>     return
    13                              <2> %%_ret:
    14 0000007C C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   106                              <1> checkRegionLock:  
   107                              <1> ;Check file region locked
   108 0000007D F8                  <1>     clc
   109                              <1>     return
    13                              <2> %%_ret:
    14 0000007E C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   110                              <1> getMFTInfo:   
   111                              <1> ;Get MFT information about file
   112 0000007F F9                  <1>     stc
   113                              <1>     return
    13                              <2> %%_ret:
    14 00000080 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   114                              <1> updateFCB: 
   115                              <1> ;UNUSED: Update FCB from the SFT
   116 00000081 F9                  <1>     stc
   117                              <1>     return
    13                              <2> %%_ret:
    14 00000082 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   118                              <1> getFirstClusterFCB:   
   119                              <1> ;UNUSED: Get first cluster of FCB
   120 00000083 F9                  <1>     stc
   121                              <1>     return
    13                              <2> %%_ret:
    14 00000084 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   122                              <1> closeNetworkFiles:   
   123                              <1> ;Close a newly created SFT-FCB handle for a procedure.
   124                              <1> ;Network SFT-FCBs handles are all collapsed into one SFT.
   125                              <1> ;----------------------------------------------------------------------------
   126                              <1> ;Input: rsi -> Newly created SFT
   127                              <1> ;       ax = SFTNdx for this newly created file
   128                              <1> ;Output: ax = SFTNdx for the file (Same as on input if not a SFT-FCB)
   129                              <1> ;----------------------------------------------------------------------------
   130                              <1> ;If
   131                              <1> ;   rsi -> SFT that is a network SFT-FCB (i.e. bit openNetFCBShr set 
   132                              <1> ;   in openmode), then we close any duplicate handles using a single
   133                              <1> ;   SFT to maintain the state (if there are none then we use this SFT
   134                              <1> ;   as the SFT-FCB). We increment the new main SFT refcount instead of 
   135                              <1> ;   having multiple SFTs.
   136                              <1> ;----------------------------------------------------------------------------
   137 00000085 F8                  <1>     clc
   138                              <1>     return
    13                              <2> %%_ret:
    14 00000086 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   139                              <1> 
   140                              <1> closeRenDel:
   141                              <1> ;On rename/delete/setattr, this function is called to check we can proceed
   142                              <1> ; with the operation.
   143                              <1> ;Finds MFT based on the filename in fname1Ptr in the dosseg
   144                              <1> ;----------------------------------------------------------------------------
   145                              <1> ;Input: fname1Ptr -> Filename to do check on
   146                              <1> ;Output: Nothing
   147                              <1> ;----------------------------------------------------------------------------
   148                              <1> ;If 
   149                              <1> ;   the file is not open, then we return ok.
   150                              <1> ;Else if 
   151                              <1> ;   the file is opened by us uniquely and is open in compatibility mode,
   152                              <1> ;   then close the file and return ok.
   153                              <1> ;Else, we fail.
   154                              <1> ;----------------------------------------------------------------------------
   155 00000087 F9                  <1>     stc
   156                              <1>     return
    13                              <2> %%_ret:
    14 00000088 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   157                              <1> dirUpdate:      
   158                              <1> ;Update dir info across all SFTs for a file. 
   159                              <1> ;----------------------------------------------------------------------------
   160                              <1> ;Input: rdi -> SFT to update dir entry from
   161                              <1> ;       eax = 0: Update the date/time fields only
   162                              <1> ;           = 1: Update size fields for growth
   163                              <1> ;           = 2: Update size fields for shrink (i.e. truncate/open calls)
   164                              <1> ;           = 3: Update all fields
   165                              <1> ;Output: Nothing, all SFTs in MFT chain updated.
   166                              <1> ;        rax and rcx trashed.
   167                              <1> ;----------------------------------------------------------------------------
   168                              <1> ; If rdi is a chardev or a redir file, return
   169                              <1> ; Get MFT pointer. 
   170                              <1> ; If 
   171                              <1> ;   MFT pointer is null, return.
   172                              <1> ; Else
   173                              <1> ;   Get first SFT pointer from MFT into rsi   
   174                              <1> ; If eax = 0:
   175                              <1> ;   Walk the SFT chain along rsi updating date/time fields except for us.
   176                              <1> ; Else if eax = 1:
   177                              <1> ;   Walk the SFT chain along rsi updating dFileSize and dStartClust fields 
   178                              <1> ;   except for us.
   179                              <1> ; Else if eax = 2:
   180                              <1> ;   Walk the SFT chain along rsi updating dFileSize, dStartClust and 
   181                              <1> ;   setting dRelClust to 0 and dAbsClust to dStartClust except for us.
   182                              <1> ; Else if eax = 3:
   183                              <1> ;   Update date/time and dFileSize, dStartClust, dRelClust and dAbsClust 
   184                              <1> ;   fields for us from the oldest SFT in the SFT chain for this MFT. 
   185                              <1> ;   
   186                              <1> ; Return.
   187                              <1> ;**** Note ****
   188                              <1> ;In open and shrink we reset dRelClust to 0 and dAbsClust to dStartClust
   189                              <1> ;to signify that all file IO should start from the start of the file.
   190                              <1> ;This is a future optimisation as right now, the DOS kernel never depends 
   191                              <1> ;on these values. These values are however correctly synchronised on each
   192                              <1> ;read/write so in the future, we can relatively easily add a check to make
   193                              <1> ;use of these values, unless they are at the start of the file at which
   194                              <1> ;case we use the current algorithms.
   195                              <1> ;----------------------------------------------------------------------------
   196 00000089 66F747058080        <1>     test word [rdi + sft.wDeviceInfo], devCharDev | devRedir
   197                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000008F 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000091 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   198 00000092 51                  <1>     push rcx
   199 00000093 56                  <1>     push rsi
   200 00000094 488B774F            <1>     mov rsi, qword [rdi + sft.pMFT] ;Get MFT pointer in rsi
   201 00000098 4885F6              <1>     test rsi, rsi   ;If this is a null pointer, return
   202                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000009B 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000009D C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   203 0000009E E885000000          <1>     call critEnter
   204 000000A3 488B760E            <1>     mov rsi, qword [rsi + mft.pSFT] ;Get first SFT of MFT in rsi
   205 000000A7 89C1                <1>     mov ecx, eax
   206 000000A9 85C9                <1>     test ecx, ecx   ;Is it 0?
   207 000000AB 7515                <1>     jnz .fileCheck
   208                              <1> ;Here we do date/time update only.
   209 000000AD 8B4713              <1>     mov eax, dword [rdi + sft.dTimeDate]
   210                              <1> .dtlp:
   211 000000B0 894613              <1>     mov dword [rsi + sft.dTimeDate], eax
   212 000000B3 E860000000          <1>     call .gotoNextSFT
   213 000000B8 75F6                <1>     jnz .dtlp
   214                              <1> .exit:
   215 000000BA E873000000          <1>     call critExit
   216                              <1> .exitNoCrit:
   217 000000BF 5E                  <1>     pop rsi
   218 000000C0 59                  <1>     pop rcx
   219                              <1>     return
    13                              <2> %%_ret:
    14 000000C1 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   220                              <1> .fileCheck:
   221 000000C2 81F903000000        <1>     cmp ecx, 3
   222 000000C8 7430                <1>     je .open
   223                              <1> ;If not 3 or 0, must be 1 or 2
   224                              <1> .gsLp:
   225                              <1> ;Always update filesize and start cluster info in rsi for growth/shrink
   226                              <1> ; to the filesize and start cluster of rdi
   227 000000CA 8B4717              <1>     mov eax, dword [rdi + sft.dFileSize]
   228 000000CD 894617              <1>     mov dword [rsi + sft.dFileSize], eax
   229 000000D0 8B470F              <1>     mov eax, dword [rdi + sft.dStartClust]
   230 000000D3 89460F              <1>     mov dword [rsi + sft.dStartClust], eax
   231 000000D6 81F902000000        <1>     cmp ecx, 2      ;Was this a shrink call?
   232 000000DC 7409                <1>     je .gsDoShrink  ;Reset the cluster info if so
   233                              <1> ;Here if we are a grow call. Check if the SFT in rsi was newly created.
   234                              <1> ;If not, skip the reset below. Else, we set the absolute cluster now to
   235                              <1> ; the start cluster to ensure that the SFTs all correctly have the same
   236                              <1> ; cluster info.  
   237 000000DE 817E2300000000      <1>     cmp dword [rsi + sft.dAbsClust], 0 ;Is this sft just created?
   238 000000E5 750A                <1>     jne .gsNextFile   ;If not, and a grow call, skip the below
   239                              <1> .gsDoShrink:
   240                              <1> ;Set the cluster information back to the start of the file.
   241 000000E7 894623              <1>     mov dword [rsi + sft.dAbsClust], eax
   242 000000EA C7461F00000000      <1>     mov dword [rsi + sft.dRelClust], 0  ;Reset the file rel cluster ptr
   243                              <1> .gsNextFile:
   244 000000F1 E822000000          <1>     call .gotoNextSFT
   245 000000F6 75D2                <1>     jnz .gsLp
   246 000000F8 EBC0                <1>     jmp short .exit 
   247                              <1> 
   248                              <1> .open:
   249                              <1> ;Here we handle new file opens! Copies data from the 
   250                              <1> ; topmost (earliest opened) SFT (rsi) of the SFT chain into 
   251                              <1> ; the newly opened SFT (rdi)
   252 000000FA 8B4613              <1>     mov eax, dword [rsi + sft.dTimeDate]
   253 000000FD 894713              <1>     mov dword [rdi + sft.dTimeDate], eax
   254 00000100 8B4617              <1>     mov eax, dword [rsi + sft.dFileSize]
   255 00000103 894717              <1>     mov dword [rdi + sft.dFileSize], eax
   256 00000106 8B460F              <1>     mov eax, dword [rsi + sft.dStartClust]
   257 00000109 89470F              <1>     mov dword [rdi + sft.dStartClust], eax
   258 0000010C 894723              <1>     mov dword [rdi + sft.dAbsClust], eax
   259 0000010F C7471F00000000      <1>     mov dword [rdi + sft.dRelClust], 0
   260 00000116 EBA2                <1>     jmp short .exit
   261                              <1> 
   262                              <1> .gotoNextSFT:
   263                              <1> ;Returns in rsi the next SFT entry.
   264                              <1> ;Input: rdi -> SFT we are updating from.
   265                              <1> ;       rsi -> SFT we just updated.
   266                              <1> ;Output: ZF=NZ: rsi -> Next SFT in the chain.
   267                              <1> ;        ZF=ZE: End of SFT chain.
   268 00000118 488B763B            <1>     mov rsi, qword [rsi + sft.pNextSFT]
   269 0000011C 4885F6              <1>     test rsi, rsi
   270                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000011F 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000121 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   271 00000122 4839FE              <1>     cmp rsi, rdi
   272 00000125 74F1                <1>     je .gotoNextSFT
   273                              <1>     return
    13                              <2> %%_ret:
    14 00000127 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    52                                  %include "./src/share/text/shutils.asm"
     1                              <1> ;All utility functions go here
     2                              <1> ;-----------------------------------------------------------------------------
     3                              <1> ; critEnter -> Enters a DOS 1 critical section
     4                              <1> ; critExit -> Exits a DOS 1 critical section
     5                              <1> ; freeMFT -> Frees an MFT from the MFT arena
     6                              <1> ; removeSFTfromMFT -> Removes an SFT from an MFT's SFT chain
     7                              <1> ; freeLocks -> Frees all file locks associated to a SFT
     8                              <1> ; addSFTtoMFT -> Adds an SFT to its MFT chain.
     9                              <1> ; getMFT -> Gets an MFT for a given filename. Creates if it has to.
    10                              <1> ; defragMFTArena -> Defragments the MFT arena
    11                              <1> ; findFreeMFT -> Finds a free MFT for a given size
    12                              <1> ; findMFT -> Find an MFT for a given filename
    13                              <1> ; errPrintAndHalt -> Prints a formatted error message and halts the machine
    14                              <1> ;-----------------------------------------------------------------------------
    15                              <1> 
    16                              <1> 
    17                              <1> critEnter:
    18 00000128 50                  <1>     push rax
    19 00000129 B801800000          <1>     mov eax, 8001h  ;Enter DOS Level 1 critical section
    20 0000012E CD2A                <1>     int 2ah
    21 00000130 58                  <1>     pop rax
    22                              <1>     return
    13                              <2> %%_ret:
    14 00000131 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    23                              <1> critExit:
    24 00000132 50                  <1>     push rax
    25 00000133 B801810000          <1>     mov eax, 8101h  ;Exit DOS Level 1 critical section
    26 00000138 CD2A                <1>     int 2ah
    27 0000013A 58                  <1>     pop rax
    28                              <1>     return
    13                              <2> %%_ret:
    14 0000013B C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    29                              <1> 
    30                              <1> freeMFT:
    31                              <1> ;Frees the MFT if it is safe to do so. Crashes otherwise. Combines 
    32                              <1> ; any adjacent free space too.
    33                              <1> ;Input: rbx -> MFT to free
    34                              <1> ;Output: MFT freed. Any adjacent free space is absorbed by this MFT too.
    35                              <1> ;Trashes rax, rbx and rsi
    36 0000013C 488B430E            <1>     mov rax, qword [rbx + mft.pSFT]
    37 00000140 48094306            <1>     or qword [rbx + mft.pLock], rax ;If pLock or pSFT is non-zero, hard error
    38 00000144 751A                <1>     jnz .crash
    39 00000146 C60300              <1>     mov byte [rbx + mft.bSig], mftFree
    40                              <1> .lp:
    41                              <1> ;Checks the adjacent MFT. If it is free, we combine it to this free MFT.
    42 00000149 4889DE              <1>     mov rsi, rbx
    43 0000014C 8B4301              <1>     mov eax, dword [rbx + mft.dLen]
    44 0000014F 4801C6              <1>     add rsi, rax    ;Point to next MFT
    45 00000152 803E00              <1>     cmp byte [rsi + mft.bSig], mftFree
    46                              <1>     retne   ;If not free, we exit
    53                              <2> cret ne
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000155 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000157 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
    47 00000158 8B4601              <1>     mov eax, dword [rsi + mft.dLen]
    48 0000015B 014301              <1>     add dword [rbx + mft.dLen], eax ;Add this size to our MFT len
    49 0000015E EBE9                <1>     jmp short .lp       ;Now go again
    50                              <1> .crash:
    51 00000160 534654204C434B2066- <1>     db "SFT LCK fields not 0",CR,LF,NUL
    51 00000169 69656C6473206E6F74- <1>
    51 00000172 20300D0A00          <1>
    52                              <1> 
    53                              <1> 
    54                              <1> removeSFTfromMFT:
    55                              <1> ;Removes the SFT from the MFT's SFT chain.
    56                              <1> ;Input: rdi -> SFT we are closing.
    57                              <1> ;Output: ZF=ZE: No more files on MFT
    58                              <1> ;        ZF=NZ: More files on MFT.
    59                              <1> ;           rbx -> MFT for this file
    60                              <1> ;Trashes rax and rsi.
    61 00000177 488B5F4F            <1>     mov rbx, qword [rdi + sft.pMFT] ;Get the MFT pointer
    62                              <1> ;Point rsi to the such that it is one sft.pNextSFT away from the pointer to
    63                              <1> ; the next SFT
    64 0000017B 488D73D3            <1>     lea rsi, qword [rbx + mft.pSFT - sft.pNextSFT]
    65                              <1> .lp:
    66 0000017F 4885F6              <1>     test rsi, rsi   ;If we dont find rdi, something has gone terribly wrong
    67 00000182 7425                <1>     jz .crash
    68 00000184 48397E3B            <1>     cmp qword [rsi + sft.pNextSFT], rdi    ;Is the next SFT us?
    69 00000188 7406                <1>     je .found
    70 0000018A 488B763B            <1>     mov rsi, qword [rsi + sft.pNextSFT] ;Go to next SFT
    71 0000018E EBEF                <1>     jmp short .lp
    72                              <1> .found:
    73                              <1> ;rsi -> Points to the previous SFT in the chain 
    74 00000190 488B473B            <1>     mov rax, qword [rdi + sft.pNextSFT] ;Get our next SFT value
    75 00000194 4889463B            <1>     mov qword [rsi + sft.pNextSFT], rax ;And set the prev SFT to link over us
    76 00000198 48C7474F00000000    <1>     mov qword [rdi + sft.pMFT], 0   ;Set pMFT to zero to mean we are done!
    77 000001A0 48817B0E00000000    <1>     cmp qword [rbx + mft.pSFT], 0   ;Is the MFT SFT chain ptr 0?
    78                              <1>     return
    13                              <2> %%_ret:
    14 000001A8 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    79                              <1> .crash:
    80 000001A9 E8D6020000          <1>     call errPrintAndHalt
    81 000001AE 534654206E6F742069- <1>     db "SFT not in SFT list",CR,LF,NUL
    81 000001B7 6E20534654206C6973- <1>
    81 000001C0 740D0A00            <1>
    82                              <1> 
    83                              <1> 
    84                              <1> freeLocks:
    85                              <1> ;Frees all file locks associated to this rdi. 
    86                              <1> ;Input: rdi -> SFT for this file
    87                              <1> ;       edx = Flag for if we should free locks for process
    88                              <1> ;             -1 -> Free for process (on 5D04h calls)
    89                              <1> ;              0 -> Dont bother (otherwise)
    90                              <1> ;Output: All file locks owned by this process are delinked from the 
    91                              <1> ;        file chain and added to the free lock chain.
    92                              <1> ;Trashes rax, rbx, rsi.
    93 000001C4 488B5F4F            <1>     mov rbx, qword [rdi + sft.pMFT]     ;Get MFT ptr in rbx
    94 000001C8 488B7306            <1>     mov rsi, qword [rbx + mft.pLock]    ;Get the first lock of MFT in rsi 
    95 000001CC 4881C306000000      <1>     add rbx, mft.pLock  ;Point rbx to the link field of the previous lock
    96                              <1> .lp:
    97 000001D3 4885F6              <1>     test rsi, rsi   ;End of list? 
    98                              <1>     retz            ;Exit if so
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000001D6 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000001D8 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
    99                              <1> ;A lock is ours if the SFT pointer of the lock matches our SFT pointer in rdi
   100 000001D9 48397E18            <1>     cmp qword [rsi + fileLock.pSFT], rdi    ;Is the SFT ours?
   101 000001DD 7536                <1>     jne .nextLock   ;If not, skip
   102 000001DF 85D2                <1>     test edx, edx   ;If it is but we dont care for process ID, skip this
   103 000001E1 7418                <1>     jz .skipProcess
   104                              <1> ;Now check this lock belongs to this process too
   105 000001E3 4150                <1>     push r8
   106 000001E5 4C8B05(26000000)    <1>     mov r8, qword [pDosseg]
   107 000001EC 498B8063040000      <1>     mov rax, qword [r8 + qPID]  ;Get the process id
   108 000001F3 48394620            <1>     cmp qword [rsi + fileLock.qPID], rax    ;And compare them
   109 000001F7 4158                <1>     pop r8
   110 000001F9 751A                <1>     jne .nextLock
   111                              <1> .skipProcess:
   112                              <1> ;Here we delink the flock. We move it from the MFT list to the Free list
   113                              <1> ; and cross link.
   114                              <1> ;Registers on entry
   115                              <1> ;rdi -> Our SFT
   116                              <1> ;rsi -> Lock
   117                              <1> ;rbx -> The previous lock in the file chain (only first qword valid)
   118                              <1> ;edx = Flag, do not use.
   119 000001FB 488B06              <1>     mov rax, qword [rsi + fileLock.pNext]   ;Unlink rsi by linking the prev...
   120 000001FE 488903              <1>     mov qword [rbx + fileLock.pNext], rax   ;... flock to the flock after rsi
   121 00000201 488B05(14000000)    <1>     mov rax, qword [pFreeLock]              ;Get head of the free lock list
   122 00000208 488906              <1>     mov qword [rsi + fileLock.pNext], rax   ;Link rsi to the head of free list
   123 0000020B 488935(14000000)    <1>     mov qword [pFreeLock], rsi              ;Make rsi the head of the free list
   124 00000212 4889DE              <1>     mov rsi, rbx    ;Start from previous lock in the list again.
   125                              <1> .nextLock:
   126 00000215 4889F3              <1>     mov rbx, rsi    ;Point rsi to this filelock
   127 00000218 488B36              <1>     mov rsi, qword [rsi + fileLock.pNext]   ;Get next file lock
   128 0000021B EBB6                <1>     jmp short .lp
   129                              <1> 
   130                              <1> addSFTtoMFT:
   131                              <1> ;Adds an SFT to the MFT chain and finishes filling in it's share fields. 
   132                              <1> ;Checks for sharing conflicts before adding.
   133                              <1> ;Input: rsi -> SFT to add
   134                              <1> ;       rbx -> MFT to add SFT to
   135                              <1> ;       r8 -> DOSSEG
   136                              <1> ;Output: CF=NC: SFT Added to list
   137                              <1> ;        CF=CY: Sharing violation. eax has error code
   138 0000021D 48817E4F00000000    <1>     cmp qword [rsi + sft.pMFT], 0   ;This SFT better not already be on a chain
   139 00000225 752E                <1>     jne .crash
   140                              <1> ;Add the networking ids now as we need them for permissions checking
   141 00000227 498B8063040000      <1>     mov rax, qword [r8 + qPID]
   142 0000022E 48894647            <1>     mov qword [rsi + sft.qPID], rax
   143 00000232 418B806B040000      <1>     mov eax, dword [r8 + dMID]
   144 00000239 894643              <1>     mov dword [rsi + sft.dMID], eax
   145                              <1> ;Now we check if there are any sharing conflicts
   146 0000023C E82E000000          <1>     call checkPermissions
   147                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000241 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000243 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   148 00000244 48895E4F            <1>     mov qword [rsi + sft.pMFT], rbx
   149                              <1> ;Now add this SFT to the front of the list.
   150 00000248 488B7B0E            <1>     mov rdi, qword [rbx + mft.pSFT] ;Get the head of the SFT list
   151 0000024C 48897E3B            <1>     mov qword [rsi + sft.pNextSFT], rdi ;Link new SFT to previous head
   152 00000250 4889730E            <1>     mov qword [rbx + mft.pSFT], rsi ;Put new SFT at head of MFT list
   153                              <1>     return
    13                              <2> %%_ret:
    14 00000254 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   154                              <1> .crash:
   155 00000255 E82A020000          <1>     call errPrintAndHalt
   156 0000025A 53465420414C524541- <1>     db "SFT ALREADY IN USE",CR,LF,NUL
   156 00000263 445920494E20555345- <1>
   156 0000026C 0D0A00              <1>
   157                              <1> 
   158                              <1> checkPermissions:
   159                              <1> ;Checks for sharing conflicts of the new SFT against all
   160                              <1> ; other SFTs in the chain. 
   161                              <1> ;If both new SFT and SFT on chain are compatibility 
   162                              <1> ; then check machine id. If they are equal, goto next SFT on chain.
   163                              <1> ;Else do table logic as described below.
   164                              <1> ;
   165                              <1> ;Input: rsi -> New SFT, with machine id field set
   166                              <1> ;       rbx -> MFT for this file.
   167                              <1> ;Output: CF=NC: No sharing conflicts.
   168                              <1> ;        CF=CY: Sharing conflict, eax has error code
   169 0000026F 53                  <1>     push rbx
   170 00000270 4889F7              <1>     mov rdi, rsi        ;Save new SFT ptr in rdi
   171 00000273 E8A5000000          <1>     call getOpenMode    ;Get the adjusted sharing mode in eax
   172 00000278 89C2                <1>     mov edx, eax        ;Use edx as the marker for if compat or not
   173 0000027A 81E2F0000000        <1>     and edx, 0F0h       ;Are the share bits 0?
   174 00000280 7405                <1>     jz .compat
   175 00000282 BAF0000000          <1>     mov edx, 0F0h       ;Set to indicate no compat mode
   176                              <1> .compat:
   177 00000287 E86C000000          <1>     call getTableIndex  ;Get table index in eax for new SFT. Use as row index
   178 0000028C D1E0                <1>     shl eax, 1          ;Multiply by two, each row is a word
   179 0000028E 488D3545000000      <1>     lea rsi, .tbl
   180 00000295 0FB72C06            <1>     movzx ebp, word [rsi + rax] ;Get the table entry (bit row) into ebp
   181 00000299 488B730E            <1>     mov rsi, qword [rbx + mft.pSFT] ;Get the first SFT in chain
   182                              <1> .lp:
   183 0000029D 4885F6              <1>     test rsi, rsi       ;Are we at the end of the chain?
   184 000002A0 7433                <1>     jz .exit            ;If so, all ok!
   185 000002A2 E876000000          <1>     call getOpenMode    ;Else, get the adjusted open mode in eax for this sft
   186 000002A7 89C1                <1>     mov ecx, eax
   187 000002A9 81E10F000000        <1>     and ecx, 0Fh        ;Get the share bits
   188 000002AF 09D1                <1>     or ecx, edx         ;Check if both new and old files are in compat mode
   189 000002B1 7508                <1>     jnz .notBothCompat
   190                              <1> ;Both in compat mode means we do machine id check instead.
   191                              <1> ;If they match, we skip.
   192 000002B3 8B5E43              <1>     mov ebx, dword [rsi + sft.dMID]
   193 000002B6 395F43              <1>     cmp dword [rdi + sft.dMID], ebx
   194 000002B9 740F                <1>     je .gotoNext
   195                              <1> .notBothCompat:
   196 000002BB E838000000          <1>     call getTableIndex  ;Get table index but use as a column (bit) index
   197 000002C0 678D4802            <1>     lea ecx, dword [eax + 2]    ;+2 to drop the x bit and push our bit into CF
   198 000002C4 89E8                <1>     mov eax, ebp        ;Move row we are interested in into eax
   199 000002C6 D3E8                <1>     shr eax, cl         ;Shift the bit we are interested into CF to check
   200 000002C8 7206                <1>     jc .exitBad
   201                              <1> .gotoNext:
   202 000002CA 488B763B            <1>     mov rsi, qword [rsi + sft.pNextSFT] ;Goto next SFT
   203 000002CE EBCD                <1>     jmp short .lp
   204                              <1> .exitBad:
   205                              <1> ;We come here with CF=CY
   206 000002D0 B820000000          <1>     mov eax, errShrVio
   207                              <1> .exit:
   208 000002D5 4889FE              <1>     mov rsi, rdi        ;Point rsi back to the new SFT
   209 000002D8 5B                  <1>     pop rbx             ;Get back MFT pointer
   210                              <1>     return
    13                              <2> %%_ret:
    14 000002D9 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   211                              <1> 
   212                              <1> .tbl:          
   213                              <1> ;Each word is a packed entry of 15 meaningful bits with the 
   214                              <1> ; lower most bit always set and meaningless.
   215                              <1> ;That is, each word is 5 lots of 3(share mode) bits.
   216                              <1> ;The bits of each word are interpreted as follows:
   217                              <1> ;     0NNNRRRWWWAAACCCxb 
   218                              <1> ; where: 
   219                              <1> ; NNN = Deny None permissions
   220                              <1> ; RRR = Deny Read permissions 
   221                              <1> ; WWW = Deny Write permissions
   222                              <1> ; AAA = Deny All permissions
   223                              <1> ; CCC = Compat permissions
   224                              <1> ; x   = Set and ignored.
   225                              <1> ;In each triple:
   226                              <1> ;   0LMNb 
   227                              <1> ; the bits are interpreted as:
   228                              <1> ; L = What to do on Read/Write access. 
   229                              <1> ; M = What to do on Write access. 
   230                              <1> ; N = What to do on Read access.
   231                              <1> ;If a bit is set, it means this combination is not allowed.
   232                              <1> ;
   233                              <1> ;We get the word we are interested in based on the open mode of
   234                              <1> ; the new SFT. This gives us a row. We then use the open mode of
   235                              <1> ; every SFT on the MFT's SFT chain, to get a bit offset into this word.
   236                              <1> ;If for every element of the SFT chain the bit in the word is 0,
   237                              <1> ; we are ok. If ever this bit is 1, we have a sharing violation.
   238                              <1> ;
   239                              <1> ;The values of this table obtained from the matrix of the the DOS 3.3 
   240                              <1> ; programmers guide (p. 6-121), where N=1 and Y=0, with the following changes
   241                              <1> ; to make implementation easier (as the numbers are ordered as so):
   242                              <1> ;1) We swap the order of the openRWAcc and openWrAcc columns/rows
   243                              <1> ;    putting RW always at the left/bottom most part. 
   244                              <1> ;2) Each row of the table below is for "subsequent IO" where each
   245                              <1> ;    bit of the entry is the column.
   246                              <1> ;3) We duplicate Deny all as for Compat
   247                              <1> 
   248                              <1> ;Table annotated as follows: 
   249                              <1> ;N=Deny none
   250                              <1> ;R=Deny read
   251                              <1> ;W=Deny write
   252                              <1> ;A=Deny all
   253                              <1> ;C=Compat
   254                              <1> ;B=Open Read/Write (both)
   255                              <1> ;O=Open Write (output)
   256                              <1> ;I=Open Read (input)
   257                              <1> ;
   258                              <1> ;        Initial Open modes
   259                              <1> ;       N   R   W   A   C  x    ;Subsequent opens
   260                              <1> ;      BOI BOI BOI BOI BOI x    
   261 000002DA FFFF                <1>     dw 111_111_111_111_111_1b   ;I        openCompat|openRdAcc
   262 000002DC FFFF                <1>     dw 111_111_111_111_111_1b   ;O C      openCompat|openWrAcc
   263 000002DE FFFF                <1>     dw 111_111_111_111_111_1b   ;B        openCompat|openRWAcc
   264                              <1> 
   265 000002E0 FFFF                <1>     dw 111_111_111_111_111_1b   ;I      openDenRWShr|openRdAcc
   266 000002E2 FFFF                <1>     dw 111_111_111_111_111_1b   ;O A    openDenRWShr|openWrAcc
   267 000002E4 FFFF                <1>     dw 111_111_111_111_111_1b   ;B      openDenRWShr|openRWAcc
   268                              <1> 
   269 000002E6 7FDF                <1>     dw 110_111_110_111_111_1b   ;I      openDenWrShr|openRdAcc
   270 000002E8 FFDB                <1>     dw 110_110_111_111_111_1b   ;O W    openDenWrShr|openWrAcc
   271 000002EA FFDF                <1>     dw 110_111_111_111_111_1b   ;B      openDenWrShr|openRWAcc
   272                              <1> 
   273 000002EC FFBE                <1>     dw 101_111_101_111_111_1b   ;I      openDenRdShr|openRdAcc
   274 000002EE FFB7                <1>     dw 101_101_111_111_111_1b   ;O R    openDenRdShr|openWrAcc
   275 000002F0 FFBF                <1>     dw 101_111_111_111_111_1b   ;B      openDenRdShr|openRWAcc
   276                              <1> 
   277 000002F2 7F1C                <1>     dw 000_111_000_111_111_1b   ;I      openDenNoShr|openRdAcc
   278 000002F4 FF03                <1>     dw 000_000_111_111_111_1b   ;O N    openDenNoShr|openWrAcc
   279 000002F6 FF1F                <1>     dw 000_111_111_111_111_1b   ;B      openDenNoShr|openWRAcc
   280                              <1> 
   281                              <1> getTableIndex:
   282                              <1> ;Turns the adjusted open mode into a table index value
   283                              <1> ;Input: eax = Adjusted open mode
   284                              <1> ;Output: eax = Index into the table (Number 0-14)
   285                              <1> ;        ecx = Share group (0-4)
   286                              <1> ;All other regs preserved
   287 000002F8 89C1                <1>     mov ecx, eax
   288 000002FA 250F000000          <1>     and eax, 0Fh    ;Isolate the open mode bits only
   289 000002FF 81E1F0000000        <1>     and ecx, 0F0h   ;Isolate the share bits only
   290 00000305 81F970000000        <1>     cmp ecx, openNetFCBShr  ;Is this a net FCB share?
   291 0000030B 7502                <1>     jnz .notNetFCB
   292 0000030D 31C9                <1>     xor ecx, ecx    ;Compatibility share in this case
   293                              <1> .notNetFCB:
   294                              <1> ;We want ecx <- (ecx >> 4)*3 to get the share group
   295 0000030F C1E904              <1>     shr ecx, 4      ;Get the share group
   296 00000312 52                  <1>     push rdx
   297 00000313 89CA                <1>     mov edx, ecx    ;Save it in edx
   298 00000315 D1E2                <1>     shl edx, 1      ;Multiply by 2
   299 00000317 01CA                <1>     add edx, ecx    ;Add to get it multiplied by three
   300 00000319 01D0                <1>     add eax, edx    ;Add share group*3 to the offset into the group
   301 0000031B 5A                  <1>     pop rdx
   302                              <1>     return
    13                              <2> %%_ret:
    14 0000031C C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   303                              <1> 
   304                              <1> getOpenMode:
   305                              <1> ;Gets the adjusted open mode.
   306                              <1> ;--------------------------------------------------------------------
   307                              <1> ;Input: rsi -> SFT to get adjusted open mode for
   308                              <1> ;Output: eax = Adjusted open mode.
   309                              <1> ;All other registers preserved.
   310                              <1> ;--------------------------------------------------------------------
   311                              <1> ;If not an FCB of any kind, then everything is ok. 
   312                              <1> ;If an SFTFCB then we put it into openCompat | openRW.
   313                              <1> ;If a NETFCB then we put it into openCompat.
   314                              <1> ;If RO file opened in openCompat, make into openDenWrShr | openRdAcc.
   315 0000031D 53                  <1>     push rbx
   316 0000031E 0FB74602            <1>     movzx eax, word [rsi + sft.wOpenMode]
   317 00000322 66A90080            <1>     test ax, openSFTFCB ;Is this a local FCB?
   318 00000326 7405                <1>     jz .notFCB
   319 00000328 B802000000          <1>     mov eax, openCompat | openRWAcc  ;FCBs have r/w access in compat mode
   320                              <1> .notFCB:
   321 0000032D 89C3                <1>     mov ebx, eax
   322 0000032F 81E3F0000000        <1>     and ebx, 0F0h           ;Mask off the access bits
   323 00000335 81FB70000000        <1>     cmp ebx, openNetFCBShr  ;Is this a net FCB?
   324 0000033B 7505                <1>     jne .notNetFCB
   325 0000033D 250F000000          <1>     and eax, 0Fh        ;Mask off the share bits, turn into compat share
   326                              <1> .notNetFCB:
   327                              <1> ;Now al has the real open mode for this file. Do RO check now
   328 00000342 89C3                <1>     mov ebx, eax
   329 00000344 81E3F0000000        <1>     and ebx, 0F0h   ;Isolate possibly adjusted share bits
   330 0000034A 5B                  <1>     pop rbx
   331                              <1>     retnz           ;If not zero, not in compat mode
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000034B 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000034D C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   332 0000034E F6460401            <1>     test byte [rsi + sft.bFileAttrib], attrFileRO
   333                              <1>     retz            ;If zero, RO bit not set
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000352 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000354 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   334 00000355 B820000000          <1>     mov eax, openDenWrShr | openRdAcc 
   335                              <1>     return
    13                              <2> %%_ret:
    14 0000035A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   336                              <1> 
   337                              <1> 
   338                              <1> getMFT:
   339                              <1> ;Search for an MFT for a file. If one is not found, it creates it.
   340                              <1> ;Input: rsi -> Filename to search for
   341                              <1> ;Output: CF=NC: rbx -> MFT for this file.
   342                              <1> ;        CF=CY: eax = Error code.
   343                              <1> ;Start by working out the string length and checksum values
   344 0000035B 56                  <1>     push rsi
   345 0000035C 31C9                <1>     xor ecx, ecx    ;Use for string length (zero inclusive)
   346 0000035E 31D2                <1>     xor edx, edx    ;Use for checksum value (dl)
   347                              <1> .metalp:
   348 00000360 AC                  <1>     lodsb
   349 00000361 00C2                <1>     add dl, al
   350 00000363 80D200              <1>     adc dl, 0       ;Add 1 if this rolls over
   351 00000366 FFC1                <1>     inc ecx
   352 00000368 84C0                <1>     test al, al
   353 0000036A 75F4                <1>     jnz .metalp
   354 0000036C 5E                  <1>     pop rsi
   355                              <1> ;Hereon: ecx = String length, dl = Checksum, rsi -> String 
   356 0000036D E8E5000000          <1>     call findMFT        ;Preserves dl and ecx
   357                              <1>     retnc
    61                              <2> cret nc
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000372 7201                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000374 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   358                              <1> ;We get here if this file has no MFT.
   359                              <1> ;Create an MFT entry. dl and ecx are always preserved in functions below
   360 00000375 81C116000000        <1>     add ecx, mft_size   ;ecx now has the full MFT entry size
   361 0000037B E8BB000000          <1>     call findFreeMFT
   362 00000380 730F                <1>     jnc .buildMFT
   363 00000382 E847000000          <1>     call defragMFTArena ;Returns rbx -> Free MFT, eax = Free MFT size
   364 00000387 39C8                <1>     cmp eax, ecx        ;Do we fit in this free space?
   365 00000389 7306                <1>     jnc .buildMFT
   366                              <1> ;Here if CF=CY. Return Sharing buffer full error!
   367 0000038B B824000000          <1>     mov eax, errShrFul
   368                              <1>     return
    13                              <2> %%_ret:
    14 00000390 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   369                              <1> .buildMFT:
   370                              <1> ;Here we have the following values:
   371                              <1> ;rsi -> String to copy in
   372                              <1> ;rbx -> Space to allocate the MFT in. rbx points to a free MFT.
   373                              <1> ;ecx = New MFT full size
   374                              <1> ;dl = String checksum 
   375                              <1> 
   376                              <1> ;Work out if we want to split space into two MFTs or keep it as one.
   377                              <1> ;Check if the MFT we are pointing at has enough space for a minimum mft and
   378                              <1> ; our MFT. If there is more than enough space, we split into two MFTs. 
   379                              <1> ;Else, we just allocate the whole space and waste the few extra bytes.
   380 00000391 8B4301              <1>     mov eax, dword [rbx + mft.dLen] ;Get the current size of the free MFT
   381 00000394 29C8                <1>     sub eax, ecx        ;Remove our own allocation from the free MFT size
   382 00000396 3D26000000          <1>     cmp eax, MIN_MFT_SIZE
   383 0000039B 760D                <1>     jbe .alloc   ;If this is beq, we just use this mft entry as is.
   384                              <1> ;eax has the size of the new free block
   385 0000039D 488D3C0B            <1>     lea rdi, qword [rbx + rcx]  ;Point rdi past the end of our new mft
   386 000003A1 C60700              <1>     mov byte [rdi + mft.bSig], mftFree  ;Make the new free block
   387 000003A4 894701              <1>     mov dword [rdi + mft.dLen], eax     ;Set the new free block's size
   388 000003A7 894B01              <1>     mov dword [rbx + mft.dLen], ecx     ;Set the newly allocated block's size
   389                              <1> .alloc:
   390                              <1> ;Finally, allocate the MFT. The size, if modified, is done already.
   391 000003AA C60301              <1>     mov byte [rbx + mft.bSig], mftAlloc
   392 000003AD 48C7430600000000    <1>     mov qword [rbx + mft.pLock], 0
   393 000003B5 48C7430E00000000    <1>     mov qword [rbx + mft.pSFT], 0
   394 000003BD 885305              <1>     mov byte [rbx + mft.bCheckSum], dl  ;Set the checksum immediately.
   395 000003C0 81E916000000        <1>     sub ecx, mft_size   ;Now get just the string length
   396 000003C6 488D7B16            <1>     lea rdi, qword [rbx + mft.name] 
   397 000003CA F3A4                <1>     rep movsb   ;Move the string over
   398 000003CC F8                  <1>     clc
   399                              <1>     return
    13                              <2> %%_ret:
    14 000003CD C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   400                              <1> 
   401                              <1> defragMFTArena:
   402                              <1> ;Defragments the MFT arena. Moves all allocated MFTs to the start.
   403                              <1> ;Creates a single large free MFT from all the free space.
   404                              <1> ;Input: Nothing
   405                              <1> ;Output: MFT defragged. rbx -> New free MFT, eax = New Free MFT size
   406                              <1> ; All other regs preserved.
   407 000003CE 51                  <1>     push rcx
   408 000003CF 52                  <1>     push rdx
   409 000003D0 56                  <1>     push rsi
   410 000003D1 57                  <1>     push rdi
   411                              <1> ;rsi = Read pointer
   412                              <1> ;rdi = Write pointer
   413                              <1> ;edx = Free space accumulator
   414 000003D2 488B35(00000000)    <1>     mov rsi, qword [pMftArena]
   415 000003D9 4889F7              <1>     mov rdi, rsi
   416 000003DC 31D2                <1>     xor edx, edx
   417                              <1> .lp:
   418                              <1> ;If we encounter an allocated mft, we move it over, moving the 
   419                              <1> ; the read and write pointers. If we encounter a free mft, we add its
   420                              <1> ; size and move the read pointer.
   421 000003DE 803E00              <1>     cmp byte [rsi + mft.bSig], mftFree
   422 000003E1 7826                <1>     js .exit    ;At this point, all compression is done. Goto end
   423 000003E3 741A                <1>     je .free
   424                              <1> ;Here we copy over. Before we do, we walk down the SFT chain
   425                              <1> ; updating the MFT pointer in each SFT.
   426                              <1> ;rsi -> Allocated MFT
   427                              <1> ;rdi -> Where this MFT will be moved to
   428 000003E5 488B5E0E            <1>     mov rbx, qword [rsi + mft.pSFT]     ;Point rbx to the first SFT in chain.
   429                              <1> .sftLp:
   430 000003E9 4885DB              <1>     test rbx, rbx   ;End of SFT chain?
   431 000003EC 740A                <1>     jz .sftEnd
   432 000003EE 48897B4F            <1>     mov qword [rbx + sft.pMFT], rdi     ;Update the SFT's MFT pointer
   433 000003F2 488B5B3B            <1>     mov rbx, qword [rbx + sft.pNextSFT]
   434 000003F6 EBF1                <1>     jmp short .sftLp
   435                              <1> .sftEnd:
   436                              <1> ;All SFTs updated, now we copy the MFT up.
   437 000003F8 8B4E01              <1>     mov ecx, dword [rsi + mft.dLen] ;Get the length of this MFT
   438 000003FB F3A4                <1>     rep movsb   ;Moves both pointers to the end of the MFT
   439                              <1> ;Now rdi points to the next write space and rsi points to the next MFT
   440 000003FD EBDF                <1>     jmp short .lp
   441                              <1> .free:
   442                              <1> ;Dont worry about overflow. Max dLen is 1Mb, way less than 32 bit max.
   443 000003FF 8B4601              <1>     mov eax, dword [rsi + mft.dLen] ;Get the length
   444 00000402 01C2                <1>     add edx, eax    ;Add to the free space accumulator
   445 00000404 4801C6              <1>     add rsi, rax    ;Move the read pointer past this free space
   446 00000407 EBD5                <1>     jmp short .lp
   447                              <1> .exit:
   448                              <1> ;Now we must make a single free MFT at the write pointer with the 
   449                              <1> ; correct size and assert it is correct
   450                              <1> ;rdi -> Where to make this MFT
   451                              <1> ;edx = Accumulated free space
   452 00000409 C60700              <1>     mov byte [rdi + mft.bSig], mftFree
   453 0000040C 895701              <1>     mov dword [rdi + mft.dLen], edx
   454 0000040F 89D0                <1>     mov eax, edx    ;Get the free MFT size into eax
   455 00000411 4889FB              <1>     mov rbx, rdi    ;Get the free MFT pointer into rbx
   456 00000414 4801D7              <1>     add rdi, rdx    ;Now check the MFT chain is not corrupted
   457 00000417 803FFF              <1>     cmp byte [rdi + mft.bSig], mftEnd
   458 0000041A 7505                <1>     jne .crash
   459 0000041C 5F                  <1>     pop rdi
   460 0000041D 5E                  <1>     pop rsi
   461 0000041E 5A                  <1>     pop rdx
   462 0000041F 59                  <1>     pop rcx
   463                              <1>     return
    13                              <2> %%_ret:
    14 00000420 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   464                              <1> .crash:
   465 00000421 E85E000000          <1>     call errPrintAndHalt    ;No return. Use call to push string ptr to stack
   466 00000426 4D4654204445465241- <1>     db "MFT DEFRAG FAILURE",CR,LF,NUL
   466 0000042F 47204641494C555245- <1>
   466 00000438 0D0A00              <1>
   467                              <1> 
   468                              <1> findFreeMFT:
   469                              <1> ;Searches for a free MFT of a particular size or greater.
   470                              <1> ;Input: ecx = Minimum MFT size 
   471                              <1> ;Output: CF=NC: rbx -> MFT of appropriate size
   472                              <1> ;        CF=CY: No MFT found of this size. rbx -> End MFT
   473                              <1> ;Trashes rax. All other regs preserved.
   474 0000043B 488B1D(00000000)    <1>     mov rbx, qword [pMftArena]
   475                              <1> .lp:
   476 00000442 803B00              <1>     cmp byte [rbx + mft.bSig], mftFree
   477 00000445 783B                <1>     js findMFT.noMFT    ;If sign bit set, must be mftEnd. Exit error!
   478 00000447 7506                <1>     jne .next           ;If not equal, must be mftAlloc. Goto next MFT
   479 00000449 394B01              <1>     cmp dword [rbx + mft.dLen], ecx ;Is this MFT ok sizewise?
   480                              <1>     retnc   ;Not carry means dLen is geq eax, as required
    61                              <2> cret nc
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000044C 7201                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000044E C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   481                              <1> .next:
   482 0000044F 8B4301              <1>     mov eax, dword [rbx + mft.dLen]
   483 00000452 4801C3              <1>     add rbx, rax    ;Point to the next MFT
   484 00000455 EBEB                <1>     jmp short .lp
   485                              <1> 
   486                              <1> findMFT:
   487                              <1> ;Searches for an MFT for the filename in rsi 
   488                              <1> ;Input: rsi -> Filename to search for
   489                              <1> ;       dl = Filename checksum
   490                              <1> ;Output: CF=NC: rbx -> MFT for file
   491                              <1> ;        CF=CY: No MFT found for this file. rbx -> End MFT
   492                              <1> ;Trashes rax. All other regs preserved.
   493 00000457 488B1D(00000000)    <1>     mov rbx, qword [pMftArena]
   494                              <1> .lp:
   495 0000045E 803B00              <1>     cmp byte [rbx + mft.bSig], mftFree  
   496 00000461 781F                <1>     js .noMFT   ;If sign bit is set, bSig must be -1. End of arena!
   497 00000463 7415                <1>     je .next    ;If this MFT is free, goto next entry
   498 00000465 385305              <1>     cmp byte [rbx + mft.bCheckSum], dl  ;Compare checksums
   499 00000468 7510                <1>     jne .next   ;If not equal, skip entry
   500 0000046A 57                  <1>     push rdi
   501 0000046B 488D7B16            <1>     lea rdi, qword [rbx + mft.name] ;Point to mft filename
   502 0000046F B81E120000          <1>     mov eax, 121Eh  ;Compare strings in rsi and rdi
   503 00000474 CD2F                <1>     int 2Fh         ;Doesnt modify string pointers
   504 00000476 5F                  <1>     pop rdi
   505                              <1>     retz    ;If ZF=ZE (also CF=NC), we have found the MFT! Return to caller.
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000477 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000479 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   506                              <1> .next:
   507 0000047A 8B4301              <1>     mov eax, dword [rbx + mft.dLen]
   508 0000047D 4801C3              <1>     add rbx, rax    ;Point to the next MFT
   509 00000480 EBDC                <1>     jmp short .lp
   510                              <1> .noMFT:
   511 00000482 F9                  <1>     stc
   512                              <1>     return
    13                              <2> %%_ret:
    14 00000483 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   513                              <1> 
   514                              <1> 
   515                              <1> ;Critical error handling
   516                              <1> errPrintAndHalt:
   517                              <1> ;This function is called such that the return address points to the 
   518                              <1> ; null terminated string to print. We never return from this.
   519                              <1> ;********************************************
   520                              <1> ;Consider requesting all disk buffers flush before entering infinite loop.
   521                              <1> ;********************************************
   522                              <1> ;Input: TOS -> Ptr to string to print after header.
   523                              <1> ;Output: Never return.
   524 00000484 488D3D51000000      <1>     lea rdi, .sHdr
   525 0000048B E80A000000          <1>     call .doWrite
   526 00000490 5F                  <1>     pop rdi         ;Get the passed in string
   527 00000491 E804000000          <1>     call .doWrite   ;Write the passed in ASCIIZ string.
   528                              <1> .halt:
   529 00000496 F390                <1>     pause           ;Hint the CPU to power down
   530 00000498 EBFC                <1>     jmp short .halt ;Infinite loop, await CTRL+ALT+DEL
   531                              <1> .doWrite:
   532                              <1> ;We write directly to the console driver completely bypassing any 
   533                              <1> ;redirection, without resorting to using BIOS functions.
   534                              <1> ;We use the PSP as the buffer for the ioReqPkt.
   535                              <1> ;We obviously do no error checking or Int 24 invokation if things
   536                              <1> ; go wrong with this. 
   537                              <1> ;Input: rdi -> String to print
   538                              <1> ;Output: Hopefully, string printed.
   539 0000049A B812120000          <1>     mov eax, 1212h  ;Do dos strlen
   540 0000049F CD2F                <1>     int 2Fh         ;Get length of string pointed to by rdi in ecx
   541                              <1> ;1) Build request packet
   542 000004A1 488B1D(2E000000)    <1>     mov rbx, qword [pPSP]   ;Get the ptr to our PSP
   543 000004A8 C6430208            <1>     mov byte [rbx + ioReqPkt.cmdcde], drvWRITE
   544 000004AC C6032A              <1>     mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   545 000004AF 66C743030000        <1>     mov word [rbx + ioReqPkt.status], 0
   546 000004B5 894B16              <1>     mov dword [rbx + ioReqPkt.tfrlen], ecx
   547 000004B8 48897B0E            <1>     mov qword [rbx + ioReqPkt.bufptr], rdi
   548                              <1> ;2) Get the driver pointer
   549 000004BC 488B35(26000000)    <1>     mov rsi, qword [pDosseg]    
   550 000004C3 488B7653            <1>     mov rsi, qword [rsi + vConPtr]  ;Get the console driver ptr
   551                              <1> ;Go driver routine here
   552 000004C7 B802800000          <1>     mov eax, 8002h  ;SPECIAL: Enter DOS Level 2 critical section
   553 000004CC CD2A                <1>     int 2ah
   554 000004CE FF560A              <1>     call qword [rsi + drvHdr.strPtr]  ;Passing rbx through here
   555 000004D1 FF5612              <1>     call qword [rsi + drvHdr.intPtr]
   556 000004D4 B802810000          <1>     mov eax, 8102h  ;SPECIAL: Exit DOS Level 2 critical section
   557 000004D9 CD2A                <1>     int 2ah
   558                              <1>     return
    13                              <2> %%_ret:
    14 000004DB C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   559                              <1> .sHdr:
   560 000004DC 0D0A0A              <1>     db CR,LF,LF
   561 000004DF 202020202020202053- <1>     db "        SCP/DOS EXCEPTION DETECTED!",CR,LF,LF
   561 000004E8 43502F444F53204558- <1>
   561 000004F1 43455054494F4E2044- <1>
   561 000004FA 45544543544544210D- <1>
   561 00000503 0A0A                <1>
   562 00000505 202020205343502F44- <1>     db "    SCP/DOS SYSTEM STOP: SHARE INTERNAL ERROR : ",NUL
   562 0000050E 4F532053595354454D- <1>
   562 00000517 2053544F503A205348- <1>
   562 00000520 41524520494E544552- <1>
   562 00000529 4E414C204552524F52- <1>
   562 00000532 203A2000            <1>
    53                                  
    54                                  segment code$i code private align=16 use64
    55                                  %include "./src/share/text/shinit.asm"
     1                              <1> 
     2                              <1> ;Initialises the share program
     3                              <1> ;1) Ensure correct DOS version. We are DOS 1.
     4                              <1> ;2) Parse the command tail. Any malformed char or switch and we abort install.
     5                              <1> ;3) Allocate a block for MFTs. If we cannot allocate we abort install.
     6                              <1> ;4) Allocate a block for file locks. If we cannot allocate we abort install.
     7                              <1> ;5) Halt interrupts
     8                              <1> ;6) Install Int 2Fh handler.
     9                              <1> ;7) Copy over all pointers to internal routines to DOS and set Share byte on.
    10                              <1> ;8) Close all file handles and free the environment.
    11                              <1> ;9) Terminate and stay resident.
    12                              <1> ep:
    13 00000000 B800300000          <1>     mov eax, 3000h  ;Get version number
    14 00000005 CD21                <1>     int 21h
    15 00000007 3C01                <1>     cmp al, 1       ;If below or equal to version 1, we are ok with this
    16 00000009 760E                <1>     jbe goInit
    17 0000000B B0FF                <1>     mov al, -1
    18                              <1> badVerExit:
    19                              <1> ;Input: al = Error code
    20 0000000D 488D15A7020000      <1>     lea rdx, sBadVer
    21 00000014 E994020000          <1>     jmp badPrintAndExit
    22                              <1> goInit:
    23 00000019 4C8905(2E000000)    <1>     mov qword [pPSP], r8    ;Save our PSP pointer
    24 00000020 B800520000          <1>     mov eax, 5200h  ;Get ptr to sysvars
    25 00000025 CD21                <1>     int 21h
    26 00000027 4881EB3B000000      <1>     sub rbx, sysVarsPtr ;Subtract the offset into the segment
    27 0000002E 48891D(26000000)    <1>     mov qword [pDosseg], rbx    ;Store ptr to the head of the segment
    28 00000035 B080                <1>     mov al, 80h         ;Error code for no SFT 
    29 00000037 48817B4300000000    <1>     cmp qword [rbx + sftHeadPtr], 0    ;Check if no SFT ptr
    30 0000003F 74CC                <1>     je badVerExit
    31 00000041 B800100000          <1>     mov eax, 1000h              ;SHARE Int 2f check
    32 00000046 CD2F                <1>     int 2Fh
    33 00000048 3CFF                <1>     cmp al, -1
    34 0000004A 750C                <1>     jne goInstall
    35 0000004C 488D15AA020000      <1>     lea rdx, sInstalled
    36 00000053 E955020000          <1>     jmp badPrintAndExit         ;Jump with al = -1
    37                              <1> goInstall:
    38 00000058 B800610000          <1>     mov eax, 6100h              ;Get the pointer to the environment in rdx
    39 0000005D CD21                <1>     int 21h
    40 0000005F 4885D2              <1>     test rdx, rdx
    41 00000062 740E                <1>     jz skipEnvFree
    42 00000064 4150                <1>     push r8
    43 00000066 4989D0              <1>     mov r8, rdx
    44 00000069 B800490000          <1>     mov eax, 4900h              ;And free the environment
    45 0000006E CD21                <1>     int 21h
    46 00000070 4158                <1>     pop r8
    47                              <1> skipEnvFree:
    48                              <1> ;Initialise the sizes with the defaults
    49 00000072 C705(08000000)0008- <1>     mov dword [dMftArenaSz], MFT_SIZE_DFLT
    49 0000007A 0000                <1>
    50 0000007C 66C705(1C000000)14- <1>     mov word [wNumLocks], LOCKS_DFLT
    50 00000084 00                  <1>
    51                              <1> ;Get switchchar
    52 00000085 B800370000          <1>     mov eax, 3700h              ;Get switchchar
    53 0000008A CD21                <1>     int 21h
    54 0000008C 881528020000        <1>     mov byte [bSwitchChar], dl
    55                              <1> ;Point rsi to cmd line and get string count
    56 00000092 498DB080000000      <1>     lea rsi, qword [r8 + 80h]   ;Go to the command line
    57 00000099 AC                  <1>     lodsb                       ;Get the string length
    58 0000009A 0FB6C8              <1>     movzx ecx, al               ;into ecx
    59                              <1> cmdlineLp:
    60                              <1> ;Here we process the command line. We only allow for /f and /l switches.
    61                              <1> ;Capital and lower case allowed. Parse based on string length.
    62                              <1> ;We really strictly parse to ensure that the user does EXACTLY what they want
    63 0000009D 85C9                <1>     test ecx, ecx
    64 0000009F 0F848C000000        <1>     jz .endParse
    65 000000A5 AC                  <1>     lodsb           ;Read a char
    66 000000A6 FFC9                <1>     dec ecx         ;Dec the count
    67 000000A8 E8EA010000          <1>     call isALsep    ;Is this a sep char?
    68 000000AD 74EE                <1>     je cmdlineLp    ;Keep looping if so
    69 000000AF 85C9                <1>     test ecx, ecx   ;If not, but we have no more chars to process, end parse
    70 000000B1 747E                <1>     jz .endParse
    71 000000B3 3A0501020000        <1>     cmp al, byte [bSwitchChar]
    72 000000B9 753B                <1>     jne .badParamExit
    73 000000BB 88C2                <1>     mov dl, al      ;Capitalise the char
    74 000000BD B820650000          <1>     mov eax, 6520h  ;Capitalise char in dl with normal table
    75 000000C2 CD21                <1>     int 21h
    76 000000C4 80FA46              <1>     cmp dl, "F"
    77 000000C7 743B                <1>     je .mftSwitch
    78 000000C9 80FA4C              <1>     cmp dl, "L"
    79 000000CC 7528                <1>     jne .badParamExit
    80                              <1> ;Here we figure out how many locks were specified.
    81 000000CE E8AC010000          <1>     call getNextChar
    82 000000D3 3C3A                <1>     cmp al, ":"  ;Next char MUST be a semicolon
    83 000000D5 751F                <1>     jne .badParamExit
    84 000000D7 E852010000          <1>     call getASCIINumber
    85 000000DC 81FB0F270000        <1>     cmp ebx, MAX_LOCKS   ;Check the argument not insane
    86 000000E2 7712                <1>     ja .badParamExit
    87 000000E4 66391D(1C000000)    <1>     cmp word [wNumLocks], bx    ;If the new value is less than default, ignore
    88 000000EB 77B0                <1>     ja cmdlineLp
    89 000000ED 66891D(1C000000)    <1>     mov word [wNumLocks], bx
    90 000000F4 EBA7                <1>     jmp short cmdlineLp
    91                              <1> .badParamExit:
    92 000000F6 488D15D6010000      <1>     lea rdx, sBadParam
    93 000000FD B0FF                <1>     mov al, -1
    94 000000FF E9A9010000          <1>     jmp badPrintAndExit
    95                              <1> .mftSwitch:
    96 00000104 E876010000          <1>     call getNextChar
    97 00000109 3C3A                <1>     cmp al, ":"  ;Next char MUST be a semicolon
    98 0000010B 75E9                <1>     jne .badParamExit
    99 0000010D E81C010000          <1>     call getASCIINumber
   100 00000112 81FB00001000        <1>     cmp ebx, MAX_MFT_SIZE
   101 00000118 77DC                <1>     ja .badParamExit
   102 0000011A 391D(08000000)      <1>     cmp dword [dMftArenaSz], ebx
   103 00000120 0F8777FFFFFF        <1>     ja cmdlineLp
   104 00000126 891D(08000000)      <1>     mov dword [dMftArenaSz], ebx
   105 0000012C E96CFFFFFF          <1>     jmp cmdlineLp
   106                              <1> .endParse:
   107                              <1> ;Now we allocate the arenas of the required size and place pointers 
   108                              <1> ; in the right places. 
   109                              <1> ;Do MFT first
   110 00000131 8B1D(08000000)      <1>     mov ebx, dword [dMftArenaSz]    ;This is in bytes
   111 00000137 81C30F000000        <1>     add ebx, 0Fh    ;Round up 
   112 0000013D C1EB04              <1>     shr ebx, 4      ;And convert to paragraphs
   113 00000140 B800480000          <1>     mov eax, 4800h
   114 00000145 CD21                <1>     int 21h
   115 00000147 0F8257010000        <1>     jc badMemError
   116 0000014D 488905(00000000)    <1>     mov qword [pMftArena], rax
   117                              <1> ;Now initialise this arena. Do this by:
   118                              <1> ; 1) Zeroing the whole block
   119                              <1> ; 2) Placing an End MFT entry at the end
   120                              <1> ; 3) Making a single MFT entry that is free and the size of the arena
   121 00000154 4889C7              <1>     mov rdi, rax
   122 00000157 31C0                <1>     xor eax, eax
   123 00000159 8B0D(08000000)      <1>     mov ecx, dword [dMftArenaSz]
   124 0000015F 89CA                <1>     mov edx, ecx    ;Save number of free bytes in the arena
   125 00000161 4889FE              <1>     mov rsi, rdi    ;Save the ptr to the head of the arena
   126 00000164 F3AA                <1>     rep stosb   ;Clear the whole arena
   127                              <1> ;rdi now points one byte past the end
   128 00000166 48FFCF              <1>     dec rdi     ;Now point rdi to the last byte in the arena
   129 00000169 C607FF              <1>     mov byte [rdi + mft.bSig], mftEnd   ;Mark as end of arena
   130 0000016C FFCA                <1>     dec edx     ;One less free byte in the arena
   131                              <1> ;Allocate the first free mft (which takes up the whole arena) at the head 
   132 0000016E C60600              <1>     mov byte [rsi + mft.bSig], mftFree
   133 00000171 895601              <1>     mov dword [rsi + mft.dLen], edx
   134                              <1> ;Get a File Lock arena
   135 00000174 0FB70D(1C000000)    <1>     movzx ecx, word [wNumLocks]
   136 0000017B B829000000          <1>     mov eax, fileLock_size
   137 00000180 F7E1                <1>     mul ecx     ;Multiply eax with ebx. Fits in eax. Sets edx = 0
   138 00000182 89C1                <1>     mov ecx, eax    ;Get number of bytes in ecx
   139 00000184 89CB                <1>     mov ebx, ecx
   140 00000186 81C30F000000        <1>     add ebx, 0Fh    ;Round up
   141 0000018C C1EB04              <1>     shr ebx, 4      ;Get number of paras
   142 0000018F B800480000          <1>     mov eax, 4800h
   143 00000194 CD21                <1>     int 21h
   144 00000196 0F8208010000        <1>     jc badMemError
   145 0000019C 488905(0C000000)    <1>     mov qword [pLockArena], rax 
   146 000001A3 4889C6              <1>     mov rsi, rax    ;Point rsi to the head of the arena
   147 000001A6 4889F7              <1>     mov rdi, rsi    ;Point rdi there too
   148 000001A9 31C0                <1>     xor eax, eax    
   149 000001AB F3AA                <1>     rep stosb   ;Sanitise the space we requested (ignore any overhang)
   150 000001AD 0FB70D(1C000000)    <1>     movzx ecx, word [wNumLocks] ;Get number of locks to process
   151 000001B4 488935(14000000)    <1>     mov qword [pFreeLock], rsi  ;rsi -> Head of the free locks list
   152                              <1> .freeLp:
   153 000001BB 4889F7              <1>     mov rdi, rsi    ;Point rdi to where rsi is pointing
   154 000001BE 4881C629000000      <1>     add rsi, fileLock_size  ;Goto next lock
   155 000001C5 488937              <1>     mov qword [rdi + fileLock.pNext], rsi
   156 000001C8 FFC9                <1>     dec ecx         ;One less lock to process
   157 000001CA 75EF                <1>     jnz .freeLp     ;If not done yet, keep adding them to the free lock list
   158                              <1> ;Get the original Int 2Fh handler in rbx and replace it with our own
   159 000001CC B82F350000          <1>     mov eax, 352Fh
   160 000001D1 CD21                <1>     int 21h 
   161 000001D3 48891D(1E000000)    <1>     mov qword [pOldI2Fh], rbx    ;Save the original Int 2Fh handler
   162 000001DA 488D15(00000000)    <1>     lea rdx, i2fHandler         ;And install our own
   163 000001E1 B82F250000          <1>     mov eax, 252Fh
   164 000001E6 CD21                <1>     int 21h
   165                              <1> ;Set SHARE byte in DOS
   166 000001E8 488B1D(26000000)    <1>     mov rbx, qword [pDosseg]    ;Get dosseg ptr
   167 000001EF C683FC030000FF      <1>     mov byte [rbx + shareFlag], -1
   168                              <1> ;Halt interrupts now as we are about to move the share pointers in
   169 000001F6 FA                  <1>     cli
   170 000001F7 488D3519010000      <1>     lea rsi, shareTable
   171 000001FE 488DBBBF000000      <1>     lea rdi, qword [rbx + shareHooks]
   172 00000205 B90F000000          <1>     mov ecx, shareTableL    ;Get number of entries 
   173                              <1> ;copyLp:
   174                              <1> ;    movsq
   175                              <1> ;    lodsq
   176                              <1> ;    add rax, r8             ;Add the program segment base address to relative addr
   177                              <1> ;    stosq
   178                              <1> ;    dec ecx
   179                              <1> ;    jnz copyLp
   180 0000020A F348A5              <1>     rep movsq   ;PE loader does the pointer fixups
   181 0000020D FB                  <1>     sti
   182                              <1> ;Close all handles. We get the number of elements in the jft and 
   183                              <1> ;close them all. This is done like this to account for the fact that the
   184                              <1> ;parent let us inherit more than just the standard handles.
   185 0000020E 410FB6504E          <1>     movzx edx, byte [r8 + psp.jftSize]  ;Get the JFT size
   186 00000213 31DB                <1>     xor ebx, ebx
   187                              <1> closeLp:
   188 00000215 B8003E0000          <1>     mov eax, 3E00h
   189 0000021A CD21                <1>     int 21h
   190 0000021C FFC3                <1>     inc ebx
   191 0000021E 39D3                <1>     cmp ebx, edx
   192 00000220 75F3                <1>     jne closeLp
   193 00000222 BA[10000000]        <1>     mov edx, resLenParas + ((psp_size + 0Fh)>> 4)     
   194 00000227 B800310000          <1>     mov eax, 3100h  ;Terminate and stay resident
   195 0000022C CD21                <1>     int 21h
   196                              <1> ;A TSR call never returns so we end here.
   197                              <1> 
   198                              <1> ;Init Common Routines. Not to be used in the main files
   199                              <1> 
   200                              <1> getASCIINumber:
   201                              <1> ;Accumulates the value in ebx and returns it.
   202                              <1> ;First char read must be a digit, else, we treat a non-digit
   203                              <1> ; as a terminator of the number. 
   204                              <1> ;If the value is greater than 32 bits, treat as invalid input
   205 0000022E 31DB                <1>     xor ebx, ebx
   206 00000230 E84A000000          <1>     call getNextChar    ;First char after : must be a digit
   207 00000235 E851000000          <1>     call isAlDigit
   208 0000023A 0F82B6FEFFFF        <1>     jc cmdlineLp.badParamExit
   209                              <1> .lp:
   210 00000240 250F000000          <1>     and eax, 0Fh    ;Save lower nybble only and zero the rest of the register
   211 00000245 89DD                <1>     mov ebp, ebx    ;Dont use lea because we cant check for carry
   212 00000247 C1E302              <1>     shl ebx, 2      ;4*ebx
   213 0000024A 0F82A6FEFFFF        <1>     jc cmdlineLp.badParamExit
   214 00000250 01EB                <1>     add ebx, ebp    ;5*ebx
   215 00000252 0F829EFEFFFF        <1>     jc cmdlineLp.badParamExit
   216 00000258 D1E3                <1>     shl ebx, 1      ;10*ebx
   217 0000025A 0F8296FEFFFF        <1>     jc cmdlineLp.badParamExit
   218 00000260 01C3                <1>     add ebx, eax    ;Add new digit value
   219 00000262 0F828EFEFFFF        <1>     jc cmdlineLp.badParamExit
   220 00000268 85C9                <1>     test ecx, ecx   ;Stop if we run out of chars to process
   221                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000026A 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000026C C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   222 0000026D E815000000          <1>     call getNextChar.noCheck    ;Else get the next char
   223 00000272 E814000000          <1>     call isAlDigit              ;If it is a digit, keep processing
   224 00000277 73C7                <1>     jnc .lp
   225                              <1> ;Else, we reset to the first non-digit char and return.
   226 00000279 48FFCE              <1>     dec rsi
   227 0000027C FFC1                <1>     inc ecx
   228                              <1>     return
    13                              <2> %%_ret:
    14 0000027E C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   229                              <1> 
   230                              <1> getNextChar:
   231                              <1> ;Gets the next char in al and decrements count. If count on entry, fail.
   232                              <1> ;Used to wrap processing of chars after a switch char
   233 0000027F 85C9                <1>     test ecx, ecx
   234 00000281 0F846FFEFFFF        <1>     jz cmdlineLp.badParamExit
   235                              <1> .noCheck:
   236 00000287 AC                  <1>     lodsb
   237 00000288 FFC9                <1>     dec ecx
   238                              <1>     return
    13                              <2> %%_ret:
    14 0000028A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   239                              <1> 
   240                              <1> 
   241                              <1> isAlDigit:
   242 0000028B 3C30                <1>     cmp al, "0"
   243 0000028D 7206                <1>     jb .notDigit
   244 0000028F 3C39                <1>     cmp al, "9"
   245 00000291 7702                <1>     ja .notDigit
   246 00000293 F8                  <1>     clc
   247                              <1>     return
    13                              <2> %%_ret:
    14 00000294 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   248                              <1> .notDigit:
   249 00000295 F9                  <1>     stc 
   250                              <1>     return
    13                              <2> %%_ret:
    14 00000296 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   251                              <1> 
   252                              <1> isALsep:
   253 00000297 3C20                <1>     cmp al, SPC
   254                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000299 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000029B C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   255 0000029C 3C09                <1>     cmp al, TAB
   256                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000029E 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000002A0 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   257 000002A1 3C0A                <1>     cmp al, LF
   258                              <1>     return
    13                              <2> %%_ret:
    14 000002A3 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   259                              <1> 
   260                              <1> badMemError:
   261 000002A4 488D153E000000      <1>     lea rdx, sBadMem
   262 000002AB B0FF                <1>     mov al, -1
   263                              <1> badPrintAndExit:
   264                              <1> ;Input: al = Error code to report
   265                              <1> ;       rdx -> String to print
   266 000002AD 50                  <1>     push rax
   267 000002AE B800090000          <1>     mov eax, 0900h
   268 000002B3 CD21                <1>     int 21h
   269 000002B5 58                  <1>     pop rax
   270                              <1> badExit:
   271 000002B6 B44C                <1>     mov ah, 4Ch  ;Exit with error code in al
   272 000002B8 CD21                <1>     int 21h
   273                              <1> 
   274                              <1> ;All the init vars
   275 000002BA 2F                  <1> bSwitchChar db "/"
   276                              <1> ;Here we place all the init strings
   277 000002BB 496E636F7272656374- <1> sBadVer     db "Incorrect DOS version",CR,LF,"$"
   277 000002C4 20444F532076657273- <1>
   277 000002CD 696F6E0D0A24        <1>
   278 000002D3 496E636F7272656374- <1> sBadParam   db "Incorrect parameter",CR,LF,"$"
   278 000002DC 20706172616D657465- <1>
   278 000002E5 720D0A24            <1>
   279 000002E9 4E6F7420656E6F7567- <1> sBadMem     db "Not enough memory",CR,LF,"$"
   279 000002F2 68206D656D6F72790D- <1>
   279 000002FB 0A24                <1>
   280 000002FD 534841524520616C72- <1> sInstalled  db "SHARE already installed",CR,LF,"$"
   280 00000306 6561647920696E7374- <1>
   280 0000030F 616C6C65640D0A24    <1>
   281                              <1> ;Function table, to be ejected
   282                              <1> shareTable:
   283 00000317 0000000000000000    <1>     dq 0
   284 0000031F [1300000000000000]  <1>     dq open           
   285 00000327 [4300000000000000]  <1>     dq close          
   286 0000032F [7300000000000000]  <1>     dq closeAllByMachine      
   287 00000337 [7500000000000000]  <1>     dq closeAllByProcess      
   288 0000033F [7700000000000000]  <1>     dq closeAllByName    
   289 00000347 [7900000000000000]  <1>     dq lockFile       
   290 0000034F [7B00000000000000]  <1>     dq unlockFile     
   291 00000357 [7D00000000000000]  <1>     dq checkRegionLock  
   292 0000035F [7F00000000000000]  <1>     dq getMFTInfo   
   293 00000367 [8100000000000000]  <1>     dq updateFCB 
   294 0000036F [8300000000000000]  <1>     dq getFirstClusterFCB   
   295 00000377 [8500000000000000]  <1>     dq closeNetworkFiles   
   296 0000037F [8700000000000000]  <1>     dq closeRenDel
   297 00000387 [8900000000000000]  <1>     dq dirUpdate 
   298                              <1> shareTableL equ ($ - shareTable)/8
    56                                  ;=========================END OF SHARE MODULE==========================
    56          ------------------       info: assembly required 1+2+2 passes

