     1                                  ;Share! Handle file sharing in this module here.
     2                                  ;This is a kernel module with the key difference that it is not linked 
     3                                  ; into the main kernel image. Instead, we produce a standalone .EXE file
     4                                  ; which hooks itself into DOS if the user runs the program.
     5                                  ;We run as a TSR with two switches:
     6                                  ;/F:xxxxxxx specifies the amount of bytes to allocate for MFT space in bytes.
     7                                  ; Max value: 1048576 bytes (1Mb).
     8                                  ; Default: 2048 bytes (2Kb).
     9                                  ;/L:xxxx specifies the number of concurrent file locks allowed.
    10                                  ; Max value: 9999
    11                                  ; Default: 20
    12                                  
    13                                  [DEFAULT REL]
    14                                  BITS 64
    15                                  
    16                                  [LIST -]
    25                                  ;========================START OF SHARE MODULE=========================
    26                                  EXTERN resLenParas
    27                                  GLOBAL ep
    28                                  ;---------------------------
    29                                  ;   DOS data segment here
    30                                  ;---------------------------
    31                                  ;Included as an absolute 
    32                                  ;segment at address 0 to
    33                                  ;allow using the dos data 
    34                                  ;segment as a struc
    35                                  ;---------------------------
    36                                  absolute 0x0
    37                                  %include "./src/dos/Kernel/BSS/dosSeg.asm"
     1                              <1> ;This file contains the main DOS data segment
     2 00000000 <res 10h>           <1>     anchorMcb   db mcb_size dup (?) ;This is space for the anchor MCB
     3                              <1> dosDataArea:    ;The returned pointer points to the variables w/o anchor MCB
     4 00000010 ??                  <1>     bootDrive   db ?    ;The logical drive we booted from
     5 00000011 ????????            <1>     biosVers    dd ?    ;Indicates BIOS type. Each OEM picks a number
     6 00000015 ????????????????    <1>     biosPtr     dq ?    ;For saving a data ptr to be used by BIOS/drivers
     7                              <1> ;Above is the system stats
     8                              <1> ;Below is the DOS vars, DO NOT TOUCH FROM validNetNam TO NUMJOINDRV
     9 0000001D ????????????????    <1>     dosPSP      dq ?    ;PSP to initial DOS PSP (aliased by 8, used by share)
    10                              <1> ;Both below variables can be edited with Int 21h AX=440Bh
    11 00000025 ????                <1>     validNetNam dw ?    ;Flag if machinename valid, deflt no=0
    12 00000027 ????                <1>     shareCount  dw ?    ;Share Retry Count, number of repeats before fail.
    13 00000029 ????                <1>     shareDelay  dw ?    ;Share Delay, in multiples of ms. (TEMP, just loop)
    14 0000002B ????????????????    <1>                 dq ?    ;Unused ptr for future, current disk buffer
    15 00000033 ????????????????    <1>     vConHdlOff  dq ?    ;Ptr into buff to the next char to process in hdl req
    16                              <1>     ;   A value of 0 means no chars buffered.
    17 0000003B ????????????????    <1>     mcbChainPtr dq ?    ;Pointer to the MCB chain x
    18                              <1> sysVarsPtr:
    19 00000043 ????????????????    <1>     dpbHeadPtr  dq ?    ;Pointer to the first DPB in the DPB chain x
    20 0000004B ????????????????    <1>     sftHeadPtr  dq ?    ;Pointer to the first SFT header in SFT chain
    21 00000053 ????????????????    <1>     clockPtr    dq ?    ;Pointer to the current active CLOCK$ device header x
    22                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
    23 0000005B ????????????????    <1>     vConPtr     dq ?    ;Ptr to the devdrv of the char dev controlling vCon x
    24                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
    25 00000063 ????                <1>     maxBytesSec dw ?    ;Maximum number of bytes per sector (size of buffers)x
    26 00000065 ????????????????    <1>     bufHeadPtr  dq ?    ;Pointer to the head of the disk buffer chain x
    27 0000006D ????????????????    <1>     cdsHeadPtr  dq ?    ;Pointer to the head of the CDS array x
    28 00000075 ????????????????    <1>     fcbsHeadPtr dq ?    ;Pointer to the head of the System FCB chain
    29 0000007D ????                <1>     numSafeSFCB dw ?    ;Number of protected FCBs (y in FCBS=x,y)
    30 0000007F ??                  <1>     numPhysVol  db ?    ;Number of physical volumes in the system x
    31 00000080 ??                  <1>     lastdrvNum  db ?    ;Value of LASTDRIVE (default = 5) [Size of CDS array]x
    32 00000081 ??                  <1>     numBuffers  db ?    ;Buffers=30 default
    33 00000082 <res 22h>           <1>     nulDevHdr   db drvHdr_size dup (?)
    34 000000A4 ??                  <1>     numJoinDrv  db ?    ;Number of Joined Drives
    35                              <1> ;Additional internal variables
    36 000000A5 ??                  <1>     numFiles    db ?    ;FILES=5 default, max 255
    37                              <1>     ;DOSMGR hook functions and variable here
    38                              <1>     ;All DOSMGR hooks are 8 byte pointers and have been introduced to allow
    39                              <1>     ; an external application to install itself as a multitasker into the
    40                              <1>     ; DOS kernel. DOS's behaviour changes accordingly when a multitasker 
    41                              <1>     ; is installed. It is recommended that a multitasker NOT be installed
    42                              <1>     ; when a file sharing broker is not installed but that is up to the 
    43                              <1>     ; implementer to decide.  
    44                              <1>     ;Three function hooks are provided. NOTE, all functions must preserve
    45                              <1>     ; ALL registers used.
    46                              <1>     ;
    47                              <1>     ;launchTask:
    48                              <1>     ;This allows for a multitasker to install its handling routine for 
    49                              <1>     ; launching tasks. Note this is called after all setup
    50                              <1>     ; for the EXE has been done except for setting the PSP.
    51                              <1>     ; If the mode bSuFunc = 4, then we have we have the following:
    52                              <1>     ;       ecx = mode of termination
    53                              <1>     ;           = 00 -> Upon terminating, leave task in Zombie mode
    54                              <1>     ;                   awaiting for a task to read it's return code
    55                              <1>     ;           = 01 -> Upon terminating, discard all resources allocated
    56                              <1>     ;                   to the task.
    57                              <1>     ;           > 01 -> Error code, unknown function (01h).
    58                              <1>     ;This function must return to the caller via DOS with CF=CY if an error 
    59                              <1>     ;   and eax = Error code or CF=NC if all ok. DOS will then return to
    60                              <1>     ;   the parent task, with the background task hopefully scheduled to run
    61                              <1>     ;   in the DOSMGR.
    62                              <1>     ;Either before or on initial run, DOSMGR must set currentDTA in a bgTasks'
    63                              <1>     ; SDA to psp+80h. This can be done in launchBgTask.
    64                              <1>     ;
    65                              <1>     ;terminateTask:
    66                              <1>     ;This allows for a multitasker to install its handling routine for
    67                              <1>     ; cleaning up resources allocated to a task. 
    68                              <1>     ;
    69                              <1>     ;Specific function definitions:
    70                              <1>     ;
    71                              <1>     ;If we enter
    72                              <1>     ;   Input:  bx = FCB drive statuses
    73                              <1>     ;           ecx = Termination mode setting
    74                              <1>     ;           rsi = RSP value to start with
    75                              <1>     ;           rbp = execFrame. Use this to get parentPSP data et al.
    76                              <1>     ;           qword [rbp - execFrame.pProgEP] = RIP value to launch from
    77                              <1>     ;   Output: CF=NC -> Proceed with launch of bg task
    78                              <1>     ;           CF=CY -> Error exit, errorcode in eax
    79                              <1> dosMgrHooks:
    80 000000A6 ??                  <1>     dosMgrPresent   db ?    ;Clear if no mgr, else set to -1
    81 000000A7 ????????????????    <1>     launchTask      dq ?    ;Registers a new task, with specifics based on bSubfunc
    82 000000AF ????????????????    <1>     terminateTask   dq ?    ;Called to tell the MGR that this task is ending
    83                              <1> 
    84                              <1>     ;DLL Manager hook functions here
    85                              <1>     ;All DLLMGR hooks are 8 byte pointers and are new to the DOS kernel.
    86                              <1>     ;They allow for the installation of a DLL manager program, which hooks
    87                              <1>     ; these pointers, to point to their own subroutines in the DLLMGR prog.
    88                              <1>     ;These hooks are called from within EXEC, only for PE type executables
    89                              <1>     ; and from within EXIT. 
    90                              <1>     ;
    91                              <1>     ;In EXEC mode, modes 0 and 1 create a PSP for the task and thus the 
    92                              <1>     ; task is self standing and has a PSP as a Unique ID. 
    93                              <1>     ;If mode 3, this is an overlay EXE. This means it is not it's own task and 
    94                              <1>     ; is an extension of the parent task. In such a case, the DLL Manager must 
    95                              <1>     ; look at where the overlay is to be loaded (execFrame.pProgBase), and if 
    96                              <1>     ; there is already an overlay there, to remove it's functions from the 
    97                              <1>     ; registery, replacing them with the new overlay's functions. All overlay
    98                              <1>     ; exports must be flagged as belonging to the parent task PSP so that
    99                              <1>     ; on EXIT, they can be removed from the registry. 
   100                              <1>     ;
   101                              <1>     ;In EXIT, the PSP of the ending task must be taken
   102                              <1>     ; into consideration, as if the PSP isn't registered then the task ending
   103                              <1>     ; is a .COM file or an .EXE with no exports.
   104                              <1>     ;Furthermore, if register fails (due to memory or namespace constraints),
   105                              <1>     ; it must return CF=CY.
   106                              <1> dllHooks:
   107 000000B7 ????????????????    <1>     registerDLL     dq ?  ;Entered with rbp = execFrame
   108 000000BF ????????????????    <1>     unloadDLLHook   dq ?  ;
   109                              <1> 
   110                              <1>     ;Share hook functions here
   111                              <1>     ;All share hooks now take 8 bytes rather than 4 bytes as before
   112                              <1>     ;Thus ALL offsets from SFT header increase by 4 bytes and each entry
   113                              <1>     ; is a QWORD entry. Please adjust SHARE.EXE access as necessary.
   114                              <1> shareHooks:
   115 000000C7 ????????????????    <1>     markerShare         dq ?  ;Marker Share hook
   116 000000CF ????????????????    <1>     openShare           dq ?  ;Share called on open. 
   117 000000D7 ????????????????    <1>     closeShare          dq ?  ;Share called on close.
   118 000000DF ????????????????    <1>     closeCompShare      dq ?  ;Share to close all files for a machine.
   119 000000E7 ????????????????    <1>     closeTaskShare      dq ?  ;Share to close all files for a task.
   120 000000EF ????????????????    <1>     closeNameShare      dq ?  ;Share to close file by name.
   121 000000F7 ????????????????    <1>     lockFileShare       dq ?  ;Share to lock file region.
   122 000000FF ????????????????    <1>     unlockFileShare     dq ?  ;Share to unlock file region.
   123 00000107 ????????????????    <1>     checkFileLockShare  dq ?  ;Share to check file region locked.
   124 0000010F ????????????????    <1>     openFileListShare   dq ?  ;Share to get open file list entry.
   125 00000117 ????????????????    <1>     updateFCBfromSFTShr dq ?  ;Share to update FCB from the SFT.    UNUSED
   126 0000011F ????????????????    <1>     fstClstOfFCBShare   dq ?  ;Share to get first cluster of FCB.   UNUSED
   127 00000127 ????????????????    <1>     closeDupNetShare    dq ?  ;Share to close file if dup for proc.
   128 0000012F ????????????????    <1>     renDelCloseShare    dq ?  ;Share to handle rename/delete correctly.
   129 00000137 ????????????????    <1>     updateDirShare      dq ?  ;Share to update dir info in SFT. 
   130                              <1> 
   131                              <1> ;Create SFT header and corresponding array of five default sft entries
   132 0000013F <res Ah>            <1>     firstSftHeader  db sfth_size dup (?)
   133 00000149 <res 57h>           <1>     firstSft        db sft_size dup (?)
   134 000001A0 <res 57h>           <1>     secondSft       db sft_size dup (?)
   135 000001F7 <res 57h>           <1>     thirdSft        db sft_size dup (?)
   136 0000024E <res 57h>           <1>     fourthSft       db sft_size dup (?)
   137 000002A5 <res 57h>           <1>     fifthSft        db sft_size dup (?)
   138                              <1> 
   139                              <1> ;Virtual CONsole Buffers
   140 000002FC ??                  <1>     vConCursPos db ?     ;Keeps track for tabs stops (and var with 7)
   141                              <1>     ;Only incremented when CON device runs vCon
   142                              <1> vConBuf:    ;Proper buffer symbol
   143 000002FD ??                  <1>     vConCurCnt  db ?     ;Current count of chars in vConBuffer
   144 000002FE <res 80h>           <1>     vConBuffer  db 128 dup (?)   ;General Buffer for vCon 256 bytes. 
   145                              <1>     ;Only 128 bytes at a time if doing CON IO via handle
   146 0000037E <res 80h>           <1>     vConInBuf   db 128 dup (?)   ;vConsole buffer for reads ONLY
   147 000003FE ??                  <1>                 db ?     ;Padding Buffer!
   148                              <1> 
   149 000003FF ??                  <1>     printEcho   db ?  ;If 0, no echo. Non-zero => Echo to PRN
   150 00000400 ??                  <1>     verifyFlag  db ?  ;If set, writes are replaces with write/verify x
   151 00000401 ??                  <1>     switchChar  db ?  ;Editable by 21h/37h. Set to / by default
   152 00000402 ??                  <1>     vConErr     db ?  ;Inc on each char output call
   153                              <1>     ;Is and-ed with 03h, checks for ^C on every fourth char output
   154                              <1> 
   155 00000403 ??                  <1>     allocStrat  db ?  ;Allocation strategy. First, Best or Last fit
   156                              <1> ;Server stuff. Default to all zeros (blank)
   157 00000404 ??                  <1>     shareFlag   db ?  ;SHARE loaded flag. -1 means loaded, 0 means not.
   158 00000405 ??                  <1>     serverCnt   db ?  ;Increments on each 21h/5E01h call
   159 00000406 <res 10h>           <1>     machineName db 16 dup (?) ;Machine name (Set via 21h/5E01h) (set to SPC)    
   160                              <1> ;Swappable Data Area
   161 00000416 <res 20h>           <1>     critPtchTbl dq 4 dup (?)  ;Offsets from DosDataArea addr to the 4 funcs
   162 00000436 ??                  <1>                 db ?  ;Alignment byte
   163                              <1> sda:    ;Start of Swappable Data Area, this bit can remain static
   164 00000437 ??                  <1>     critErrFlag db ?  ;Critical error flag, set on entry to Int 24h x
   165 00000438 ??                  <1>     inDOS       db ?  ;Inc on each DOS call, dec when leaving x
   166 00000439 ??                  <1>     errorDrv    db ?  ;Drive on which error occured or FFh x
   167 0000043A ??                  <1>     errorLocus  db ?  ;Where the error took place  
   168 0000043B ????                <1>     errorExCde  dw ?  ;Extended Error Code
   169 0000043D ??                  <1>     errorAction db ?  ;Suggested action for error  
   170 0000043E ??                  <1>     errorClass  db ?  ;Error Class
   171 0000043F ????????????????    <1>     errorVolLbl dq ?    ;Sets a ptr to the volume label of the error disk
   172 00000447 ????????????????    <1>     currentDTA  dq ?  ;Address of the current DTA x
   173 0000044F ????????????????    <1>     currentPSP  dq ?  ;Address of current PSP x
   174                              <1> 
   175 00000457 ????????????????    <1>     xInt23hRSP  dq ?  ;Saves RSP across an Int 23h call
   176 0000045F ????                <1>     errorLevel  dw ?  ;Last return code returned by Int 21h/4Ch x
   177                              <1>     ;Upper byte: 0=Normal, 1=Abort Occured, 2=CtrlC, 3=TSR 21h/31h
   178                              <1>     ;Lower byte: User Specified
   179 00000461 ??                  <1>     currentDrv  db ?  ;Default drive x
   180 00000462 ??                  <1>     breakFlag   db ?  ;If set, check for CTRL+C on all DOS calls x
   181                              <1> ;SDA, needs to be replaced between processes
   182                              <1> sdaDOSSwap:
   183 00000463 ????????????????    <1>     oldRAX      dq ?  ;Store rax on entering Int21h or returning Int 23h
   184                              <1> ;Next two vars contain info for networking and sharing software to identify
   185                              <1> ; the requester of the call.
   186 0000046B ????????????????    <1>     qPID        dq ?  ;PSP of process making server request. 0 = current psp
   187 00000473 ????????            <1>     dMID        dd ?  ;Requesters' (VM) Network ID. 0 = local machine
   188 00000477 ????????????????    <1>     firstMCB    dq ?  ;First fit MCB for request
   189 0000047F ????????????????    <1>     bestMCB     dq ?  ;Best fit MCB for request
   190 00000487 ????????????????    <1>     lastMCB     dq ?  ;Last fit MCB for request
   191 0000048F ????                <1>     dirEntryNum dw ?  ;Offset into directory of entry we are looking for
   192 00000491 ??                  <1>     volIdFlag   db ?  ;If set, we are searching for a volume ID
   193 00000492 ????????????????    <1>     xInt24hRSP  dq ?  ;RSP across an Int 24h call
   194 0000049A ??                  <1>     Int24bitfld db ?  ;Copies the bit field given to the Int 24h handler
   195 0000049B ??                  <1>     fileDirFlag db ?  ;File/Directory flag. 0 = Dir, Â¬0 = File
   196 0000049C ??                  <1>     Int24Fail   db ?  ;Set if Int 24h returned fail
   197                              <1> 
   198 0000049D ????????????????    <1>     oldoldRSP   dq ?  ;RSP at prev Int 21h entry if called from within Int 21h
   199 000004A5 ????????????????    <1>     dosReturn   dq ?  ;Used as a var to return when juggling stack
   200 000004AD ????????????????    <1>     oldRSP      dq ?  ;RSP when entering Int 21h
   201 000004B5 ????????????????    <1>     oldRBX      dq ?  ;Temp var to save value of rbx during an Int 21 call
   202 000004BD ??                  <1>     dirFlag     db ?  ;Directory Flag. 0 => Search for Dir, 1 => for File
   203                              <1> ;The below flag tells DOS to print ^C in the termination function
   204 000004BE ??                  <1>     ctrlCExit   db ?  ;-1 => CTRL+BREAK termination, 0 otherwise
   205 000004BF ??                  <1>     fcbSpaceOk  db ?  ;If set, we allow embedded spaces in the filenames
   206                              <1> ;Time stuff
   207                              <1> ;Read the below two as a word
   208 000004C0 ??                  <1>     dayOfMonth  db ?  ;01h - 1Fh (1 - 31)
   209 000004C1 ??                  <1>     monthOfYear db ?  ;01h - 0Ch (1 - 12)
   210 000004C2 ??                  <1>     years       db ?  ;00h - 7Fh (00 = 1980 - 127 = 2107)
   211 000004C3 ????                <1>     daysOffset  dw ?  ;Days since 1-1-1980
   212 000004C5 ??                  <1>     dayOfWeek   db ?  ;0 = Sunday <-> 6 = Saturday
   213                              <1> 
   214 000004C6 ??                  <1>     vConDrvSwp  db ?  ;Set if vCon controlled by a different driver to vConPtr
   215 000004C7 ??                  <1>     int28Flag   db ?  ;If set, Int 28h should be called, if clear no
   216 000004C8 ??                  <1>     procExiting db ?  ;Set to -1 if in process termination
   217                              <1> ;A request routed through the FCB or handle uses primReqPkt for its main IO.
   218                              <1> ;A secondary header is present to allow simultaneous echoing to console 
   219                              <1> ; without forcing to re-build the whole primary request block.
   220                              <1> ;Thus all disk io uses the primary and CharIO goes through the primary
   221                              <1> ; with secondary char output going through the secondary header
   222                              <1> ;(i.e the char input functions use the primary for main input and secondary 
   223                              <1> ; for output)
   224                              <1> ;ioReqPkt is the largest possible packet
   225 000004C9 <res 2Ah>           <1>     secdReqPkt  db ioReqPkt_size dup (?) ;Secondary, Char IO Reqhdr
   226 000004F3 <res 2Ah>           <1>     primReqPkt  db ioReqPkt_size dup (?) ;Main Drv Reqhdr 
   227                              <1> altRet: ;Accessed as a qword
   228 0000051D <res 2Ah>           <1>     critReqPkt  db ioReqPkt_size dup (?)  ;Used for ^C detection!
   229 00000547 ??                  <1>     pspCopyFlg  db ?  ;Set to -1 for child process PSP, 0 for simple PSP copy
   230                              <1> ;Swappable Buffers
   231 00000548 ????????????        <1>     CLOCKrecrd  db 6 dup (?)  ;Clock driver record
   232                              <1>     ;We add an additional byte to save ah too
   233 0000054E ????                <1>     singleIObyt dw ?  ;For single IO byte buffers
   234                              <1> extErrByteBuf:  ;Used by DOS execpt hdlr to build strings. Immediate abort!
   235                              <1> exeHdrSpace:    ;This needs 112 bytes in EXEC only, buffer is free for use!
   236 00000550 <res 80h>           <1>     buffer1     db 2*MAX_FSPEC dup (?)  ;Space for max expanded MAX_FSPEC
   237                              <1> sectHdr:        ;This needs 20 bytes in EXEC only
   238 000005D0 <res 80h>           <1>     buffer2     db 2*MAX_FSPEC dup (?) ;Space for a second path
   239 00000650 ????????????????    <1>     fname1Ptr   dq ?  ;Ptr to first filename argument
   240 00000658 ????????????????    <1>     fname2Ptr   dq ?  ;Ptr to second filename argument
   241 00000660 ??                  <1>     skipDisk    db ?  ;Set => Read Disk, Clear => Skip checking on disk
   242                              <1> ;Misc bookkeeping flags and vars
   243 00000661 <res 2Bh>           <1>     dosffblock  db ffBlock_size dup (?)  ;FF block (fullsize unlike DOS)
   244 0000068C <res 20h>           <1>     curDirCopy  db fatDirEntry_size dup (?)  ;Dir copy
   245 000006AC <res 5Fh>           <1>     tmpCDS      db cds_size dup (?)  ;For server calls that need a tmp CDS
   246                              <1> ;These two are used to expand filenames into FCB format. The extra char 
   247                              <1> ; is used to store the terminator of the portion (either a pathsep or null)
   248 0000070B <res Ch>            <1>     fcbName     db MAX_NAME_FCBZ dup (?)
   249 00000717 <res Ch>            <1>     wcdFcbName  db MAX_NAME_FCBZ dup (?)  ;Expands wildcards for rename
   250 00000723 ????????????????    <1>     fileDirSect dq ?  ;File/Directory starting sector, for each level
   251 0000072B ??                  <1>     volIncmpFCB db ?  ;Set to -1 if the volume uses FAT32 (or all incompat FS)
   252 0000072C ??                  <1>     extFCBAttr  db ?  ;Extended FCB file attribute
   253 0000072D ??                  <1>     extFCBFlag  db ?  ;Set to -1 if Extended FCB
   254 0000072E ??                  <1>     searchAttr  db ?  ;Directory Search attributes
   255                              <1> ;    fileOpenMd  db ?  ;Open mode (compat, r/w/rw?) 
   256 0000072F ??                  <1>     renFlags    db ?  ;01h = Rename in same dir, 02h = Wildcard in destination
   257 00000730 ??                  <1>     badNameRen  db ?  ;Device name or File not found for rename
   258 00000731 ??                  <1>     rwFlag      db ?  ;00h=Read, 1=Write, read/write/share error reporting
   259 00000732 ??                  <1>     spliceFlag  db ?  ;00 = Relative path, !0 = Full path
   260 00000733 ??                  <1>     dosInvoke   db ?  ;0 = Invoked via Int 21h, -1 = Invoked via 21h/5D01h
   261                              <1> 
   262 00000734 ??                  <1>     vConInsert  db ?  ;Insert mode on 21/0ah (0 = not insert, !0 = insert)
   263 00000735 ??                  <1>     fileExist   db ?  ;-1 if file in pathspec exists (create/open)
   264 00000736 ??                  <1>     parDirExist db ?  ;-1 if parent directory for file exists (create/open)
   265 00000737 ??                  <1>     exitType    db ?  ;Forms the upper byte of the errorlvl
   266 00000738 ??                  <1>     openCreate  db ?  ;If open, set to 0, if Create set to -1
   267                              <1> ;Set to E5h for renaming and deletion. Can be set to 0 if *.* chosen
   268                              <1> ; to speed up the deletion but we don't use this (yet).
   269 00000739 ??                  <1>     delChar     db ?
   270 0000073A ??                  <1>     workingDrv  db ?  ;Working drive number, 0 based, from DPB
   271                              <1> qPtr:       ;Stores working DPB and/or device driver (if r/w a char device)
   272                              <1> workingDD:  ;Create a symbol for the working device driver too
   273 0000073B ????????????????    <1>     workingDPB  dq ?  ;Ptr to the DPB of the drive being accessed
   274 00000743 ????????????????    <1>     workingCDS  dq ?  ;Ptr to the CDS of the drive being accessed
   275 0000074B ????????????????    <1>     workingFCB  dq ?  ;Ptr to the caller FCB for FCB function
   276                              <1> ;Below is the symbol for saving the oldSFTptr during a char func
   277                              <1> vConAltSFTPtr: ;Alternate symbol for working SFT (used when CON is swapped)
   278 00000753 ????????????????    <1>     workingSFT  dq ?  ;Temporary SFT (may not be not current) ptr being used
   279 0000075B ????????????????    <1>     curHdlPtr   dq ?  ;Ptr to JFT handle entry in current PSP
   280 00000763 ????????????????    <1>     currentSFT  dq ?  ;Ptr to the SFT of the file being accessed
   281 0000076B ????                <1>     currentNdx  dw ?  ;Used to access the current SFTNdx being opened/created
   282 0000076D ????                <1>     currentHdl  dw ?  ;The current file handle is saved here
   283 0000076F ????????????????    <1>     currBuff    dq ?  ;Ptr to the Current Buffer (hdr) being accessed
   284                              <1> ;Temp vars, used when walking FAT or changing sectors, or reporting sector num
   285                              <1> ; and 32 byte offset into the sector for directory
   286 00000777 ????????????????    <1>     tempSect    dq ?  ;A scratch sector number
   287                              <1> pathLen:    ;Used to store the length of a path string for removal strcmp
   288 0000077F ????                <1>     entry       dw ?  ;32 byte offset into a sector or #fats sectors/fat
   289                              <1> ;***************************************************|
   290                              <1> ; Needs to be set up before any file access         |
   291                              <1> ; These vars keep track of file access properties   |
   292                              <1> ;   and must be used only for such purposes.        |
   293                              <1> ;***************************************************|
   294 00000781 ????????            <1>     currClustF  dd ?  ;Relative cluster in file being r/w to/from
   295 00000785 ????????            <1>     currClustD  dd ?  ;Current Disk Cluster being r/w to/from
   296                              <1> 
   297 00000789 ????????            <1>     currSectF   dd ?  ;Current Sector in File being r/w to/from
   298 0000078D ??                  <1>     currSectC   db ?  ;Current Sector in Cluster being r/w to/from
   299 0000078E ????????????????    <1>     currSectD   dq ?  ;Current absolute Sector number on Disk
   300                              <1> 
   301 00000796 ????                <1>     currByteS   dw ?  ;Current Byte in sector being r/w to/from
   302 00000798 ????????            <1>     currByteF   dd ?  ;Current Byte in file being r/w to/from
   303                              <1> ;***************************************************|
   304 0000079C ????????            <1>     lastClust   dd ?  ;Number of the last (rel) cluster of the file
   305 000007A0 ????????            <1>     lastClustA  dd ?  ;Number of the last (abs) cluster of file on disk
   306 000007A4 ????????            <1>     tfrLen      dd ?  ;Number of bytes to transfer
   307 000007A8 ????????            <1>     tfrCntr     dd ?  ;Number of bytes left to transfer
   308                              <1> ;Directory stuff
   309 000007AC ????????            <1>     dirClustPar dd ?  ;Absolute disk cluster of the start of the parent dir
   310 000007B0 ????????            <1>     dirClustA   dd ?  ;Absolute cluster number of current directory
   311 000007B4 ????                <1>     dirSect     dw ?  ;Sector of current directory cluster
   312 000007B6 ????????            <1>     dirEntry    dd ?  ;32 byte offset in dir for file being searched for
   313                              <1> ;Extended Open vars
   314 000007BA ????                <1>     wEOFlags    dw ?  ;Set if we are doing an extended open with various flags
   315 000007BC ????                <1>     wEOActions  dw ?  ;Extended open actions (user DX)
   316 000007BE ????                <1>     wEOOpenMode dw ?  ;Symbol to the next two bytes. (USER BX)
   317 000007C0 ????                <1>     wEOAttribs  dw ?  ;Symbol to the next two bytes (USER CX)
   318 000007C2 ????????????????    <1>     pszEOfile   dq ?  ;Ptr to null terminated string to file name (USER RSI)
   319                              <1> ;Error DPB 
   320 000007CA ????????????????    <1>     tmpDPBPtr   dq ?  ;A DPB for error/temporary situations
   321                              <1> ;No clash recycling below var as the vars in SDA are invalid if in CPU 
   322                              <1> ; exception hdlr. This var gets cleared on entry to the exception handler. 
   323                              <1> ;If it remains clear, the task will Abort. If it gets set, DOS or COMMAND.COM 
   324                              <1> ; caused CPU exception or we have an NMI. Then we freeze as we cant guarantee 
   325                              <1> ; anything anymore.
   326                              <1> haltDOS:
   327 000007D2 ??                  <1>     mediaByte   db ?  ;Calls 1Bh and 1Ch return ptr to here
   328                              <1>     
   329 000007D3 <res 2Bh>           <1>     renameFFBlk db ffBlock_size dup (?)  ;Source file "find first" block
   330 000007FE <res 20h>           <1>     renameDir   db fatDirEntry_size dup (?)  ;Build new file dir entry here
   331                              <1> ;Stacks and scratch SFT
   332 0000081E ????                <1>     alignb  8
   333 00000820 <res 528h>          <1>     critStack   dq 165 dup (?)
   334 00000D48 ????????????????    <1>     critStakTop dq ?
   335                              <1> 
   336 00000D50 <res 57h>           <1>     scratchSFT  db sft_size dup (?)  ;Used in FCB calls to emulate a SFT
   337                              <1>     
   338 00000DA7 ??                  <1>     alignb  8
   339 00000DA8 <res 638h>          <1>     AuxStack    dq 199 dup (?)
   340 000013E0 ????????????????    <1>     AuxStakTop  dq ?  ;Auxilliary stack (Char IO, Int 25h/46h etc)
   341 000013E8 <res 638h>          <1>     DiskStack   dq 199 dup (?)
   342 00001A20 ????????????????    <1>     DiskStakTop dq ?
   343                              <1> 
   344 00001A28 ??                  <1>     lookahead   db ?  ;-1 => Lookahead on select Char function calls!
   345                              <1> ;Below is used in create and delete for vol lbl only. Else is -1.
   346 00001A29 ??                  <1>     rebuildDrv  db ?  ;Stores the drive letter of the dpb to reset.
   347                              <1>     sdaLen      equ     $ - sda 
   348                              <1>     sdaDOSLen   equ     $ - sdaDOSSwap
   349                              <1> 
   350                              <1> ;Additional variables NOT in the SDA
   351 00001A2A ????????????????    <1>     serverDispTblPtr    dq ?  ;DO NOT MOVE! Used to find server dispatch tbl
   352                              <1> ;A backup header to allow copying to for saving the current header when 
   353                              <1> ; quickly doing a second request
   354 00001A32 <res 2Ah>           <1>     bkupReqHdr          db ioReqPkt_size dup (?)  
   355                              <1> ;Prevent toggling print if in the middle of reading an extended ASCII char
   356                              <1> inExtASCII:
   357 00001A5C ??                  <1>     noPrintTog  db ?  ;00 = Toggle as usual, 01 = Prevent toggle
   358 00001A5D ????                <1>     keybTicks   dw ?  ;Counts the number of cycles spent in a kb loop.
   359                              <1> ;Every time this overflows, we read the clock and update the DOS internal
   360                              <1> ; copy of the date/time record
   361                              <1> ;The idt doesnt need to be in the SDA as we will halt interrupts
   362                              <1> ; until we get/set the address. Thus the IDT entry returned is the 
   363                              <1> ; correct one AT the time of calling up to "the time it takes to get
   364                              <1> ; to the read IDT routine".
   365                              <1> dosIdtPtr:          ;21h/25h will always read a new copy of IDT here
   366 00001A5F ????                <1>     .limit  dw ?    ;Overlap this with stack below as no call overlap
   367 00001A61 ????????????????    <1>     .base   dq ?
   368                              <1> ;Lseek and IOCTL return data in registers as well as on the caller's 
   369                              <1> ; stack. In Int 2Fh, this could overwrite user data if the functions
   370                              <1> ; were allowed to write to original callers register stack. 
   371                              <1> ; So we have this structure below that is used by these functions to 
   372                              <1> ; write their "return" data onto a "stack", even though when accessed 
   373                              <1> ; through the multiplexer we never will read this structure. 
   374                              <1> ; Really only 4 qwords are needed (rax-rdx) but yaknow... safety
   375                              <1> labelPkt:   ;Whilst this is here, keep the thing below kinda big :)
   376 00001A69 <res 60h>           <1>     mplxRegStack    db callerFrame_size dup (?) 
    38                                  
    39                                  ;---------------------------
    40                                  ;       Share data seg
    41                                  ;---------------------------
    42                                  segment bss$r bss private align=16
    43                                  %include "./src/share/data/shbss.asm"
     1                              <1> ;All BSS variables go here
     2                              <1> 
     3 00000000 ????????????????    <1> pMftArena   dq ?
     4 00000008 ????????            <1> dMftArenaSz dd ?    ;Size of MFT arena in bytes (max 1048576 bytes i.e. 1 Mb)
     5 0000000C ????????????????    <1> pLockArena  dq ?
     6 00000014 ????????????????    <1> pFreeLock   dq ?    ;Ptr to head of Free lock chain. 0 means no free locks left
     7 0000001C ????                <1> wNumLocks   dw ?    ;Store number of locks here (max 9999)
     8 0000001E ????????????????    <1> pOldI2Fh    dq ?    ;Ptr to old Int 2Fh for chaining
     9 00000026 ????????????????    <1> pDosseg     dq ?    ;Ptr to the DOSSEG
    10 0000002E ????????????????    <1> pPSP        dq ?    ;Ptr to share psp. Used as scratch space once resident.
    44                                  
    45                                  ;---------------------------
    46                                  ;       Share code seg
    47                                  ;---------------------------
    48                                  segment .text code private align=16 use64
    49                                  ;Place this explicit .text section to calm nasm down
    50                                  segment code$r code private align=16 use64
    51                                  %include "./src/share/text/shmain.asm"
     1                              <1> ;-------------------------------------------------------------------------
     2                              <1> ;This file contains the all the functions that have external linkage.
     3                              <1> ;
     4                              <1> ; Int 2Fh handler
     5                              <1> ; open           
     6                              <1> ; close          
     7                              <1> ; closeAllByMachine      
     8                              <1> ; closeAllByProcess      
     9                              <1> ; closeAllByName    
    10                              <1> ; lockFile       
    11                              <1> ; unlockFile     
    12                              <1> ; checkRegionLock  
    13                              <1> ; getMFTInfo   
    14                              <1> ; updateFCB 
    15                              <1> ; getFirstClusterFCB   
    16                              <1> ; closeNetworkFiles   
    17                              <1> ; closeRenDel
    18                              <1> ; dirUpdate      
    19                              <1> ;-------------------------------------------------------------------------
    20                              <1> 
    21                              <1> i2fHandler:
    22 00000000 80FC10              <1>     cmp ah, 10h ;Is this call for us?
    23 00000003 7508                <1>     jne .gotoNext
    24 00000005 84C0                <1>     test al, al ;Do we test presence of share?
    25 00000007 7502                <1>     jnz .exit   ;If not, probably badly behaved code. Let it return silently
    26 00000009 B0FF                <1>     mov al, -1  ;Else, indicate we are already installed
    27                              <1> .exit:
    28 0000000B 48CF                <1>     iretq
    29                              <1> .gotoNext:
    30 0000000D FF25(1E000000)      <1>     jmp qword [pOldI2Fh]
    31                              <1> 
    32                              <1> open:           
    33                              <1> ;Called on file create/open. Creates/Finds an MFT entry for the file
    34                              <1> ; being opened and adds the new SFT to the MFT chain.
    35                              <1> ;----------------------------------------------------------------------------
    36                              <1> ;Input: qword [fname1Ptr] -> Fully qualified pathname to open
    37                              <1> ;       qword [currentSFT] -> SFT that was just created/opened
    38                              <1> ;           This SFT needs the following fields filled in:
    39                              <1> ;               .wOpenMode
    40                              <1> ;               .bFileAttrib
    41                              <1> ;               .dMID
    42                              <1> ;               .qPID
    43                              <1> ;               .pMFT
    44                              <1> ;       qword [qPID] -> Process ID of the requesting task
    45                              <1> ;       dword [dMID] -> Machine ID of the requesting task
    46                              <1> ;Output: CF=NC: Proceed happily with SFT linked into the MFT for the file.
    47                              <1> ;        CF=CY: eax = Error code for request. Abort, free SFT.
    48                              <1> ;Use r8 as DOSSEG base
    49                              <1> ;----------------------------------------------------------------------------
    50 00000013 E889020000          <1>     call critEnter
    51 00000018 4150                <1>     push r8
    52 0000001A 4C8B05(26000000)    <1>     mov r8, qword [pDosseg]
    53 00000021 498BB050060000      <1>     mov rsi, qword [r8 + fname1Ptr] ;Get the filename pointer
    54 00000028 E8A7040000          <1>     call getMFT
    55 0000002D 720C                <1>     jc .exit
    56                              <1> ;rbx -> MFT for this file here.
    57 0000002F 498BB063070000      <1>     mov rsi, qword [r8 + currentSFT]    ;Get the current SFT now
    58 00000036 E85B030000          <1>     call addSFTtoMFT    ;Bubble CF
    59                              <1> .exit:
    60 0000003B 4158                <1>     pop r8
    61 0000003D E869020000          <1>     call critExit
    62                              <1>     return
    13                              <2> %%_ret:
    14 00000042 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    63                              <1> 
    64                              <1> close:          
    65                              <1> ;Called on file close. Frees all sharing information associated with
    66                              <1> ; a file.
    67                              <1> ;Input: rdi -> SFT we are closing.
    68 00000043 E859020000          <1>     call critEnter
    69 00000048 488B5F4F            <1>     mov rbx, qword [rdi + sft.pMFT]
    70 0000004C 4885DB              <1>     test rbx, rbx   ;If this is an SFT from before Share loaded, do nothing!
    71 0000004F 741C                <1>     jz .exit
    72 00000051 0FBF07              <1>     movsx eax, word [rdi + sft.wNumHandles] ;Get the count
    73 00000054 85C0                <1>     test eax, eax   ;If count is zero, free all sharing data
    74 00000056 7404                <1>     jz .goClose
    75 00000058 FFC0                <1>     inc eax         ;If this handle is -1, also free any sharing data.
    76 0000005A 7511                <1>     jnz .exit       ;If not -1 or 0, then inc eax > 0 and so we just exit
    77                              <1> .goClose:
    78 0000005C E8DC020000          <1>     call freeLocks  ;Free all locks associated to this SFT
    79 00000061 E88A020000          <1>     call removeSFTfromMFT ;Delink this SFT from the SFT link
    80 00000066 7505                <1>     jnz .exit       ;If not last SFT in MFT chain, dont free MFT
    81 00000068 E848020000          <1>     call freeMFT    ;If no more SFTs, free the MFT. Do small GC.
    82                              <1> .exit:
    83 0000006D E839020000          <1>     call critExit
    84                              <1>     return
    13                              <2> %%_ret:
    14 00000072 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    85                              <1> 
    86                              <1> closeAllByMachine:      
    87                              <1> ;Close all files for a machine
    88 00000073 F9                  <1>     stc
    89                              <1>     return
    13                              <2> %%_ret:
    14 00000074 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    90                              <1> closeAllByProcess:      
    91                              <1> ;Close all files for a task
    92 00000075 F9                  <1>     stc
    93                              <1>     return
    13                              <2> %%_ret:
    14 00000076 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    94                              <1> closeAllByName:      
    95                              <1> ;Close file by name
    96 00000077 F9                  <1>     stc
    97                              <1>     return
    13                              <2> %%_ret:
    14 00000078 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    98                              <1> lockFile:       
    99                              <1> ;Lock a file region
   100 00000079 F9                  <1>     stc
   101                              <1>     return
    13                              <2> %%_ret:
    14 0000007A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   102                              <1> unlockFile:     
   103                              <1> ;Unlock file region
   104 0000007B F9                  <1>     stc
   105                              <1>     return
    13                              <2> %%_ret:
    14 0000007C C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   106                              <1> checkRegionLock:  
   107                              <1> ;Check file region locked
   108 0000007D F8                  <1>     clc
   109                              <1>     return
    13                              <2> %%_ret:
    14 0000007E C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   110                              <1> getMFTInfo:   
   111                              <1> ;Get MFT information about file
   112 0000007F F9                  <1>     stc
   113                              <1>     return
    13                              <2> %%_ret:
    14 00000080 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   114                              <1> updateFCB: 
   115                              <1> ;UNUSED: Update FCB from the SFT
   116 00000081 F9                  <1>     stc
   117                              <1>     return
    13                              <2> %%_ret:
    14 00000082 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   118                              <1> getFirstClusterFCB:   
   119                              <1> ;UNUSED: Get first cluster of FCB
   120 00000083 F9                  <1>     stc
   121                              <1>     return
    13                              <2> %%_ret:
    14 00000084 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   122                              <1> closeNetworkFiles:   
   123                              <1> ;Close a newly created SFT-FCB handle for a procedure.
   124                              <1> ;Network SFT-FCBs handles are all collapsed into one SFT.
   125                              <1> ;----------------------------------------------------------------------------
   126                              <1> ;Input: rsi -> Newly created SFT
   127                              <1> ;       ax = SFTNdx for this newly created file
   128                              <1> ;Output: CF=NC: ax = SFTNdx for the SFT (Same as on input if not a SFT-FCB)
   129                              <1> ;        CF=CY: No SFT found
   130                              <1> ;----------------------------------------------------------------------------
   131                              <1> ;If
   132                              <1> ;   rsi -> SFT that is a network SFT-FCB (i.e. bit openNetFCBShr set 
   133                              <1> ;   in openmode), then we close any duplicate handles using a single
   134                              <1> ;   SFT to maintain the state (if there are none then we use this SFT
   135                              <1> ;   as the SFT-FCB). We increment the new main SFT refcount instead of 
   136                              <1> ;   having multiple SFTs.
   137                              <1> ;----------------------------------------------------------------------------
   138 00000085 4150                <1>     push r8
   139 00000087 4C8B05(26000000)    <1>     mov r8, qword [pDosseg]
   140 0000008E 0FB74602            <1>     movzx eax, word [rsi + sft.wOpenMode]
   141 00000092 25F0000000          <1>     and eax, 0F0h    ;Save the share bits
   142 00000097 3D70000000          <1>     cmp eax, openNetFCBShr
   143 0000009C 7573                <1>     jne .exitNormal
   144 0000009E 31DB                <1>     xor ebx, ebx
   145                              <1> .ptrLp:
   146 000000A0 53                  <1>     push rbx
   147 000000A1 B816120000          <1>     mov eax, 1216h  ;getSFTPtrfromSFTNdx -> Get in rdi the SFT for index bx
   148 000000A6 CD2F                <1>     int 2Fh
   149 000000A8 5B                  <1>     pop rbx
   150 000000A9 726E                <1>     jc .exit
   151 000000AB 4839F7              <1>     cmp rdi, rsi    ;Skip ourselves
   152 000000AE 742D                <1>     je .ptrNext
   153 000000B0 66813F0000          <1>     cmp word [rdi + sft.wNumHandles], 0 ;Handle must have empty count
   154 000000B5 7426                <1>     je .ptrNext
   155 000000B7 0FB74602            <1>     movzx eax, word [rsi + sft.wOpenMode]
   156 000000BB 663B4702            <1>     cmp ax, word [rdi + sft.wOpenMode]
   157 000000BF 751C                <1>     jne .ptrNext
   158 000000C1 8B4643              <1>     mov eax, dword [rsi + sft.dMID]
   159 000000C4 394743              <1>     cmp dword [rdi + sft.dMID], eax
   160 000000C7 7514                <1>     jne .ptrNext
   161 000000C9 488B4647            <1>     mov rax, qword [rsi + sft.qPID]
   162 000000CD 48394747            <1>     cmp qword [rdi + sft.qPID], rax
   163 000000D1 750A                <1>     jne .ptrNext
   164 000000D3 488B464F            <1>     mov rax, qword [rsi + sft.pMFT]
   165 000000D7 4839474F            <1>     cmp qword [rdi + sft.pMFT], rax
   166 000000DB 7404                <1>     je .ptrFnd  ;If all this, then we have a duplicate net handle
   167                              <1> .ptrNext:
   168 000000DD FFC3                <1>     inc ebx
   169 000000DF EBBF                <1>     jmp short .ptrLp
   170                              <1> .ptrFnd:
   171                              <1> ;rsi is a duplicate of rdi for this process
   172 000000E1 66C7060000          <1>     mov word [rsi + sft.wNumHandles], 0 ;Free the handle we just allocated
   173 000000E6 57                  <1>     push rdi    ;rdi is the master FCB SFT 
   174 000000E7 53                  <1>     push rbx    ;Save the sftindex
   175 000000E8 4889F7              <1>     mov rdi, rsi
   176 000000EB E853FFFFFF          <1>     call close  ;Close the current SFT now
   177 000000F0 58                  <1>     pop rax     ;Get the sftindex into eax
   178 000000F1 5F                  <1>     pop rdi
   179 000000F2 66FF07              <1>     inc word [rdi + sft.wNumHandles]    ;Add one now
   180 000000F5 31DB                <1>     xor ebx, ebx
   181                              <1> .jftlp:
   182 000000F7 50                  <1>     push rax
   183 000000F8 B820120000          <1>     mov eax, 1220h  ;getJFTPtr -> Get ptr to this jft entry in psp in rdi
   184 000000FD CD2F                <1>     int 2Fh
   185 000000FF 58                  <1>     pop rax
   186 00000100 7217                <1>     jc .exit
   187 00000102 3807                <1>     cmp byte [rdi], al
   188 00000104 7404                <1>     je .jftFnd
   189 00000106 FFC3                <1>     inc ebx
   190 00000108 EBED                <1>     jmp short .jftlp
   191                              <1> .jftFnd:
   192 0000010A C607FF              <1>     mov byte [rdi], -1
   193 0000010D 89D8                <1>     mov eax, ebx
   194 0000010F EB08                <1>     jmp short .exit
   195                              <1> .exitNormal:
   196 00000111 410FB7806D070000    <1>     movzx eax, word [r8 + currentHdl]   ;Get the handle value to return
   197                              <1> .exit:
   198 00000119 4158                <1>     pop r8
   199                              <1>     return
    13                              <2> %%_ret:
    14 0000011B C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   200                              <1> 
   201                              <1> closeRenDel:
   202                              <1> ;On rename/delete/setattr, this function is called to check we can proceed
   203                              <1> ; with the operation.
   204                              <1> ;Finds MFT based on the filename in fname1Ptr in the dosseg
   205                              <1> ;----------------------------------------------------------------------------
   206                              <1> ;Input: fname1Ptr -> Filename to do check on
   207                              <1> ;Output: Nothing
   208                              <1> ;----------------------------------------------------------------------------
   209                              <1> ;If 
   210                              <1> ;   the file is not open, then we return ok.
   211                              <1> ;Else if 
   212                              <1> ;   the file is opened by us uniquely and is open in compatibility mode,
   213                              <1> ;   then close the file and return ok.
   214                              <1> ;Else, we fail.
   215                              <1> ;----------------------------------------------------------------------------
   216 0000011C 4150                <1>     push r8
   217 0000011E 4C8B05(26000000)    <1>     mov r8, qword [pDosseg]
   218 00000125 E877010000          <1>     call critEnter
   219                              <1> .again:
   220 0000012A 498BB050060000      <1>     mov rsi, qword [r8 + fname1Ptr] ;Get the filename pointer
   221 00000131 E888040000          <1>     call findMFT    ;Looks for this file
   222 00000136 7237                <1>     jc .exit    ;If the file doesn't exist, exit
   223                              <1> ;File MFT found. rbx -> MFT. 
   224                              <1> ; Now check that all the files on this chain have the mid and pid of 
   225                              <1> ; the requester and (are in compatibility mode or a net SFT).
   226 00000138 488B730E            <1>     mov rsi, qword [rbx + mft.pSFT] ;This cant be empty so it must be an SFT
   227 0000013C 4889F7              <1>     mov rdi, rsi    ;Save this SFT pointer in rdi
   228                              <1> .scanLp:
   229 0000013F 418B8073040000      <1>     mov eax, dword [r8 + dMID]
   230 00000146 3B4643              <1>     cmp eax, dword [rsi + sft.dMID]
   231 00000149 7524                <1>     jne .exit
   232 0000014B 498B806B040000      <1>     mov rax, qword [r8 + qPID]
   233 00000152 483B4647            <1>     cmp rax, qword [rsi + sft.qPID]
   234 00000156 7517                <1>     jne .exit
   235 00000158 0FB74602            <1>     movzx eax, word [rsi + sft.wOpenMode]
   236 0000015C 25F0000000          <1>     and eax, 0F0h    ;Get the sharing mode
   237                              <1> ;If compatibility mode or net fcb, proceed with close
   238 00000161 3D70000000          <1>     cmp eax, openNetFCBShr
   239 00000166 740F                <1>     je .next
   240 00000168 3D00000000          <1>     cmp eax, openCompat
   241 0000016D 7408                <1>     je .next
   242                              <1> .exit:
   243 0000016F E837010000          <1>     call critExit
   244 00000174 4158                <1>     pop r8
   245                              <1>     return
    13                              <2> %%_ret:
    14 00000176 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   246                              <1> .next:
   247 00000177 488B763B            <1>     mov rsi, qword [rsi + sft.pNextSFT]
   248 0000017B 4885F6              <1>     test rsi, rsi
   249 0000017E 75BF                <1>     jnz .scanLp
   250                              <1> ;Here we must close all the handles referring to this SFT
   251                              <1> ;rdi -> First SFT 
   252 00000180 4989B863070000      <1>     mov qword [r8 + currentSFT], rdi    ;Set this SFT as current SFT
   253 00000187 4889FE              <1>     mov rsi, rdi
   254 0000018A 31DB                <1>     xor ebx, ebx
   255                              <1> .sftIndxLp:
   256 0000018C 53                  <1>     push rbx
   257 0000018D B816120000          <1>     mov eax, 1216h  ;Get SFT Ptr from SFT Index into rdi
   258 00000192 CD2F                <1>     int 2Fh
   259 00000194 5B                  <1>     pop rbx
   260 00000195 FFC3                <1>     inc ebx
   261 00000197 4839FE              <1>     cmp rsi, rdi    ;Was this index correct?
   262 0000019A 75F0                <1>     jne .sftIndxLp
   263 0000019C FFCB                <1>     dec ebx         ;Decrement it back, we are looking for this number
   264                              <1> ;Now we walk the Arena Chain to find every task ID and close the
   265                              <1> ; JFT entry for this file if the SFTIndex exists in that task's JFT
   266 0000019E 31C0                <1>     xor eax, eax    ;Zero to give a PID that will not be at the start
   267 000001A0 498B783B            <1>     mov rdi, qword [r8 + mcbChainPtr]   ;Get the MCB chain header in rdi
   268 000001A4 EB25                <1>     jmp short .checkMCB ;Make sure this MCB is a valid MCB
   269                              <1> .mcbLp:
   270 000001A6 483B4701            <1>     cmp rax, qword [rdi + mcb.owner]    ;If new PID same as before, skip
   271 000001AA 7409                <1>     je .getNextMCB
   272 000001AC 488B4701            <1>     mov rax, qword [rdi + mcb.owner]    ;Else, get the new PID
   273 000001B0 E84E040000          <1>     call closeJFTEntries    ;Close all JFT entries for this process
   274                              <1> .getNextMCB:
   275 000001B5 803F5A              <1>     cmp byte [rdi + mcb.marker], mcbMarkEnd ;If we processed end block, exit
   276 000001B8 743C                <1>     je .mcbEnd
   277                              <1> ;Else, goto next block
   278 000001BA 8B4F09              <1>     mov ecx, dword [rdi + mcb.blockSize]    ;Get size of block in paras
   279 000001BD 48C1E104            <1>     shl rcx, 4      ;Turn into bytes
   280 000001C1 4881C110000000      <1>     add rcx, mcb_size
   281 000001C8 4801CF              <1>     add rdi, rcx    ;Go to next MCB
   282                              <1> .checkMCB:
   283 000001CB 8A0F                <1>     mov cl, byte [rdi + mcb.marker] ;Now check the new MCB is valid
   284 000001CD 80F95A              <1>     cmp cl, mcbMarkEnd
   285 000001D0 74D4                <1>     je .mcbLp
   286 000001D2 80F94D              <1>     cmp cl, mcbMarkCtn
   287 000001D5 74CF                <1>     je .mcbLp
   288 000001D7 E883040000          <1>     call errPrintAndHalt    ;Wasn't a end or cont block, error!
   289 000001DC 4D434220434F525255- <1>     db "MCB CORRUPTION DETECTED",CR,LF,NUL
   289 000001E5 5054494F4E20444554- <1>
   289 000001EE 45435445440D0A00    <1>
   290                              <1> .mcbEnd:
   291 000001F6 B801120000          <1>     mov eax, 1201h ;Close the currentSFT
   292 000001FB CD2F                <1>     int 2Fh
   293 000001FD E928FFFFFF          <1>     jmp .again  ;Now do this again until no more files
   294                              <1> 
   295                              <1> dirUpdate:      
   296                              <1> ;Update dir info across all SFTs for a file. 
   297                              <1> ;----------------------------------------------------------------------------
   298                              <1> ;Input: rdi -> SFT to update dir entry from
   299                              <1> ;       eax = 0: Update the date/time fields only
   300                              <1> ;           = 1: Update size fields for growth
   301                              <1> ;           = 2: Update size fields for shrink (i.e. truncate/open calls)
   302                              <1> ;           = 3: Update all fields
   303                              <1> ;Output: Nothing, all SFTs in MFT chain updated.
   304                              <1> ;        rax and rcx trashed.
   305                              <1> ;----------------------------------------------------------------------------
   306                              <1> ; If rdi is a chardev or a redir file, return
   307                              <1> ; Get MFT pointer. 
   308                              <1> ; If 
   309                              <1> ;   MFT pointer is null, return.
   310                              <1> ; Else
   311                              <1> ;   Get first SFT pointer from MFT into rsi   
   312                              <1> ; If eax = 0:
   313                              <1> ;   Walk the SFT chain along rsi updating date/time fields except for us.
   314                              <1> ; Else if eax = 1:
   315                              <1> ;   Walk the SFT chain along rsi updating dFileSize and dStartClust fields 
   316                              <1> ;   except for us.
   317                              <1> ; Else if eax = 2:
   318                              <1> ;   Walk the SFT chain along rsi updating dFileSize, dStartClust and 
   319                              <1> ;   setting dRelClust to 0 and dAbsClust to dStartClust except for us.
   320                              <1> ; Else if eax = 3:
   321                              <1> ;   Update date/time and dFileSize, dStartClust, dRelClust and dAbsClust 
   322                              <1> ;   fields for us from the oldest SFT in the SFT chain for this MFT. 
   323                              <1> ;   
   324                              <1> ; Return.
   325                              <1> ;**** Note ****
   326                              <1> ;In open and shrink we reset dRelClust to 0 and dAbsClust to dStartClust
   327                              <1> ;to signify that all file IO should start from the start of the file.
   328                              <1> ;This is a future optimisation as right now, the DOS kernel never depends 
   329                              <1> ;on these values. These values are however correctly synchronised on each
   330                              <1> ;read/write so in the future, we can relatively easily add a check to make
   331                              <1> ;use of these values, unless they are at the start of the file at which
   332                              <1> ;case we use the current algorithms.
   333                              <1> ;----------------------------------------------------------------------------
   334 00000202 66F747058080        <1>     test word [rdi + sft.wDeviceInfo], devCharDev | devRedir
   335                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000208 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000020A C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   336 0000020B 51                  <1>     push rcx
   337 0000020C 56                  <1>     push rsi
   338 0000020D 488B774F            <1>     mov rsi, qword [rdi + sft.pMFT] ;Get MFT pointer in rsi
   339 00000211 4885F6              <1>     test rsi, rsi   ;If this is a null pointer, return
   340                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000214 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000216 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   341 00000217 E885000000          <1>     call critEnter
   342 0000021C 488B760E            <1>     mov rsi, qword [rsi + mft.pSFT] ;Get first SFT of MFT in rsi
   343 00000220 89C1                <1>     mov ecx, eax
   344 00000222 85C9                <1>     test ecx, ecx   ;Is it 0?
   345 00000224 7515                <1>     jnz .fileCheck
   346                              <1> ;Here we do date/time update only.
   347 00000226 8B4713              <1>     mov eax, dword [rdi + sft.dTimeDate]
   348                              <1> .dtlp:
   349 00000229 894613              <1>     mov dword [rsi + sft.dTimeDate], eax
   350 0000022C E860000000          <1>     call .gotoNextSFT
   351 00000231 75F6                <1>     jnz .dtlp
   352                              <1> .exit:
   353 00000233 E873000000          <1>     call critExit
   354                              <1> .exitNoCrit:
   355 00000238 5E                  <1>     pop rsi
   356 00000239 59                  <1>     pop rcx
   357                              <1>     return
    13                              <2> %%_ret:
    14 0000023A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   358                              <1> .fileCheck:
   359 0000023B 81F903000000        <1>     cmp ecx, 3
   360 00000241 7430                <1>     je .open
   361                              <1> ;If not 3 or 0, must be 1 or 2
   362                              <1> .gsLp:
   363                              <1> ;Always update filesize and start cluster info in rsi for growth/shrink
   364                              <1> ; to the filesize and start cluster of rdi
   365 00000243 8B4717              <1>     mov eax, dword [rdi + sft.dFileSize]
   366 00000246 894617              <1>     mov dword [rsi + sft.dFileSize], eax
   367 00000249 8B470F              <1>     mov eax, dword [rdi + sft.dStartClust]
   368 0000024C 89460F              <1>     mov dword [rsi + sft.dStartClust], eax
   369 0000024F 81F902000000        <1>     cmp ecx, 2      ;Was this a shrink call?
   370 00000255 7409                <1>     je .gsDoShrink  ;Reset the cluster info if so
   371                              <1> ;Here if we are a grow call. Check if the SFT in rsi was newly created.
   372                              <1> ;If not, skip the reset below. Else, we set the absolute cluster now to
   373                              <1> ; the start cluster to ensure that the SFTs all correctly have the same
   374                              <1> ; cluster info.  
   375 00000257 817E2300000000      <1>     cmp dword [rsi + sft.dAbsClust], 0 ;Is this sft just created?
   376 0000025E 750A                <1>     jne .gsNextFile   ;If not, and a grow call, skip the below
   377                              <1> .gsDoShrink:
   378                              <1> ;Set the cluster information back to the start of the file.
   379 00000260 894623              <1>     mov dword [rsi + sft.dAbsClust], eax
   380 00000263 C7461F00000000      <1>     mov dword [rsi + sft.dRelClust], 0  ;Reset the file rel cluster ptr
   381                              <1> .gsNextFile:
   382 0000026A E822000000          <1>     call .gotoNextSFT
   383 0000026F 75D2                <1>     jnz .gsLp
   384 00000271 EBC0                <1>     jmp short .exit 
   385                              <1> 
   386                              <1> .open:
   387                              <1> ;Here we handle new file opens! Copies data from the 
   388                              <1> ; topmost (earliest opened) SFT (rsi) of the SFT chain into 
   389                              <1> ; the newly opened SFT (rdi)
   390 00000273 8B4613              <1>     mov eax, dword [rsi + sft.dTimeDate]
   391 00000276 894713              <1>     mov dword [rdi + sft.dTimeDate], eax
   392 00000279 8B4617              <1>     mov eax, dword [rsi + sft.dFileSize]
   393 0000027C 894717              <1>     mov dword [rdi + sft.dFileSize], eax
   394 0000027F 8B460F              <1>     mov eax, dword [rsi + sft.dStartClust]
   395 00000282 89470F              <1>     mov dword [rdi + sft.dStartClust], eax
   396 00000285 894723              <1>     mov dword [rdi + sft.dAbsClust], eax
   397 00000288 C7471F00000000      <1>     mov dword [rdi + sft.dRelClust], 0
   398 0000028F EBA2                <1>     jmp short .exit
   399                              <1> 
   400                              <1> .gotoNextSFT:
   401                              <1> ;Returns in rsi the next SFT entry.
   402                              <1> ;Input: rdi -> SFT we are updating from.
   403                              <1> ;       rsi -> SFT we just updated.
   404                              <1> ;Output: ZF=NZ: rsi -> Next SFT in the chain.
   405                              <1> ;        ZF=ZE: End of SFT chain.
   406 00000291 488B763B            <1>     mov rsi, qword [rsi + sft.pNextSFT]
   407 00000295 4885F6              <1>     test rsi, rsi
   408                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000298 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000029A C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   409 0000029B 4839FE              <1>     cmp rsi, rdi
   410 0000029E 74F1                <1>     je .gotoNextSFT
   411                              <1>     return
    13                              <2> %%_ret:
    14 000002A0 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    52                                  %include "./src/share/text/shutils.asm"
     1                              <1> ;All utility functions go here
     2                              <1> ;-----------------------------------------------------------------------------
     3                              <1> ; critEnter -> Enters a DOS 1 critical section
     4                              <1> ; critExit -> Exits a DOS 1 critical section
     5                              <1> ; freeMFT -> Frees an MFT from the MFT arena
     6                              <1> ; removeSFTfromMFT -> Removes an SFT from an MFT's SFT chain
     7                              <1> ; freeLocks -> Frees all file locks associated to a SFT
     8                              <1> ; addSFTtoMFT -> Adds an SFT to its MFT chain.
     9                              <1> ; getMFT -> Gets an MFT for a given filename. Creates if it has to.
    10                              <1> ; defragMFTArena -> Defragments the MFT arena
    11                              <1> ; findFreeMFT -> Finds a free MFT for a given size
    12                              <1> ; findMFT -> Find an MFT for a given filename
    13                              <1> ; getNameMeta -> Computes the length and checksum of a filename
    14                              <1> ; closeJFTentries -> Closes all JFT entries pointing to a 
    15                              <1> ;                       particular SFT for a process.
    16                              <1> ; errPrintAndHalt -> Prints a formatted error message and halts the machine
    17                              <1> ;-----------------------------------------------------------------------------
    18                              <1> 
    19                              <1> 
    20                              <1> critEnter:
    21 000002A1 50                  <1>     push rax
    22 000002A2 B801800000          <1>     mov eax, 8001h  ;Enter DOS Level 1 critical section
    23 000002A7 CD2A                <1>     int 2ah
    24 000002A9 58                  <1>     pop rax
    25                              <1>     return
    13                              <2> %%_ret:
    14 000002AA C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    26                              <1> critExit:
    27 000002AB 50                  <1>     push rax
    28 000002AC B801810000          <1>     mov eax, 8101h  ;Exit DOS Level 1 critical section
    29 000002B1 CD2A                <1>     int 2ah
    30 000002B3 58                  <1>     pop rax
    31                              <1>     return
    13                              <2> %%_ret:
    14 000002B4 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    32                              <1> 
    33                              <1> freeMFT:
    34                              <1> ;Frees the MFT if it is safe to do so. Crashes otherwise. Combines 
    35                              <1> ; any adjacent free space too.
    36                              <1> ;Input: rbx -> MFT to free
    37                              <1> ;Output: MFT freed. Any adjacent free space is absorbed by this MFT too.
    38                              <1> ;Trashes rax, rbx and rsi
    39 000002B5 488B430E            <1>     mov rax, qword [rbx + mft.pSFT]
    40 000002B9 48094306            <1>     or qword [rbx + mft.pLock], rax ;If pLock or pSFT is non-zero, hard error
    41 000002BD 751A                <1>     jnz .crash
    42 000002BF C60300              <1>     mov byte [rbx + mft.bSig], mftFree
    43                              <1> .lp:
    44                              <1> ;Checks the adjacent MFT. If it is free, we combine it to this free MFT.
    45 000002C2 4889DE              <1>     mov rsi, rbx
    46 000002C5 8B4301              <1>     mov eax, dword [rbx + mft.dLen]
    47 000002C8 4801C6              <1>     add rsi, rax    ;Point to next MFT
    48 000002CB 803E00              <1>     cmp byte [rsi + mft.bSig], mftFree
    49                              <1>     retne   ;If not free, we exit
    53                              <2> cret ne
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000002CE 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000002D0 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
    50 000002D1 8B4601              <1>     mov eax, dword [rsi + mft.dLen]
    51 000002D4 014301              <1>     add dword [rbx + mft.dLen], eax ;Add this size to our MFT len
    52 000002D7 EBE9                <1>     jmp short .lp       ;Now go again
    53                              <1> .crash:
    54 000002D9 534654204C434B2066- <1>     db "SFT LCK fields not 0",CR,LF,NUL
    54 000002E2 69656C6473206E6F74- <1>
    54 000002EB 20300D0A00          <1>
    55                              <1> 
    56                              <1> 
    57                              <1> removeSFTfromMFT:
    58                              <1> ;Removes the SFT from the MFT's SFT chain.
    59                              <1> ;Input: rdi -> SFT we are closing.
    60                              <1> ;Output: ZF=ZE: No more files on MFT
    61                              <1> ;        ZF=NZ: More files on MFT.
    62                              <1> ;           rbx -> MFT for this file
    63                              <1> ;Trashes rax and rsi.
    64 000002F0 488B5F4F            <1>     mov rbx, qword [rdi + sft.pMFT] ;Get the MFT pointer
    65                              <1> ;Point rsi to the such that it is one sft.pNextSFT away from the pointer to
    66                              <1> ; the next SFT
    67 000002F4 488D73D3            <1>     lea rsi, qword [rbx + mft.pSFT - sft.pNextSFT]
    68                              <1> .lp:
    69 000002F8 4885F6              <1>     test rsi, rsi   ;If we dont find rdi, something has gone terribly wrong
    70 000002FB 7425                <1>     jz .crash
    71 000002FD 48397E3B            <1>     cmp qword [rsi + sft.pNextSFT], rdi    ;Is the next SFT us?
    72 00000301 7406                <1>     je .found
    73 00000303 488B763B            <1>     mov rsi, qword [rsi + sft.pNextSFT] ;Go to next SFT
    74 00000307 EBEF                <1>     jmp short .lp
    75                              <1> .found:
    76                              <1> ;rsi -> Points to the previous SFT in the chain 
    77 00000309 488B473B            <1>     mov rax, qword [rdi + sft.pNextSFT] ;Get our next SFT value
    78 0000030D 4889463B            <1>     mov qword [rsi + sft.pNextSFT], rax ;And set the prev SFT to link over us
    79 00000311 48C7474F00000000    <1>     mov qword [rdi + sft.pMFT], 0   ;Set pMFT to zero to mean we are done!
    80 00000319 48817B0E00000000    <1>     cmp qword [rbx + mft.pSFT], 0   ;Is the MFT SFT chain ptr 0?
    81                              <1>     return
    13                              <2> %%_ret:
    14 00000321 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    82                              <1> .crash:
    83 00000322 E838030000          <1>     call errPrintAndHalt
    84 00000327 534654204E4F542049- <1>     db "SFT NOT IN SFT LIST",CR,LF,NUL
    84 00000330 4E20534654204C4953- <1>
    84 00000339 540D0A00            <1>
    85                              <1> 
    86                              <1> 
    87                              <1> freeLocks:
    88                              <1> ;Frees all file locks associated to this rdi. 
    89                              <1> ;Input: rdi -> SFT for this file
    90                              <1> ;       edx = Flag for if we should free locks for process
    91                              <1> ;             -1 -> Free for process (on 5D04h calls)
    92                              <1> ;              0 -> Dont bother (otherwise)
    93                              <1> ;Output: All file locks owned by this process are delinked from the 
    94                              <1> ;        file chain and added to the free lock chain.
    95                              <1> ;Trashes rax, rbx, rsi.
    96 0000033D 488B5F4F            <1>     mov rbx, qword [rdi + sft.pMFT]     ;Get MFT ptr in rbx
    97 00000341 488B7306            <1>     mov rsi, qword [rbx + mft.pLock]    ;Get the first lock of MFT in rsi 
    98 00000345 4881C306000000      <1>     add rbx, mft.pLock  ;Point rbx to the link field of the previous lock
    99                              <1> .lp:
   100 0000034C 4885F6              <1>     test rsi, rsi   ;End of list? 
   101                              <1>     retz            ;Exit if so
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000034F 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000351 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   102                              <1> ;A lock is ours if the SFT pointer of the lock matches our SFT pointer in rdi
   103 00000352 48397E18            <1>     cmp qword [rsi + fileLock.pSFT], rdi    ;Is the SFT ours?
   104 00000356 7536                <1>     jne .nextLock   ;If not, skip
   105 00000358 85D2                <1>     test edx, edx   ;If it is but we dont care for process ID, skip this
   106 0000035A 7418                <1>     jz .skipProcess
   107                              <1> ;Now check this lock belongs to this process too
   108 0000035C 4150                <1>     push r8
   109 0000035E 4C8B05(26000000)    <1>     mov r8, qword [pDosseg]
   110 00000365 498B806B040000      <1>     mov rax, qword [r8 + qPID]  ;Get the process id
   111 0000036C 48394620            <1>     cmp qword [rsi + fileLock.qPID], rax    ;And compare them
   112 00000370 4158                <1>     pop r8
   113 00000372 751A                <1>     jne .nextLock
   114                              <1> .skipProcess:
   115                              <1> ;Here we delink the flock. We move it from the MFT list to the Free list
   116                              <1> ; and cross link.
   117                              <1> ;Registers on entry
   118                              <1> ;rdi -> Our SFT
   119                              <1> ;rsi -> Lock
   120                              <1> ;rbx -> The previous lock in the file chain (only first qword valid)
   121                              <1> ;edx = Flag, do not use.
   122 00000374 488B06              <1>     mov rax, qword [rsi + fileLock.pNext]   ;Unlink rsi by linking the prev...
   123 00000377 488903              <1>     mov qword [rbx + fileLock.pNext], rax   ;... flock to the flock after rsi
   124 0000037A 488B05(14000000)    <1>     mov rax, qword [pFreeLock]              ;Get head of the free lock list
   125 00000381 488906              <1>     mov qword [rsi + fileLock.pNext], rax   ;Link rsi to the head of free list
   126 00000384 488935(14000000)    <1>     mov qword [pFreeLock], rsi              ;Make rsi the head of the free list
   127 0000038B 4889DE              <1>     mov rsi, rbx    ;Start from previous lock in the list again.
   128                              <1> .nextLock:
   129 0000038E 4889F3              <1>     mov rbx, rsi    ;Point rsi to this filelock
   130 00000391 488B36              <1>     mov rsi, qword [rsi + fileLock.pNext]   ;Get next file lock
   131 00000394 EBB6                <1>     jmp short .lp
   132                              <1> 
   133                              <1> addSFTtoMFT:
   134                              <1> ;Adds an SFT to the MFT chain and finishes filling in it's share fields. 
   135                              <1> ;Checks for sharing conflicts before adding.
   136                              <1> ;Input: rsi -> SFT to add
   137                              <1> ;       rbx -> MFT to add SFT to
   138                              <1> ;       r8 -> DOSSEG
   139                              <1> ;Output: CF=NC: SFT Added to list
   140                              <1> ;        CF=CY: Sharing violation. eax has error code
   141 00000396 48817E4F00000000    <1>     cmp qword [rsi + sft.pMFT], 0   ;This SFT better not already be on a chain
   142 0000039E 752E                <1>     jne .crash
   143                              <1> ;Add the networking ids now as we need them for permissions checking
   144 000003A0 498B806B040000      <1>     mov rax, qword [r8 + qPID]
   145 000003A7 48894647            <1>     mov qword [rsi + sft.qPID], rax
   146 000003AB 418B8073040000      <1>     mov eax, dword [r8 + dMID]
   147 000003B2 894643              <1>     mov dword [rsi + sft.dMID], eax
   148                              <1> ;Now we check if there are any sharing conflicts
   149 000003B5 E82E000000          <1>     call checkPermissions
   150                              <1>     retc
    57                              <2> cret c
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000003BA 7301                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000003BC C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   151 000003BD 48895E4F            <1>     mov qword [rsi + sft.pMFT], rbx
   152                              <1> ;Now add this SFT to the front of the list.
   153 000003C1 488B7B0E            <1>     mov rdi, qword [rbx + mft.pSFT] ;Get the head of the SFT list
   154 000003C5 48897E3B            <1>     mov qword [rsi + sft.pNextSFT], rdi ;Link new SFT to previous head
   155 000003C9 4889730E            <1>     mov qword [rbx + mft.pSFT], rsi ;Put new SFT at head of MFT list
   156                              <1>     return
    13                              <2> %%_ret:
    14 000003CD C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   157                              <1> .crash:
   158 000003CE E88C020000          <1>     call errPrintAndHalt
   159 000003D3 53465420414C524541- <1>     db "SFT ALREADY IN USE",CR,LF,NUL
   159 000003DC 445920494E20555345- <1>
   159 000003E5 0D0A00              <1>
   160                              <1> 
   161                              <1> checkPermissions:
   162                              <1> ;Checks for sharing conflicts of the new SFT against all
   163                              <1> ; other SFTs in the chain. 
   164                              <1> ;If both new SFT and SFT on chain are compatibility 
   165                              <1> ; then check machine id. If they are equal, goto next SFT on chain.
   166                              <1> ;Else do table logic as described below.
   167                              <1> ;
   168                              <1> ;Input: rsi -> New SFT, with machine id field set
   169                              <1> ;       rbx -> MFT for this file.
   170                              <1> ;Output: CF=NC: No sharing conflicts.
   171                              <1> ;        CF=CY: Sharing conflict, eax has error code
   172 000003E8 53                  <1>     push rbx
   173 000003E9 4889F7              <1>     mov rdi, rsi        ;Save new SFT ptr in rdi
   174 000003EC E8A5000000          <1>     call getOpenMode    ;Get the adjusted sharing mode in eax
   175 000003F1 89C2                <1>     mov edx, eax        ;Use edx as the marker for if compat or not
   176 000003F3 81E2F0000000        <1>     and edx, 0F0h       ;Are the share bits 0?
   177 000003F9 7405                <1>     jz .compat
   178 000003FB BAF0000000          <1>     mov edx, 0F0h       ;Set to indicate no compat mode
   179                              <1> .compat:
   180 00000400 E86C000000          <1>     call getTableIndex  ;Get table index in eax for new SFT. Use as row index
   181 00000405 D1E0                <1>     shl eax, 1          ;Multiply by two, each row is a word
   182 00000407 488D3545000000      <1>     lea rsi, .tbl
   183 0000040E 0FB72C06            <1>     movzx ebp, word [rsi + rax] ;Get the table entry (bit row) into ebp
   184 00000412 488B730E            <1>     mov rsi, qword [rbx + mft.pSFT] ;Get the first SFT in chain
   185                              <1> .lp:
   186 00000416 4885F6              <1>     test rsi, rsi       ;Are we at the end of the chain?
   187 00000419 7433                <1>     jz .exit            ;If so, all ok!
   188 0000041B E876000000          <1>     call getOpenMode    ;Else, get the adjusted open mode in eax for this sft
   189 00000420 89C1                <1>     mov ecx, eax
   190 00000422 81E10F000000        <1>     and ecx, 0Fh        ;Get the share bits
   191 00000428 09D1                <1>     or ecx, edx         ;Check if both new and old files are in compat mode
   192 0000042A 7508                <1>     jnz .notBothCompat
   193                              <1> ;Both in compat mode means we do machine id check instead.
   194                              <1> ;If they match, we skip.
   195 0000042C 8B5E43              <1>     mov ebx, dword [rsi + sft.dMID]
   196 0000042F 395F43              <1>     cmp dword [rdi + sft.dMID], ebx
   197 00000432 740F                <1>     je .gotoNext
   198                              <1> .notBothCompat:
   199 00000434 E838000000          <1>     call getTableIndex  ;Get table index but use as a column (bit) index
   200 00000439 678D4802            <1>     lea ecx, dword [eax + 2]    ;+2 to drop the x bit and push our bit into CF
   201 0000043D 89E8                <1>     mov eax, ebp        ;Move row we are interested in into eax
   202 0000043F D3E8                <1>     shr eax, cl         ;Shift the bit we are interested into CF to check
   203 00000441 7206                <1>     jc .exitBad
   204                              <1> .gotoNext:
   205 00000443 488B763B            <1>     mov rsi, qword [rsi + sft.pNextSFT] ;Goto next SFT
   206 00000447 EBCD                <1>     jmp short .lp
   207                              <1> .exitBad:
   208                              <1> ;We come here with CF=CY
   209 00000449 B820000000          <1>     mov eax, errShrVio
   210                              <1> .exit:
   211 0000044E 4889FE              <1>     mov rsi, rdi        ;Point rsi back to the new SFT
   212 00000451 5B                  <1>     pop rbx             ;Get back MFT pointer
   213                              <1>     return
    13                              <2> %%_ret:
    14 00000452 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   214                              <1> 
   215                              <1> .tbl:          
   216                              <1> ;Each word is a packed entry of 15 meaningful bits with the 
   217                              <1> ; lower most bit always set and meaningless.
   218                              <1> ;That is, each word is 5 lots of 3(share mode) bits.
   219                              <1> ;The bits of each word are interpreted as follows:
   220                              <1> ;     0NNNRRRWWWAAACCCxb 
   221                              <1> ; where: 
   222                              <1> ; NNN = Deny None permissions
   223                              <1> ; RRR = Deny Read permissions 
   224                              <1> ; WWW = Deny Write permissions
   225                              <1> ; AAA = Deny All permissions
   226                              <1> ; CCC = Compat permissions
   227                              <1> ; x   = Set and ignored.
   228                              <1> ;In each triple:
   229                              <1> ;   0LMNb 
   230                              <1> ; the bits are interpreted as:
   231                              <1> ; L = What to do on Read/Write access. 
   232                              <1> ; M = What to do on Write access. 
   233                              <1> ; N = What to do on Read access.
   234                              <1> ;If a bit is set, it means this combination is not allowed.
   235                              <1> ;
   236                              <1> ;We get the word we are interested in based on the open mode of
   237                              <1> ; the new SFT. This gives us a row. We then use the open mode of
   238                              <1> ; every SFT on the MFT's SFT chain, to get a bit offset into this word.
   239                              <1> ;If for every element of the SFT chain the bit in the word is 0,
   240                              <1> ; we are ok. If ever this bit is 1, we have a sharing violation.
   241                              <1> ;
   242                              <1> ;The values of this table obtained from the matrix of the the DOS 3.3 
   243                              <1> ; programmers guide (p. 6-121), where N=1 and Y=0, with the following changes
   244                              <1> ; to make implementation easier (as the numbers are ordered as so):
   245                              <1> ;1) We swap the order of the openRWAcc and openWrAcc columns/rows
   246                              <1> ;    putting RW always at the left/bottom most part. 
   247                              <1> ;2) Each row of the table below is for "subsequent IO" where each
   248                              <1> ;    bit of the entry is the column.
   249                              <1> ;3) We duplicate Deny all as for Compat
   250                              <1> 
   251                              <1> ;Table annotated as follows: 
   252                              <1> ;N=Deny none
   253                              <1> ;R=Deny read
   254                              <1> ;W=Deny write
   255                              <1> ;A=Deny all
   256                              <1> ;C=Compat
   257                              <1> ;B=Open Read/Write (both)
   258                              <1> ;O=Open Write (output)
   259                              <1> ;I=Open Read (input)
   260                              <1> ;
   261                              <1> ;        Initial Open modes
   262                              <1> ;       N   R   W   A   C  x    ;Subsequent opens
   263                              <1> ;      BOI BOI BOI BOI BOI x    
   264 00000453 FFFF                <1>     dw 111_111_111_111_111_1b   ;I        openCompat|openRdAcc
   265 00000455 FFFF                <1>     dw 111_111_111_111_111_1b   ;O C      openCompat|openWrAcc
   266 00000457 FFFF                <1>     dw 111_111_111_111_111_1b   ;B        openCompat|openRWAcc
   267                              <1> 
   268 00000459 FFFF                <1>     dw 111_111_111_111_111_1b   ;I      openDenRWShr|openRdAcc
   269 0000045B FFFF                <1>     dw 111_111_111_111_111_1b   ;O A    openDenRWShr|openWrAcc
   270 0000045D FFFF                <1>     dw 111_111_111_111_111_1b   ;B      openDenRWShr|openRWAcc
   271                              <1> 
   272 0000045F 7FDF                <1>     dw 110_111_110_111_111_1b   ;I      openDenWrShr|openRdAcc
   273 00000461 FFDB                <1>     dw 110_110_111_111_111_1b   ;O W    openDenWrShr|openWrAcc
   274 00000463 FFDF                <1>     dw 110_111_111_111_111_1b   ;B      openDenWrShr|openRWAcc
   275                              <1> 
   276 00000465 FFBE                <1>     dw 101_111_101_111_111_1b   ;I      openDenRdShr|openRdAcc
   277 00000467 FFB7                <1>     dw 101_101_111_111_111_1b   ;O R    openDenRdShr|openWrAcc
   278 00000469 FFBF                <1>     dw 101_111_111_111_111_1b   ;B      openDenRdShr|openRWAcc
   279                              <1> 
   280 0000046B 7F1C                <1>     dw 000_111_000_111_111_1b   ;I      openDenNoShr|openRdAcc
   281 0000046D FF03                <1>     dw 000_000_111_111_111_1b   ;O N    openDenNoShr|openWrAcc
   282 0000046F FF1F                <1>     dw 000_111_111_111_111_1b   ;B      openDenNoShr|openWRAcc
   283                              <1> 
   284                              <1> getTableIndex:
   285                              <1> ;Turns the adjusted open mode into a table index value
   286                              <1> ;Input: eax = Adjusted open mode
   287                              <1> ;Output: eax = Index into the table (Number 0-14)
   288                              <1> ;        ecx = Share group (0-4)
   289                              <1> ;All other regs preserved
   290 00000471 89C1                <1>     mov ecx, eax
   291 00000473 250F000000          <1>     and eax, 0Fh    ;Isolate the open mode bits only
   292 00000478 81E1F0000000        <1>     and ecx, 0F0h   ;Isolate the share bits only
   293 0000047E 81F970000000        <1>     cmp ecx, openNetFCBShr  ;Is this a net FCB share?
   294 00000484 7502                <1>     jnz .notNetFCB
   295 00000486 31C9                <1>     xor ecx, ecx    ;Compatibility share in this case
   296                              <1> .notNetFCB:
   297                              <1> ;We want ecx <- (ecx >> 4)*3 to get the share group
   298 00000488 C1E904              <1>     shr ecx, 4      ;Get the share group
   299 0000048B 52                  <1>     push rdx
   300 0000048C 89CA                <1>     mov edx, ecx    ;Save it in edx
   301 0000048E D1E2                <1>     shl edx, 1      ;Multiply by 2
   302 00000490 01CA                <1>     add edx, ecx    ;Add to get it multiplied by three
   303 00000492 01D0                <1>     add eax, edx    ;Add share group*3 to the offset into the group
   304 00000494 5A                  <1>     pop rdx
   305                              <1>     return
    13                              <2> %%_ret:
    14 00000495 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   306                              <1> 
   307                              <1> getOpenMode:
   308                              <1> ;Gets the adjusted open mode.
   309                              <1> ;--------------------------------------------------------------------
   310                              <1> ;Input: rsi -> SFT to get adjusted open mode for
   311                              <1> ;Output: eax = Adjusted open mode.
   312                              <1> ;All other registers preserved.
   313                              <1> ;--------------------------------------------------------------------
   314                              <1> ;If not an FCB of any kind, then everything is ok. 
   315                              <1> ;If an SFTFCB then we put it into openCompat | openRW.
   316                              <1> ;If a NETFCB then we put it into openCompat.
   317                              <1> ;If RO file opened in openCompat, make into openDenWrShr | openRdAcc.
   318 00000496 53                  <1>     push rbx
   319 00000497 0FB74602            <1>     movzx eax, word [rsi + sft.wOpenMode]
   320 0000049B 66A90080            <1>     test ax, openSFTFCB ;Is this a local FCB?
   321 0000049F 7405                <1>     jz .notFCB
   322 000004A1 B802000000          <1>     mov eax, openCompat | openRWAcc  ;FCBs have r/w access in compat mode
   323                              <1> .notFCB:
   324 000004A6 89C3                <1>     mov ebx, eax
   325 000004A8 81E3F0000000        <1>     and ebx, 0F0h           ;Mask off the access bits
   326 000004AE 81FB70000000        <1>     cmp ebx, openNetFCBShr  ;Is this a net FCB?
   327 000004B4 7505                <1>     jne .notNetFCB
   328 000004B6 250F000000          <1>     and eax, 0Fh        ;Mask off the share bits, turn into compat share
   329                              <1> .notNetFCB:
   330                              <1> ;Now al has the real open mode for this file. Do RO check now
   331 000004BB 89C3                <1>     mov ebx, eax
   332 000004BD 81E3F0000000        <1>     and ebx, 0F0h   ;Isolate possibly adjusted share bits
   333 000004C3 5B                  <1>     pop rbx
   334                              <1>     retnz           ;If not zero, not in compat mode
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000004C4 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000004C6 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   335 000004C7 F6460401            <1>     test byte [rsi + sft.bFileAttrib], attrFileRO
   336                              <1>     retz            ;If zero, RO bit not set
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000004CB 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000004CD C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   337 000004CE B820000000          <1>     mov eax, openDenWrShr | openRdAcc 
   338                              <1>     return
    13                              <2> %%_ret:
    14 000004D3 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   339                              <1> 
   340                              <1> 
   341                              <1> getMFT:
   342                              <1> ;Search for an MFT for a file. If one is not found, it creates it.
   343                              <1> ;Input: rsi -> Filename to search for
   344                              <1> ;Output: CF=NC: rbx -> MFT for this file.
   345                              <1> ;        CF=CY: eax = Error code.
   346                              <1> ;Start by working out the string length and checksum values
   347 000004D4 E8E5000000          <1>     call findMFT        ;Sets dl for checksum and ecx for string length
   348                              <1>     retnc
    61                              <2> cret nc
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000004D9 7201                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000004DB C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   349                              <1> ;We get here if this file has no MFT.
   350                              <1> ;Create an MFT entry. dl and ecx are always preserved in functions below
   351 000004DC 81C116000000        <1>     add ecx, mft_size   ;ecx now has the full MFT entry size
   352 000004E2 E8BB000000          <1>     call findFreeMFT
   353 000004E7 730F                <1>     jnc .buildMFT
   354 000004E9 E847000000          <1>     call defragMFTArena ;Returns rbx -> Free MFT, eax = Free MFT size
   355 000004EE 39C8                <1>     cmp eax, ecx        ;Do we fit in this free space?
   356 000004F0 7306                <1>     jnc .buildMFT
   357                              <1> ;Here if CF=CY. Return Sharing buffer full error!
   358 000004F2 B824000000          <1>     mov eax, errShrFul
   359                              <1>     return
    13                              <2> %%_ret:
    14 000004F7 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   360                              <1> .buildMFT:
   361                              <1> ;Here we have the following values:
   362                              <1> ;rsi -> String to copy in
   363                              <1> ;rbx -> Space to allocate the MFT in. rbx points to a free MFT.
   364                              <1> ;ecx = New MFT full size
   365                              <1> ;dl = String checksum 
   366                              <1> 
   367                              <1> ;Work out if we want to split space into two MFTs or keep it as one.
   368                              <1> ;Check if the MFT we are pointing at has enough space for a minimum mft and
   369                              <1> ; our MFT. If there is more than enough space, we split into two MFTs. 
   370                              <1> ;Else, we just allocate the whole space and waste the few extra bytes.
   371 000004F8 8B4301              <1>     mov eax, dword [rbx + mft.dLen] ;Get the current size of the free MFT
   372 000004FB 29C8                <1>     sub eax, ecx        ;Remove our own allocation from the free MFT size
   373 000004FD 3D26000000          <1>     cmp eax, MIN_MFT_SIZE
   374 00000502 760D                <1>     jbe .alloc   ;If this is beq, we just use this mft entry as is.
   375                              <1> ;eax has the size of the new free block
   376 00000504 488D3C0B            <1>     lea rdi, qword [rbx + rcx]  ;Point rdi past the end of our new mft
   377 00000508 C60700              <1>     mov byte [rdi + mft.bSig], mftFree  ;Make the new free block
   378 0000050B 894701              <1>     mov dword [rdi + mft.dLen], eax     ;Set the new free block's size
   379 0000050E 894B01              <1>     mov dword [rbx + mft.dLen], ecx     ;Set the newly allocated block's size
   380                              <1> .alloc:
   381                              <1> ;Finally, allocate the MFT. The size, if modified, is done already.
   382 00000511 C60301              <1>     mov byte [rbx + mft.bSig], mftAlloc
   383 00000514 48C7430600000000    <1>     mov qword [rbx + mft.pLock], 0
   384 0000051C 48C7430E00000000    <1>     mov qword [rbx + mft.pSFT], 0
   385 00000524 885305              <1>     mov byte [rbx + mft.bCheckSum], dl  ;Set the checksum immediately.
   386 00000527 81E916000000        <1>     sub ecx, mft_size   ;Now get just the string length
   387 0000052D 488D7B16            <1>     lea rdi, qword [rbx + mft.name] 
   388 00000531 F3A4                <1>     rep movsb   ;Move the string over
   389 00000533 F8                  <1>     clc
   390                              <1>     return
    13                              <2> %%_ret:
    14 00000534 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   391                              <1> 
   392                              <1> defragMFTArena:
   393                              <1> ;Defragments the MFT arena. Moves all allocated MFTs to the start.
   394                              <1> ;Creates a single large free MFT from all the free space.
   395                              <1> ;Input: Nothing
   396                              <1> ;Output: MFT defragged. rbx -> New free MFT, eax = New Free MFT size
   397                              <1> ; All other regs preserved.
   398 00000535 51                  <1>     push rcx
   399 00000536 52                  <1>     push rdx
   400 00000537 56                  <1>     push rsi
   401 00000538 57                  <1>     push rdi
   402                              <1> ;rsi = Read pointer
   403                              <1> ;rdi = Write pointer
   404                              <1> ;edx = Free space accumulator
   405 00000539 488B35(00000000)    <1>     mov rsi, qword [pMftArena]
   406 00000540 4889F7              <1>     mov rdi, rsi
   407 00000543 31D2                <1>     xor edx, edx
   408                              <1> .lp:
   409                              <1> ;If we encounter an allocated mft, we move it over, moving the 
   410                              <1> ; the read and write pointers. If we encounter a free mft, we add its
   411                              <1> ; size and move the read pointer.
   412 00000545 803E00              <1>     cmp byte [rsi + mft.bSig], mftFree
   413 00000548 7826                <1>     js .exit    ;At this point, all compression is done. Goto end
   414 0000054A 741A                <1>     je .free
   415                              <1> ;Here we copy over. Before we do, we walk down the SFT chain
   416                              <1> ; updating the MFT pointer in each SFT.
   417                              <1> ;rsi -> Allocated MFT
   418                              <1> ;rdi -> Where this MFT will be moved to
   419 0000054C 488B5E0E            <1>     mov rbx, qword [rsi + mft.pSFT]     ;Point rbx to the first SFT in chain.
   420                              <1> .sftLp:
   421 00000550 4885DB              <1>     test rbx, rbx   ;End of SFT chain?
   422 00000553 740A                <1>     jz .sftEnd
   423 00000555 48897B4F            <1>     mov qword [rbx + sft.pMFT], rdi     ;Update the SFT's MFT pointer
   424 00000559 488B5B3B            <1>     mov rbx, qword [rbx + sft.pNextSFT]
   425 0000055D EBF1                <1>     jmp short .sftLp
   426                              <1> .sftEnd:
   427                              <1> ;All SFTs updated, now we copy the MFT up.
   428 0000055F 8B4E01              <1>     mov ecx, dword [rsi + mft.dLen] ;Get the length of this MFT
   429 00000562 F3A4                <1>     rep movsb   ;Moves both pointers to the end of the MFT
   430                              <1> ;Now rdi points to the next write space and rsi points to the next MFT
   431 00000564 EBDF                <1>     jmp short .lp
   432                              <1> .free:
   433                              <1> ;Dont worry about overflow. Max dLen is 1Mb, way less than 32 bit max.
   434 00000566 8B4601              <1>     mov eax, dword [rsi + mft.dLen] ;Get the length
   435 00000569 01C2                <1>     add edx, eax    ;Add to the free space accumulator
   436 0000056B 4801C6              <1>     add rsi, rax    ;Move the read pointer past this free space
   437 0000056E EBD5                <1>     jmp short .lp
   438                              <1> .exit:
   439                              <1> ;Now we must make a single free MFT at the write pointer with the 
   440                              <1> ; correct size and assert it is correct
   441                              <1> ;rdi -> Where to make this MFT
   442                              <1> ;edx = Accumulated free space
   443 00000570 C60700              <1>     mov byte [rdi + mft.bSig], mftFree
   444 00000573 895701              <1>     mov dword [rdi + mft.dLen], edx
   445 00000576 89D0                <1>     mov eax, edx    ;Get the free MFT size into eax
   446 00000578 4889FB              <1>     mov rbx, rdi    ;Get the free MFT pointer into rbx
   447 0000057B 4801D7              <1>     add rdi, rdx    ;Now check the MFT chain is not corrupted
   448 0000057E 803FFF              <1>     cmp byte [rdi + mft.bSig], mftEnd
   449 00000581 7505                <1>     jne .crash
   450 00000583 5F                  <1>     pop rdi
   451 00000584 5E                  <1>     pop rsi
   452 00000585 5A                  <1>     pop rdx
   453 00000586 59                  <1>     pop rcx
   454                              <1>     return
    13                              <2> %%_ret:
    14 00000587 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   455                              <1> .crash:
   456 00000588 E8D2000000          <1>     call errPrintAndHalt    ;No return. Use call to push string ptr to stack
   457 0000058D 4D4654204445465241- <1>     db "MFT DEFRAG FAILURE",CR,LF,NUL
   457 00000596 47204641494C555245- <1>
   457 0000059F 0D0A00              <1>
   458                              <1> 
   459                              <1> findFreeMFT:
   460                              <1> ;Searches for a free MFT of a particular size or greater.
   461                              <1> ;Input: ecx = Minimum MFT size 
   462                              <1> ;Output: CF=NC: rbx -> MFT of appropriate size
   463                              <1> ;        CF=CY: No MFT found of this size. rbx -> End MFT
   464                              <1> ;Trashes rax. All other regs preserved.
   465 000005A2 488B1D(00000000)    <1>     mov rbx, qword [pMftArena]
   466                              <1> .lp:
   467 000005A9 803B00              <1>     cmp byte [rbx + mft.bSig], mftFree
   468 000005AC 7840                <1>     js findMFT.noMFT    ;If sign bit set, must be mftEnd. Exit error!
   469 000005AE 7506                <1>     jne .next           ;If not equal, must be mftAlloc. Goto next MFT
   470 000005B0 394B01              <1>     cmp dword [rbx + mft.dLen], ecx ;Is this MFT ok sizewise?
   471                              <1>     retnc   ;Not carry means dLen is geq eax, as required
    61                              <2> cret nc
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000005B3 7201                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000005B5 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   472                              <1> .next:
   473 000005B6 8B4301              <1>     mov eax, dword [rbx + mft.dLen]
   474 000005B9 4801C3              <1>     add rbx, rax    ;Point to the next MFT
   475 000005BC EBEB                <1>     jmp short .lp
   476                              <1> 
   477                              <1> findMFT:
   478                              <1> ;Searches for an MFT for the filename in rsi 
   479                              <1> ;Input: rsi -> Filename to search for
   480                              <1> ;       
   481                              <1> ;Output: ecx = String length
   482                              <1> ;        dl = Filename checksum
   483                              <1> ;        CF=NC: rbx -> MFT for file
   484                              <1> ;        CF=CY: No MFT found for this file. rbx -> End MFT
   485                              <1> ;Trashes rax. All other regs preserved.
   486 000005BE E82D000000          <1>     call getNameMeta    ;Sets ecx and dl
   487 000005C3 488B1D(00000000)    <1>     mov rbx, qword [pMftArena]
   488                              <1> .lp:
   489 000005CA 803B00              <1>     cmp byte [rbx + mft.bSig], mftFree  
   490 000005CD 781F                <1>     js .noMFT   ;If sign bit is set, bSig must be -1. End of arena!
   491 000005CF 7415                <1>     je .next    ;If this MFT is free, goto next entry
   492 000005D1 385305              <1>     cmp byte [rbx + mft.bCheckSum], dl  ;Compare checksums
   493 000005D4 7510                <1>     jne .next   ;If not equal, skip entry
   494 000005D6 57                  <1>     push rdi
   495 000005D7 488D7B16            <1>     lea rdi, qword [rbx + mft.name] ;Point to mft filename
   496 000005DB B81E120000          <1>     mov eax, 121Eh  ;Compare strings in rsi and rdi
   497 000005E0 CD2F                <1>     int 2Fh         ;Doesnt modify string pointers
   498 000005E2 5F                  <1>     pop rdi
   499                              <1>     retz    ;If ZF=ZE (also CF=NC), we have found the MFT! Return to caller.
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 000005E3 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000005E5 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   500                              <1> .next:
   501 000005E6 8B4301              <1>     mov eax, dword [rbx + mft.dLen]
   502 000005E9 4801C3              <1>     add rbx, rax    ;Point to the next MFT
   503 000005EC EBDC                <1>     jmp short .lp
   504                              <1> .noMFT:
   505 000005EE F9                  <1>     stc
   506                              <1>     return
    13                              <2> %%_ret:
    14 000005EF C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   507                              <1> 
   508                              <1> getNameMeta:
   509                              <1> ;Gets the string length and checksum value
   510                              <1> ;Input: rsi -> String to search on
   511                              <1> ;Output: ecx = String length
   512                              <1> ;        edx = Checksum value
   513                              <1> ;Trashes eax.
   514 000005F0 56                  <1>     push rsi
   515 000005F1 31C9                <1>     xor ecx, ecx    ;Use for string length (zero inclusive)
   516 000005F3 31D2                <1>     xor edx, edx    ;Use for checksum value (dl)
   517                              <1> .metalp:
   518 000005F5 AC                  <1>     lodsb
   519 000005F6 00C2                <1>     add dl, al
   520 000005F8 80D200              <1>     adc dl, 0       ;Add 1 if this rolls over
   521 000005FB FFC1                <1>     inc ecx
   522 000005FD 84C0                <1>     test al, al
   523 000005FF 75F4                <1>     jnz .metalp
   524 00000601 5E                  <1>     pop rsi
   525                              <1>     return
    13                              <2> %%_ret:
    14 00000602 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   526                              <1> 
   527                              <1> closeJFTEntries:
   528                              <1> ;Closes all JFT entries pointing to a particular SFT for a process.
   529                              <1> ;Input: bl = SFTIndex
   530                              <1> ;       rax = PID
   531                              <1> ;Output: Closes all JFT entries.
   532                              <1> ;Preserves all registers
   533 00000603 50                  <1>     push rax
   534 00000604 E82C000000          <1>     call .isPIDSpecial   ;If the PID is special, we just exit.
   535 00000609 7428                <1>     je .cjeExit2
   536 0000060B 51                  <1>     push rcx
   537 0000060C 57                  <1>     push rdi
   538 0000060D 4889C7              <1>     mov rdi, rax
   539 00000610 0FB74F4E            <1>     movzx ecx, word [rdi + psp.jftSize]   ;Get the size
   540 00000614 488D7F2A            <1>     lea rdi, qword [rdi + psp.jobFileTbl]   ;Point to JFT or JFTptr
   541 00000618 81F914000000        <1>     cmp ecx, dfltJFTsize
   542 0000061E 480F473F            <1>     cmova rdi, qword [rdi]  ;If above normal, pull the JFTPtr
   543 00000622 89D8                <1>     mov eax, ebx    ;Get the SFTIndx to scan for
   544                              <1> .cjeLp:
   545 00000624 F2AE                <1>     repne scasb     ;DOS sets direction so we dont worry
   546 00000626 7508                <1>     jne .cjeExit
   547 00000628 C647FFFF            <1>     mov byte [rdi - 1], -1  ;Free the entry
   548 0000062C 85C9                <1>     test ecx, ecx  ;If we are out of entries, dont reenter loop
   549 0000062E 75F4                <1>     jnz .cjeLp
   550                              <1> .cjeExit:
   551 00000630 F8                  <1>     clc
   552 00000631 5F                  <1>     pop rdi
   553 00000632 59                  <1>     pop rcx
   554                              <1> .cjeExit2:
   555 00000633 58                  <1>     pop rax
   556                              <1>     return
    13                              <2> %%_ret:
    14 00000634 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   557                              <1> .isPIDSpecial:
   558                              <1> ;Certain PIDs have special meaning and must be ignored.
   559                              <1> ;If free or a hole, ignore.
   560                              <1> ;If DOS or New DOS (should NEVER exist outside of a drivers init)
   561                              <1> ; we get return the DOS PSP address in rax and pretend it is not 
   562                              <1> ; special.
   563                              <1> ;Input: rax = PID to check
   564                              <1> ;Output: ZF=ZE: Special PID, don't operate on it
   565                              <1> ;        ZF=NZ: Normal PID, proceed.
   566 00000635 483D00000000        <1>     cmp rax, mcbOwnerFree   ;Bona-fide must be ignored
   567                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000063B 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000063D C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   568 0000063E 483D07000000        <1>     cmp rax, mcbOwnerHole   ;Bona-fide must be ignored 
   569                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000644 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000646 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   570 00000647 483D09000000        <1>     cmp rax, mcbOwnerNewDOS ;None should ever exist from the POV of share.exe
   571 0000064D 7409                <1>     je .ips1
   572 0000064F 483D08000000        <1>     cmp rax, mcbOwnerDOS
   573                              <1>     retne
    53                              <2> cret ne
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000655 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000657 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   574                              <1> .ips1:
   575 00000658 85C0                <1>     test eax, eax   ;eax = 8 or 9 so anding it with itself will clear ZF
   576 0000065A 498B401D            <1>     mov rax, qword [r8 + dosPSP]    ;Get the actual DOS PSP value
   577                              <1>     return
    13                              <2> %%_ret:
    14 0000065E C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   578                              <1>     
   579                              <1> 
   580                              <1> ;Critical error handling
   581                              <1> errPrintAndHalt:
   582                              <1> ;This function is called such that the return address points to the 
   583                              <1> ; null terminated string to print. We never return from this.
   584                              <1> ;********************************************
   585                              <1> ;Consider requesting all disk buffers flush before entering infinite loop.
   586                              <1> ;********************************************
   587                              <1> ;Input: TOS -> Ptr to string to print after header.
   588                              <1> ;Output: Never return.
   589 0000065F 488D3D56000000      <1>     lea rdi, .sHdr
   590 00000666 E80A000000          <1>     call .doWrite
   591 0000066B 5F                  <1>     pop rdi         ;Get the passed in string
   592 0000066C E804000000          <1>     call .doWrite   ;Write the passed in ASCIIZ string.
   593                              <1> .halt:
   594 00000671 F390                <1>     pause           ;Hint the CPU to power down
   595 00000673 EBFC                <1>     jmp short .halt ;Infinite loop, await CTRL+ALT+DEL
   596                              <1> .doWrite:
   597                              <1> ;We write directly to the console driver completely bypassing any 
   598                              <1> ;redirection, without resorting to using BIOS functions.
   599                              <1> ;We use the PSP as the buffer for the ioReqPkt.
   600                              <1> ;We obviously do no error checking or Int 24 invokation if things
   601                              <1> ; go wrong with this. 
   602                              <1> ;Input: rdi -> String to print
   603                              <1> ;Output: Hopefully, string printed.
   604 00000675 B812120000          <1>     mov eax, 1212h  ;Do dos strlen
   605 0000067A CD2F                <1>     int 2Fh         ;Get length of string pointed to by rdi in ecx
   606 0000067C FFC9                <1>     dec ecx ;Drop the terminating null from the count
   607                              <1>     retz    ;If this is zero, forget the error
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000067E 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000680 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   608                              <1> ;1) Build request packet
   609 00000681 488B1D(2E000000)    <1>     mov rbx, qword [pPSP]   ;Get the ptr to our PSP
   610 00000688 C6430208            <1>     mov byte [rbx + ioReqPkt.cmdcde], drvWRITE
   611 0000068C C6032A              <1>     mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   612 0000068F 66C743030000        <1>     mov word [rbx + ioReqPkt.status], 0
   613 00000695 894B16              <1>     mov dword [rbx + ioReqPkt.tfrlen], ecx
   614 00000698 48897B0E            <1>     mov qword [rbx + ioReqPkt.bufptr], rdi
   615                              <1> ;2) Get the driver pointer
   616 0000069C 488B35(26000000)    <1>     mov rsi, qword [pDosseg]    
   617 000006A3 488B765B            <1>     mov rsi, qword [rsi + vConPtr]  ;Get the console driver ptr
   618                              <1> ;Go driver routine here
   619 000006A7 B802800000          <1>     mov eax, 8002h  ;SPECIAL: Enter DOS Level 2 critical section
   620 000006AC CD2A                <1>     int 2ah
   621 000006AE FF560A              <1>     call qword [rsi + drvHdr.strPtr]  ;Passing rbx through here
   622 000006B1 FF5612              <1>     call qword [rsi + drvHdr.intPtr]
   623 000006B4 B802810000          <1>     mov eax, 8102h  ;SPECIAL: Exit DOS Level 2 critical section
   624 000006B9 CD2A                <1>     int 2ah
   625                              <1>     return
    13                              <2> %%_ret:
    14 000006BB C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   626                              <1> .sHdr:
   627 000006BC 0D0A0A              <1>     db CR,LF,LF
   628 000006BF 202020202020202053- <1>     db "        SCP/DOS EXCEPTION DETECTED!",CR,LF,LF
   628 000006C8 43502F444F53204558- <1>
   628 000006D1 43455054494F4E2044- <1>
   628 000006DA 45544543544544210D- <1>
   628 000006E3 0A0A                <1>
   629 000006E5 202020205343502F44- <1>     db "    SCP/DOS SYSTEM STOP: SHARE INTERNAL ERROR : ",NUL
   629 000006EE 4F532053595354454D- <1>
   629 000006F7 2053544F503A205348- <1>
   629 00000700 41524520494E544552- <1>
   629 00000709 4E414C204552524F52- <1>
   629 00000712 203A2000            <1>
    53                                  
    54                                  segment code$i code private align=16 use64
    55                                  %include "./src/share/text/shinit.asm"
     1                              <1> 
     2                              <1> ;Initialises the share program
     3                              <1> ;1) Ensure correct DOS version. We are DOS 1.
     4                              <1> ;2) Parse the command tail. Any malformed char or switch and we abort install.
     5                              <1> ;3) Allocate a block for MFTs. If we cannot allocate we abort install.
     6                              <1> ;4) Allocate a block for file locks. If we cannot allocate we abort install.
     7                              <1> ;5) Halt interrupts
     8                              <1> ;6) Install Int 2Fh handler.
     9                              <1> ;7) Copy over all pointers to internal routines to DOS and set Share byte on.
    10                              <1> ;8) Close all file handles and free the environment.
    11                              <1> ;9) Terminate and stay resident.
    12                              <1> ep:
    13 00000000 B800300000          <1>     mov eax, 3000h  ;Get version number
    14 00000005 CD21                <1>     int 21h
    15 00000007 3C01                <1>     cmp al, 1       ;If below or equal to version 1, we are ok with this
    16 00000009 760E                <1>     jbe goInit
    17 0000000B B0FF                <1>     mov al, -1
    18                              <1> badVerExit:
    19                              <1> ;Input: al = Error code
    20 0000000D 488D15A7020000      <1>     lea rdx, sBadVer
    21 00000014 E994020000          <1>     jmp badPrintAndExit
    22                              <1> goInit:
    23 00000019 4C8905(2E000000)    <1>     mov qword [pPSP], r8    ;Save our PSP pointer
    24 00000020 B800520000          <1>     mov eax, 5200h  ;Get ptr to sysvars
    25 00000025 CD21                <1>     int 21h
    26 00000027 4881EB43000000      <1>     sub rbx, sysVarsPtr ;Subtract the offset into the segment
    27 0000002E 48891D(26000000)    <1>     mov qword [pDosseg], rbx    ;Store ptr to the head of the segment
    28 00000035 B080                <1>     mov al, 80h         ;Error code for no SFT 
    29 00000037 48817B4B00000000    <1>     cmp qword [rbx + sftHeadPtr], 0    ;Check if no SFT ptr
    30 0000003F 74CC                <1>     je badVerExit
    31 00000041 B800100000          <1>     mov eax, 1000h              ;SHARE Int 2f check
    32 00000046 CD2F                <1>     int 2Fh
    33 00000048 3CFF                <1>     cmp al, -1
    34 0000004A 750C                <1>     jne goInstall
    35 0000004C 488D15AA020000      <1>     lea rdx, sInstalled
    36 00000053 E955020000          <1>     jmp badPrintAndExit         ;Jump with al = -1
    37                              <1> goInstall:
    38 00000058 B800610000          <1>     mov eax, 6100h              ;Get the pointer to the environment in rdx
    39 0000005D CD21                <1>     int 21h
    40 0000005F 4885D2              <1>     test rdx, rdx
    41 00000062 740E                <1>     jz skipEnvFree
    42 00000064 4150                <1>     push r8
    43 00000066 4989D0              <1>     mov r8, rdx
    44 00000069 B800490000          <1>     mov eax, 4900h              ;And free the environment
    45 0000006E CD21                <1>     int 21h
    46 00000070 4158                <1>     pop r8
    47                              <1> skipEnvFree:
    48                              <1> ;Initialise the sizes with the defaults
    49 00000072 C705(08000000)0008- <1>     mov dword [dMftArenaSz], MFT_SIZE_DFLT
    49 0000007A 0000                <1>
    50 0000007C 66C705(1C000000)14- <1>     mov word [wNumLocks], LOCKS_DFLT
    50 00000084 00                  <1>
    51                              <1> ;Get switchchar
    52 00000085 B800370000          <1>     mov eax, 3700h              ;Get switchchar
    53 0000008A CD21                <1>     int 21h
    54 0000008C 881528020000        <1>     mov byte [bSwitchChar], dl
    55                              <1> ;Point rsi to cmd line and get string count
    56 00000092 498DB080000000      <1>     lea rsi, qword [r8 + 80h]   ;Go to the command line
    57 00000099 AC                  <1>     lodsb                       ;Get the string length
    58 0000009A 0FB6C8              <1>     movzx ecx, al               ;into ecx
    59                              <1> cmdlineLp:
    60                              <1> ;Here we process the command line. We only allow for /f and /l switches.
    61                              <1> ;Capital and lower case allowed. Parse based on string length.
    62                              <1> ;We really strictly parse to ensure that the user does EXACTLY what they want
    63 0000009D 85C9                <1>     test ecx, ecx
    64 0000009F 0F848C000000        <1>     jz .endParse
    65 000000A5 AC                  <1>     lodsb           ;Read a char
    66 000000A6 FFC9                <1>     dec ecx         ;Dec the count
    67 000000A8 E8EA010000          <1>     call isALsep    ;Is this a sep char?
    68 000000AD 74EE                <1>     je cmdlineLp    ;Keep looping if so
    69 000000AF 85C9                <1>     test ecx, ecx   ;If not, but we have no more chars to process, end parse
    70 000000B1 747E                <1>     jz .endParse
    71 000000B3 3A0501020000        <1>     cmp al, byte [bSwitchChar]
    72 000000B9 753B                <1>     jne .badParamExit
    73 000000BB 88C2                <1>     mov dl, al      ;Capitalise the char
    74 000000BD B820650000          <1>     mov eax, 6520h  ;Capitalise char in dl with normal table
    75 000000C2 CD21                <1>     int 21h
    76 000000C4 80FA46              <1>     cmp dl, "F"
    77 000000C7 743B                <1>     je .mftSwitch
    78 000000C9 80FA4C              <1>     cmp dl, "L"
    79 000000CC 7528                <1>     jne .badParamExit
    80                              <1> ;Here we figure out how many locks were specified.
    81 000000CE E8AC010000          <1>     call getNextChar
    82 000000D3 3C3A                <1>     cmp al, ":"  ;Next char MUST be a semicolon
    83 000000D5 751F                <1>     jne .badParamExit
    84 000000D7 E852010000          <1>     call getASCIINumber
    85 000000DC 81FB0F270000        <1>     cmp ebx, MAX_LOCKS   ;Check the argument not insane
    86 000000E2 7712                <1>     ja .badParamExit
    87 000000E4 66391D(1C000000)    <1>     cmp word [wNumLocks], bx    ;If the new value is less than default, ignore
    88 000000EB 77B0                <1>     ja cmdlineLp
    89 000000ED 66891D(1C000000)    <1>     mov word [wNumLocks], bx
    90 000000F4 EBA7                <1>     jmp short cmdlineLp
    91                              <1> .badParamExit:
    92 000000F6 488D15D6010000      <1>     lea rdx, sBadParam
    93 000000FD B0FF                <1>     mov al, -1
    94 000000FF E9A9010000          <1>     jmp badPrintAndExit
    95                              <1> .mftSwitch:
    96 00000104 E876010000          <1>     call getNextChar
    97 00000109 3C3A                <1>     cmp al, ":"  ;Next char MUST be a semicolon
    98 0000010B 75E9                <1>     jne .badParamExit
    99 0000010D E81C010000          <1>     call getASCIINumber
   100 00000112 81FB00001000        <1>     cmp ebx, MAX_MFT_SIZE
   101 00000118 77DC                <1>     ja .badParamExit
   102 0000011A 391D(08000000)      <1>     cmp dword [dMftArenaSz], ebx
   103 00000120 0F8777FFFFFF        <1>     ja cmdlineLp
   104 00000126 891D(08000000)      <1>     mov dword [dMftArenaSz], ebx
   105 0000012C E96CFFFFFF          <1>     jmp cmdlineLp
   106                              <1> .endParse:
   107                              <1> ;Now we allocate the arenas of the required size and place pointers 
   108                              <1> ; in the right places. 
   109                              <1> ;Do MFT first
   110 00000131 8B1D(08000000)      <1>     mov ebx, dword [dMftArenaSz]    ;This is in bytes
   111 00000137 81C30F000000        <1>     add ebx, 0Fh    ;Round up 
   112 0000013D C1EB04              <1>     shr ebx, 4      ;And convert to paragraphs
   113 00000140 B800480000          <1>     mov eax, 4800h
   114 00000145 CD21                <1>     int 21h
   115 00000147 0F8257010000        <1>     jc badMemError
   116 0000014D 488905(00000000)    <1>     mov qword [pMftArena], rax
   117                              <1> ;Now initialise this arena. Do this by:
   118                              <1> ; 1) Zeroing the whole block
   119                              <1> ; 2) Placing an End MFT entry at the end
   120                              <1> ; 3) Making a single MFT entry that is free and the size of the arena
   121 00000154 4889C7              <1>     mov rdi, rax
   122 00000157 31C0                <1>     xor eax, eax
   123 00000159 8B0D(08000000)      <1>     mov ecx, dword [dMftArenaSz]
   124 0000015F 89CA                <1>     mov edx, ecx    ;Save number of free bytes in the arena
   125 00000161 4889FE              <1>     mov rsi, rdi    ;Save the ptr to the head of the arena
   126 00000164 F3AA                <1>     rep stosb   ;Clear the whole arena
   127                              <1> ;rdi now points one byte past the end
   128 00000166 48FFCF              <1>     dec rdi     ;Now point rdi to the last byte in the arena
   129 00000169 C607FF              <1>     mov byte [rdi + mft.bSig], mftEnd   ;Mark as end of arena
   130 0000016C FFCA                <1>     dec edx     ;One less free byte in the arena
   131                              <1> ;Allocate the first free mft (which takes up the whole arena) at the head 
   132 0000016E C60600              <1>     mov byte [rsi + mft.bSig], mftFree
   133 00000171 895601              <1>     mov dword [rsi + mft.dLen], edx
   134                              <1> ;Get a File Lock arena
   135 00000174 0FB70D(1C000000)    <1>     movzx ecx, word [wNumLocks]
   136 0000017B B829000000          <1>     mov eax, fileLock_size
   137 00000180 F7E1                <1>     mul ecx     ;Multiply eax with ebx. Fits in eax. Sets edx = 0
   138 00000182 89C1                <1>     mov ecx, eax    ;Get number of bytes in ecx
   139 00000184 89CB                <1>     mov ebx, ecx
   140 00000186 81C30F000000        <1>     add ebx, 0Fh    ;Round up
   141 0000018C C1EB04              <1>     shr ebx, 4      ;Get number of paras
   142 0000018F B800480000          <1>     mov eax, 4800h
   143 00000194 CD21                <1>     int 21h
   144 00000196 0F8208010000        <1>     jc badMemError
   145 0000019C 488905(0C000000)    <1>     mov qword [pLockArena], rax 
   146 000001A3 4889C6              <1>     mov rsi, rax    ;Point rsi to the head of the arena
   147 000001A6 4889F7              <1>     mov rdi, rsi    ;Point rdi there too
   148 000001A9 31C0                <1>     xor eax, eax    
   149 000001AB F3AA                <1>     rep stosb   ;Sanitise the space we requested (ignore any overhang)
   150 000001AD 0FB70D(1C000000)    <1>     movzx ecx, word [wNumLocks] ;Get number of locks to process
   151 000001B4 488935(14000000)    <1>     mov qword [pFreeLock], rsi  ;rsi -> Head of the free locks list
   152                              <1> .freeLp:
   153 000001BB 4889F7              <1>     mov rdi, rsi    ;Point rdi to where rsi is pointing
   154 000001BE 4881C629000000      <1>     add rsi, fileLock_size  ;Goto next lock
   155 000001C5 488937              <1>     mov qword [rdi + fileLock.pNext], rsi
   156 000001C8 FFC9                <1>     dec ecx         ;One less lock to process
   157 000001CA 75EF                <1>     jnz .freeLp     ;If not done yet, keep adding them to the free lock list
   158                              <1> ;Get the original Int 2Fh handler in rbx and replace it with our own
   159 000001CC B82F350000          <1>     mov eax, 352Fh
   160 000001D1 CD21                <1>     int 21h 
   161 000001D3 48891D(1E000000)    <1>     mov qword [pOldI2Fh], rbx    ;Save the original Int 2Fh handler
   162 000001DA 488D15(00000000)    <1>     lea rdx, i2fHandler         ;And install our own
   163 000001E1 B82F250000          <1>     mov eax, 252Fh
   164 000001E6 CD21                <1>     int 21h
   165                              <1> ;Set SHARE byte in DOS
   166 000001E8 488B1D(26000000)    <1>     mov rbx, qword [pDosseg]    ;Get dosseg ptr
   167 000001EF C68304040000FF      <1>     mov byte [rbx + shareFlag], -1
   168                              <1> ;Halt interrupts now as we are about to move the share pointers in
   169 000001F6 FA                  <1>     cli
   170 000001F7 488D3519010000      <1>     lea rsi, shareTable
   171 000001FE 488DBBC7000000      <1>     lea rdi, qword [rbx + shareHooks]
   172 00000205 B90F000000          <1>     mov ecx, shareTableL    ;Get number of entries 
   173                              <1> ;copyLp:
   174                              <1> ;    movsq
   175                              <1> ;    lodsq
   176                              <1> ;    add rax, r8             ;Add the program segment base address to relative addr
   177                              <1> ;    stosq
   178                              <1> ;    dec ecx
   179                              <1> ;    jnz copyLp
   180 0000020A F348A5              <1>     rep movsq   ;PE loader does the pointer fixups
   181 0000020D FB                  <1>     sti
   182                              <1> ;Close all handles. We get the number of elements in the jft and 
   183                              <1> ;close them all. This is done like this to account for the fact that the
   184                              <1> ;parent let us inherit more than just the standard handles.
   185 0000020E 410FB6504E          <1>     movzx edx, byte [r8 + psp.jftSize]  ;Get the JFT size
   186 00000213 31DB                <1>     xor ebx, ebx
   187                              <1> closeLp:
   188 00000215 B8003E0000          <1>     mov eax, 3E00h
   189 0000021A CD21                <1>     int 21h
   190 0000021C FFC3                <1>     inc ebx
   191 0000021E 39D3                <1>     cmp ebx, edx
   192 00000220 75F3                <1>     jne closeLp
   193 00000222 BA[10000000]        <1>     mov edx, resLenParas + ((psp_size + 0Fh)>> 4)     
   194 00000227 B800310000          <1>     mov eax, 3100h  ;Terminate and stay resident
   195 0000022C CD21                <1>     int 21h
   196                              <1> ;A TSR call never returns so we end here.
   197                              <1> 
   198                              <1> ;Init Common Routines. Not to be used in the main files
   199                              <1> 
   200                              <1> getASCIINumber:
   201                              <1> ;Accumulates the value in ebx and returns it.
   202                              <1> ;First char read must be a digit, else, we treat a non-digit
   203                              <1> ; as a terminator of the number. 
   204                              <1> ;If the value is greater than 32 bits, treat as invalid input
   205 0000022E 31DB                <1>     xor ebx, ebx
   206 00000230 E84A000000          <1>     call getNextChar    ;First char after : must be a digit
   207 00000235 E851000000          <1>     call isAlDigit
   208 0000023A 0F82B6FEFFFF        <1>     jc cmdlineLp.badParamExit
   209                              <1> .lp:
   210 00000240 250F000000          <1>     and eax, 0Fh    ;Save lower nybble only and zero the rest of the register
   211 00000245 89DD                <1>     mov ebp, ebx    ;Dont use lea because we cant check for carry
   212 00000247 C1E302              <1>     shl ebx, 2      ;4*ebx
   213 0000024A 0F82A6FEFFFF        <1>     jc cmdlineLp.badParamExit
   214 00000250 01EB                <1>     add ebx, ebp    ;5*ebx
   215 00000252 0F829EFEFFFF        <1>     jc cmdlineLp.badParamExit
   216 00000258 D1E3                <1>     shl ebx, 1      ;10*ebx
   217 0000025A 0F8296FEFFFF        <1>     jc cmdlineLp.badParamExit
   218 00000260 01C3                <1>     add ebx, eax    ;Add new digit value
   219 00000262 0F828EFEFFFF        <1>     jc cmdlineLp.badParamExit
   220 00000268 85C9                <1>     test ecx, ecx   ;Stop if we run out of chars to process
   221                              <1>     retz
    41                              <2> cret z
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000026A 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000026C C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   222 0000026D E815000000          <1>     call getNextChar.noCheck    ;Else get the next char
   223 00000272 E814000000          <1>     call isAlDigit              ;If it is a digit, keep processing
   224 00000277 73C7                <1>     jnc .lp
   225                              <1> ;Else, we reset to the first non-digit char and return.
   226 00000279 48FFCE              <1>     dec rsi
   227 0000027C FFC1                <1>     inc ecx
   228                              <1>     return
    13                              <2> %%_ret:
    14 0000027E C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   229                              <1> 
   230                              <1> getNextChar:
   231                              <1> ;Gets the next char in al and decrements count. If count on entry, fail.
   232                              <1> ;Used to wrap processing of chars after a switch char
   233 0000027F 85C9                <1>     test ecx, ecx
   234 00000281 0F846FFEFFFF        <1>     jz cmdlineLp.badParamExit
   235                              <1> .noCheck:
   236 00000287 AC                  <1>     lodsb
   237 00000288 FFC9                <1>     dec ecx
   238                              <1>     return
    13                              <2> %%_ret:
    14 0000028A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   239                              <1> 
   240                              <1> 
   241                              <1> isAlDigit:
   242 0000028B 3C30                <1>     cmp al, "0"
   243 0000028D 7206                <1>     jb .notDigit
   244 0000028F 3C39                <1>     cmp al, "9"
   245 00000291 7702                <1>     ja .notDigit
   246 00000293 F8                  <1>     clc
   247                              <1>     return
    13                              <2> %%_ret:
    14 00000294 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   248                              <1> .notDigit:
   249 00000295 F9                  <1>     stc 
   250                              <1>     return
    13                              <2> %%_ret:
    14 00000296 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   251                              <1> 
   252                              <1> isALsep:
   253 00000297 3C20                <1>     cmp al, SPC
   254                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 00000299 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000029B C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   255 0000029C 3C09                <1>     cmp al, TAB
   256                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3> 
    22                              <3> 
    23                              <3> 
    24                              <3> 
    25                              <3> 
    26                              <3> 
    27                              <3> 
    28                              <3> 
    29                              <3> 
    30                              <3> 
    31                              <3> 
    32                              <3> 
    33                              <3> 
    34 0000029E 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 000002A0 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3> 
   257 000002A1 3C0A                <1>     cmp al, LF
   258                              <1>     return
    13                              <2> %%_ret:
    14 000002A3 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   259                              <1> 
   260                              <1> badMemError:
   261 000002A4 488D153E000000      <1>     lea rdx, sBadMem
   262 000002AB B0FF                <1>     mov al, -1
   263                              <1> badPrintAndExit:
   264                              <1> ;Input: al = Error code to report
   265                              <1> ;       rdx -> String to print
   266 000002AD 50                  <1>     push rax
   267 000002AE B800090000          <1>     mov eax, 0900h
   268 000002B3 CD21                <1>     int 21h
   269 000002B5 58                  <1>     pop rax
   270                              <1> badExit:
   271 000002B6 B44C                <1>     mov ah, 4Ch  ;Exit with error code in al
   272 000002B8 CD21                <1>     int 21h
   273                              <1> 
   274                              <1> ;All the init vars
   275 000002BA 2F                  <1> bSwitchChar db "/"
   276                              <1> ;Here we place all the init strings
   277 000002BB 496E636F7272656374- <1> sBadVer     db "Incorrect DOS version",CR,LF,"$"
   277 000002C4 20444F532076657273- <1>
   277 000002CD 696F6E0D0A24        <1>
   278 000002D3 496E636F7272656374- <1> sBadParam   db "Incorrect parameter",CR,LF,"$"
   278 000002DC 20706172616D657465- <1>
   278 000002E5 720D0A24            <1>
   279 000002E9 4E6F7420656E6F7567- <1> sBadMem     db "Not enough memory",CR,LF,"$"
   279 000002F2 68206D656D6F72790D- <1>
   279 000002FB 0A24                <1>
   280 000002FD 534841524520616C72- <1> sInstalled  db "SHARE already installed",CR,LF,"$"
   280 00000306 6561647920696E7374- <1>
   280 0000030F 616C6C65640D0A24    <1>
   281                              <1> ;Function table, to be ejected
   282                              <1> shareTable:
   283 00000317 0000000000000000    <1>     dq 0
   284 0000031F [1300000000000000]  <1>     dq open           
   285 00000327 [4300000000000000]  <1>     dq close          
   286 0000032F [7300000000000000]  <1>     dq closeAllByMachine      
   287 00000337 [7500000000000000]  <1>     dq closeAllByProcess      
   288 0000033F [7700000000000000]  <1>     dq closeAllByName    
   289 00000347 [7900000000000000]  <1>     dq lockFile       
   290 0000034F [7B00000000000000]  <1>     dq unlockFile     
   291 00000357 [7D00000000000000]  <1>     dq checkRegionLock  
   292 0000035F [7F00000000000000]  <1>     dq getMFTInfo   
   293 00000367 [8100000000000000]  <1>     dq updateFCB 
   294 0000036F [8300000000000000]  <1>     dq getFirstClusterFCB   
   295 00000377 [8500000000000000]  <1>     dq closeNetworkFiles   
   296 0000037F [1C01000000000000]  <1>     dq closeRenDel
   297 00000387 [0202000000000000]  <1>     dq dirUpdate 
   298                              <1> shareTableL equ ($ - shareTable)/8
    56                                  ;=========================END OF SHARE MODULE==========================
    56          ------------------       info: assembly required 1+2+2 passes

