     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   requestHdr  resb ioReqPkt_size   
    12                                      ;The device driver header with space for the largest possible packet
    13 00000033 ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    14 0000003B ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    15 00000043 ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    16 0000004B ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    17 00000053 ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    18                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    19 0000005B ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    20                                      ;                    The last driver loaded with the STDIN bit[0] set
    21 00000063 ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    22 00000065 ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    23 0000006D ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    24 00000075 ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    25 0000007D ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    26 0000007F ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    27 00000080 ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    28 00000081 ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    29 00000082 <res 22h>                   nulDevHdr   resb drvHdr_size
    30                                  
    31                                  ;Swappable, process related data here
    32 000000A4 ??                          inDOS       resb 1    ;Inc on each DOS call, dec when leaving
    33 000000A5 ??                          breakFlag   resb 1    ;If set, check for CTRL+C on all DOS calls
    34 000000A6 ??                          defaultDrv  resb 1    ;Default, last accessed drive
    35 000000A7 ????????????????            currentPSP  resq 1    ;Address of current PSP
    36 000000AF ????????????????            oldRSP      resq 1    ;RSP value before stack switch
    37                                  
    38 000000B7 <res 148h>                  critStack   resq 41
    39 000001FF ????????????????            critStakTop resq 1
    40 00000207 <res 638h>                  IOStack     resq 199
    41 0000083F ????????????????            IOStakTop   resq 1
    42 00000847 <res 638h>                  DiskStack   resq 199
    43 00000E7F ????????????????            DiskStakTop resq 1
    44                                      dSegLen     equ     $
    45                                  
    46                                  Segment .text align=1
    47                                  ; We arrive here with the following values in the registers.
    48                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    49                                  ; dx  = Int 33h boot device number
    50                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    51 00000000 55AA                        dw 0AA55h           ;Initial signature
    52 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    53                                  
    54 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    55 0000000F 0F32                        rdmsr
    56 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    57 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    58 00000017 89C7                        mov edi, eax        ;Get the low dword in
    59                                  
    60 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    60 0000001E [00000000]         
    61 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    62 00000025 4881C7[870E0000]            add rdi, dSegLen ;Move destination past end of data area
    63 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    64 00000033 B900100000                  mov ecx, 1000h
    65 00000038 F348A5                      rep movsq
    66                                  
    67                                  ;Modify the pointers in nData before putting them in the data area
    68 0000003B 48012DC6000000              add qword [nData + drvHdr.nxtPtr], rbp
    69 00000042 48012DC9000000              add qword [nData + drvHdr.strPtr], rbp
    70 00000049 48012DCA000000              add qword [nData + drvHdr.intPtr], rbp
    71                                  ;Copy the Null driver to its location in Sysvars
    72 00000050 B922000000                  mov ecx, drvHdr_size
    73 00000055 488D35AC000000              lea rsi, qword [nData]
    74 0000005C 488DBD[82000000]            lea rdi, qword [rbp + nulDevHdr]
    75 00000063 F3A4                        rep movsb   
    76                                  
    77                                  ;Adjust the addresses in the other driver headers 
    78 00000065 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    78 00000067 [0203000000000000] 
    79 0000006F B90C000000                  mov ecx, 12      ;12 drivers in data area
    80 00000074 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    81                                  adjDrivers:
    82 00000078 E862000000                  call adjustDrvHdr
    83 0000007D E2F9                        loop adjDrivers
    84                                  
    85 0000007F 6687DB                      xchg bx, bx
    86                                      ;Open NUL
    87 00000082 488D9D[8C000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    88 00000089 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    89 0000008C 30C0                        xor al, al
    90 0000008E FFD3                        call rbx
    91                                  
    92                                      ;Open CON
    93 00000090 48BB-                       mov rbx, conDriver
    93 00000092 [B104000000000000] 
    94 0000009A 488D5C1D00                  lea rbx, qword [rbp+rbx]
    95 0000009F 30C0                        xor al, al
    96 000000A1 FFD3                        call rbx
    97                                  
    98                                      ;Open Mass Storage
    99 000000A3 48BB-                       mov rbx, msdDriver
    99 000000A5 [1706000000000000] 
   100 000000AD 488D5C1D00                  lea rbx, qword [rbp+rbx]
   101 000000B2 30C0                        xor al, al
   102 000000B4 FFD3                        call rbx
   103                                  
   104 000000B6 488D2D35000000              lea rbp, qword [startmsg]   ;Get the absolute address of message
   105 000000BD B804130000                  mov eax, 1304h
   106 000000C2 CD30                        int 30h
   107                                  
   108 000000C4 64488B3425-                 mov rsi, fs:[nulDevHdr]
   108 000000C9 [82000000]         
   109 000000CD B801C50000                  mov eax, 0C501h ;Connect debugger
   110 000000D2 CD35                        int 35h
   111                                  l1:
   112 000000D4 6631C0                      xor ax, ax
   113 000000D7 CD36                        int 36h
   114 000000D9 B40E                        mov ah, 0Eh
   115 000000DB CD30                        int 30h
   116 000000DD EBF5                        jmp short l1
   117                                  adjustDrvHdr:
   118                                  ;Input: rsi = Effective address of driver in DOS segment
   119                                  ;       rbp = Ptr to the start of the DOS segment
   120                                  ;Output: rsi = EA of next header in DOS segment
   121 000000DF 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   122 000000E2 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   123 000000E6 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   124 000000EA 4881C622000000              add rsi, drvHdr_size
   125 000000F1 C3                          ret
   126                                  
   127 000000F2 5374617274696E6720-     startmsg db "Starting SCP/DOS...",0Ah,0Dh,0
   127 000000FB 5343502F444F532E2E-
   127 00000104 2E0A0D00           
   128                                  nData:
   129 00000108 [0203000000000000]          dq conHdr
   130 00000110 0480                        dw 08004h
   131 00000112 [AA04000000000000]          dq nulStrat
   132 0000011A [B004000000000000]          dq nulIntr
   133 00000122 4E554C2020202020            db "NUL     " ;Default NUL data
   134                                  
   135                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   136                                  ;-----------------------------------:
   137                                  ;       Misc System routines        :
   138                                  ;-----------------------------------:
   139                                  findLRUBuffer: 
   140                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   141                                  ;Input: Nothing
   142                                  ;Output: rbx = Pointer to the buffer to use
   143 00000000 52                          push rdx
   144 00000001 488B1D(65000000)            mov rbx, qword [bufHeadPtr]
   145 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   146 0000000F 7502                        jne .flb1
   147 00000011 5A                          pop rdx
   148 00000012 C3                          ret
   149                                  .flb1:
   150 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   151 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   152 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   153 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   154 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   155 00000029 488B15(65000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   156 00000030 48891D(65000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   157 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   158 0000003A 5A                          pop rdx
   159 0000003B C3                          ret
   160                                  
   161                                  findDPB:
   162                                  ;Finds the DPB for a given drive
   163                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   164                                  ;Output: al = 00, rbx = Pointer to the DPB
   165                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   166 0000003C 488B1D(43000000)            mov rbx, qword [dpbHeadPtr]
   167                                  .fd1:
   168 00000043 30C0                        xor al, al
   169 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   170 00000047 740F                        je .fd2
   171 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   172 0000004D B0FF                        mov al, -1
   173 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   174 00000056 75EB                        jne .fd1
   175                                  .fd2:
   176 00000058 C3                          ret
   177                                  ;-----------------------------------:
   178                                  ;       File System routines        :
   179                                  ;-----------------------------------:
   180                                  fatProc:
   181                                  ;-----------------------------------:
   182                                  ;        Interrupt routines         :
   183                                  ;-----------------------------------:
   184                                  terminateProcess:   ;Int 40h
   185                                  functionDispatch:   ;Int 41h Main function dispatcher
   186                                  terminateHandler:   ;Int 42h
   187                                  ctrlCHandler:       ;Int 43h
   188                                  critErrorHandler:   ;Int 44h
   189                                  ;User Stack in usage here, must be swapped to before this is called
   190                                  ;Entered with:  
   191                                  ;               AH = Critical Error Bitfield
   192                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   193                                  ;               Bit 6 - Reserved
   194                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   195                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   196                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   197                                  ;               Bits [2-1] = Affected Disk Error
   198                                  ;                     0 0   DOS area
   199                                  ;                     0 1   FAT area
   200                                  ;                     1 0   Directory area
   201                                  ;                     1 1   Data area
   202                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   203                                  ;               AL  = Failing drive number if AH[7] = 0
   204                                  ;               DIL = Error code for errorMsg
   205                                  ;               RSI = EA of Device Header for which device the error occured
   206                                  ;Return:
   207                                  ;               AL = 0 - Ignore the Error       (Ignore)
   208                                  ;                  = 1 - Retry the Operation    (Retry)
   209                                  ;                  = 2 - Terminate the Program  (Abort)
   210                                  ;                  = 3 - Fail the DOS call      (Fail)
   211 00000059 53                          push rbx
   212 0000005A 51                          push rcx
   213 0000005B 52                          push rdx
   214 0000005C 57                          push rdi
   215 0000005D 56                          push rsi
   216 0000005E FC                          cld         ;Make String ops go forward
   217                                  
   218 0000005F 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   219 00000062 488D1540020000              lea rdx, qword [.crlf]
   220 00000069 B409                        mov ah, 09h ;Print String
   221 0000006B CD41                        int 41h     ;Call DOS to print CRLF part of message
   222                                  
   223 0000006D 6681E7FF00                  and di, 00FFh   ;Zero the upper byte of DI just in case
   224 00000072 480FB7FF                    movzx rdi, di
   225 00000076 4889FA                      mov rdx, rdi    ;Copy error code
   226 00000079 48C1E704                    shl rdi, 4  ;Multiply by 16
   227 0000007D 48D1E2                      shl rdx, 1  ;Multiply by 2
   228 00000080 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   229 00000083 488D97[9A010000]            lea rdx, qword [.errorMsgTable + rdi]   ;Load EA to rdx
   230 0000008A B409                        mov ah, 09h ;Print String
   231 0000008C CD41                        int 41h     ;Call DOS to print first part of message
   232                                  
   233 0000008E 488D15F6010000              lea rdx, qword [.readmsg]
   234 00000095 488D3DFE010000              lea rdi, qword [.writemsg]
   235 0000009C F6C701                      test bh, 1  ;Bit 0 is set if write operation
   236 0000009F 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   237 000000A3 B409                        mov ah, 09h ;Print String
   238 000000A5 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   239                                  
   240 000000A7 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   241 000000AA 0F85D0000000                jnz .charError
   242                                  ;Disk error continues here
   243 000000B0 488D15CD010000              lea rdx, qword [.drive] ;Drive message
   244 000000B7 B409                        mov ah, 09h
   245 000000B9 CD41                        int 41h
   246 000000BB 88DA                        mov dl, bl  ;Get zero based drive number into dl
   247 000000BD 80C241                      add dl, "A" ;Add ASCII code
   248 000000C0 B402                        mov ah, 02h ;Print char in dl
   249 000000C2 CD41                        int 41h
   250                                  .userInput:
   251 000000C4 488D15DE010000              lea rdx, qword [.crlf]  ;Print new line
   252 000000CB B409                        mov ah, 09h
   253 000000CD CD41                        int 41h
   254                                  ;Abort, Retry, Ignore, Fail is word order
   255                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   256                                  .userAbort:
   257                                  ;Abort is always an option
   258 000000CF 488D15D6010000              lea rdx, qword [.abortmsg]
   259 000000D6 B409                        mov ah, 09h
   260 000000D8 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   261                                  .userRetry:
   262 000000DA F6C710                      test bh, 10h  ;Bit 4 is retry bit
   263 000000DD 7416                        jz .userIgnore    ;If clear, dont print message
   264 000000DF 488D15DE010000              lea rdx, qword [.betweenMsg]
   265 000000E6 B409                        mov ah, 09h
   266 000000E8 CD41                        int 41h
   267 000000EA 488D15C8010000              lea rdx, qword [.retrymsg]
   268 000000F1 B409                        mov ah, 09h
   269 000000F3 CD41                        int 41h
   270                                  .userIgnore:
   271 000000F5 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   272 000000F8 7416                        jz .userFail
   273 000000FA 488D15C3010000              lea rdx, qword [.betweenMsg]
   274 00000101 B409                        mov ah, 09h
   275 00000103 CD41                        int 41h
   276 00000105 488D15A6010000              lea rdx, qword [.ignoremsg]
   277 0000010C B409                        mov ah, 09h
   278 0000010E CD41                        int 41h
   279                                  .userFail:
   280 00000110 F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   281 00000113 7416                        jz .userMsgEnd
   282 00000115 488D15A8010000              lea rdx, qword [.betweenMsg]
   283 0000011C B409                        mov ah, 09h
   284 0000011E CD41                        int 41h
   285 00000120 488D1598010000              lea rdx, qword [.failmsg]
   286 00000127 B409                        mov ah, 09h
   287 00000129 CD41                        int 41h
   288                                  .userMsgEnd:
   289 0000012B 488D1595010000              lea rdx, qword [.endMsg]
   290 00000132 B409                        mov ah, 09h
   291 00000134 CD41                        int 41h
   292                                  ;Get user input now 
   293                                  .userInputPhase:
   294 00000136 31C9                        xor ecx, ecx  ;4 Possible Responses
   295 00000138 488D3D8B010000              lea rdi, qword [.responses] ;Go to start of string
   296 0000013F B408                        mov ah, 08h ;STDIN without Console Echo
   297 00000141 CD41                        int 41h ;Get char in al
   298 00000143 3C61                        cmp al, "a" ;Chack if lowercase
   299 00000145 7202                        jb .uip1    ;If the value is below, ignore subtraction
   300 00000147 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   301                                  .uip1:
   302 00000149 AE                          scasb   ;Compare char to list, offset gives return code
   303 0000014A 740C                        je .validInput  ;If they are equal, ecx has return code
   304 0000014C FFC1                        inc ecx
   305 0000014E 81F904000000                cmp ecx, 4
   306 00000154 75F3                        jne .uip1
   307 00000156 EBDE                        jmp short .userInputPhase ;If valid char not found, keep waiting 
   308                                  .validInput:
   309 00000158 88C8                        mov al, cl  ;Move the offset into .responses into al
   310                                  ;Now check if the input is permitted
   311 0000015A 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   312 0000015C 741B                        je .cehExit
   313 0000015E 84C0                        test al, al ;Check if 0 => Ignore
   314 00000160 740B                        je .viIgnore
   315 00000162 3C01                        cmp al, 1   ;Check if 1 => Retry
   316 00000164 740E                        je .viRetry
   317                                  .viFail:    ;Fallthrough for fail (al = 3)
   318 00000166 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   319 00000169 74CB                        jz .userInputPhase  ;If bit 3 is zero, get input again
   320 0000016B EB0C                        jmp short .cehExit
   321                                  .viIgnore:
   322 0000016D F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   323 00000170 74C4                        jz .userInputPhase
   324 00000172 EB05                        jmp short .cehExit
   325                                  .viRetry:
   326 00000174 F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   327 00000177 74BD                        jz .userInputPhase
   328                                  .cehExit:
   329 00000179 5E                          pop rsi
   330 0000017A 5F                          pop rdi
   331 0000017B 5A                          pop rdx
   332 0000017C 59                          pop rcx
   333 0000017D 5B                          pop rbx
   334 0000017E 48CF                        iretq
   335                                  .charError:
   336 00000180 B908000000                  mov ecx, 8  ;8 chars in device name
   337 00000185 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   338                                  .ce1:
   339 0000018C AC                          lodsb   ;Get a string char into al and inc rsi
   340 0000018D 88C2                        mov dl, al  ;Move char into dl
   341 0000018F B402                        mov ah, 02h
   342 00000191 CD41                        int 41h ;Print char
   343 00000193 E2F7                        loop .ce1   ;Keep looping until all 8 char device cahrs have been printed
   344 00000195 E92AFFFFFF                  jmp .userInput
   345                                  
   346                                  .errorMsgTable: ;Each table entry is 18 chars long
   347 0000019A 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   347 000001A3 746563742024202020 
   348 000001AC 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   348 000001B5 6E6974202420202020 
   349 000001BE 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   349 000001C7 202420202020202020 
   350 000001D0 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   350 000001D9 6F6D6D616E64202420 
   351 000001E2 44617461204572726F-                 db "Data Error $      "       ;Error 4
   351 000001EB 722024202020202020 
   352 000001F4 426164205265717565-                 db "Bad Request $     "       ;Error 5
   352 000001FD 737420242020202020 
   353 00000206 5365656B2024202020-                 db "Seek $            "       ;Error 6
   353 0000020F 202020202020202020 
   354 00000218 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   354 00000221 656469612024202020 
   355 0000022A 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   355 00000233 7420466F756E642024 
   356 0000023C 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   356 00000245 706572202420202020 
   357 0000024E 577269746520466175-                 db "Write Fault $     "       ;Error A
   357 00000257 6C7420242020202020 
   358 00000260 52656164204661756C-                 db "Read Fault $      "       ;Error B
   358 00000269 742024202020202020 
   359 00000272 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   359 0000027B 61696C757265202420 
   360                                  
   361 00000284 64726976652024          .drive      db "drive $"
   362 0000028B 6572726F7220726561-     .readmsg    db "error reading $"
   362 00000294 64696E672024       
   363 0000029A 6572726F7220777269-     .writemsg   db "error writing $"
   363 000002A3 74696E672024       
   364 000002A9 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   365 000002AC 41626F727424            .abortmsg   db "Abort$" 
   366 000002B2 49676E6F726524          .ignoremsg  db "Ignore$"
   367 000002B9 526574727924            .retrymsg   db "Retry$"
   368 000002BF 4661696C24              .failmsg    db "Fail$"
   369 000002C4 2C2024                  .betweenMsg db ", $"
   370 000002C7 3F2024                  .endMsg     db "? $"
   371 000002CA 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   372                                  absDiskRead:        ;Int 45h
   373                                  ;al = Drive number
   374                                  ;rbx = Memory Buffer address
   375                                  ;ecx = Number of sectors to read (max 255 for now)
   376                                  ;rdx = Start LBA to read from
   377 000002CE 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   378 000002D2 8A80[8C080000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   379 000002D8 4891                        xchg rax, rcx
   380 000002DA 4887CA                      xchg rcx, rdx
   381 000002DD B482                        mov ah, 82h
   382 000002DF CD33                        int 33h
   383 000002E1 48CF                        iretq
   384                                  absDiskWrite:       ;Int 46h
   385 000002E3 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   386 000002E7 8A80[8C080000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   387 000002ED 4891                        xchg rax, rcx
   388 000002EF 4887CA                      xchg rcx, rdx
   389 000002F2 B483                        mov ah, 83h
   390 000002F4 CD33                        int 33h
   391 000002F6 48CF                        iretq
   392                                  terminateResident:  ;Int 47h
   393                                  inDosHandler:       ;Int 48h
   394                                  ;Called when DOS idle
   395 000002F8 48CF                        iretq
   396                                  fastOutput:         ;Int 49h
   397                                  ;Called with char to transfer in al
   398 000002FA 50                          push rax
   399 000002FB B40E                        mov ah, 0Eh
   400 000002FD CD30                        int 30h
   401 000002FF 58                          pop rax
   402 00000300 48CF                        iretq
   403                                  passCommand:        ;Int 4Eh
   404                                  multiplex:          ;Int 4Fh
   405                                  ;-----------------------------------:
   406                                  ;          Driver routines          :
   407                                  ;-----------------------------------:
   408                                  drivers:
   409                                  conHdr:
   410 00000302 [2403000000000000]          dq auxHdr
   411 0000030A 1308                        dw 0813h
   412 0000030C [9A04000000000000]          dq commonStrat
   413 00000314 [B104000000000000]          dq conDriver
   414 0000031C 434F4E2020202020            db "CON     "
   415                                  auxHdr:
   416 00000324 [4603000000000000]          dq prnHdr
   417 0000032C 0080                        dw 08000h
   418 0000032E [9A04000000000000]          dq commonStrat
   419 00000336 [6C05000000000000]          dq com1Intr
   420 0000033E 4155582020202020            db "AUX     "
   421                                  prnHdr:
   422 00000346 [6803000000000000]          dq clkHdr
   423 0000034E 40A0                        dw 0A040h
   424 00000350 [9A04000000000000]          dq commonStrat
   425 00000358 [3404000000000000]          dq lpt1Hdr
   426 00000360 50524E2020202020            db "PRN     "
   427                                  clkHdr:
   428 00000368 [8A03000000000000]          dq msdHdr
   429 00000370 0880                        dw 08008h
   430 00000372 [9A04000000000000]          dq commonStrat
   431 0000037A [6C05000000000000]          dq clkDriver
   432 00000382 434C4F434B242020            db "CLOCK$  "
   433                                  msdHdr:
   434 0000038A [AC03000000000000]          dq com1Hdr
   435 00000392 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   436 00000394 [9A04000000000000]          dq commonStrat
   437 0000039C [1706000000000000]          dq msdDriver
   438 000003A4 0000000000000000            db 0,0,0,0,0,0,0,0
   439                                  com1Hdr:
   440 000003AC [CE03000000000000]          dq com2Hdr
   441 000003B4 0080                        dw 08000h
   442 000003B6 [9A04000000000000]          dq commonStrat
   443 000003BE [6C05000000000000]          dq com1Intr
   444 000003C6 434F4D3120202020            db "COM1    "
   445                                  com2Hdr:
   446 000003CE [F003000000000000]          dq com3Hdr
   447 000003D6 0080                        dw 08000h
   448 000003D8 [9A04000000000000]          dq commonStrat
   449 000003E0 [7505000000000000]          dq com2Intr
   450 000003E8 434F4D3220202020            db "COM2    "
   451                                  com3Hdr:
   452 000003F0 [1204000000000000]          dq com4Hdr
   453 000003F8 0080                        dw 08000h
   454 000003FA [9A04000000000000]          dq commonStrat
   455 00000402 [7E05000000000000]          dq com3Intr
   456 0000040A 434F4D3320202020            db "COM3    "
   457                                  com4Hdr:
   458 00000412 [3404000000000000]          dq lpt1Hdr
   459 0000041A 0080                        dw 08000h
   460 0000041C [9A04000000000000]          dq commonStrat
   461 00000424 [8705000000000000]          dq com4Intr
   462 0000042C 434F4D3420202020            db "COM4    "
   463                                  lpt1Hdr:
   464 00000434 [5604000000000000]          dq lpt2Hdr
   465 0000043C 40A0                        dw 0A040h
   466 0000043E [9A04000000000000]          dq commonStrat
   467 00000446 [0706000000000000]          dq lptDriver
   468 0000044E 4C50543120202020            db "LPT1    "
   469                                  lpt2Hdr:
   470 00000456 [7804000000000000]          dq lpt3Hdr
   471 0000045E 40A0                        dw 0A040h
   472 00000460 [9A04000000000000]          dq commonStrat
   473 00000468 [0706000000000000]          dq lptDriver
   474 00000470 4C50543220202020            db "LPT2    "
   475                                  lpt3Hdr:
   476 00000478 FFFFFFFFFFFFFFFF            dq -1
   477 00000480 40A0                        dw 0A040h
   478 00000482 [9A04000000000000]          dq commonStrat
   479 0000048A [0706000000000000]          dq lptDriver
   480 00000492 4C50543320202020            dq "LPT3    "
   481                                  
   482                                  commonStrat:
   483                                  ;DOS calls this function with rbx=Ptr to request header
   484 0000049A 48891D01000000              mov qword [reqHdrPtr], rbx
   485 000004A1 C3                          ret
   486 000004A2 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   487                                  
   488                                  nulStrat:
   489 000004AA 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   490                                  nulIntr:
   491 000004B0 C3                          ret
   492                                  
   493                                  conDriver:
   494 000004B1 50                          push rax
   495 000004B2 53                          push rbx
   496 000004B3 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   497 000004BA 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   498 000004BD 84C0                        test al, al
   499 000004BF 7421                        jz conInit
   500 000004C1 3C04                        cmp al, 4
   501 000004C3 744D                        jz conRead
   502 000004C5 3C05                        cmp al, 5
   503 000004C7 7466                        jz conNondestructiveRead
   504 000004C9 3C06                        cmp al, 6
   505 000004CB 740C                        jz conExit
   506 000004CD 3C07                        cmp al, 7
   507 000004CF 7471                        jz conFlushInputBuffers
   508 000004D1 3C08                        cmp al, 8
   509 000004D3 7479                        jz conWrite
   510 000004D5 3C09                        cmp al, 9
   511 000004D7 7475                        jz conWrite
   512                                  ;All other cases fall through here
   513                                  conExit:
   514 000004D9 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   515 000004DF 5B                          pop rbx
   516 000004E0 58                          pop rax
   517 000004E1 C3                          ret
   518                                  conInit:    ;Function 0
   519 000004E2 52                          push rdx
   520                                      ;Flush keyboard buffer
   521                                  .ci0:
   522 000004E3 B401                        mov ah, 01      ;Get buffer status
   523 000004E5 CD36                        int 36h
   524 000004E7 7406                        jz .ci1      ;If zero clear => no more keys to read
   525 000004E9 30E4                        xor ah, ah
   526 000004EB CD36                        int 36h ;Read key to flush from buffer
   527 000004ED EBF4                        jmp short .ci0
   528                                  .ci1:
   529 000004EF B800050000                  mov eax, 0500h  ;Set page zero as the default page
   530 000004F4 CD30                        int 30h
   531 000004F6 B402                        mov ah, 02h
   532 000004F8 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   533 000004FA 88D7                        mov bh, dl      ;Set cursor for page 0
   534 000004FC CD30                        int 30h
   535 000004FE B707                        mov bh, 07h     ;Grey/Black attribs
   536 00000500 B800060000                  mov eax, 0600h  ;Clear whole screen
   537 00000505 CD30                        int 30h
   538 00000507 5A                          pop rdx
   539 00000508 EBCF                        jmp short conExit
   540                                  conIORead:
   541 0000050A 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   542 00000510 EBC7                        jmp short conExit
   543                                  conRead:    ;Function 4
   544 00000512 57                          push rdi
   545 00000513 51                          push rcx
   546 00000514 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   547 00000518 31C9                        xor ecx, ecx    ;Zero the char counter
   548                                  .cr1:
   549 0000051A 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   550 0000051D 7409                        je .cre2
   551 0000051F 31C0                        xor eax, eax
   552 00000521 CD36                        int 36h
   553 00000523 AA                          stosb   ;Store char in al into buffer and inc rdi
   554 00000524 FFC1                        inc ecx
   555 00000526 EBF2                        jmp short .cr1
   556                                  .cre2:
   557 00000528 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   558 0000052B 59                          pop rcx
   559 0000052C 5F                          pop rdi
   560 0000052D EBAA                        jmp short conExit
   561                                  conNondestructiveRead:  ;Function 5
   562 0000052F B401                        mov ah, 01h     ;Get key if exists
   563 00000531 CD36                        int 36h
   564 00000533 7405                        jz .cnr           ;If zero clear => no key, go forwards
   565                                      ;Keystroke available
   566 00000535 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   567 00000538 EB9F                        jmp short conExit
   568                                  .cnr: ;No keystroke available
   569 0000053A 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   570 00000540 EB97                        jmp short conExit
   571                                  conFlushInputBuffers:   ;Function 7
   572 00000542 B401                        mov ah, 01      ;Get buffer status
   573 00000544 CD36                        int 36h
   574 00000546 7491                        jz conExit      ;If zero clear => no more keys to read
   575 00000548 30E4                        xor ah, ah
   576 0000054A CD36                        int 36h ;Read key to flush from buffer
   577 0000054C EBF4                        jmp short conFlushInputBuffers
   578                                  conWrite:   ;Function 8 and 9
   579 0000054E 56                          push rsi
   580 0000054F 51                          push rcx
   581 00000550 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   582 00000554 31C9                        xor ecx, ecx    ;Zero the char counter
   583                                  .cw1: 
   584 00000556 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   585 00000559 7407                        je .cw2
   586 0000055B AC                          lodsb   ;Get char into al, and inc rsi
   587 0000055C CD49                        int 49h ;Fast print char
   588 0000055E FFC1                        inc ecx
   589 00000560 EBF4                        jmp short .cw1 ;keep printing until all chars printed
   590                                  .cw2:
   591 00000562 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   592 00000565 59                          pop rcx
   593 00000566 5E                          pop rsi
   594 00000567 E96DFFFFFF                  jmp conExit
   595                                  
   596                                  clkDriver:
   597                                  
   598                                  comDriver:
   599                                  com1Intr:
   600 0000056C C6059300000000              mov byte [comDevice], 0
   601 00000573 EB19                        jmp short comIntr
   602                                  com2Intr:
   603 00000575 C6058A00000001              mov byte [comDevice], 1
   604 0000057C EB10                        jmp short comIntr
   605                                  com3Intr:
   606 0000057E C6058100000002              mov byte [comDevice], 2
   607 00000585 EB07                        jmp short comIntr
   608                                  com4Intr:
   609 00000587 C6057800000003              mov byte [comDevice], 3
   610                                  comIntr:
   611 0000058E 50                          push rax
   612 0000058F 53                          push rbx
   613 00000590 51                          push rcx
   614 00000591 52                          push rdx
   615 00000592 56                          push rsi
   616 00000593 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   617 0000059A 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   618 0000059D 3C04                        cmp al, 4
   619 0000059F 7418                        jz comRead
   620 000005A1 3C05                        cmp al, 5
   621 000005A3 7439                        jz comNondestructiveRead
   622 000005A5 3C08                        cmp al, 8
   623 000005A7 743D                        jz comWrite
   624 000005A9 3C09                        cmp al, 9
   625 000005AB 7439                        jz comWrite
   626                                  ;All other cases fall through here
   627                                  comExit:
   628 000005AD 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   629 000005B3 5E                          pop rsi
   630 000005B4 5A                          pop rdx
   631 000005B5 59                          pop rcx
   632 000005B6 5B                          pop rbx
   633 000005B7 58                          pop rax
   634 000005B8 C3                          ret
   635                                  comRead:
   636 000005B9 57                          push rdi
   637 000005BA 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   638 000005BE 31C9                        xor ecx, ecx    ;Zero the char counter
   639                                  .cr1:
   640 000005C0 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   641 000005C3 7413                        je .cre2
   642 000005C5 B802000000                  mov eax, 02h    ;Recieve 
   643 000005CA 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   644 000005D1 CD34                        int 34h ;Recieve Char
   645 000005D3 AA                          stosb   ;Store char in al into buffer and inc rdi
   646 000005D4 FFC1                        inc ecx
   647 000005D6 EBE8                        jmp short .cr1
   648                                  .cre2:
   649 000005D8 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   650 000005DB 5F                          pop rdi
   651 000005DC EBCF                        jmp short comExit
   652                                  comNondestructiveRead:
   653 000005DE 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
   654 000005E4 EBC7                        jmp short comExit
   655                                  comWrite:
   656 000005E6 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   657 000005EA 31C9                        xor ecx, ecx    ;Zero the char counter
   658                                  .cw1: 
   659 000005EC 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   660 000005EF 7410                        je .cw2
   661 000005F1 AC                          lodsb   ;Get char into al, and inc rsi
   662 000005F2 B401                        mov ah, 01h ;Move function number into ah
   663 000005F4 668B150B000000              mov dx, word [comDevice]
   664 000005FB CD34                        int 34h ;Transmit char
   665 000005FD FFC1                        inc ecx
   666 000005FF EBEB                        jmp short .cw1 ;keep printing until all chars printed
   667                                  .cw2:
   668 00000601 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   669 00000604 EBA7                        jmp short comExit
   670 00000606 00                      comDevice   db 0
   671                                  
   672                                  lptDriver:    ;Drivers for LPT 1, 2, 3
   673 00000607 57                          push rdi
   674 00000608 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
   675 0000060F 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
   676 00000615 5F                          pop rdi
   677 00000616 C3                          ret
   678                                  
   679                                  msdDriver:
   680 00000617 50                          push rax
   681 00000618 53                          push rbx
   682 00000619 51                          push rcx
   683 0000061A 52                          push rdx
   684 0000061B 56                          push rsi
   685 0000061C 57                          push rdi
   686 0000061D 55                          push rbp
   687 0000061E 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
   688 00000625 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
   689 00000628 3C18                        cmp al, 24  ;Check cmd num is valid
   690 0000062A 776C                        ja .msdError
   691 0000062C 84C0                        test al, al
   692 0000062E 7476                        jz .msdInit
   693 00000630 3C01                        cmp al, 01
   694 00000632 0F8409010000                jz .msdMedChk
   695 00000638 3C02                        cmp al, 02
   696 0000063A 0F8442010000                jz .msdBuildBPB
   697 00000640 3C03                        cmp al, 03
   698 00000642 0F847B010000                jz .msdIOCTLRead
   699 00000648 3C04                        cmp al, 04
   700 0000064A 0F8478010000                jz .msdRead
   701 00000650 3C08                        cmp al, 08
   702 00000652 0F8482010000                jz .msdWrite
   703 00000658 3C09                        cmp al, 09
   704 0000065A 0F848C010000                jz .msdWriteVerify
   705 00000660 3C0C                        cmp al, 12
   706 00000662 0F849D010000                jz .msdIOCTLWrite
   707 00000668 3C0D                        cmp al, 13
   708 0000066A 0F849A010000                jz .msdDevOpen
   709 00000670 3C0E                        cmp al, 14
   710 00000672 0F84A2010000                jz .msdDevClose
   711 00000678 3C0F                        cmp al, 15
   712 0000067A 0F84AA010000                jz .msdRemovableMedia
   713 00000680 3C13                        cmp al, 19
   714 00000682 0F84C0010000                jz .msdGenericIOCTL
   715 00000688 3C17                        cmp al, 23
   716 0000068A 0F84BD010000                jz .msdGetLogicalDev
   717 00000690 3C18                        cmp al, 24
   718 00000692 0F84C3010000                jz .msdSetLogicalDev
   719                                  .msdError:
   720                                  .msdDriverExit:
   721 00000698 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
   722 0000069E 5D                          pop rbp
   723 0000069F 5F                          pop rdi
   724 000006A0 5E                          pop rsi
   725 000006A1 5A                          pop rdx
   726 000006A2 59                          pop rcx
   727 000006A3 5B                          pop rbx
   728 000006A4 58                          pop rax
   729 000006A5 C3                          ret
   730                                  .msdInit:            ;Function 0
   731 000006A6 CD31                        int 31h ;Get number of Int 33h devices in r8b
   732 000006A8 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
   733 000006AC 4489C0                      mov eax, r8d
   734 000006AF 3C01                        cmp al, 1
   735 000006B1 7702                        ja .mi1
   736 000006B3 FEC0                        inc al ;Make it two
   737                                  .mi1:
   738 000006B5 BA05000000                  mov edx, 5
   739 000006BA 39D0                        cmp eax, edx
   740 000006BC 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
   741 000006BF 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
   742 000006C5 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
   743 000006C8 440005(7F000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
   744 000006CF 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
   745 000006D1 488D3DE6010000              lea rdi, qword [.msdBPBblks]
   746 000006D8 53                          push rbx
   747                                  .mi2:
   748 000006D9 89EA                        mov edx, ebp
   749 000006DB 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
   750 000006E2 31C9                        xor ecx, ecx    ;Sector 0
   751 000006E4 B801820000                  mov eax, 8201h       ;Read 1 sector
   752 000006E9 CD33                        int 33h
   753 000006EB 724E                        jc .msdInitError
   754                                  
   755 000006ED 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
   756 000006F4 B90F000000                  mov ecx, bpbEx_size/8
   757 000006F9 F348A5                      rep movsq   ;Move the BPB data into the right block
   758                                  
   759 000006FC FFC5                        inc ebp
   760 000006FE 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
   761 00000701 75D6                        jne .mi2  ;No? Go again
   762                                  
   763 00000703 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
   764 0000070A 488D15AD010000              lea rdx, qword [.msdBPBblks]
   765                                  .mi3:
   766 00000711 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
   767 00000714 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
   768 0000071B FFCD                        dec ebp
   769 0000071D 75F2                        jnz .mi3  ;If not zero yet, go again
   770                                  
   771 0000071F 5B                          pop rbx
   772 00000720 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
   773 00000727 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
   774 0000072B 488D15E4030000              lea rdx, qword [driverDataPtr]
   775 00000732 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
   776 00000736 E95DFFFFFF                  jmp .msdDriverExit
   777                                  .msdInitError:
   778 0000073B 5B                          pop rbx
   779 0000073C E957FFFFFF                  jmp .msdDriverExit
   780                                  .msdMedChk:          ;Function 1
   781                                  ;Once the BIOS function is implmented that reads the changeline, use that!
   782                                  ;For BIOSes that dont support the changeline, the following procedure will 
   783                                  ; suffice.
   784 00000741 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
   785 00000746 8A90[8C080000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
   786 0000074C F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
   787 0000074F 7528                        jnz .mmcNoChange
   788                                  ;Now we test Media Descriptor
   789 00000751 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
   790 00000754 488B3CC5[96080000]          mov rdi, qword [.msdBPBTbl + 8*rax]
   791 0000075C 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
   792 0000075F 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
   793 00000762 740C                        je .mmcUnsure
   794                                  .mmcChange: ;Fail safe, always assume the device has changed
   795 00000764 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
   796 00000768 48C7430F[82080000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
   797                                  .mmcUnsure:
   798 00000770 C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
   799 00000774 E91FFFFFFF                  jmp .msdDriverExit
   800                                  .mmcNoChange:
   801 00000779 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
   802 0000077D E916FFFFFF                  jmp .msdDriverExit
   803                                  
   804                                  .msdBuildBPB:        ;Function 2
   805 00000782 4889DE                      mov rsi, rbx
   806 00000785 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
   807 0000078A 8A90[8C080000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
   808 00000790 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
   809 00000794 31C9                        xor ecx, ecx    ;Read Sector 0
   810 00000796 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
   811 0000079B CD33                        int 33h
   812 0000079D 7224                        jc .mbbpbError
   813 0000079F 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
   814 000007A2 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
   815 000007A7 488B3CC5[96080000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
   816 000007AF 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
   817 000007B2 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
   818 000007B6 B90F000000                  mov ecx, bpbEx_size/8
   819 000007BB F348A5                      rep movsq   ;Move the BPB data into the right space
   820 000007BE E9D5FEFFFF                  jmp .msdDriverExit
   821                                  .mbbpbError:
   822                                  .msdIOCTLRead:       ;Function 3, returns done
   823 000007C3 E9D0FEFFFF                  jmp .msdDriverExit
   824                                  .msdRead:            ;Function 4
   825 000007C8 4889DD                      mov rbp, rbx
   826 000007CB B482                        mov ah, 82h ;LBA Read Sectors
   827 000007CD E897000000                  call .msdBlkIOCommon
   828 000007D2 4889EB                      mov rbx, rbp
   829 000007D5 E9BEFEFFFF                  jmp .msdDriverExit
   830                                  .msdWrite:           ;Function 8
   831 000007DA 4889DD                      mov rbp, rbx
   832 000007DD B483                        mov ah, 83h ;LBA Write Sectors
   833 000007DF E885000000                  call .msdBlkIOCommon
   834 000007E4 4889EB                      mov rbx, rbp
   835 000007E7 E9ACFEFFFF                  jmp .msdDriverExit
   836                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
   837 000007EC 4889DD                      mov rbp, rbx
   838 000007EF B483                        mov ah, 83h ;LBA Write Sectors
   839 000007F1 E873000000                  call .msdBlkIOCommon
   840 000007F6 B484                        mov ah, 84h ;LBA Verify Sectors
   841 000007F8 E86C000000                  call .msdBlkIOCommon
   842 000007FD 4889EB                      mov rbx, rbp
   843 00000800 E993FEFFFF                  jmp .msdDriverExit
   844                                  .msdIOCTLWrite:      ;Function 12, returns done
   845 00000805 E98EFEFFFF                  jmp .msdDriverExit
   846                                  .msdDevOpen:         ;Function 13
   847 0000080A 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
   848 0000080F FE80[91080000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
   849 00000815 E97EFEFFFF                  jmp .msdDriverExit
   850                                  .msdDevClose:        ;Function 14
   851 0000081A 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
   852 0000081F FE88[91080000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
   853 00000825 E96EFEFFFF                  jmp .msdDriverExit
   854                                  .msdRemovableMedia:  ;Function 15
   855 0000082A 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
   856 0000082F 8A80[8C080000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
   857 00000835 A880                        test al, 80h
   858 00000837 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
   859 0000083D 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
   860 00000843 E950FEFFFF                  jmp .msdDriverExit
   861                                  .msdGenericIOCTL:    ;Function 19
   862 00000848 E94BFEFFFF                  jmp .msdDriverExit
   863                                  .msdGetLogicalDev:   ;Function 23
   864 0000084D 8A0538000000                mov al, byte [.msdCurDev]
   865 00000853 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
   866 00000856 E93DFEFFFF                  jmp .msdDriverExit
   867                                  .msdSetLogicalDev:   ;Function 24
   868 0000085B 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
   869 0000085E 880527000000                mov byte [.msdCurDev], al
   870 00000864 E92FFEFFFF                  jmp .msdDriverExit
   871                                  
   872                                  .msdBlkIOCommon:  ;Does block IO
   873                                  ;Called with rbp containing old rbx value and ah with function number
   874                                  ;Error handled by caller
   875 00000869 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
   876 0000086E 8A90[8C080000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
   877 00000874 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
   878 00000878 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
   879 0000087B 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
   880 0000087F CD33                        int 33h
   881 00000881 C3                          ret
   882                                  
   883 00000882 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
   884                                  ;LASTDRIVE default is 5
   885 0000088B 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
   886                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
   887 0000088C 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
   888 00000891 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
   889 00000896 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
   889 0000089F 000000000000000000-
   889 000008A8 000000000000000000-
   889 000008B1 000000000000000000-
   889 000008BA 00000000           
   890 000008BE 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
   890 000008C7 000000000000000000-
   890 000008D0 000000000000000000-
   890 000008D9 000000000000000000-
   890 000008E2 000000000000000000-
   890 000008EB 000000000000000000-
   890 000008F4 000000000000000000-
   890 000008FD 000000000000000000-
   890 00000906 000000000000000000-
   890 0000090F 000000000000000000-
   890 00000918 000000000000000000-
   890 00000921 000000000000000000-
   890 0000092A 000000000000000000-
   890 00000933 000000000000000000-
   890 0000093C 000000000000000000-
   890 00000945 000000000000000000-
   890 0000094E 000000000000000000-
   890 00000957 000000000000000000-
   890 00000960 000000000000000000-
   890 00000969 000000000000000000-
   890 00000972 000000000000000000-
   890 0000097B 000000000000000000-
   890 00000984 000000000000000000-
   890 0000098D 000000000000000000-
   890 00000996 000000000000000000-
   890 0000099F 000000000000000000-
   890 000009A8 000000000000000000-
   890 000009B1 000000000000000000-
   890 000009BA 000000000000000000-
   890 000009C3 000000000000000000-
   890 000009CC 000000000000000000-
   890 000009D5 000000000000000000-
   890 000009DE 000000000000000000-
   890 000009E7 000000000000000000-
   890 000009F0 000000000000000000-
   890 000009F9 000000000000000000-
   890 00000A02 000000000000000000-
   890 00000A0B 000000000000000000-
   890 00000A14 000000000000000000-
   890 00000A1D 000000000000000000-
   890 00000A26 000000000000000000-
   890 00000A2F 000000000000000000-
   890 00000A38 000000000000000000-
   890 00000A41 000000000000000000-
   890 00000A4A 000000000000000000-
   890 00000A53 000000000000000000-
   890 00000A5C 000000000000000000-
   890 00000A65 000000000000000000-
   890 00000A6E 000000000000000000-
   890 00000A77 000000000000000000-
   890 00000A80 000000000000000000-
   890 00000A89 000000000000000000-
   890 00000A92 000000000000000000-
   890 00000A9B 000000000000000000-
   890 00000AA4 000000000000000000-
   890 00000AAD 000000000000000000-
   890 00000AB6 000000000000000000-
   890 00000ABF 000000000000000000-
   890 00000AC8 000000000000000000-
   890 00000AD1 000000000000000000-
   890 00000ADA 000000000000000000-
   890 00000AE3 000000000000000000-
   890 00000AEC 000000000000000000-
   890 00000AF5 000000000000000000-
   890 00000AFE 000000000000000000-
   890 00000B07 000000000000000000-
   890 00000B10 000000000000       
   891                                  
   892                                  driverDataPtr:
