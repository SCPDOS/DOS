     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame   
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, rbp + 0
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> endstruc
   186                              <1> 
   187                              <1> %macro pushDOS 0
   188                              <1>     push r9
   189                              <1>     push r8
   190                              <1>     push rbp
   191                              <1>     push rdi
   192                              <1>     push rsi
   193                              <1>     push rdx
   194                              <1>     push rcx
   195                              <1>     push rbx
   196                              <1>     push rax
   197                              <1> %endmacro
   198                              <1> 
   199                              <1> %macro popDOS 0
   200                              <1>     pop rax
   201                              <1>     pop rbx
   202                              <1>     pop rcx
   203                              <1>     pop rdx
   204                              <1>     pop rsi
   205                              <1>     pop rdi
   206                              <1>     pop r8
   207                              <1>     pop r9
   208                              <1> %endmacro
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   requestHdr  resb ioReqPkt_size   
    12                                      ;The device driver header with space for the largest possible packet
    13 00000033 ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    14 0000003B ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    15 00000043 ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    16 0000004B ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    17 00000053 ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    18                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    19 0000005B ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    20                                      ;                    The last driver loaded with the STDIN bit[0] set
    21 00000063 ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    22 00000065 ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    23 0000006D ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    24 00000075 ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    25 0000007D ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    26 0000007F ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    27 00000080 ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    28 00000081 ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    29 00000082 <res 22h>                   nulDevHdr   resb drvHdr_size
    30                                  
    31                                  ;Swappable, process related data here
    32 000000A4 ??                          inDOS       resb 1    ;Inc on each DOS call, dec when leaving
    33 000000A5 ??                          breakFlag   resb 1    ;If set, check for CTRL+C on all DOS calls
    34 000000A6 ??                          defaultDrv  resb 1    ;Default, last accessed drive
    35 000000A7 ????????????????            currentPSP  resq 1    ;Address of current PSP
    36 000000AF ????????????????            oldRSP      resq 1    ;RSP value before stack switch
    37                                  
    38 000000B7 <res 528h>                  critStack   resq 165
    39 000005DF ????????????????            critStakTop resq 1
    40 000005E7 <res 638h>                  IOStack     resq 199
    41 00000C1F ????????????????            IOStakTop   resq 1
    42 00000C27 <res 638h>                  DiskStack   resq 199
    43 0000125F ????????????????            DiskStakTop resq 1
    44                                      dSegLen     equ     $
    45                                  
    46                                  Segment .text align=1
    47                                  ; We arrive here with the following values in the registers.
    48                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    49                                  ; dx  = Int 33h boot device number
    50                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    51 00000000 55AA                        dw 0AA55h           ;Initial signature
    52 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    53                                  
    54 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    55 0000000F 0F32                        rdmsr
    56 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    57 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    58 00000017 89C7                        mov edi, eax        ;Get the low dword in
    59                                  
    60 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    60 0000001E [00000000]         
    61 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    62 00000025 4881C7[67120000]            add rdi, dSegLen ;Move destination past end of data area
    63 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    64 00000033 B900100000                  mov ecx, 1000h
    65 00000038 F348A5                      rep movsq
    66                                  
    67                                  ;Modify the pointers in nData before putting them in the data area
    68 0000003B 48012DC6000000              add qword [nData + drvHdr.nxtPtr], rbp
    69 00000042 48012DC9000000              add qword [nData + drvHdr.strPtr], rbp
    70 00000049 48012DCA000000              add qword [nData + drvHdr.intPtr], rbp
    71                                  ;Copy the Null driver to its location in Sysvars
    72 00000050 B922000000                  mov ecx, drvHdr_size
    73 00000055 488D35AC000000              lea rsi, qword [nData]
    74 0000005C 488DBD[82000000]            lea rdi, qword [rbp + nulDevHdr]
    75 00000063 F3A4                        rep movsb   
    76                                  
    77                                  ;Adjust the addresses in the other driver headers 
    78 00000065 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    78 00000067 [5906000000000000] 
    79 0000006F B90C000000                  mov ecx, 12      ;12 drivers in data area
    80 00000074 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    81                                  adjDrivers:
    82 00000078 E862000000                  call adjustDrvHdr
    83 0000007D E2F9                        loop adjDrivers
    84                                  
    85 0000007F 6687DB                      xchg bx, bx
    86                                      ;Open NUL
    87 00000082 488D9D[8C000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    88 00000089 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    89 0000008C 30C0                        xor al, al
    90 0000008E FFD3                        call rbx
    91                                  
    92                                      ;Open CON
    93 00000090 48BB-                       mov rbx, conDriver
    93 00000092 [0808000000000000] 
    94 0000009A 488D5C1D00                  lea rbx, qword [rbp+rbx]
    95 0000009F 30C0                        xor al, al
    96 000000A1 FFD3                        call rbx
    97                                  
    98                                      ;Open Mass Storage
    99 000000A3 48BB-                       mov rbx, msdDriver
    99 000000A5 [6E09000000000000] 
   100 000000AD 488D5C1D00                  lea rbx, qword [rbp+rbx]
   101 000000B2 30C0                        xor al, al
   102 000000B4 FFD3                        call rbx
   103                                  
   104 000000B6 488D2D35000000              lea rbp, qword [startmsg]   ;Get the absolute address of message
   105 000000BD B804130000                  mov eax, 1304h
   106 000000C2 CD30                        int 30h
   107                                  
   108 000000C4 64488B3425-                 mov rsi, fs:[nulDevHdr]
   108 000000C9 [82000000]         
   109 000000CD B801C50000                  mov eax, 0C501h ;Connect debugger
   110 000000D2 CD35                        int 35h
   111                                  l1:
   112 000000D4 6631C0                      xor ax, ax
   113 000000D7 CD36                        int 36h
   114 000000D9 B40E                        mov ah, 0Eh
   115 000000DB CD30                        int 30h
   116 000000DD EBF5                        jmp short l1
   117                                  adjustDrvHdr:
   118                                  ;Input: rsi = Effective address of driver in DOS segment
   119                                  ;       rbp = Ptr to the start of the DOS segment
   120                                  ;Output: rsi = EA of next header in DOS segment
   121 000000DF 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   122 000000E2 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   123 000000E6 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   124 000000EA 4881C622000000              add rsi, drvHdr_size
   125 000000F1 C3                          ret
   126                                  
   127 000000F2 5374617274696E6720-     startmsg db "Starting SCP/DOS...",0Ah,0Dh,0
   127 000000FB 5343502F444F532E2E-
   127 00000104 2E0A0D00           
   128                                  nData:
   129 00000108 [5906000000000000]          dq conHdr
   130 00000110 0480                        dw 08004h
   131 00000112 [0108000000000000]          dq nulStrat
   132 0000011A [0708000000000000]          dq nulIntr
   133 00000122 4E554C2020202020            db "NUL     " ;Default NUL data
   134                                  
   135                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   136                                  ;-----------------------------------:
   137                                  ;       Misc System routines        :
   138                                  ;-----------------------------------:
   139                                  findLRUBuffer: 
   140                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   141                                  ;Input: Nothing
   142                                  ;Output: rbx = Pointer to the buffer to use
   143 00000000 52                          push rdx
   144 00000001 488B1D(65000000)            mov rbx, qword [bufHeadPtr]
   145 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   146 0000000F 7502                        jne .flb1
   147 00000011 5A                          pop rdx
   148 00000012 C3                          ret
   149                                  .flb1:
   150 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   151 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   152 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   153 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   154 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   155 00000029 488B15(65000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   156 00000030 48891D(65000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   157 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   158 0000003A 5A                          pop rdx
   159 0000003B C3                          ret
   160                                  
   161                                  findDPB:
   162                                  ;Finds the DPB for a given drive
   163                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   164                                  ;Output: al = 00, rbx = Pointer to the DPB
   165                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   166 0000003C 488B1D(43000000)            mov rbx, qword [dpbHeadPtr]
   167                                  .fd1:
   168 00000043 30C0                        xor al, al
   169 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   170 00000047 740F                        je .fd2
   171 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   172 0000004D B0FF                        mov al, -1
   173 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   174 00000056 75EB                        jne .fd1
   175                                  .fd2:
   176 00000058 C3                          ret
   177                                  callCritError:
   178                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   179                                  ;-----------------------------------:
   180                                  ;       File System routines        :
   181                                  ;-----------------------------------:
   182                                  fatProc:
   183                                  ;-----------------------------------:
   184                                  ;        Interrupt routines         :
   185                                  ;-----------------------------------:
   186                                  terminateProcess:   ;Int 40h
   187                                  
   188                                  functionDispatch:   ;Int 41h Main function dispatcher
   189                                  ;ah = Function number, all other registers have various meanings
   190 00000059 FA                          cli ;Halt external interrupts
   191 0000005A 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   192 0000005D 7700                        ja .fdExitBad
   193                                      
   194                                  .fdExit:
   195                                  .fdExitBad:
   196                                  
   197                                  .dispTerminate:     ;ah = 00h
   198                                  .stdinReadEcho:     ;ah = 01h
   199                                  .stdoutWrite:       ;ah = 02h
   200                                  ;Bspace is regular cursor left, does not insert a blank
   201                                  .stdauxRead:        ;ah = 03h
   202                                  .stdauxWrite:       ;ah = 04h
   203                                  .stdprnWrite:       ;ah = 05h
   204                                  .directCONIO:       ;ah = 06h
   205                                  .waitDirectInNoEcho:;ah = 07h
   206                                  .waitStdinNoEcho:   ;ah = 08h
   207                                  .printString:       ;ah = 09h
   208                                  .buffStdinInput:    ;ah = 0Ah
   209                                  .checkStdinStatus:  ;ah = 0Bh
   210                                  .clearbuffDoFunc:   ;ah = 0Ch
   211                                  .diskReset:         ;ah = 0Dh
   212                                  .selectDisk:        ;ah = 0Eh
   213                                  .openFileFCB:       ;ah = 0Fh
   214                                  .closeFileFCB:      ;ah = 10h
   215                                  .findFirstFileFCB:  ;ah = 11h
   216                                  .findNextFileFCB:   ;ah = 12h
   217                                  .deleteFileFCB:     ;ah = 13h
   218                                  .sequentialReadFCB: ;ah = 14h
   219                                  .sequentialWriteFCB:;ah = 15h
   220                                  .createFileFCB:     ;ah = 16h
   221                                  .renameFileFCB:     ;ah = 17h
   222                                                      ;ah = 18h unused
   223                                  .currentDisk:       ;ah = 19h, get current default drive
   224                                  .setDTA:            ;ah = 1Ah
   225                                  .FATinfoDefault:    ;ah = 1Bh
   226                                  .FatinfoDevice:     ;ah = 1Ch
   227                                                      ;ah = 1Dh unused
   228                                                      ;ah = 1Eh unused
   229                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   230                                                      ;ah = 20h unused
   231                                  .randomReadFCB:     ;ah = 21h
   232                                  .randomWriteFCB:    ;ah = 22h
   233                                  .getFileSizeFCB:    ;ah = 23h
   234                                  .setRelRecordFCB:   ;ah = 24h
   235                                  .setIntVector:      ;ah = 25h
   236                                  .createNewProgSeg:  ;ah = 26h
   237                                  .randBlockReadFCB:  ;ah = 27h
   238                                  .randBlockWriteFCB: ;ah = 28h
   239                                  .parseFilenameFCB:  ;ah = 29h
   240                                  .getDate:           ;ah = 2Ah
   241                                  .setDate:           ;ah = 2Bh
   242                                  .getTime:           ;ah = 2Ch
   243                                  .setTime:           ;ah = 2Dh
   244                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   245                                  .getDTA:            ;ah = 2Fh
   246                                  .getDOSversion:     ;ah = 30h
   247                                  .terminateStayRes:  ;ah = 31h
   248                                  .getDeviceDPBptr:   ;ah = 32h
   249                                  .ctrlBreakCheck:    ;ah = 33h
   250                                  .getInDOSflagPtr:   ;ah = 34h
   251                                  .getIntVector:      ;ah = 35h
   252                                  .getDiskFreeSpace:  ;ah = 36h
   253                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   254                                  .getsetCountryInfo: ;ah = 38h, localisation info
   255                                  .makeDIR:           ;ah = 39h
   256                                  .removeDIR:         ;ah = 3Ah
   257                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   258                                  .createFileHdl:     ;ah = 3Ch, handle function
   259                                  .openFileHdl:       ;ah = 3Dh, handle function
   260                                  .closeFileHdl:      ;ah = 3Eh, handle function
   261                                  .readFileHdl:       ;ah = 3Fh, handle function
   262                                  .writeFileHdl:      ;ah = 40h, handle function
   263                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   264                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   265                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   266                                  .ioctrl:            ;ah = 44h, handle function
   267                                  .duplicateHandle:   ;ah = 45h, handle function
   268                                  .forceDuplicateHdl: ;ah = 46h, handle function
   269                                  .getCurrentDIR:     ;ah = 47h
   270                                  .allocateMemory:    ;ah = 48h
   271                                  .freeMemory:        ;ah = 49h
   272                                  .reallocMemory:     ;ah = 4Ah
   273                                  .loadExecChild:     ;ah = 4Bh, EXEC
   274                                  .terminateClean:    ;ah = 4Ch, EXIT
   275                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   276                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   277                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   278                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   279                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   280                                  .getSysVarsPtr:     ;ah = 52h
   281                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   282                                  .getVerifySetting:  ;ah = 54h
   283                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   284                                  .renameFile:        ;ah = 56h
   285                                  .getSetFileDateTime:;ah = 57h
   286                                  .getsetMallocStrat: ;ah = 58h
   287                                  .getExtendedError:  ;ah = 59h
   288                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   289                                  .createNewFile:     ;ah = 5Bh
   290                                  .lockUnlockFile:    ;ah = 5Ch
   291                                  .getCritErrorInfo:  ;ah = 5Dh
   292                                  .networkServices:   ;ah = 5Eh, do nothing
   293                                  .networkRedirection:;ah = 5Fh, do nothing
   294                                  .trueName:          ;ah = 60h, get fully qualified name
   295                                                      ;ah = 61h, reserved
   296                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   297                                                      ;ah = 63h, reserved
   298                                  .setDriverLookahead:;ah = 64h, reserved
   299                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   300                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   301                                  .setHandleCount:    ;ah = 67h
   302                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   303                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   304                                  .return:
   305 0000005F C3                          ret
   306                                  
   307                                  
   308                                  .dispatchTable:
   309 00000060 [5F00000000000000]          dq .dispTerminate
   310 00000068 [5F00000000000000]          dq .stdinReadEcho
   311 00000070 [5F00000000000000]          dq .stdoutWrite
   312 00000078 [5F00000000000000]          dq .stdauxRead
   313 00000080 [5F00000000000000]          dq .stdauxWrite
   314 00000088 [5F00000000000000]          dq .stdprnWrite
   315 00000090 [5F00000000000000]          dq .directCONIO
   316 00000098 [5F00000000000000]          dq .waitDirectInNoEcho
   317 000000A0 [5F00000000000000]          dq .waitStdinNoEcho
   318 000000A8 [5F00000000000000]          dq .printString
   319 000000B0 [5F00000000000000]          dq .buffStdinInput
   320 000000B8 [5F00000000000000]          dq .checkStdinStatus
   321 000000C0 [5F00000000000000]          dq .clearbuffDoFunc
   322 000000C8 [5F00000000000000]          dq .diskReset
   323 000000D0 [5F00000000000000]          dq .selectDisk
   324 000000D8 [5F00000000000000]          dq .openFileFCB
   325 000000E0 [5F00000000000000]          dq .closeFileFCB
   326 000000E8 [5F00000000000000]          dq .findFirstFileFCB
   327 000000F0 [5F00000000000000]          dq .findNextFileFCB
   328 000000F8 [5F00000000000000]          dq .deleteFileFCB
   329 00000100 [5F00000000000000]          dq .sequentialReadFCB
   330 00000108 [5F00000000000000]          dq .sequentialWriteFCB
   331 00000110 [5F00000000000000]          dq .createFileFCB
   332 00000118 [5F00000000000000]          dq .renameFileFCB
   333 00000120 [5F00000000000000]          dq .return
   334 00000128 [5F00000000000000]          dq .currentDisk
   335 00000130 [5F00000000000000]          dq .setDTA
   336 00000138 [5F00000000000000]          dq .FATinfoDefault
   337 00000140 [5F00000000000000]          dq .FatinfoDevice
   338 00000148 [5F00000000000000]          dq .return
   339 00000150 [5F00000000000000]          dq .return
   340 00000158 [5F00000000000000]          dq .getCurrentDPBptr
   341 00000160 [5F00000000000000]          dq .return
   342 00000168 [5F00000000000000]          dq .randomReadFCB
   343 00000170 [5F00000000000000]          dq .randomWriteFCB
   344 00000178 [5F00000000000000]          dq .getFileSizeFCB
   345 00000180 [5F00000000000000]          dq .setRelRecordFCB
   346 00000188 [5F00000000000000]          dq .setIntVector
   347 00000190 [5F00000000000000]          dq .createNewProgSeg
   348 00000198 [5F00000000000000]          dq .randBlockReadFCB
   349 000001A0 [5F00000000000000]          dq .randBlockWriteFCB
   350 000001A8 [5F00000000000000]          dq .parseFilenameFCB
   351 000001B0 [5F00000000000000]          dq .getDate
   352 000001B8 [5F00000000000000]          dq .setDate
   353 000001C0 [5F00000000000000]          dq .getTime
   354 000001C8 [5F00000000000000]          dq .setTime
   355 000001D0 [5F00000000000000]          dq .setResetVerify
   356 000001D8 [5F00000000000000]          dq .getDTA
   357 000001E0 [5F00000000000000]          dq .getDOSversion
   358 000001E8 [5F00000000000000]          dq .terminateStayRes
   359 000001F0 [5F00000000000000]          dq .getDeviceDPBptr
   360 000001F8 [5F00000000000000]          dq .ctrlBreakCheck
   361 00000200 [5F00000000000000]          dq .getInDOSflagPtr
   362 00000208 [5F00000000000000]          dq .getIntVector
   363 00000210 [5F00000000000000]          dq .getDiskFreeSpace
   364 00000218 [5F00000000000000]          dq .getsetSwitchChar
   365 00000220 [5F00000000000000]          dq .getsetCountryInfo
   366 00000228 [5F00000000000000]          dq .makeDIR
   367 00000230 [5F00000000000000]          dq .removeDIR
   368 00000238 [5F00000000000000]          dq .changeCurrentDIR
   369 00000240 [5F00000000000000]          dq .createFileHdl
   370 00000248 [5F00000000000000]          dq .openFileHdl
   371 00000250 [5F00000000000000]          dq .closeFileHdl
   372 00000258 [5F00000000000000]          dq .readFileHdl
   373 00000260 [5F00000000000000]          dq .writeFileHdl
   374 00000268 [5F00000000000000]          dq .deleteFileHdl
   375 00000270 [5F00000000000000]          dq .movFileReadPtr
   376 00000278 [5F00000000000000]          dq .changeFileModeHdl
   377 00000280 [5F00000000000000]          dq .ioctrl
   378 00000288 [5F00000000000000]          dq .duplicateHandle
   379 00000290 [5F00000000000000]          dq .forceDuplicateHdl
   380 00000298 [5F00000000000000]          dq .getCurrentDIR
   381 000002A0 [5F00000000000000]          dq .allocateMemory
   382 000002A8 [5F00000000000000]          dq .freeMemory
   383 000002B0 [5F00000000000000]          dq .reallocMemory
   384 000002B8 [5F00000000000000]          dq .loadExecChild
   385 000002C0 [5F00000000000000]          dq .terminateClean
   386 000002C8 [5F00000000000000]          dq .getRetCodeChild
   387 000002D0 [5F00000000000000]          dq .findFirstFileHdl
   388 000002D8 [5F00000000000000]          dq .findNextFileHdl
   389 000002E0 [5F00000000000000]          dq .setCurrProcessID
   390 000002E8 [5F00000000000000]          dq .getCurrProcessID
   391 000002F0 [5F00000000000000]          dq .getSysVarsPtr
   392 000002F8 [5F00000000000000]          dq .createDPB
   393 00000300 [5F00000000000000]          dq .getVerifySetting
   394 00000308 [5F00000000000000]          dq .createPSP
   395 00000310 [5F00000000000000]          dq .renameFile
   396 00000318 [5F00000000000000]          dq .getSetFileDateTime
   397 00000320 [5F00000000000000]          dq .getsetMallocStrat
   398 00000328 [5F00000000000000]          dq .getExtendedError
   399 00000330 [5F00000000000000]          dq .createUniqueFile
   400 00000338 [5F00000000000000]          dq .createNewFile
   401 00000340 [5F00000000000000]          dq .lockUnlockFile
   402 00000348 [5F00000000000000]          dq .getCritErrorInfo
   403 00000350 [5F00000000000000]          dq .networkServices
   404 00000358 [5F00000000000000]          dq .networkRedirection
   405 00000360 [5F00000000000000]          dq .trueName
   406 00000368 [5F00000000000000]          dq .return
   407 00000370 [5F00000000000000]          dq .getPSPaddr
   408 00000378 [5F00000000000000]          dq .return
   409 00000380 [5F00000000000000]          dq .setDriverLookahead
   410 00000388 [5F00000000000000]          dq .getExtLocalInfo
   411 00000390 [5F00000000000000]          dq .getsetGlobalCP
   412 00000398 [5F00000000000000]          dq .setHandleCount
   413 000003A0 [5F00000000000000]          dq .commitFile
   414 000003A8 [5F00000000000000]          dq .getsetDiskSerial
   415                                  dispatchTableL  equ $ - .dispatchTable 
   416                                  
   417                                  terminateHandler:   ;Int 42h
   418                                  ctrlCHandler:       ;Int 43h
   419                                  critErrorHandler:   ;Int 44h
   420                                  ;User Stack in usage here, must be swapped to before this is called
   421                                  ;Entered with:  
   422                                  ;               AH = Critical Error Bitfield
   423                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   424                                  ;               Bit 6 - Reserved
   425                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   426                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   427                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   428                                  ;               Bits [2-1] = Affected Disk Error
   429                                  ;                     0 0   DOS area
   430                                  ;                     0 1   FAT area
   431                                  ;                     1 0   Directory area
   432                                  ;                     1 1   Data area
   433                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   434                                  ;               AL  = Failing drive number if AH[7] = 0
   435                                  ;               DIL = Error code for errorMsg
   436                                  ;               RSI = EA of Device Header for which device the error occured
   437                                  ;Return:
   438                                  ;               AL = 0 - Ignore the Error       (Ignore)
   439                                  ;                  = 1 - Retry the Operation    (Retry)
   440                                  ;                  = 2 - Terminate the Program  (Abort)
   441                                  ;                  = 3 - Fail the DOS call      (Fail)
   442 000003B0 53                          push rbx
   443 000003B1 51                          push rcx
   444 000003B2 52                          push rdx
   445 000003B3 57                          push rdi
   446 000003B4 56                          push rsi
   447 000003B5 FC                          cld         ;Make String ops go forward
   448                                  
   449 000003B6 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   450 000003B9 488D1540020000              lea rdx, qword [.crlf]
   451 000003C0 B409                        mov ah, 09h ;Print String
   452 000003C2 CD41                        int 41h     ;Call DOS to print CRLF part of message
   453                                  
   454 000003C4 6681E7FF00                  and di, 00FFh   ;Zero the upper byte of DI just in case
   455 000003C9 480FB7FF                    movzx rdi, di
   456 000003CD 4889FA                      mov rdx, rdi    ;Copy error code
   457 000003D0 48C1E704                    shl rdi, 4  ;Multiply by 16
   458 000003D4 48D1E2                      shl rdx, 1  ;Multiply by 2
   459 000003D7 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   460 000003DA 488D97[F1040000]            lea rdx, qword [.errorMsgTable + rdi]   ;Load EA to rdx
   461 000003E1 B409                        mov ah, 09h ;Print String
   462 000003E3 CD41                        int 41h     ;Call DOS to print first part of message
   463                                  
   464 000003E5 488D15F6010000              lea rdx, qword [.readmsg]
   465 000003EC 488D3DFE010000              lea rdi, qword [.writemsg]
   466 000003F3 F6C701                      test bh, 1  ;Bit 0 is set if write operation
   467 000003F6 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   468 000003FA B409                        mov ah, 09h ;Print String
   469 000003FC CD41                        int 41h     ;Call DOS to print error reading/writing portion
   470                                  
   471 000003FE F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   472 00000401 0F85D0000000                jnz .charError
   473                                  ;Disk error continues here
   474 00000407 488D15CD010000              lea rdx, qword [.drive] ;Drive message
   475 0000040E B409                        mov ah, 09h
   476 00000410 CD41                        int 41h
   477 00000412 88DA                        mov dl, bl  ;Get zero based drive number into dl
   478 00000414 80C241                      add dl, "A" ;Add ASCII code
   479 00000417 B402                        mov ah, 02h ;Print char in dl
   480 00000419 CD41                        int 41h
   481                                  .userInput:
   482 0000041B 488D15DE010000              lea rdx, qword [.crlf]  ;Print new line
   483 00000422 B409                        mov ah, 09h
   484 00000424 CD41                        int 41h
   485                                  ;Abort, Retry, Ignore, Fail is word order
   486                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   487                                  .userAbort:
   488                                  ;Abort is always an option
   489 00000426 488D15D6010000              lea rdx, qword [.abortmsg]
   490 0000042D B409                        mov ah, 09h
   491 0000042F CD41                        int 41h ;Call DOS to prompt user for ABORT option
   492                                  .userRetry:
   493 00000431 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   494 00000434 7416                        jz .userIgnore    ;If clear, dont print message
   495 00000436 488D15DE010000              lea rdx, qword [.betweenMsg]
   496 0000043D B409                        mov ah, 09h
   497 0000043F CD41                        int 41h
   498 00000441 488D15C8010000              lea rdx, qword [.retrymsg]
   499 00000448 B409                        mov ah, 09h
   500 0000044A CD41                        int 41h
   501                                  .userIgnore:
   502 0000044C F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   503 0000044F 7416                        jz .userFail
   504 00000451 488D15C3010000              lea rdx, qword [.betweenMsg]
   505 00000458 B409                        mov ah, 09h
   506 0000045A CD41                        int 41h
   507 0000045C 488D15A6010000              lea rdx, qword [.ignoremsg]
   508 00000463 B409                        mov ah, 09h
   509 00000465 CD41                        int 41h
   510                                  .userFail:
   511 00000467 F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   512 0000046A 7416                        jz .userMsgEnd
   513 0000046C 488D15A8010000              lea rdx, qword [.betweenMsg]
   514 00000473 B409                        mov ah, 09h
   515 00000475 CD41                        int 41h
   516 00000477 488D1598010000              lea rdx, qword [.failmsg]
   517 0000047E B409                        mov ah, 09h
   518 00000480 CD41                        int 41h
   519                                  .userMsgEnd:
   520 00000482 488D1595010000              lea rdx, qword [.endMsg]
   521 00000489 B409                        mov ah, 09h
   522 0000048B CD41                        int 41h
   523                                  ;Get user input now 
   524                                  .userInputPhase:
   525 0000048D 31C9                        xor ecx, ecx  ;4 Possible Responses
   526 0000048F 488D3D8B010000              lea rdi, qword [.responses] ;Go to start of string
   527 00000496 B408                        mov ah, 08h ;STDIN without Console Echo
   528 00000498 CD41                        int 41h ;Get char in al
   529 0000049A 3C61                        cmp al, "a" ;Chack if lowercase
   530 0000049C 7202                        jb .uip1    ;If the value is below, ignore subtraction
   531 0000049E 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   532                                  .uip1:
   533 000004A0 AE                          scasb   ;Compare char to list, offset gives return code
   534 000004A1 740C                        je .validInput  ;If they are equal, ecx has return code
   535 000004A3 FFC1                        inc ecx
   536 000004A5 81F904000000                cmp ecx, 4
   537 000004AB 75F3                        jne .uip1
   538 000004AD EBDE                        jmp short .userInputPhase ;If valid char not found, keep waiting 
   539                                  .validInput:
   540 000004AF 88C8                        mov al, cl  ;Move the offset into .responses into al
   541                                  ;Now check if the input is permitted
   542 000004B1 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   543 000004B3 741B                        je .cehExit
   544 000004B5 84C0                        test al, al ;Check if 0 => Ignore
   545 000004B7 740B                        je .viIgnore
   546 000004B9 3C01                        cmp al, 1   ;Check if 1 => Retry
   547 000004BB 740E                        je .viRetry
   548                                  .viFail:    ;Fallthrough for fail (al = 3)
   549 000004BD F6C708                      test bh, 8  ;Bit 3 is Fail bit
   550 000004C0 74CB                        jz .userInputPhase  ;If bit 3 is zero, get input again
   551 000004C2 EB0C                        jmp short .cehExit
   552                                  .viIgnore:
   553 000004C4 F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   554 000004C7 74C4                        jz .userInputPhase
   555 000004C9 EB05                        jmp short .cehExit
   556                                  .viRetry:
   557 000004CB F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   558 000004CE 74BD                        jz .userInputPhase
   559                                  .cehExit:
   560 000004D0 5E                          pop rsi
   561 000004D1 5F                          pop rdi
   562 000004D2 5A                          pop rdx
   563 000004D3 59                          pop rcx
   564 000004D4 5B                          pop rbx
   565 000004D5 48CF                        iretq
   566                                  .charError:
   567 000004D7 B908000000                  mov ecx, 8  ;8 chars in device name
   568 000004DC 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   569                                  .ce1:
   570 000004E3 AC                          lodsb   ;Get a string char into al and inc rsi
   571 000004E4 88C2                        mov dl, al  ;Move char into dl
   572 000004E6 B402                        mov ah, 02h
   573 000004E8 CD41                        int 41h ;Print char
   574 000004EA E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   575 000004EC E92AFFFFFF                  jmp .userInput
   576                                  
   577                                  .errorMsgTable: ;Each table entry is 18 chars long
   578 000004F1 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   578 000004FA 746563742024202020 
   579 00000503 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   579 0000050C 6E6974202420202020 
   580 00000515 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   580 0000051E 202420202020202020 
   581 00000527 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   581 00000530 6F6D6D616E64202420 
   582 00000539 44617461204572726F-                 db "Data Error $      "       ;Error 4
   582 00000542 722024202020202020 
   583 0000054B 426164205265717565-                 db "Bad Request $     "       ;Error 5
   583 00000554 737420242020202020 
   584 0000055D 5365656B2024202020-                 db "Seek $            "       ;Error 6
   584 00000566 202020202020202020 
   585 0000056F 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   585 00000578 656469612024202020 
   586 00000581 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   586 0000058A 7420466F756E642024 
   587 00000593 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   587 0000059C 706572202420202020 
   588 000005A5 577269746520466175-                 db "Write Fault $     "       ;Error A
   588 000005AE 6C7420242020202020 
   589 000005B7 52656164204661756C-                 db "Read Fault $      "       ;Error B
   589 000005C0 742024202020202020 
   590 000005C9 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   590 000005D2 61696C757265202420 
   591                                  
   592 000005DB 64726976652024          .drive      db "drive $"
   593 000005E2 6572726F7220726561-     .readmsg    db "error reading $"
   593 000005EB 64696E672024       
   594 000005F1 6572726F7220777269-     .writemsg   db "error writing $"
   594 000005FA 74696E672024       
   595 00000600 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   596 00000603 41626F727424            .abortmsg   db "Abort$" 
   597 00000609 49676E6F726524          .ignoremsg  db "Ignore$"
   598 00000610 526574727924            .retrymsg   db "Retry$"
   599 00000616 4661696C24              .failmsg    db "Fail$"
   600 0000061B 2C2024                  .betweenMsg db ", $"
   601 0000061E 3F2024                  .endMsg     db "? $"
   602 00000621 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   603                                  absDiskRead:        ;Int 45h
   604                                  ;al = Drive number
   605                                  ;rbx = Memory Buffer address
   606                                  ;ecx = Number of sectors to read (max 255 for now)
   607                                  ;rdx = Start LBA to read from
   608 00000625 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   609 00000629 8A80[E30B0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   610 0000062F 4891                        xchg rax, rcx
   611 00000631 4887CA                      xchg rcx, rdx
   612 00000634 B482                        mov ah, 82h
   613 00000636 CD33                        int 33h
   614 00000638 48CF                        iretq
   615                                  absDiskWrite:       ;Int 46h
   616 0000063A 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   617 0000063E 8A80[E30B0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   618 00000644 4891                        xchg rax, rcx
   619 00000646 4887CA                      xchg rcx, rdx
   620 00000649 B483                        mov ah, 83h
   621 0000064B CD33                        int 33h
   622 0000064D 48CF                        iretq
   623                                  terminateResident:  ;Int 47h
   624                                  inDosHandler:       ;Int 48h
   625                                  ;Called when DOS idle
   626 0000064F 48CF                        iretq
   627                                  fastOutput:         ;Int 49h
   628                                  ;Called with char to transfer in al
   629 00000651 50                          push rax
   630 00000652 B40E                        mov ah, 0Eh
   631 00000654 CD30                        int 30h
   632 00000656 58                          pop rax
   633 00000657 48CF                        iretq
   634                                  passCommand:        ;Int 4Eh
   635                                  multiplex:          ;Int 4Fh
   636                                  ;-----------------------------------:
   637                                  ;          Driver routines          :
   638                                  ;-----------------------------------:
   639                                  drivers:
   640                                  conHdr:
   641 00000659 [7B06000000000000]          dq auxHdr
   642 00000661 1308                        dw 0813h
   643 00000663 [F107000000000000]          dq commonStrat
   644 0000066B [0808000000000000]          dq conDriver
   645 00000673 434F4E2020202020            db "CON     "
   646                                  auxHdr:
   647 0000067B [9D06000000000000]          dq prnHdr
   648 00000683 0080                        dw 08000h
   649 00000685 [F107000000000000]          dq commonStrat
   650 0000068D [C308000000000000]          dq com1Intr
   651 00000695 4155582020202020            db "AUX     "
   652                                  prnHdr:
   653 0000069D [BF06000000000000]          dq clkHdr
   654 000006A5 40A0                        dw 0A040h
   655 000006A7 [F107000000000000]          dq commonStrat
   656 000006AF [8B07000000000000]          dq lpt1Hdr
   657 000006B7 50524E2020202020            db "PRN     "
   658                                  clkHdr:
   659 000006BF [E106000000000000]          dq msdHdr
   660 000006C7 0880                        dw 08008h
   661 000006C9 [F107000000000000]          dq commonStrat
   662 000006D1 [C308000000000000]          dq clkDriver
   663 000006D9 434C4F434B242020            db "CLOCK$  "
   664                                  msdHdr:
   665 000006E1 [0307000000000000]          dq com1Hdr
   666 000006E9 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   667 000006EB [F107000000000000]          dq commonStrat
   668 000006F3 [6E09000000000000]          dq msdDriver
   669 000006FB 0000000000000000            db 0,0,0,0,0,0,0,0
   670                                  com1Hdr:
   671 00000703 [2507000000000000]          dq com2Hdr
   672 0000070B 0080                        dw 08000h
   673 0000070D [F107000000000000]          dq commonStrat
   674 00000715 [C308000000000000]          dq com1Intr
   675 0000071D 434F4D3120202020            db "COM1    "
   676                                  com2Hdr:
   677 00000725 [4707000000000000]          dq com3Hdr
   678 0000072D 0080                        dw 08000h
   679 0000072F [F107000000000000]          dq commonStrat
   680 00000737 [CC08000000000000]          dq com2Intr
   681 0000073F 434F4D3220202020            db "COM2    "
   682                                  com3Hdr:
   683 00000747 [6907000000000000]          dq com4Hdr
   684 0000074F 0080                        dw 08000h
   685 00000751 [F107000000000000]          dq commonStrat
   686 00000759 [D508000000000000]          dq com3Intr
   687 00000761 434F4D3320202020            db "COM3    "
   688                                  com4Hdr:
   689 00000769 [8B07000000000000]          dq lpt1Hdr
   690 00000771 0080                        dw 08000h
   691 00000773 [F107000000000000]          dq commonStrat
   692 0000077B [DE08000000000000]          dq com4Intr
   693 00000783 434F4D3420202020            db "COM4    "
   694                                  lpt1Hdr:
   695 0000078B [AD07000000000000]          dq lpt2Hdr
   696 00000793 40A0                        dw 0A040h
   697 00000795 [F107000000000000]          dq commonStrat
   698 0000079D [5E09000000000000]          dq lptDriver
   699 000007A5 4C50543120202020            db "LPT1    "
   700                                  lpt2Hdr:
   701 000007AD [CF07000000000000]          dq lpt3Hdr
   702 000007B5 40A0                        dw 0A040h
   703 000007B7 [F107000000000000]          dq commonStrat
   704 000007BF [5E09000000000000]          dq lptDriver
   705 000007C7 4C50543220202020            db "LPT2    "
   706                                  lpt3Hdr:
   707 000007CF FFFFFFFFFFFFFFFF            dq -1
   708 000007D7 40A0                        dw 0A040h
   709 000007D9 [F107000000000000]          dq commonStrat
   710 000007E1 [5E09000000000000]          dq lptDriver
   711 000007E9 4C50543320202020            dq "LPT3    "
   712                                  
   713                                  commonStrat:
   714                                  ;DOS calls this function with rbx=Ptr to request header
   715 000007F1 48891D01000000              mov qword [reqHdrPtr], rbx
   716 000007F8 C3                          ret
   717 000007F9 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   718                                  
   719                                  nulStrat:
   720 00000801 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   721                                  nulIntr:
   722 00000807 C3                          ret
   723                                  
   724                                  conDriver:
   725 00000808 50                          push rax
   726 00000809 53                          push rbx
   727 0000080A 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   728 00000811 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   729 00000814 84C0                        test al, al
   730 00000816 7421                        jz conInit
   731 00000818 3C04                        cmp al, 4
   732 0000081A 744D                        jz conRead
   733 0000081C 3C05                        cmp al, 5
   734 0000081E 7466                        jz conNondestructiveRead
   735 00000820 3C06                        cmp al, 6
   736 00000822 740C                        jz conExit
   737 00000824 3C07                        cmp al, 7
   738 00000826 7471                        jz conFlushInputBuffers
   739 00000828 3C08                        cmp al, 8
   740 0000082A 7479                        jz conWrite
   741 0000082C 3C09                        cmp al, 9
   742 0000082E 7475                        jz conWrite
   743                                  ;All other cases fall through here
   744                                  conExit:
   745 00000830 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   746 00000836 5B                          pop rbx
   747 00000837 58                          pop rax
   748 00000838 C3                          ret
   749                                  conInit:    ;Function 0
   750 00000839 52                          push rdx
   751                                      ;Flush keyboard buffer
   752                                  .ci0:
   753 0000083A B401                        mov ah, 01      ;Get buffer status
   754 0000083C CD36                        int 36h
   755 0000083E 7406                        jz .ci1      ;If zero clear => no more keys to read
   756 00000840 30E4                        xor ah, ah
   757 00000842 CD36                        int 36h ;Read key to flush from buffer
   758 00000844 EBF4                        jmp short .ci0
   759                                  .ci1:
   760 00000846 B800050000                  mov eax, 0500h  ;Set page zero as the default page
   761 0000084B CD30                        int 30h
   762 0000084D B402                        mov ah, 02h
   763 0000084F 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   764 00000851 88D7                        mov bh, dl      ;Set cursor for page 0
   765 00000853 CD30                        int 30h
   766 00000855 B707                        mov bh, 07h     ;Grey/Black attribs
   767 00000857 B800060000                  mov eax, 0600h  ;Clear whole screen
   768 0000085C CD30                        int 30h
   769 0000085E 5A                          pop rdx
   770 0000085F EBCF                        jmp short conExit
   771                                  conIORead:
   772 00000861 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   773 00000867 EBC7                        jmp short conExit
   774                                  conRead:    ;Function 4
   775 00000869 57                          push rdi
   776 0000086A 51                          push rcx
   777 0000086B 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   778 0000086F 31C9                        xor ecx, ecx    ;Zero the char counter
   779                                  .cr1:
   780 00000871 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   781 00000874 7409                        je .cre2
   782 00000876 31C0                        xor eax, eax
   783 00000878 CD36                        int 36h
   784 0000087A AA                          stosb   ;Store char in al into buffer and inc rdi
   785 0000087B FFC1                        inc ecx
   786 0000087D EBF2                        jmp short .cr1
   787                                  .cre2:
   788 0000087F 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   789 00000882 59                          pop rcx
   790 00000883 5F                          pop rdi
   791 00000884 EBAA                        jmp short conExit
   792                                  conNondestructiveRead:  ;Function 5
   793 00000886 B401                        mov ah, 01h     ;Get key if exists
   794 00000888 CD36                        int 36h
   795 0000088A 7405                        jz .cnr           ;If zero clear => no key, go forwards
   796                                      ;Keystroke available
   797 0000088C 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   798 0000088F EB9F                        jmp short conExit
   799                                  .cnr: ;No keystroke available
   800 00000891 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   801 00000897 EB97                        jmp short conExit
   802                                  conFlushInputBuffers:   ;Function 7
   803 00000899 B401                        mov ah, 01      ;Get buffer status
   804 0000089B CD36                        int 36h
   805 0000089D 7491                        jz conExit      ;If zero clear => no more keys to read
   806 0000089F 30E4                        xor ah, ah
   807 000008A1 CD36                        int 36h ;Read key to flush from buffer
   808 000008A3 EBF4                        jmp short conFlushInputBuffers
   809                                  conWrite:   ;Function 8 and 9
   810 000008A5 56                          push rsi
   811 000008A6 51                          push rcx
   812 000008A7 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   813 000008AB 31C9                        xor ecx, ecx    ;Zero the char counter
   814                                  .cw1: 
   815 000008AD 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   816 000008B0 7407                        je .cw2
   817 000008B2 AC                          lodsb   ;Get char into al, and inc rsi
   818 000008B3 CD49                        int 49h ;Fast print char
   819 000008B5 FFC1                        inc ecx
   820 000008B7 EBF4                        jmp short .cw1 ;keep printing until all chars printed
   821                                  .cw2:
   822 000008B9 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   823 000008BC 59                          pop rcx
   824 000008BD 5E                          pop rsi
   825 000008BE E96DFFFFFF                  jmp conExit
   826                                  
   827                                  clkDriver:
   828                                  
   829                                  comDriver:
   830                                  com1Intr:
   831 000008C3 C6059300000000              mov byte [comDevice], 0
   832 000008CA EB19                        jmp short comIntr
   833                                  com2Intr:
   834 000008CC C6058A00000001              mov byte [comDevice], 1
   835 000008D3 EB10                        jmp short comIntr
   836                                  com3Intr:
   837 000008D5 C6058100000002              mov byte [comDevice], 2
   838 000008DC EB07                        jmp short comIntr
   839                                  com4Intr:
   840 000008DE C6057800000003              mov byte [comDevice], 3
   841                                  comIntr:
   842 000008E5 50                          push rax
   843 000008E6 53                          push rbx
   844 000008E7 51                          push rcx
   845 000008E8 52                          push rdx
   846 000008E9 56                          push rsi
   847 000008EA 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   848 000008F1 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   849 000008F4 3C04                        cmp al, 4
   850 000008F6 7418                        jz comRead
   851 000008F8 3C05                        cmp al, 5
   852 000008FA 7439                        jz comNondestructiveRead
   853 000008FC 3C08                        cmp al, 8
   854 000008FE 743D                        jz comWrite
   855 00000900 3C09                        cmp al, 9
   856 00000902 7439                        jz comWrite
   857                                  ;All other cases fall through here
   858                                  comExit:
   859 00000904 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   860 0000090A 5E                          pop rsi
   861 0000090B 5A                          pop rdx
   862 0000090C 59                          pop rcx
   863 0000090D 5B                          pop rbx
   864 0000090E 58                          pop rax
   865 0000090F C3                          ret
   866                                  comRead:
   867 00000910 57                          push rdi
   868 00000911 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   869 00000915 31C9                        xor ecx, ecx    ;Zero the char counter
   870                                  .cr1:
   871 00000917 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   872 0000091A 7413                        je .cre2
   873 0000091C B802000000                  mov eax, 02h    ;Recieve 
   874 00000921 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   875 00000928 CD34                        int 34h ;Recieve Char
   876 0000092A AA                          stosb   ;Store char in al into buffer and inc rdi
   877 0000092B FFC1                        inc ecx
   878 0000092D EBE8                        jmp short .cr1
   879                                  .cre2:
   880 0000092F 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   881 00000932 5F                          pop rdi
   882 00000933 EBCF                        jmp short comExit
   883                                  comNondestructiveRead:
   884 00000935 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
   885 0000093B EBC7                        jmp short comExit
   886                                  comWrite:
   887 0000093D 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   888 00000941 31C9                        xor ecx, ecx    ;Zero the char counter
   889                                  .cw1: 
   890 00000943 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   891 00000946 7410                        je .cw2
   892 00000948 AC                          lodsb   ;Get char into al, and inc rsi
   893 00000949 B401                        mov ah, 01h ;Move function number into ah
   894 0000094B 668B150B000000              mov dx, word [comDevice]
   895 00000952 CD34                        int 34h ;Transmit char
   896 00000954 FFC1                        inc ecx
   897 00000956 EBEB                        jmp short .cw1 ;keep printing until all chars printed
   898                                  .cw2:
   899 00000958 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   900 0000095B EBA7                        jmp short comExit
   901 0000095D 00                      comDevice   db 0
   902                                  
   903                                  lptDriver:    ;Drivers for LPT 1, 2, 3
   904 0000095E 57                          push rdi
   905 0000095F 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
   906 00000966 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
   907 0000096C 5F                          pop rdi
   908 0000096D C3                          ret
   909                                  
   910                                  msdDriver:
   911 0000096E 50                          push rax
   912 0000096F 53                          push rbx
   913 00000970 51                          push rcx
   914 00000971 52                          push rdx
   915 00000972 56                          push rsi
   916 00000973 57                          push rdi
   917 00000974 55                          push rbp
   918 00000975 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
   919 0000097C 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
   920 0000097F 3C18                        cmp al, 24  ;Check cmd num is valid
   921 00000981 776C                        ja .msdError
   922 00000983 84C0                        test al, al
   923 00000985 7476                        jz .msdInit
   924 00000987 3C01                        cmp al, 01
   925 00000989 0F8409010000                jz .msdMedChk
   926 0000098F 3C02                        cmp al, 02
   927 00000991 0F8442010000                jz .msdBuildBPB
   928 00000997 3C03                        cmp al, 03
   929 00000999 0F847B010000                jz .msdIOCTLRead
   930 0000099F 3C04                        cmp al, 04
   931 000009A1 0F8478010000                jz .msdRead
   932 000009A7 3C08                        cmp al, 08
   933 000009A9 0F8482010000                jz .msdWrite
   934 000009AF 3C09                        cmp al, 09
   935 000009B1 0F848C010000                jz .msdWriteVerify
   936 000009B7 3C0C                        cmp al, 12
   937 000009B9 0F849D010000                jz .msdIOCTLWrite
   938 000009BF 3C0D                        cmp al, 13
   939 000009C1 0F849A010000                jz .msdDevOpen
   940 000009C7 3C0E                        cmp al, 14
   941 000009C9 0F84A2010000                jz .msdDevClose
   942 000009CF 3C0F                        cmp al, 15
   943 000009D1 0F84AA010000                jz .msdRemovableMedia
   944 000009D7 3C13                        cmp al, 19
   945 000009D9 0F84C0010000                jz .msdGenericIOCTL
   946 000009DF 3C17                        cmp al, 23
   947 000009E1 0F84BD010000                jz .msdGetLogicalDev
   948 000009E7 3C18                        cmp al, 24
   949 000009E9 0F84C3010000                jz .msdSetLogicalDev
   950                                  .msdError:
   951                                  .msdDriverExit:
   952 000009EF 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
   953 000009F5 5D                          pop rbp
   954 000009F6 5F                          pop rdi
   955 000009F7 5E                          pop rsi
   956 000009F8 5A                          pop rdx
   957 000009F9 59                          pop rcx
   958 000009FA 5B                          pop rbx
   959 000009FB 58                          pop rax
   960 000009FC C3                          ret
   961                                  .msdInit:            ;Function 0
   962 000009FD CD31                        int 31h ;Get number of Int 33h devices in r8b
   963 000009FF 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
   964 00000A03 4489C0                      mov eax, r8d
   965 00000A06 3C01                        cmp al, 1
   966 00000A08 7702                        ja .mi1
   967 00000A0A FEC0                        inc al ;Make it two
   968                                  .mi1:
   969 00000A0C BA05000000                  mov edx, 5
   970 00000A11 39D0                        cmp eax, edx
   971 00000A13 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
   972 00000A16 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
   973 00000A1C 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
   974 00000A1F 440005(7F000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
   975 00000A26 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
   976 00000A28 488D3DE6010000              lea rdi, qword [.msdBPBblks]
   977 00000A2F 53                          push rbx
   978                                  .mi2:
   979 00000A30 89EA                        mov edx, ebp
   980 00000A32 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
   981 00000A39 31C9                        xor ecx, ecx    ;Sector 0
   982 00000A3B B801820000                  mov eax, 8201h       ;Read 1 sector
   983 00000A40 CD33                        int 33h
   984 00000A42 724E                        jc .msdInitError
   985                                  
   986 00000A44 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
   987 00000A4B B90F000000                  mov ecx, bpbEx_size/8
   988 00000A50 F348A5                      rep movsq   ;Move the BPB data into the right block
   989                                  
   990 00000A53 FFC5                        inc ebp
   991 00000A55 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
   992 00000A58 75D6                        jne .mi2  ;No? Go again
   993                                  
   994 00000A5A 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
   995 00000A61 488D15AD010000              lea rdx, qword [.msdBPBblks]
   996                                  .mi3:
   997 00000A68 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
   998 00000A6B 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
   999 00000A72 FFCD                        dec ebp
  1000 00000A74 75F2                        jnz .mi3  ;If not zero yet, go again
  1001                                  
  1002 00000A76 5B                          pop rbx
  1003 00000A77 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1004 00000A7E 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1005 00000A82 488D15E4030000              lea rdx, qword [driverDataPtr]
  1006 00000A89 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1007 00000A8D E95DFFFFFF                  jmp .msdDriverExit
  1008                                  .msdInitError:
  1009 00000A92 5B                          pop rbx
  1010 00000A93 E957FFFFFF                  jmp .msdDriverExit
  1011                                  .msdMedChk:          ;Function 1
  1012                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1013                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1014                                  ; suffice.
  1015 00000A98 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1016 00000A9D 8A90[E30B0000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1017 00000AA3 F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1018 00000AA6 7528                        jnz .mmcNoChange
  1019                                  ;Now we test Media Descriptor
  1020 00000AA8 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1021 00000AAB 488B3CC5[ED0B0000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1022 00000AB3 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1023 00000AB6 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1024 00000AB9 740C                        je .mmcUnsure
  1025                                  .mmcChange: ;Fail safe, always assume the device has changed
  1026 00000ABB C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1027 00000ABF 48C7430F[D90B0000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
  1028                                  .mmcUnsure:
  1029 00000AC7 C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1030 00000ACB E91FFFFFFF                  jmp .msdDriverExit
  1031                                  .mmcNoChange:
  1032 00000AD0 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1033 00000AD4 E916FFFFFF                  jmp .msdDriverExit
  1034                                  
  1035                                  .msdBuildBPB:        ;Function 2
  1036 00000AD9 4889DE                      mov rsi, rbx
  1037 00000ADC 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1038 00000AE1 8A90[E30B0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1039 00000AE7 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1040 00000AEB 31C9                        xor ecx, ecx    ;Read Sector 0
  1041 00000AED B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1042 00000AF2 CD33                        int 33h
  1043 00000AF4 7224                        jc .mbbpbError
  1044 00000AF6 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1045 00000AF9 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1046 00000AFE 488B3CC5[ED0B0000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1047 00000B06 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1048 00000B09 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1049 00000B0D B90F000000                  mov ecx, bpbEx_size/8
  1050 00000B12 F348A5                      rep movsq   ;Move the BPB data into the right space
  1051 00000B15 E9D5FEFFFF                  jmp .msdDriverExit
  1052                                  .mbbpbError:
  1053                                  .msdIOCTLRead:       ;Function 3, returns done
  1054 00000B1A E9D0FEFFFF                  jmp .msdDriverExit
  1055                                  .msdRead:            ;Function 4
  1056 00000B1F 4889DD                      mov rbp, rbx
  1057 00000B22 B482                        mov ah, 82h ;LBA Read Sectors
  1058 00000B24 E897000000                  call .msdBlkIOCommon
  1059 00000B29 4889EB                      mov rbx, rbp
  1060 00000B2C E9BEFEFFFF                  jmp .msdDriverExit
  1061                                  .msdWrite:           ;Function 8
  1062 00000B31 4889DD                      mov rbp, rbx
  1063 00000B34 B483                        mov ah, 83h ;LBA Write Sectors
  1064 00000B36 E885000000                  call .msdBlkIOCommon
  1065 00000B3B 4889EB                      mov rbx, rbp
  1066 00000B3E E9ACFEFFFF                  jmp .msdDriverExit
  1067                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1068 00000B43 4889DD                      mov rbp, rbx
  1069 00000B46 B483                        mov ah, 83h ;LBA Write Sectors
  1070 00000B48 E873000000                  call .msdBlkIOCommon
  1071 00000B4D B484                        mov ah, 84h ;LBA Verify Sectors
  1072 00000B4F E86C000000                  call .msdBlkIOCommon
  1073 00000B54 4889EB                      mov rbx, rbp
  1074 00000B57 E993FEFFFF                  jmp .msdDriverExit
  1075                                  .msdIOCTLWrite:      ;Function 12, returns done
  1076 00000B5C E98EFEFFFF                  jmp .msdDriverExit
  1077                                  .msdDevOpen:         ;Function 13
  1078 00000B61 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1079 00000B66 FE80[E80B0000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1080 00000B6C E97EFEFFFF                  jmp .msdDriverExit
  1081                                  .msdDevClose:        ;Function 14
  1082 00000B71 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1083 00000B76 FE88[E80B0000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1084 00000B7C E96EFEFFFF                  jmp .msdDriverExit
  1085                                  .msdRemovableMedia:  ;Function 15
  1086 00000B81 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1087 00000B86 8A80[E30B0000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1088 00000B8C A880                        test al, 80h
  1089 00000B8E 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1090 00000B94 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
  1091 00000B9A E950FEFFFF                  jmp .msdDriverExit
  1092                                  .msdGenericIOCTL:    ;Function 19
  1093 00000B9F E94BFEFFFF                  jmp .msdDriverExit
  1094                                  .msdGetLogicalDev:   ;Function 23
  1095 00000BA4 8A0538000000                mov al, byte [.msdCurDev]
  1096 00000BAA 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1097 00000BAD E93DFEFFFF                  jmp .msdDriverExit
  1098                                  .msdSetLogicalDev:   ;Function 24
  1099 00000BB2 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1100 00000BB5 880527000000                mov byte [.msdCurDev], al
  1101 00000BBB E92FFEFFFF                  jmp .msdDriverExit
  1102                                  
  1103                                  .msdBlkIOCommon:  ;Does block IO
  1104                                  ;Called with rbp containing old rbx value and ah with function number
  1105                                  ;Error handled by caller
  1106 00000BC0 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1107 00000BC5 8A90[E30B0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1108 00000BCB 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1109 00000BCF 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
  1110 00000BD2 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1111 00000BD6 CD33                        int 33h
  1112 00000BD8 C3                          ret
  1113                                  
  1114 00000BD9 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1115                                  ;LASTDRIVE default is 5
  1116 00000BE2 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1117                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1118 00000BE3 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1119 00000BE8 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1120 00000BED 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1120 00000BF6 000000000000000000-
  1120 00000BFF 000000000000000000-
  1120 00000C08 000000000000000000-
  1120 00000C11 00000000           
  1121 00000C15 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1121 00000C1E 000000000000000000-
  1121 00000C27 000000000000000000-
  1121 00000C30 000000000000000000-
  1121 00000C39 000000000000000000-
  1121 00000C42 000000000000000000-
  1121 00000C4B 000000000000000000-
  1121 00000C54 000000000000000000-
  1121 00000C5D 000000000000000000-
  1121 00000C66 000000000000000000-
  1121 00000C6F 000000000000000000-
  1121 00000C78 000000000000000000-
  1121 00000C81 000000000000000000-
  1121 00000C8A 000000000000000000-
  1121 00000C93 000000000000000000-
  1121 00000C9C 000000000000000000-
  1121 00000CA5 000000000000000000-
  1121 00000CAE 000000000000000000-
  1121 00000CB7 000000000000000000-
  1121 00000CC0 000000000000000000-
  1121 00000CC9 000000000000000000-
  1121 00000CD2 000000000000000000-
  1121 00000CDB 000000000000000000-
  1121 00000CE4 000000000000000000-
  1121 00000CED 000000000000000000-
  1121 00000CF6 000000000000000000-
  1121 00000CFF 000000000000000000-
  1121 00000D08 000000000000000000-
  1121 00000D11 000000000000000000-
  1121 00000D1A 000000000000000000-
  1121 00000D23 000000000000000000-
  1121 00000D2C 000000000000000000-
  1121 00000D35 000000000000000000-
  1121 00000D3E 000000000000000000-
  1121 00000D47 000000000000000000-
  1121 00000D50 000000000000000000-
  1121 00000D59 000000000000000000-
  1121 00000D62 000000000000000000-
  1121 00000D6B 000000000000000000-
  1121 00000D74 000000000000000000-
  1121 00000D7D 000000000000000000-
  1121 00000D86 000000000000000000-
  1121 00000D8F 000000000000000000-
  1121 00000D98 000000000000000000-
  1121 00000DA1 000000000000000000-
  1121 00000DAA 000000000000000000-
  1121 00000DB3 000000000000000000-
  1121 00000DBC 000000000000000000-
  1121 00000DC5 000000000000000000-
  1121 00000DCE 000000000000000000-
  1121 00000DD7 000000000000000000-
  1121 00000DE0 000000000000000000-
  1121 00000DE9 000000000000000000-
  1121 00000DF2 000000000000000000-
  1121 00000DFB 000000000000000000-
  1121 00000E04 000000000000000000-
  1121 00000E0D 000000000000000000-
  1121 00000E16 000000000000000000-
  1121 00000E1F 000000000000000000-
  1121 00000E28 000000000000000000-
  1121 00000E31 000000000000000000-
  1121 00000E3A 000000000000000000-
  1121 00000E43 000000000000000000-
  1121 00000E4C 000000000000000000-
  1121 00000E55 000000000000000000-
  1121 00000E5E 000000000000000000-
  1121 00000E67 000000000000       
  1122                                  
  1123                                  driverDataPtr:
