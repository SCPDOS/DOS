     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, pointer to rax saved in oldRSP
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> ;Pushed by Processor when invoked via Interrupt
   186 00000048 ????????????????    <1>     .rip    resq 1
   187 00000050 ????????????????    <1>     .cs     resq 1
   188 00000058 ????????????????    <1>     .flags  resq 1
   189                              <1> endstruc
   190                              <1> 
   191                              <1> %macro pushDOS 0
   192                              <1>     push r9
   193                              <1>     push r8
   194                              <1>     push rbp
   195                              <1>     push rdi
   196                              <1>     push rsi
   197                              <1>     push rdx
   198                              <1>     push rcx
   199                              <1>     push rbx
   200                              <1>     push rax
   201                              <1> %endmacro
   202                              <1> 
   203                              <1> %macro popDOS 0
   204                              <1>     pop rax
   205                              <1>     pop rbx
   206                              <1>     pop rcx
   207                              <1>     pop rdx
   208                              <1>     pop rsi
   209                              <1>     pop rdi
   210                              <1>     pop rbp
   211                              <1>     pop r8
   212                              <1>     pop r9
   213                              <1> %endmacro
   214                              <1> 
   215                              <1> struc psp
   216 00000000 ????                <1>     .return     resb 2  ;Should always be CDh 40h
   217 00000002 ????????????????    <1>     .startSeg   resq 1  ;Pointer to the start of the PSP
   218 0000000A ????????????????    <1>     .oldInt42h  resq 1  ;Int 42h pointer on overlay load
   219 00000012 ????????????????    <1>     .oldInt43h  resq 1  ;Int 43h pointer on overlay load
   220 0000001A ????????????????    <1>     .oldInt44h  resq 1  ;Int 44h pointer on overlay load
   221 00000022 ????????????????    <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   222 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   223 0000003E ????????????????    <1>     .envPtr     resq 1  ;Pointer to the environment
   224 00000046 ????????????????    <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to Int 41h
   225 0000004E ????                <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   226 00000050 ??????              <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   227 00000053 ????????????????    <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   228 0000005B ????????????????    <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   229 00000063 ????????????????    <1>     .fcbPtr1    resq 1  ;Pointer to the first OS allocated FCB
   230 0000006B <res 15h>           <1>     .reserved   resb 21
   231 00000080 ??                  <1>     .charCount  resb 1  ;Number of characters in command tail
   232 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   233                              <1> endstruc
   234                              <1> 
   235                              <1> struc mcb
   236 00000000 ??                  <1>     .mzbyte     resb 1  ;M=In use, Z=Free
   237 00000001 ????????????????    <1>     .processPtr resq 1  ;Points to the start of the process PSP
   238 00000009 ????????            <1>     .paragraphs resd 1  ;Gives the number of paras allocated to this process
   239 0000000D ??????              <1>     .reserved   resb 3
   240                              <1>     .program:
   241                              <1> endstruc
     7                                  %include "dosSeg.asm"
     8                              <1> ;This file contains the main DOS data segment
     9                              <1> 
    10                              <1> Segment dSeg nobits align=1 
    11 00000000 ????????????????    <1>     dosSegPtr   resq 1    ;Pointer to the data Segment itself
    12 00000008 ??                  <1>     bootDrive   resb 1    ;The Int 33h device we booted from
    13 00000009 <res 2Ah>           <1>     charReqHdr  resb ioReqPkt_size  ;Character IO Request header
    14 00000033 <res 2Ah>           <1>     diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
    15                              <1>     ;The device driver header with space for the largest possible packet
    16 0000005D ????????????????    <1>     sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    17 00000065 ????????????????    <1>     mcbChainPtr resq 1    ;Pointer to the MCB chain
    18 0000006D ????????????????    <1>     dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    19 00000075 ????????????????    <1>     sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    20 0000007D ????????????????    <1>     clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    21                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
    22 00000085 ????????????????    <1>     conPtr      resq 1    ;Pointer to the current active CON device header 
    23                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
    24 0000008D ????                <1>     maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    25 0000008F ????????????????    <1>     bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    26 00000097 ????????????????    <1>     cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    27 0000009F ????????????????    <1>     sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    28 000000A7 ????                <1>     numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    29 000000A9 ??                  <1>     numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    30 000000AA ??                  <1>     lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    31 000000AB ??                  <1>     numJoinDrv  resb 1    ;Number of Joined Drives
    32 000000AC <res 22h>           <1>     nulDevHdr   resb drvHdr_size
    33                              <1> 
    34                              <1> ;Start of Swappable Data Area, this bit can remain static
    35 000000CE ??                  <1>     critErrFlag resb 1  ;Critical error flag, set on entry to INT 44h
    36 000000CF ??                  <1>     inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    37 000000D0 ??                  <1>     errorDrv    resb 1  ;Drive on which error occured or FFh
    38 000000D1 ??                  <1>     errorLocus  resb 1  ;Where the error took place  
    39 000000D2 ????                <1>     errorExt    resw 1  ;Extended Error Code
    40 000000D4 ??                  <1>     errorAction resb 1  ;Suggested action for error  
    41 000000D5 ??                  <1>     errorClass  resb 1  ;Error Class
    42                              <1> 
    43 000000D6 ????????????????    <1>     currentDTA  resq 1  ;Address of the current DTA
    44 000000DE ????????????????    <1>     currentPSP  resq 1  ;Address of current PSP
    45 000000E6 ????????????????    <1>     rdiErrorPtr resq 1  ;Saves RDI value of last error
    46 000000EE ????????????????    <1>     xInt43hRSP  resq 1  ;Saves RSP across an Int 43h call
    47 000000F6 ????                <1>     lastRetCode resw 1  ;Last return code returned by Int 41h/4Ch
    48 000000F8 ??                  <1>     currentDrv  resb 1  ;Default, last accessed drive
    49 000000F9 ??                  <1>     breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    50                              <1> ;SDA, needs to be replaced between processes
    51 000000FA ????????????????    <1>     xInt44hRSP  resq 1  ;RSP across an Int 44h call
    52                              <1> 
    53 00000102 ??                  <1>     Int44RetVal resb 1  ;Saves a copy of the Int 44 return value
    54 00000103 ??                  <1>     Int44bitfld resb 1  ;Copies the bit field given to the Int 44h handler
    55 00000104 ??                  <1>     int48Flag   resb 1  ;If set, Int 48h should be called, if clear no
    56 00000105 ????????????????    <1>     oldoldRSP   resq 1  ;RSP at prev Int 41h entry if called from within Int 41h
    57 0000010D ????????????????    <1>     oldRSP      resq 1  ;RSP when entering Int 41h
    58 00000115 ????????????????    <1>     oldRBX      resq 1  ;Temp var to save value of rbx during an Int 41 call
    59                              <1> ;Time stuff
    60 0000011D ????????????        <1>     CLOCKrecrd  resb 6  ;Clock driver record
    61 00000123 ??                  <1>     dayOfMonth  resb 1  ;1 - 31 BCD
    62 00000124 ??                  <1>     monthOfYear resb 1  ;1 - 12 BCD
    63 00000125 ????                <1>     years       resw 1  ;0000 - 9999 BCD
    64 00000127 ????                <1>     yearsOffset resw 1  ;Current Year - 1980
    65 00000129 ????????            <1>     daysOffset  resd 1  ;Days since 1-1-1980
    66 0000012D ??                  <1>     dayOfWeek   resb 1  ;0 = Sunday <-> 6 = Saturday
    67                              <1> 
    68                              <1> ;Stacks
    69 0000012E <res 528h>          <1>     critStack   resq 165
    70 00000656 ????????????????    <1>     critStakTop resq 1
    71 0000065E <res 638h>          <1>     IOStack     resq 199
    72 00000C96 ????????????????    <1>     IOStakTop   resq 1
    73 00000C9E <res 638h>          <1>     DiskStack   resq 199
    74 000012D6 ????????????????    <1>     DiskStakTop resq 1
    75                              <1>     dSegLen     equ     $
     8                                  
     9                                  Segment .text align=1
    10                                  ; We arrive here with the following values in the registers.
    11                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    12                                  ; dx  = Int 33h boot device number
    13                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    14                                  tempPSP:    ;Here to allow the loader to use Int 41h once it is loaded high
    15 00000000 55AA                        dw 0AA55h           ;Initial signature
    16 00000002 909090909090909090-         db (100h-2) dup (90h)   ;Duplicate NOPs for the PSP
    16 0000000B 909090909090909090-
    16 00000014 909090909090909090-
    16 0000001D 909090909090909090-
    16 00000026 909090909090909090-
    16 0000002F 909090909090909090-
    16 00000038 909090909090909090-
    16 00000041 909090909090909090-
    16 0000004A 909090909090909090-
    16 00000053 909090909090909090-
    16 0000005C 909090909090909090-
    16 00000065 909090909090909090-
    16 0000006E 909090909090909090-
    16 00000077 909090909090909090-
    16 00000080 909090909090909090-
    16 00000089 909090909090909090-
    16 00000092 909090909090909090-
    16 0000009B 909090909090909090-
    16 000000A4 909090909090909090-
    16 000000AD 909090909090909090-
    16 000000B6 909090909090909090-
    16 000000BF 909090909090909090-
    16 000000C8 909090909090909090-
    16 000000D1 909090909090909090-
    16 000000DA 909090909090909090-
    16 000000E3 909090909090909090-
    16 000000EC 909090909090909090-
    16 000000F5 909090909090909090-
    16 000000FE 9090               
    17 00000100 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    18 00000108 488D15F1FEFFFF              lea rdx, qword [tempPSP]    ;Get the address of the tempPSP
    19 0000010F 6448891425-                 mov qword fs:[currentPSP], rdx
    19 00000114 [DE000000]         
    20                                  ;DOS allows for non-PARA aligned PSPs but DOS aligns all programs on PARA bndry
    21 00000118 B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    22 0000011D 0F32                        rdmsr
    23 0000011F 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    24 00000121 48C1E720                    shl rdi, 20h        ;Shift high
    25 00000125 89C7                        mov edi, eax        ;Get the low dword in
    26                                  
    27 00000127 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    27 0000012C [00000000]         
    28 00000130 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    29 00000133 4881C7[DE120000]            add rdi, dSegLen ;Move destination past end of data area
    30 0000013A 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    31 00000141 B900100000                  mov ecx, 1000h
    32 00000146 F348A5                      rep movsq
    33                                  
    34                                  ;Modify the pointers in nData before putting them in the data area
    35 00000149 48012D72010000              add qword [nData + drvHdr.nxtPtr], rbp
    36 00000150 48012D75010000              add qword [nData + drvHdr.strPtr], rbp
    37 00000157 48012D76010000              add qword [nData + drvHdr.intPtr], rbp
    38                                  ;Copy the Null driver to its location in Sysvars
    39 0000015E B922000000                  mov ecx, drvHdr_size
    40 00000163 488D3558010000              lea rsi, qword [nData]
    41 0000016A 488DBD[AC000000]            lea rdi, qword [rbp + nulDevHdr]
    42 00000171 F3A4                        rep movsb   
    43                                  
    44                                  ;Adjust the addresses in the other driver headers 
    45 00000173 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    45 00000175 [C407000000000000] 
    46 0000017D B90C000000                  mov ecx, 12      ;12 drivers in data area
    47 00000182 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    48                                  adjDrivers:
    49 00000186 E8BC000000                  call adjustDrvHdr
    50 0000018B E2F9                        loop adjDrivers
    51                                  
    52                                      ;Open NUL
    53 0000018D 488D9D[B6000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    54 00000194 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    55 00000197 30C0                        xor al, al
    56 00000199 FFD3                        call rbx
    57                                  
    58                                      ;Open CON
    59 0000019B 48BB-                       mov rbx, conDriver
    59 0000019D [7309000000000000] 
    60 000001A5 488D5C1D00                  lea rbx, qword [rbp+rbx]
    61 000001AA 30C0                        xor al, al
    62 000001AC FFD3                        call rbx
    63                                  
    64                                      ;Open Mass Storage
    65 000001AE 48BB-                       mov rbx, msdDriver
    65 000001B0 [1F0C000000000000] 
    66 000001B8 488D5C1D00                  lea rbx, qword [rbp+rbx]
    67 000001BD 30C0                        xor al, al
    68 000001BF FFD3                        call rbx
    69                                  ;Adjust Int 41h address table
    70                                  
    71                                  adjInt41h:
    72 000001C1 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
    73 000001C6 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
    73 000001C8 [A901000000000000] 
    74 000001D0 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
    75                                  .ai41h:
    76 000001D5 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
    77 000001D8 4881C308000000              add rbx, 8              ;Each entry is size 8
    78 000001DF FFC9                        dec ecx
    79 000001E1 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
    80                                  
    81                                  ;Adjust Interrupt Entries Int 40h-49h
    82                                  adjInts:
    83 000001E3 B340                        mov bl, 40h
    84 000001E5 B807F00000                  mov eax, 0F007h ;Get the descriptor
    85 000001EA CD35                        int 35h
    86 000001EC B940000000                  mov ecx, 40h    ;Start from interrupt 40h
    87 000001F1 488D3D7A000000              lea rdi, intData
    88 000001F8 89C6                        mov esi, eax    ;Move segment selector info to esi
    89                                  .ai0:
    90 000001FA B808F00000                  mov eax, 0F008h ;Set the descriptor
    91 000001FF 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
    92 00000202 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
    93 00000205 CD35                        int 35h
    94 00000207 4881C708000000              add rdi, 8
    95 0000020E FFC1                        inc ecx
    96 00000210 81F94A000000                cmp ecx, 4Ah
    97 00000216 75E2                        jne .ai0
    98                                  
    99                                  ;Test Error Case
   100 00000218 B430                        mov ah, 00110000b
   101 0000021A B000                        mov al, 00h
   102 0000021C BF0C000000                  mov edi, 0Ch
   103 00000221 CD44                        int 44h
   104                                  
   105                                  
   106 00000223 488D1530000000              lea rdx, qword [startmsg]   ;Get the absolute address of message
   107 0000022A B409                        mov ah, 09h
   108 0000022C CD41                        int 41h
   109                                  
   110 0000022E 64488B3425-                 mov rsi, fs:[nulDevHdr]
   110 00000233 [AC000000]         
   111 00000237 B801C50000                  mov eax, 0C501h ;Connect debugger
   112 0000023C CD35                        int 35h
   113 0000023E 6687DB                      xchg bx, bx
   114                                  l1:
   115 00000241 B401                        mov ah, 01h  ;Write with echo
   116 00000243 CD41                        int 41h
   117 00000245 EBFA                        jmp short l1
   118                                  adjustDrvHdr:
   119                                  ;Input: rsi = Effective address of driver in DOS segment
   120                                  ;       rbp = Ptr to the start of the DOS segment
   121                                  ;Output: rsi = EA of next header in DOS segment
   122 00000247 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   123 0000024A 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   124 0000024E 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   125 00000252 4881C622000000              add rsi, drvHdr_size
   126 00000259 C3                          ret
   127                                  
   128 0000025A 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,"$"
   128 00000263 67205343502F444F53-
   128 0000026C 2E2E2E0A0D24       
   129                                  intData:
   130 00000272 [5900000000000000]          dq terminateProcess ;Int 40h
   131 0000027A [5900000000000000]          dq functionDispatch ;Int 41h
   132 00000282 [F904000000000000]          dq terminateHandler ;Int 42h
   133 0000028A [F904000000000000]          dq ctrlCHandler     ;Int 43h
   134 00000292 [F904000000000000]          dq critErrorHandler ;Int 44h
   135 0000029A [8C07000000000000]          dq absDiskRead      ;Int 45h
   136 000002A2 [A107000000000000]          dq absDiskWrite     ;Int 46h
   137 000002AA [B607000000000000]          dq terminateResident    ;Int 47h
   138 000002B2 [B607000000000000]          dq inDosHandler     ;Int 48h
   139 000002BA [B807000000000000]          dq fastOutput       ;Int 49h
   140                                  nData:
   141 000002C2 [C407000000000000]          dq conHdr
   142 000002CA 0480                        dw 08004h
   143 000002CC [6C09000000000000]          dq nulStrat
   144 000002D4 [7209000000000000]          dq nulIntr
   145 000002DC 4E554C2020202020            db "NUL     " ;Default NUL data
   146                                  
   147                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   148                                  ;-----------------------------------:
   149                                  ;       Misc System routines        :
   150                                  ;-----------------------------------:
   151                                  findLRUBuffer: 
   152                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   153                                  ;Input: Nothing
   154                                  ;Output: rbx = Pointer to the buffer to use
   155 00000000 52                          push rdx
   156 00000001 488B1D(8F000000)            mov rbx, qword [bufHeadPtr]
   157 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   158 0000000F 7502                        jne .flb1
   159 00000011 5A                          pop rdx
   160 00000012 C3                          ret
   161                                  .flb1:
   162 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   163 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   164 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   165 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   166 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   167 00000029 488B15(8F000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   168 00000030 48891D(8F000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   169 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   170 0000003A 5A                          pop rdx
   171 0000003B C3                          ret
   172                                  
   173                                  findDPB:
   174                                  ;Finds the DPB for a given drive
   175                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   176                                  ;Output: al = 00, rbx = Pointer to the DPB
   177                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   178 0000003C 488B1D(6D000000)            mov rbx, qword [dpbHeadPtr]
   179                                  .fd1:
   180 00000043 30C0                        xor al, al
   181 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   182 00000047 740F                        je .fd2
   183 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   184 0000004D B0FF                        mov al, -1
   185 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   186 00000056 75EB                        jne .fd1
   187                                  .fd2:
   188 00000058 C3                          ret
   189                                  callCritError:
   190                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   191                                  ;-----------------------------------:
   192                                  ;       File System routines        :
   193                                  ;-----------------------------------:
   194                                  name2Clust:
   195                                  ;Converts a file name to a first cluster number
   196                                  ;-----------------------------------:
   197                                  ;        Interrupt routines         :
   198                                  ;-----------------------------------:
   199                                  terminateProcess:   ;Int 40h
   200                                  
   201                                  functionDispatch:   ;Int 41h Main function dispatcher
   202                                  ;ah = Function number, all other registers have various meanings
   203 00000059 FA                          cli ;Halt external interrupts
   204 0000005A FC                          cld ;Ensure all string ops occur in the right direction
   205 0000005B 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   206 0000005E 0F871E010000                ja .fdExitBad
   207                                      ;Cherry pick functions
   208 00000064 80FC33                      cmp ah, 33h ;CTRL+BREAK check
   209 00000067 722C                        jb .fsbegin   ;If below skip these checks
   210 00000069 0F8439010000                je .ctrlBreakCheck
   211 0000006F 80FC64                      cmp ah, 64h
   212 00000072 0F8430010000                je .setDriverLookahead  ;Reserved, but avoids usual Int 41h spiel
   213 00000078 771B                        ja .fsbegin   ;If above, do usual Int41 entry
   214 0000007A 80FC51                      cmp ah, 51h
   215 0000007D 0F8425010000                je .getCurrProcessID    ;This an below are exactly the same
   216 00000083 80FC62                      cmp ah, 62h
   217 00000086 0F841C010000                je .getPSPaddr          ;Calls the above function
   218 0000008C 80FC50                      cmp ah, 50h
   219 0000008F 0F8413010000                je .setCurrProcessID
   220                                  .fsbegin:
   221                                      pushDOS ;Push the usual prologue registers
   192 00000095 4151                <1>  push r9
   193 00000097 4150                <1>  push r8
   194 00000099 55                  <1>  push rbp
   195 0000009A 57                  <1>  push rdi
   196 0000009B 56                  <1>  push rsi
   197 0000009C 52                  <1>  push rdx
   198 0000009D 51                  <1>  push rcx
   199 0000009E 53                  <1>  push rbx
   200 0000009F 50                  <1>  push rax
   222 000000A0 488B05(0D010000)            mov rax, qword [oldRSP]
   223 000000A7 488905(05010000)            mov qword [oldoldRSP], rax
   224 000000AE FE05(CF000000)              inc byte [inDOS]    ;Increment in DOS flag
   225 000000B4 488925(0D010000)            mov qword [oldRSP], rsp
   226                                  ;Here, we want to save oldRSP in the callers PSP
   227 000000BB 803D(CF000000)01            cmp byte [inDOS], 1 ;Check how many times we are in DOS
   228 000000C2 750B                        jne .fsb1   ;If this is first entry, save rsp in callers PSP
   229 000000C4 488B05(DE000000)            mov rax, qword [currentPSP] ;Get current PSP address
   230 000000CB 48896046                    mov qword [rax + psp.rspPtr], rsp    ;Save rsp on callers stack
   231                                  .fsb1:
   232 000000CF 58                          pop rax     ;Get old rax back
   233 000000D0 50                          push rax    ;and push it back onto the stack
   234 000000D1 488D25(56060000)            lea rsp, critStakTop
   235 000000D8 FB                          sti         ;Reenable interrupts
   236                                  
   237 000000D9 C605(04010000)01            mov byte [int48Flag], 1 ;Make it ok to trigger Int 48h
   238                                  
   239 000000E0 48891D(15010000)            mov qword [oldRBX], rbx ;Need to do this as I might switch stacks later
   240 000000E7 0FB6DC                      movzx ebx, ah   ;Move the function number bl zero extended to rbx
   241 000000EA C1E303                      shl ebx, 3      ;Multiply the function number by 8 for offset into table
   242 000000ED 50                          push rax        ;Push rax onto the stack
   243 000000EE 488D05B4000000              lea rax, qword [.dispatchTable]
   244 000000F5 4801C3                      add rbx, rax    ;Add dispatch table offset into rbx
   245 000000F8 58                          pop rax
   246 000000F9 488B1B                      mov rbx, qword [rbx]    ;Get the address from the dispatch table
   247                                  
   248 000000FC 84E4                        test ah, ah     ;Simple Terminate function?
   249 000000FE 741C                        jz .fddiskOp
   250 00000100 80FC59                      cmp ah, 59h     ;Extended Error report?
   251 00000103 7443                        je .fdGoToFunction  ;Bypass code that clears the error report
   252 00000105 80FC0C                      cmp ah, 0Ch     ;Are we a char function?
   253 00000108 7712                        ja .fddiskOp
   254                                  ;Char operations here
   255 0000010A F605(CE000000)01            test byte [critErrFlag], 1  ;Are we in critical error?
   256 00000111 7535                        jnz .fdGoToFunction         ;If we are, stay on Critical Error Stack
   257 00000113 488D25(960C0000)            lea rsp, IOStakTop          ;Otherwise, switch to IO stack
   258 0000011A EB2C                        jmp short .fdGoToFunction
   259                                  .fddiskOp:
   260                                      ;Disk operations go here
   261                                      ;Clear up error info
   262 0000011C C605(D1000000)01            mov byte [errorLocus], 1    ;Reset to generic, unknown locus
   263 00000123 C605(CE000000)00            mov byte [critErrFlag], 0   ;Clear the Critical Error Flag
   264 0000012A C605(D0000000)FF            mov byte [errorDrv], -1     ;Set the drive which caused the error to none
   265                                  
   266 00000131 C605(04010000)00            mov byte [int48Flag], 0     ;Turn off the ability to trigger Int 48h
   267 00000138 488D25(D6120000)            lea rsp, DiskStakTop        ;Swap the stack to the Disk Transfer Stack
   268 0000013F F605(F9000000)FF            test byte [breakFlag], -1   ;Test if set
   269 00000146 7400                        jz .fdGoToFunction
   270                                  ; HANDLE CTRL+BREAK HERE!
   271                                  .fdGoToFunction:
   272 00000148 48871D(15010000)            xchg rbx, qword [oldRBX]    ;Put the call addr in oldRBX and get oldRBX back
   273                                      ;Potentially point rbp to caller reg frame for easy access of registers 
   274                                      ;mov rbp, qword [oldRSP]    ;Move rsp on entry into rbp
   275 0000014F FF15(15010000)              call qword [oldRBX]     ;Call the desired function, rax contains ret code
   276                                  .fdExit:
   277 00000155 FA                          cli     ;Redisable interrupts
   278                                      ;???
   279 00000156 FE0D(CF000000)              dec byte [inDOS]            ;Decrement the inDOS count
   280 0000015C 488B25(0D010000)            mov rsp, qword [oldRSP]     ;Point rsp to old stack
   281 00000163 48890424                    mov qword [rsp], rax    ;Put the ret code into its pos on the register frame
   282 00000167 488B05(05010000)            mov rax, qword [oldoldRSP]
   283 0000016E 488905(0D010000)            mov qword [oldRSP], rax
   284                                      popDOS  ;Pop the frame
   204 00000175 58                  <1>  pop rax
   205 00000176 5B                  <1>  pop rbx
   206 00000177 59                  <1>  pop rcx
   207 00000178 5A                  <1>  pop rdx
   208 00000179 5E                  <1>  pop rsi
   209 0000017A 5F                  <1>  pop rdi
   210 0000017B 5D                  <1>  pop rbp
   211 0000017C 4158                <1>  pop r8
   212 0000017E 4159                <1>  pop r9
   285 00000180 48CF                        iretq
   286                                  .fdExitBad:
   287 00000182 B400                        mov ah, 0
   288 00000184 48CF                        iretq
   289                                  .simpleTerminate:     ;ah = 00h
   290 00000186 C3                          ret
   291                                  .stdinReadEcho:     ;ah = 01h
   292 00000187 30E4                        xor ah, ah
   293 00000189 CD36                        int 36h
   294 0000018B CD49                        int 49h ;Pass al to fast output
   295 0000018D C3                          ret
   296                                  .stdoutWrite:       ;ah = 02h
   297                                  ;Bspace is regular cursor left, does not insert a blank
   298 0000018E 50                          push rax
   299 0000018F 88D0                        mov al, dl
   300 00000191 CD49                        int 49h
   301 00000193 58                          pop rax
   302 00000194 C3                          ret
   303                                  .stdauxRead:        ;ah = 03h
   304                                  .stdauxWrite:       ;ah = 04h
   305                                  .stdprnWrite:       ;ah = 05h
   306                                  .directCONIO:       ;ah = 06h
   307                                  .waitDirectInNoEcho:;ah = 07h
   308                                  .waitStdinNoEcho:   ;ah = 08h
   309 00000195 C3                          ret
   310                                  .printString:       ;ah = 09h
   311 00000196 50                          push rax
   312 00000197 52                          push rdx
   313                                  .ps0:
   314 00000198 8A02                        mov al, byte [rdx]
   315 0000019A 3C24                        cmp al, "$"
   316 0000019C 7407                        je .ps1
   317 0000019E 48FFC2                      inc rdx ;Goto next char
   318 000001A1 CD49                        int 49h ;Print char in al
   319 000001A3 EBF3                        jmp short .ps0
   320                                  .ps1:
   321 000001A5 5A                          pop rdx
   322 000001A6 58                          pop rax
   323 000001A7 C3                          ret
   324                                  .buffStdinInput:    ;ah = 0Ah
   325                                  .checkStdinStatus:  ;ah = 0Bh
   326                                  .clearbuffDoFunc:   ;ah = 0Ch
   327                                  .diskReset:         ;ah = 0Dh
   328                                  .selectDisk:        ;ah = 0Eh
   329                                  .openFileFCB:       ;ah = 0Fh
   330                                  .closeFileFCB:      ;ah = 10h
   331                                  .findFirstFileFCB:  ;ah = 11h
   332                                  .findNextFileFCB:   ;ah = 12h
   333                                  .deleteFileFCB:     ;ah = 13h
   334                                  .sequentialReadFCB: ;ah = 14h
   335                                  .sequentialWriteFCB:;ah = 15h
   336                                  .createFileFCB:     ;ah = 16h
   337                                  .renameFileFCB:     ;ah = 17h
   338                                                      ;ah = 18h unused
   339                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   340                                  .setDTA:            ;ah = 1Ah
   341                                  .FATinfoDefault:    ;ah = 1Bh
   342                                  .FatinfoDevice:     ;ah = 1Ch
   343                                                      ;ah = 1Dh unused
   344                                                      ;ah = 1Eh unused
   345                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   346                                                      ;ah = 20h unused
   347                                  .randomReadFCB:     ;ah = 21h
   348                                  .randomWriteFCB:    ;ah = 22h
   349                                  .getFileSizeFCB:    ;ah = 23h
   350                                  .setRelRecordFCB:   ;ah = 24h
   351                                  .setIntVector:      ;ah = 25h
   352                                  .createNewPSP:      ;ah = 26h
   353                                  .randBlockReadFCB:  ;ah = 27h
   354                                  .randBlockWriteFCB: ;ah = 28h
   355                                  .parseFilenameFCB:  ;ah = 29h
   356                                  .getDate:           ;ah = 2Ah
   357                                  .setDate:           ;ah = 2Bh
   358                                  .getTime:           ;ah = 2Ch
   359                                  .setTime:           ;ah = 2Dh
   360                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   361                                  .getDTA:            ;ah = 2Fh
   362                                  .getDOSversion:     ;ah = 30h
   363                                  .terminateStayRes:  ;ah = 31h
   364                                  .getDeviceDPBptr:   ;ah = 32h
   365                                  .ctrlBreakCheck:    ;ah = 33h
   366                                  .getInDOSflagPtr:   ;ah = 34h
   367                                  .getIntVector:      ;ah = 35h
   368                                  .getDiskFreeSpace:  ;ah = 36h
   369                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   370                                  .getsetCountryInfo: ;ah = 38h, localisation info
   371                                  .makeDIR:           ;ah = 39h
   372                                  .removeDIR:         ;ah = 3Ah
   373                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   374                                  .createFileHdl:     ;ah = 3Ch, handle function
   375                                  .openFileHdl:       ;ah = 3Dh, handle function
   376                                  .closeFileHdl:      ;ah = 3Eh, handle function
   377                                  .readFileHdl:       ;ah = 3Fh, handle function
   378                                  .writeFileHdl:      ;ah = 40h, handle function
   379                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   380                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   381                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   382                                  .ioctrl:            ;ah = 44h, handle function
   383                                  .duplicateHandle:   ;ah = 45h, handle function
   384                                  .forceDuplicateHdl: ;ah = 46h, handle function
   385                                  .getCurrentDIR:     ;ah = 47h
   386                                  .allocateMemory:    ;ah = 48h
   387                                  .freeMemory:        ;ah = 49h
   388                                  .reallocMemory:     ;ah = 4Ah
   389                                  .loadExecChild:     ;ah = 4Bh, EXEC
   390                                  .terminateClean:    ;ah = 4Ch, EXIT
   391                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   392                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   393                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   394                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   395                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   396                                  .getSysVarsPtr:     ;ah = 52h
   397                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   398                                  .getVerifySetting:  ;ah = 54h
   399                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   400                                  .renameFile:        ;ah = 56h
   401                                  .getSetFileDateTime:;ah = 57h
   402                                  .getsetMallocStrat: ;ah = 58h
   403                                  .getExtendedError:  ;ah = 59h
   404                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   405                                  .createNewFile:     ;ah = 5Bh
   406                                  .lockUnlockFile:    ;ah = 5Ch
   407                                  .getCritErrorInfo:  ;ah = 5Dh
   408                                  .networkServices:   ;ah = 5Eh, do nothing
   409                                  .networkRedirection:;ah = 5Fh, do nothing
   410                                  .trueName:          ;ah = 60h, get fully qualified name
   411                                                      ;ah = 61h, reserved
   412                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   413                                                      ;ah = 63h, reserved
   414                                  .setDriverLookahead:;ah = 64h, reserved
   415                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   416                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   417                                  .setHandleCount:    ;ah = 67h
   418                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   419                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   420                                  .return:
   421 000001A8 C3                          ret
   422                                  
   423                                  
   424                                  .dispatchTable:
   425 000001A9 [8601000000000000]          dq .simpleTerminate     ;AH = 00H, PROCESS MANAGEMENT
   426 000001B1 [8701000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   427 000001B9 [8E01000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   428 000001C1 [9501000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   429 000001C9 [9501000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   430 000001D1 [9501000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   431 000001D9 [9501000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   432 000001E1 [9501000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   433 000001E9 [9501000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   434 000001F1 [9601000000000000]          dq .printString         ;AH = 09H, CHAR IO
   435 000001F9 [A801000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   436 00000201 [A801000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   437 00000209 [A801000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   438 00000211 [A801000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   439 00000219 [A801000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   440 00000221 [A801000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   441 00000229 [A801000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   442 00000231 [A801000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   443 00000239 [A801000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   444 00000241 [A801000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   445 00000249 [A801000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   446 00000251 [A801000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   447 00000259 [A801000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   448 00000261 [A801000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   449 00000269 [A801000000000000]          dq .return              ;AH = 18H, RESERVED
   450 00000271 [A801000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   451 00000279 [A801000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   452 00000281 [A801000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   453 00000289 [A801000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   454 00000291 [A801000000000000]          dq .return              ;AH = 1DH, RESERVED
   455 00000299 [A801000000000000]          dq .return              ;AH = 1EH, RESERVED
   456 000002A1 [A801000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   457 000002A9 [A801000000000000]          dq .return              ;AH = 20H, RESERVED
   458 000002B1 [A801000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   459 000002B9 [A801000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   460 000002C1 [A801000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   461 000002C9 [A801000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   462 000002D1 [A801000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   463 000002D9 [A801000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   464 000002E1 [A801000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   465 000002E9 [A801000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   466 000002F1 [A801000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   467 000002F9 [A801000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   468 00000301 [A801000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   469 00000309 [A801000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   470 00000311 [A801000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   471 00000319 [A801000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   472 00000321 [A801000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   473 00000329 [A801000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   474 00000331 [A801000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   475 00000339 [A801000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   476 00000341 [A801000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   477 00000349 [A801000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   478 00000351 [A801000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   479 00000359 [A801000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   480 00000361 [A801000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   481 00000369 [A801000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   482 00000371 [A801000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   483 00000379 [A801000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   484 00000381 [A801000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   485 00000389 [A801000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   486 00000391 [A801000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   487 00000399 [A801000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   488 000003A1 [A801000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   489 000003A9 [A801000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   490 000003B1 [A801000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   491 000003B9 [A801000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   492 000003C1 [A801000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   493 000003C9 [A801000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   494 000003D1 [A801000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   495 000003D9 [A801000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   496 000003E1 [A801000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   497 000003E9 [A801000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   498 000003F1 [A801000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   499 000003F9 [A801000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   500 00000401 [A801000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   501 00000409 [A801000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   502 00000411 [A801000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   503 00000419 [A801000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   504 00000421 [A801000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   505 00000429 [A801000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   506 00000431 [A801000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   507 00000439 [A801000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   508 00000441 [A801000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   509 00000449 [A801000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   510 00000451 [A801000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   511 00000459 [A801000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   512 00000461 [A801000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   513 00000469 [A801000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   514 00000471 [A801000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   515 00000479 [A801000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   516 00000481 [A801000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   517 00000489 [A801000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   518 00000491 [A801000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   519 00000499 [A801000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   520 000004A1 [A801000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   521 000004A9 [A801000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   522 000004B1 [A801000000000000]          dq .return              ;AH = 61H, RESERVED
   523 000004B9 [A801000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   524 000004C1 [A801000000000000]          dq .return              ;AH = 63H, RESERVED
   525 000004C9 [A801000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   526 000004D1 [A801000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   527 000004D9 [A801000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   528 000004E1 [A801000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   529 000004E9 [A801000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   530 000004F1 [A801000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   531                                  dispatchTableL  equ $ - .dispatchTable 
   532                                  
   533                                  terminateHandler:   ;Int 42h
   534                                  ctrlCHandler:       ;Int 43h
   535                                  critErrorHandler:   ;Int 44h
   536                                  ;User Stack in usage here, must be swapped to before this is called
   537                                  ;Entered with:  
   538                                  ;               AH = Critical Error Bitfield
   539                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   540                                  ;               Bit 6 - Reserved
   541                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   542                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   543                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   544                                  ;               Bits [2-1] = Affected Disk Error
   545                                  ;                     0 0   DOS area
   546                                  ;                     0 1   FAT area
   547                                  ;                     1 0   Directory area
   548                                  ;                     1 1   Data area
   549                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   550                                  ;               AL  = Failing drive number if AH[7] = 0
   551                                  ;               DIL = Error code for errorMsg
   552                                  ;               RSI = EA of Device Header for which device the error occured
   553                                  ;Return:
   554                                  ;               AL = 0 - Ignore the Error       (Ignore)
   555                                  ;                  = 1 - Retry the Operation    (Retry)
   556                                  ;                  = 2 - Terminate the Program  (Abort)
   557                                  ;                  = 3 - Fail the DOS call      (Fail)
   558 000004F9 53                          push rbx
   559 000004FA 51                          push rcx
   560 000004FB 52                          push rdx
   561 000004FC 57                          push rdi
   562 000004FD 56                          push rsi
   563 000004FE FC                          cld         ;Make String ops go forward
   564                                  
   565 000004FF 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   566 00000502 488D155E020000              lea rdx, qword [.crlf]
   567 00000509 B409                        mov ah, 09h ;Print String
   568 0000050B CD41                        int 41h     ;Call DOS to print CRLF part of message
   569                                  
   570 0000050D 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   571 00000513 B90C000000                  mov ecx, 0Ch
   572 00000518 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   573 0000051A 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   574 0000051D 480FB7FF                    movzx rdi, di
   575 00000521 4889FA                      mov rdx, rdi    ;Copy error code
   576 00000524 48C1E704                    shl rdi, 4  ;Multiply by 16
   577 00000528 48D1E2                      shl rdx, 1  ;Multiply by 2
   578 0000052B 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   579 0000052E 488D1523010000              lea rdx, qword [.errorMsgTable]
   580 00000535 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   581 00000539 B409                        mov ah, 09h ;Print String
   582 0000053B CD41                        int 41h     ;Call DOS to print first part of message
   583                                  
   584 0000053D 488D1505020000              lea rdx, qword [.readmsg]
   585 00000544 488D3D0D020000              lea rdi, qword [.writemsg]
   586 0000054B F6C701                      test bh, 1  ;Bit 0 is set if write operation
   587 0000054E 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   588 00000552 B409                        mov ah, 09h ;Print String
   589 00000554 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   590                                  
   591 00000556 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   592 00000559 0F85DF000000                jnz .charError
   593                                  ;Disk error continues here
   594 0000055F 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   595 00000566 B409                        mov ah, 09h
   596 00000568 CD41                        int 41h
   597 0000056A 88DA                        mov dl, bl  ;Get zero based drive number into dl
   598 0000056C 80C241                      add dl, "A" ;Add ASCII code
   599 0000056F B402                        mov ah, 02h ;Print char in dl
   600 00000571 CD41                        int 41h
   601                                  .userInput:
   602 00000573 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   603 0000057A B409                        mov ah, 09h
   604 0000057C CD41                        int 41h
   605                                  ;Abort, Retry, Ignore, Fail is word order
   606                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   607                                  .userAbort:
   608                                  ;Abort is always an option
   609 0000057E 488D15E5010000              lea rdx, qword [.abortmsg]
   610 00000585 B409                        mov ah, 09h
   611 00000587 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   612                                  .userRetry:
   613 00000589 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   614 0000058C 7416                        jz .userIgnore    ;If clear, dont print message
   615 0000058E 488D15ED010000              lea rdx, qword [.betweenMsg]
   616 00000595 B409                        mov ah, 09h
   617 00000597 CD41                        int 41h
   618 00000599 488D15D7010000              lea rdx, qword [.retrymsg]
   619 000005A0 B409                        mov ah, 09h
   620 000005A2 CD41                        int 41h
   621                                  .userIgnore:
   622 000005A4 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   623 000005A7 7416                        jz .userFail
   624 000005A9 488D15D2010000              lea rdx, qword [.betweenMsg]
   625 000005B0 B409                        mov ah, 09h
   626 000005B2 CD41                        int 41h
   627 000005B4 488D15B5010000              lea rdx, qword [.ignoremsg]
   628 000005BB B409                        mov ah, 09h
   629 000005BD CD41                        int 41h
   630                                  .userFail:
   631 000005BF F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   632 000005C2 7416                        jz .userMsgEnd
   633 000005C4 488D15B7010000              lea rdx, qword [.betweenMsg]
   634 000005CB B409                        mov ah, 09h
   635 000005CD CD41                        int 41h
   636 000005CF 488D15A7010000              lea rdx, qword [.failmsg]
   637 000005D6 B409                        mov ah, 09h
   638 000005D8 CD41                        int 41h
   639                                  .userMsgEnd:
   640 000005DA 488D15A4010000              lea rdx, qword [.endMsg]
   641 000005E1 B409                        mov ah, 09h
   642 000005E3 CD41                        int 41h
   643                                  ;Get user input now 
   644 000005E5 31C9                        xor ecx, ecx  ;4 Possible Responses
   645 000005E7 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   646 000005EE B401                        mov ah, 01h ;STDIN without Console Echo
   647 000005F0 CD41                        int 41h ;Get char in al
   648 000005F2 3C61                        cmp al, "a" ;Chack if lowercase
   649 000005F4 7202                        jb .uip1    ;If the value is below, ignore subtraction
   650 000005F6 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   651                                  .uip1:
   652 000005F8 AE                          scasb   ;Compare char to list, offset gives return code
   653 000005F9 740F                        je .validInput  ;If they are equal, ecx has return code
   654 000005FB FFC1                        inc ecx
   655 000005FD 81F904000000                cmp ecx, 4
   656 00000603 75F3                        jne .uip1
   657 00000605 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   658                                  .validInput:
   659 0000060A 88C8                        mov al, cl  ;Move the offset into .responses into al
   660                                  ;Now check if the input is permitted
   661 0000060C 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   662 0000060E 7427                        je .cehExit
   663 00000610 84C0                        test al, al ;Check if 0 => Ignore
   664 00000612 740F                        je .viIgnore
   665 00000614 3C01                        cmp al, 1   ;Check if 1 => Retry
   666 00000616 7416                        je .viRetry
   667                                  .viFail:    ;Fallthrough for fail (al = 3)
   668 00000618 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   669 0000061B 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   670 00000621 EB14                        jmp short .cehExit
   671                                  .viIgnore:
   672 00000623 F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   673 00000626 0F8447FFFFFF                jz .userInput
   674 0000062C EB09                        jmp short .cehExit
   675                                  .viRetry:
   676 0000062E F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   677 00000631 0F843CFFFFFF                jz .userInput
   678                                  .cehExit:
   679 00000637 5E                          pop rsi
   680 00000638 5F                          pop rdi
   681 00000639 5A                          pop rdx
   682 0000063A 59                          pop rcx
   683 0000063B 5B                          pop rbx
   684 0000063C 48CF                        iretq
   685                                  .charError:
   686 0000063E B908000000                  mov ecx, 8  ;8 chars in device name
   687 00000643 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   688                                  .ce1:
   689 0000064A AC                          lodsb   ;Get a string char into al and inc rsi
   690 0000064B 88C2                        mov dl, al  ;Move char into dl
   691 0000064D B402                        mov ah, 02h
   692 0000064F CD41                        int 41h ;Print char
   693 00000651 E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   694 00000653 E91BFFFFFF                  jmp .userInput
   695                                  
   696                                  .errorMsgTable: ;Each table entry is 18 chars long
   697 00000658 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   697 00000661 746563742024202020 
   698 0000066A 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   698 00000673 6E6974202420202020 
   699 0000067C 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   699 00000685 202420202020202020 
   700 0000068E 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   700 00000697 6F6D6D616E64202420 
   701 000006A0 446174612024202020-                 db "Data $            "       ;Error 4
   701 000006A9 202020202020202020 
   702 000006B2 426164205265717565-                 db "Bad Request $     "       ;Error 5
   702 000006BB 737420242020202020 
   703 000006C4 5365656B2024202020-                 db "Seek $            "       ;Error 6
   703 000006CD 202020202020202020 
   704 000006D6 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   704 000006DF 656469612024202020 
   705 000006E8 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   705 000006F1 7420466F756E642024 
   706 000006FA 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   706 00000703 706572202420202020 
   707 0000070C 577269746520466175-                 db "Write Fault $     "       ;Error A
   707 00000715 6C7420242020202020 
   708 0000071E 52656164204661756C-                 db "Read Fault $      "       ;Error B
   708 00000727 742024202020202020 
   709 00000730 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   709 00000739 61696C757265202420 
   710                                  
   711 00000742 64726976652024          .drive      db "drive $"
   712 00000749 6572726F7220726561-     .readmsg    db "error reading $"
   712 00000752 64696E672024       
   713 00000758 6572726F7220777269-     .writemsg   db "error writing $"
   713 00000761 74696E672024       
   714 00000767 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   715 0000076A 41626F727424            .abortmsg   db "Abort$" 
   716 00000770 49676E6F726524          .ignoremsg  db "Ignore$"
   717 00000777 526574727924            .retrymsg   db "Retry$"
   718 0000077D 4661696C24              .failmsg    db "Fail$"
   719 00000782 2C2024                  .betweenMsg db ", $"
   720 00000785 3F2024                  .endMsg     db "? $"
   721 00000788 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   722                                  absDiskRead:        ;Int 45h
   723                                  ;al = Drive number
   724                                  ;rbx = Memory Buffer address
   725                                  ;ecx = Number of sectors to read (max 255 for now)
   726                                  ;rdx = Start LBA to read from
   727 0000078C 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   728 00000790 8A80[75100000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   729 00000796 4891                        xchg rax, rcx
   730 00000798 4887CA                      xchg rcx, rdx
   731 0000079B B482                        mov ah, 82h
   732 0000079D CD33                        int 33h
   733 0000079F 48CF                        iretq
   734                                  absDiskWrite:       ;Int 46h
   735 000007A1 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   736 000007A5 8A80[75100000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   737 000007AB 4891                        xchg rax, rcx
   738 000007AD 4887CA                      xchg rcx, rdx
   739 000007B0 B483                        mov ah, 83h
   740 000007B2 CD33                        int 33h
   741 000007B4 48CF                        iretq
   742                                  terminateResident:  ;Int 47h
   743                                  inDosHandler:       ;Int 48h
   744                                  ;Called when DOS idle
   745 000007B6 48CF                        iretq
   746                                  fastOutput:         ;Int 49h
   747                                  ;Called with char to transfer in al
   748 000007B8 50                          push rax
   749 000007B9 B40E                        mov ah, 0Eh
   750 000007BB CD30                        int 30h
   751 000007BD 58                          pop rax
   752 000007BE 48CF                        iretq
   753                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   754 000007C0 48CF                        iretq
   755                                  multiplex:          ;Int 4Fh, kept as iretq for now
   756 000007C2 48CF                        iretq
   757                                  ;-----------------------------------:
   758                                  ;          Driver routines          :
   759                                  ;-----------------------------------:
   760                                  drivers:
   761                                  conHdr:
   762 000007C4 [E607000000000000]          dq auxHdr
   763 000007CC 1308                        dw 0813h
   764 000007CE [5C09000000000000]          dq commonStrat
   765 000007D6 [7309000000000000]          dq conDriver
   766 000007DE 434F4E2020202020            db "CON     "
   767                                  auxHdr:
   768 000007E6 [0808000000000000]          dq prnHdr
   769 000007EE 0080                        dw 08000h
   770 000007F0 [5C09000000000000]          dq commonStrat
   771 000007F8 [7A0A000000000000]          dq com1Intr
   772 00000800 4155582020202020            db "AUX     "
   773                                  prnHdr:
   774 00000808 [2A08000000000000]          dq clkHdr
   775 00000810 40A0                        dw 0A040h
   776 00000812 [6C09000000000000]          dq nulStrat
   777 0000081A [7209000000000000]          dq nulIntr
   778 00000822 50524E2020202020            db "PRN     "
   779                                  clkHdr:
   780 0000082A [4C08000000000000]          dq msdHdr
   781 00000832 0880                        dw 08008h
   782 00000834 [5C09000000000000]          dq commonStrat
   783 0000083C [7A0A000000000000]          dq clkDriver
   784 00000844 434C4F434B242020            db "CLOCK$  "
   785                                  msdHdr:
   786 0000084C [6E08000000000000]          dq com1Hdr
   787 00000854 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   788 00000856 [5C09000000000000]          dq commonStrat
   789 0000085E [1F0C000000000000]          dq msdDriver
   790 00000866 0000000000000000            db 0,0,0,0,0,0,0,0
   791                                  com1Hdr:
   792 0000086E [9008000000000000]          dq com2Hdr
   793 00000876 0080                        dw 08000h
   794 00000878 [5C09000000000000]          dq commonStrat
   795 00000880 [7A0A000000000000]          dq com1Intr
   796 00000888 434F4D3120202020            db "COM1    "
   797                                  com2Hdr:
   798 00000890 [B208000000000000]          dq com3Hdr
   799 00000898 0080                        dw 08000h
   800 0000089A [5C09000000000000]          dq commonStrat
   801 000008A2 [830A000000000000]          dq com2Intr
   802 000008AA 434F4D3220202020            db "COM2    "
   803                                  com3Hdr:
   804 000008B2 [D408000000000000]          dq com4Hdr
   805 000008BA 0080                        dw 08000h
   806 000008BC [5C09000000000000]          dq commonStrat
   807 000008C4 [8C0A000000000000]          dq com3Intr
   808 000008CC 434F4D3320202020            db "COM3    "
   809                                  com4Hdr:
   810 000008D4 [F608000000000000]          dq lpt1Hdr
   811 000008DC 0080                        dw 08000h
   812 000008DE [5C09000000000000]          dq commonStrat
   813 000008E6 [950A000000000000]          dq com4Intr
   814 000008EE 434F4D3420202020            db "COM4    "
   815                                  lpt1Hdr:
   816 000008F6 [1809000000000000]          dq lpt2Hdr
   817 000008FE 40A0                        dw 0A040h
   818 00000900 [6C09000000000000]          dq nulStrat
   819 00000908 [7209000000000000]          dq nulIntr
   820 00000910 4C50543120202020            db "LPT1    "
   821                                  lpt2Hdr:
   822 00000918 [3A09000000000000]          dq lpt3Hdr
   823 00000920 40A0                        dw 0A040h
   824 00000922 [6C09000000000000]          dq nulStrat
   825 0000092A [7209000000000000]          dq nulIntr
   826 00000932 4C50543220202020            db "LPT2    "
   827                                  lpt3Hdr:
   828 0000093A FFFFFFFFFFFFFFFF            dq -1
   829 00000942 40A0                        dw 0A040h
   830 00000944 [6C09000000000000]          dq nulStrat
   831 0000094C [7209000000000000]          dq nulIntr
   832 00000954 4C50543320202020            dq "LPT3    "
   833                                  
   834                                  commonStrat:
   835                                  ;DOS calls this function with rbx=Ptr to request header
   836 0000095C 48891D01000000              mov qword [reqHdrPtr], rbx
   837 00000963 C3                          ret
   838 00000964 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   839                                  
   840                                  nulStrat:
   841 0000096C 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   842                                  nulIntr:
   843 00000972 C3                          ret
   844                                  
   845                                  conDriver:
   846 00000973 50                          push rax
   847 00000974 53                          push rbx
   848 00000975 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   849 0000097C B003                        mov al, 03h ;Unknown Command
   850 0000097E 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
   851 00000982 772D                        ja .conWriteErrorCode ;If yes, error!
   852                                  
   853 00000984 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   854 00000987 84C0                        test al, al
   855 00000989 0F84C0000000                jz .conInit
   856 0000098F 3C04                        cmp al, 4
   857 00000991 742D                        jz .conRead
   858 00000993 3C05                        cmp al, 5
   859 00000995 744D                        jz .conNondestructiveRead
   860 00000997 3C06                        cmp al, 6
   861 00000999 7463                        jz .conInputStatus
   862 0000099B 3C07                        cmp al, 7
   863 0000099D 7468                        jz .conFlushInputBuffers
   864 0000099F 3C08                        cmp al, 8
   865 000009A1 7477                        jz .conWrite
   866 000009A3 3C09                        cmp al, 9
   867 000009A5 7473                        jz .conWrite
   868 000009A7 3C0A                        cmp al, 0Ah
   869 000009A9 0F8490000000                jz .conOutputStatus
   870 000009AF EB06                        jmp short .conExit  ;All other valid functions return done
   871                                  .conWriteErrorCode:     ;Jump to with al=Standard Error code
   872 000009B1 B480                        mov ah, 80h ;Set error bit
   873 000009B3 66894303                    mov word [rbx + drvReqHdr.status], ax
   874                                  .conExit:
   875 000009B7 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   876 000009BD 5B                          pop rbx
   877 000009BE 58                          pop rax
   878 000009BF C3                          ret
   879                                  .conRead:    ;Function 4
   880 000009C0 B005                        mov al, 05h ;Bad request structure length?
   881 000009C2 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
   882 000009C5 75EA                        jne .conWriteErrorCode
   883                                  
   884 000009C7 57                          push rdi
   885 000009C8 51                          push rcx
   886 000009C9 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   887 000009CD 31C9                        xor ecx, ecx    ;Zero the char counter
   888                                  .cr1:
   889 000009CF 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   890 000009D2 7409                        je .cre2
   891 000009D4 31C0                        xor eax, eax
   892 000009D6 CD36                        int 36h
   893 000009D8 AA                          stosb   ;Store char in al into buffer and inc rdi
   894 000009D9 FFC1                        inc ecx
   895 000009DB EBF2                        jmp short .cr1
   896                                  .cre2:
   897 000009DD 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   898 000009E0 59                          pop rcx
   899 000009E1 5F                          pop rdi
   900 000009E2 EBD3                        jmp short .conExit
   901                                  
   902                                  .conNondestructiveRead:  ;Function 5
   903 000009E4 B005                        mov al, 05h ;Bad request structure length?
   904 000009E6 803B0E                      cmp byte [rbx + drvReqHdr.hdrlen], nonDestInNoWaitReqPkt_size
   905 000009E9 75C6                        jne .conWriteErrorCode
   906                                  
   907 000009EB B401                        mov ah, 01h     ;Get key if exists
   908 000009ED CD36                        int 36h
   909 000009EF 7405                        jz .cnr           ;If zero clear => no key, go forwards
   910                                      ;Keystroke available
   911 000009F1 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   912 000009F4 EBC1                        jmp short .conExit
   913                                  .cnr: ;No keystroke available
   914 000009F6 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h   ;Set busy bit
   915 000009FC EBB9                        jmp short .conExit
   916                                  
   917                                  .conInputStatus:         ;Function 6
   918 000009FE B005                        mov al, 05h ;Bad request structure length?
   919 00000A00 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
   920 00000A03 75AC                        jne .conWriteErrorCode
   921 00000A05 EBB0                        jmp short .conExit ;Exit, device ready
   922                                  
   923                                  .conFlushInputBuffers:   ;Function 7
   924 00000A07 B005                        mov al, 05h ;Bad request structure length?
   925 00000A09 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
   926 00000A0C 75A3                        jne .conWriteErrorCode
   927                                  .cfib0:
   928 00000A0E B401                        mov ah, 01      ;Get buffer status
   929 00000A10 CD36                        int 36h
   930 00000A12 74A3                        jz .conExit     ;If zero clear => no more keys to read
   931 00000A14 30E4                        xor ah, ah
   932 00000A16 CD36                        int 36h ;Read key to flush from buffer
   933 00000A18 EBF4                        jmp short .cfib0
   934                                  
   935                                  .conWrite:   ;Function 8 and 9
   936 00000A1A B005                        mov al, 05h ;Bad request structure length?
   937 00000A1C 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
   938 00000A1F 7590                        jne .conWriteErrorCode
   939                                  
   940 00000A21 56                          push rsi
   941 00000A22 51                          push rcx
   942 00000A23 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   943 00000A27 31C9                        xor ecx, ecx    ;Zero the char counter
   944                                  .cw1: 
   945 00000A29 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   946 00000A2C 7407                        je .cw2
   947 00000A2E AC                          lodsb   ;Get char into al, and inc rsi
   948 00000A2F CD49                        int 49h ;Fast print char
   949 00000A31 FFC1                        inc ecx
   950 00000A33 EBF4                        jmp short .cw1 ;keep printing until all chars printed
   951                                  .cw2:
   952 00000A35 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   953 00000A38 59                          pop rcx
   954 00000A39 5E                          pop rsi
   955 00000A3A E978FFFFFF                  jmp .conExit
   956                                  .conOutputStatus:   ;Function 0Ah
   957 00000A3F B005                        mov al, 05h ;Bad request structure length?
   958 00000A41 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
   959 00000A44 0F8567FFFFFF                jne .conWriteErrorCode
   960 00000A4A E968FFFFFF                  jmp .conExit
   961                                  
   962                                  .conInit:    ;Function 0
   963 00000A4F 52                          push rdx
   964                                      ;Flush keyboard buffer
   965                                  .ci0:
   966 00000A50 B401                        mov ah, 01      ;Get buffer status
   967 00000A52 CD36                        int 36h
   968 00000A54 7406                        jz .ci1      ;If zero clear => no more keys to read
   969 00000A56 30E4                        xor ah, ah
   970 00000A58 CD36                        int 36h ;Read key to flush from buffer
   971 00000A5A EBF4                        jmp short .ci0
   972                                  .ci1:
   973 00000A5C B800050000                  mov eax, 0500h  ;Set page zero as the default page
   974 00000A61 CD30                        int 30h
   975 00000A63 B402                        mov ah, 02h
   976 00000A65 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   977 00000A67 88D7                        mov bh, dl      ;Set cursor for page 0
   978 00000A69 CD30                        int 30h
   979 00000A6B B707                        mov bh, 07h     ;Grey/Black attribs
   980 00000A6D B800060000                  mov eax, 0600h  ;Clear whole screen
   981 00000A72 CD30                        int 30h
   982 00000A74 5A                          pop rdx
   983 00000A75 E93DFFFFFF                  jmp .conExit
   984                                      
   985                                  clkDriver:
   986                                  
   987                                  ;COM Driver headers and main interrupt strat
   988                                  com1Intr:
   989 00000A7A C6059D01000000              mov byte [comIntr.comDevice], 0
   990 00000A81 EB19                        jmp short comIntr
   991                                  com2Intr:
   992 00000A83 C6059401000001              mov byte [comIntr.comDevice], 1
   993 00000A8A EB10                        jmp short comIntr
   994                                  com3Intr:
   995 00000A8C C6058B01000002              mov byte [comIntr.comDevice], 2
   996 00000A93 EB07                        jmp short comIntr
   997                                  com4Intr:
   998 00000A95 C6058201000003              mov byte [comIntr.comDevice], 3
   999                                  comIntr:
  1000 00000A9C 50                          push rax
  1001 00000A9D 53                          push rbx
  1002 00000A9E 51                          push rcx
  1003 00000A9F 52                          push rdx
  1004 00000AA0 56                          push rsi
  1005 00000AA1 488B1DBCFEFFFF              mov rbx, qword [reqHdrPtr]
  1006 00000AA8 B003                        mov al, 03h ;Unknown Command
  1007 00000AAA 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1008 00000AAE 7756                        ja .comWriteErrorCode ;If yes, error!
  1009                                  
  1010 00000AB0 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
  1011 00000AB3 3C04                        cmp al, 4   ;Read Character(s)
  1012 00000AB5 7461                        jz .comRead
  1013 00000AB7 3C05                        cmp al, 5   ;Non-destructive read, acts like fast read 1 char if available
  1014 00000AB9 0F849C000000                jz .comNondestructiveRead   
  1015 00000ABF 3C06                        cmp al, 6   ;Read Input Status, always return with Busy bit = 0
  1016 00000AC1 0F8485000000                jz .comReadInputStatus
  1017 00000AC7 3C07                        cmp al, 7   ;Flush read buffers, return done
  1018 00000AC9 0F84BA000000                jz .comFlushInputBuffers
  1019 00000ACF 3C08                        cmp al, 8
  1020 00000AD1 0F84DC000000                jz .comWrite
  1021 00000AD7 3C09                        cmp al, 9
  1022 00000AD9 0F84D4000000                jz .comWrite
  1023 00000ADF 3C0A                        cmp al, 0Ah
  1024 00000AE1 0F8401010000                jz .comOutputStatus ;Return Clear to send bit inverted for busy bit
  1025 00000AE7 EB23                        jmp short .comExit  ;All other valid functions should return done
  1026                                  .comErrorNoCount:
  1027 00000AE9 B002                        mov al, 02h ;Unknown device
  1028 00000AEB EB19                        jmp short .comWriteErrorCode
  1029                                  .comReadError:
  1030 00000AED BA0B000000                  mov edx, 0Bh
  1031                                  .comWriteError:
  1032 00000AF2 BA0A000000                  mov edx, 0Ah
  1033                                  .comError:
  1034 00000AF7 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx ;Store actual transferred chars
  1035 00000AFA B902000000                  mov ecx, 02h    ;Unknown device
  1036 00000AFF 3CFE                        cmp al, 0FEh    ;Invalid COM port
  1037 00000B01 0F44D1                      cmove edx, ecx  ;Only move unknown device error code if invalid COM port
  1038 00000B04 88D0                        mov al, dl      ;Move dl to al to store error code
  1039                                  .comWriteErrorCode:    ;Jump to with al=Standard Error code
  1040 00000B06 B480                        mov ah, 80h ;Set error bit
  1041 00000B08 66894303                    mov word [rbx + drvReqHdr.status], ax
  1042                                  .comExit:
  1043 00000B0C 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
  1044 00000B12 5E                          pop rsi
  1045 00000B13 5A                          pop rdx
  1046 00000B14 59                          pop rcx
  1047 00000B15 5B                          pop rbx
  1048 00000B16 58                          pop rax
  1049 00000B17 C3                          ret
  1050                                  
  1051                                  .comRead:
  1052 00000B18 B005                        mov al, 05h ;Bad request structure length?
  1053 00000B1A 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1054 00000B1D 75E7                        jne .comWriteErrorCode
  1055                                  
  1056 00000B1F 57                          push rdi
  1057 00000B20 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
  1058 00000B24 31C9                        xor ecx, ecx    ;Zero the char counter
  1059                                  .cr1:
  1060 00000B26 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1061 00000B29 741B                        je .cre2
  1062                                  .cr11:  ;Blocking wait, could be an infinite loop. Imitate basic DOS driver
  1063 00000B2B B802000000                  mov eax, 02h    ;Recieve 
  1064 00000B30 8A15E8000000                mov dl, byte [.comDevice]    ;Get transacting com device
  1065 00000B36 6698                        cbw     ;Zero extend to upper byte
  1066 00000B38 CD34                        int 34h ;Recieve Char
  1067 00000B3A 72BB                        jc .comError
  1068 00000B3C 80FC80                      cmp ah, 80h ;Did a "timeout" occur? If so, keep waiting
  1069 00000B3F 74EA                        je .cr11
  1070 00000B41 AA                          stosb   ;Store char in al into buffer and inc rdi
  1071 00000B42 FFC1                        inc ecx
  1072 00000B44 EBE0                        jmp short .cr1
  1073                                  .cre2:
  1074 00000B46 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1075 00000B49 5F                          pop rdi
  1076 00000B4A EBC0                        jmp short .comExit
  1077                                  
  1078                                  .comReadInputStatus:
  1079 00000B4C B005                        mov al, 05h ;Bad request structure length?
  1080 00000B4E 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1081 00000B51 75B3                        jne .comWriteErrorCode
  1082 00000B53 66C743030000                mov word [rbx + statusReqPkt.status], 0 ;Chars ready to read status
  1083 00000B59 EBB1                        jmp short .comExit
  1084                                  
  1085                                  .comNondestructiveRead:
  1086                                  ;Acts like a "read one character if there is one" function
  1087 00000B5B B005                        mov al, 05h ;Bad request structure length?
  1088 00000B5D 803B0E                      cmp byte [rbx + drvReqHdr.hdrlen], nonDestInNoWaitReqPkt_size
  1089 00000B60 75A4                        jne .comWriteErrorCode
  1090                                  .cndr1:
  1091 00000B62 B802000000                  mov eax, 02h    ;Recieve 
  1092 00000B67 8A15B1000000                mov dl, byte [.comDevice]    ;Get transacting com device
  1093 00000B6D 6698                        cbw     ;Zero extend to upper byte
  1094 00000B6F CD34                        int 34h ;Recieve Char
  1095 00000B71 0F8272FFFFFF                jc .comErrorNoCount ;Dont save a char transfer number
  1096 00000B77 80FC80                      cmp ah, 80h ;Did a "timeout" occur? If so, return with busy = 1
  1097 00000B7A 7405                        je .cndr2
  1098 00000B7C 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Get next char
  1099 00000B7F EB8B                        jmp short .comExit
  1100                                  .cndr2:
  1101 00000B81 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 200h ;Busy bit set
  1102 00000B87 EB83                        jmp short .comExit
  1103                                  
  1104                                  .comFlushInputBuffers:
  1105 00000B89 B005                        mov al, 05h ;Bad request structure length?
  1106 00000B8B 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], flushReqPkt_size
  1107 00000B8E 0F8572FFFFFF                jne .comWriteErrorCode
  1108                                  .cfib0:
  1109 00000B94 8A1584000000                mov dl, byte [.comDevice]
  1110 00000B9A 6698                        cbw
  1111 00000B9C B802000000                  mov eax, 02h    ;Recieve
  1112 00000BA1 CD34                        int 34h
  1113 00000BA3 0F8240FFFFFF                jc .comErrorNoCount
  1114 00000BA9 80FC80                      cmp ah, 80h ;Keep looping until ah = 80h (no more chars in buffer)
  1115 00000BAC 75E6                        jne .cfib0
  1116 00000BAE E959FFFFFF                  jmp .comExit
  1117                                  
  1118                                  .comWrite:
  1119 00000BB3 B005                        mov al, 05h ;Bad request structure length?
  1120 00000BB5 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1121 00000BB8 0F8548FFFFFF                jne .comWriteErrorCode
  1122                                  
  1123 00000BBE 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1124 00000BC2 31C9                        xor ecx, ecx    ;Zero the char counter
  1125                                  .cw1: 
  1126 00000BC4 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1127 00000BC7 7417                        je .cw2
  1128 00000BC9 AC                          lodsb   ;Get char into al, and inc rsi
  1129 00000BCA B401                        mov ah, 01h ;Move function number into ah
  1130 00000BCC 8A154C000000                mov dl, byte [.comDevice]
  1131 00000BD2 6698                        cbw     ;Zero extend to upper byte
  1132 00000BD4 CD34                        int 34h ;Transmit char
  1133 00000BD6 0F821BFFFFFF                jc .comError
  1134 00000BDC FFC1                        inc ecx
  1135 00000BDE EBE4                        jmp short .cw1 ;keep printing until all chars printed
  1136                                  .cw2:
  1137 00000BE0 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1138 00000BE3 E924FFFFFF                  jmp .comExit
  1139                                  
  1140                                  .comOutputStatus:
  1141                                  ;Read MODEM status
  1142 00000BE8 B005                        mov al, 05h ;Bad request structure length?
  1143 00000BEA 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1144 00000BED 0F8513FFFFFF                jne .comWriteErrorCode
  1145                                  
  1146 00000BF3 8A1525000000                mov dl, byte [.comDevice]
  1147 00000BF9 6698                        cbw     ;Zero extend to upper byte
  1148 00000BFB B403                        mov ah, 03h     ;Get status
  1149 00000BFD CD34                        int 34h
  1150 00000BFF 0F82E4FEFFFF                jc .comErrorNoCount
  1151 00000C05 2510000000                  and eax, 10h ;Isolate bit 4 of al, clear to set, and clear all other bits
  1152 00000C0A C1E005                      shl eax, 5   ;Shift it up to bit 9 (busy bit in status word) 
  1153 00000C0D F7D0                        not eax      ;Bitwise inversion
  1154 00000C0F 2500020000                  and eax, 200h   ;Isolate bit 9
  1155 00000C14 6689441B03                  mov word [rbx + rbx + drvReqHdr.status], ax  ;Add the busy bit
  1156 00000C19 E9EEFEFFFF                  jmp .comExit
  1157 00000C1E 00                      .comDevice   db 0
  1158                                  
  1159                                  msdDriver:
  1160 00000C1F 50                          push rax
  1161 00000C20 53                          push rbx
  1162 00000C21 51                          push rcx
  1163 00000C22 52                          push rdx
  1164 00000C23 56                          push rsi
  1165 00000C24 57                          push rdi
  1166 00000C25 55                          push rbp
  1167 00000C26 4150                        push r8
  1168 00000C28 488B1D35FDFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1169 00000C2F 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1170 00000C33 B003                        mov al, 03h
  1171 00000C35 0F87F9000000                ja .msdWriteErrorCode ;If yes, error!
  1172 00000C3B B001                        mov al, 01h ;Unknown Unit Error
  1173 00000C3D 807B0105                    cmp byte [rbx + drvReqHdr.unitnm], 05h  ;Unit greater than 5 is invalid
  1174 00000C41 0F87ED000000                ja .msdWriteErrorCode ;If yes, error!
  1175 00000C47 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1176 00000C4A 84C0                        test al, al
  1177 00000C4C 0F84F8000000                jz .msdInit
  1178 00000C52 3C01                        cmp al, 01
  1179 00000C54 0F8496010000                jz .msdMedChk
  1180 00000C5A 3C02                        cmp al, 02
  1181 00000C5C 0F84FF010000                jz .msdBuildBPB
  1182 00000C62 3C03                        cmp al, 03
  1183 00000C64 0F8465020000                jz .msdIOCTLRead
  1184 00000C6A 3C04                        cmp al, 04
  1185 00000C6C 0F846D020000                jz .msdRead
  1186 00000C72 3C08                        cmp al, 08
  1187 00000C74 0F84A1020000                jz .msdWrite
  1188 00000C7A 3C09                        cmp al, 09
  1189 00000C7C 0F84D5020000                jz .msdWriteVerify
  1190 00000C82 3C0C                        cmp al, 12
  1191 00000C84 0F8416030000                jz .msdIOCTLWrite
  1192 00000C8A 3C0D                        cmp al, 13
  1193 00000C8C 0F841E030000                jz .msdDevOpen
  1194 00000C92 3C0E                        cmp al, 14
  1195 00000C94 0F8431030000                jz .msdDevClose
  1196 00000C9A 3C0F                        cmp al, 15
  1197 00000C9C 0F8444030000                jz .msdRemovableMedia
  1198 00000CA2 3C13                        cmp al, 19
  1199 00000CA4 0F8465030000                jz .msdGenericIOCTL
  1200 00000CAA 3C17                        cmp al, 23
  1201 00000CAC 0F846D030000                jz .msdGetLogicalDev
  1202 00000CB2 3C18                        cmp al, 24
  1203 00000CB4 0F847E030000                jz .msdSetLogicalDev
  1204 00000CBA EB7E                        jmp short .msdDriverExit    ;All other valid functions exit done
  1205                                  .msdIOError:  ;In Read and Write errors, rbp points to the dev struc
  1206 00000CBC 4889EB                      mov rbx, rbp
  1207 00000CBF 0FB6C0                      movzx eax, al   ;Number of IO-ed sectors in last request
  1208 00000CC2 01C6                        add esi, eax    ;esi Keeps sector count across transfers
  1209 00000CC4 897316                      mov dword [rbx + ioReqPkt.tfrlen], esi ;Save number of IO-ed sectors
  1210                                  ;Now fall through to general error
  1211                                  .msdGenDiskError:
  1212 00000CC7 B401                        mov ah, 01h
  1213 00000CC9 30D2                        xor dl, dl  ;Work around bug that fails request if dl > 7Fh
  1214 00000CCB CD33                        int 33h ;Read status of last operation
  1215 00000CCD 80FC06                      cmp ah, 06h ;Mock Seek response (device not present)
  1216 00000CD0 B002                        mov al, 02h ;Give device not ready error (sensibly I think)
  1217 00000CD2 7460                        je .msdWriteErrorCode 
  1218 00000CD4 B00C                        mov al, 0Ch ;Preliminary General Error Faults
  1219 00000CD6 80FCFF                      cmp ah, -1  ;Sense operation failed
  1220 00000CD9 7459                        je .msdWriteErrorCode 
  1221 00000CDB 80FC20                      cmp ah, 20h ;Gen. ctrlr. failure. Consider new error code to halt system.
  1222 00000CDE 7454                        je .msdWriteErrorCode
  1223                                  ;Device Not Ready
  1224 00000CE0 B002                        mov al, 02h  ;Device not ready code
  1225 00000CE2 4138C0                      cmp r8b, al  ;SCSI Not ready commands start with 2
  1226 00000CE5 744D                        je .msdWriteErrorCode
  1227 00000CE7 49C1E808                    shr r8, 8       ;Remove Sense Key
  1228 00000CEB 410FB7C8                    movzx ecx, r8w  ;Get ASC and ASCQ in cl and ch bzw.
  1229                                  ;Write Protected
  1230 00000CEF 30C0                        xor al, al
  1231 00000CF1 6681F92700                  cmp cx, 0027h   ;Write protected error
  1232 00000CF6 743C                        je .msdWriteErrorCode
  1233                                  ;CRC Error
  1234 00000CF8 B004                        mov al, 04h     ;CRC error code
  1235 00000CFA 6681F90803                  cmp cx, 0308h   ;LU comms CRC error (UDMA/32)
  1236 00000CFF 7433                        je .msdWriteErrorCode
  1237 00000D01 6681F91000                  cmp cx, 0010h   ;ID CRC or ECC error
  1238 00000D06 742C                        je .msdWriteErrorCode
  1239 00000D08 6681F94701                  cmp cx, 0147h   ;Data phase CRC error detected
  1240 00000D0D 7425                        je .msdWriteErrorCode
  1241                                  ;Seek Error
  1242 00000D0F B006                        mov al, 06h     ;Seek error code
  1243 00000D11 80F902                      cmp cl, 02h     ;No Seek Complete
  1244 00000D14 741E                        je .msdWriteErrorCode
  1245                                  ;Unknown Hardware Media (Shouldn't happen with Flash Drives)
  1246                                  ;This error should only be called if BPB not recognised for Flash Drives
  1247 00000D16 B007                        mov al, 07h
  1248 00000D18 80F930                      cmp cl, 30h   ;All issues with media returns unknown media
  1249 00000D1B 7417                        je .msdWriteErrorCode
  1250                                  ;Sector Not Found
  1251 00000D1D B008                        mov al, 08h     ;Sector not found code
  1252 00000D1F 80F921                      cmp cl, 21h     ;Illegal Request - Invalid LBA
  1253 00000D22 7410                        je .msdWriteErrorCode
  1254                                  ;Write faults
  1255 00000D24 B00A                        mov al, 0Ah     ;Write fault
  1256 00000D26 80F90C                      cmp cl, 0Ch     ;Write Error ASC code
  1257 00000D29 7409                        je .msdWriteErrorCode
  1258                                  ;Read faults
  1259 00000D2B B00B                        mov al, 0Bh     ;Read fault
  1260 00000D2D 80F911                      cmp cl, 11h     ;Read error
  1261 00000D30 7402                        je .msdWriteErrorCode
  1262                                  ;General Errors
  1263 00000D32 B00C                        mov al, 0Ch     ;Everything else is general error
  1264                                  .msdWriteErrorCode:    ;Jump to with al=Standard Error code
  1265 00000D34 B480                        mov ah, 80h ;Set error bit
  1266 00000D36 66894303                    mov word [rbx + drvReqHdr.status], ax
  1267                                  .msdDriverExit:
  1268 00000D3A 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1269 00000D40 4158                        pop r8
  1270 00000D42 5D                          pop rbp
  1271 00000D43 5F                          pop rdi
  1272 00000D44 5E                          pop rsi
  1273 00000D45 5A                          pop rdx
  1274 00000D46 59                          pop rcx
  1275 00000D47 5B                          pop rbx
  1276 00000D48 58                          pop rax
  1277 00000D49 C3                          ret
  1278                                  .msdInit:            ;Function 0
  1279 00000D4A B005                        mov al, 05h ;Bad request structure length
  1280 00000D4C 803B1F                      cmp byte [rbx + drvReqHdr.hdrlen], initReqPkt_size
  1281 00000D4F 75E3                        jne .msdWriteErrorCode
  1282                                  
  1283 00000D51 4151                        push r9
  1284 00000D53 CD31                        int 31h ;Get number of Int 33h devices in r8b
  1285 00000D55 4159                        pop r9
  1286 00000D57 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1287 00000D5B 4489C0                      mov eax, r8d
  1288 00000D5E 3C01                        cmp al, 1
  1289 00000D60 7702                        ja .mi1
  1290 00000D62 FEC0                        inc al ;Make it two
  1291                                  .mi1:
  1292 00000D64 BA05000000                  mov edx, 5
  1293 00000D69 39D0                        cmp eax, edx
  1294 00000D6B 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1295 00000D6E 8805F2FAFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1296 00000D74 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1297 00000D77 440005(A9000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1298 00000D7E 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1299 00000D80 488D3D20030000              lea rdi, qword [.msdBPBblks]
  1300 00000D87 53                          push rbx
  1301                                  .mi2:
  1302 00000D88 89EA                        mov edx, ebp
  1303 00000D8A 488D1D6E050000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1304 00000D91 31C9                        xor ecx, ecx    ;Sector 0
  1305 00000D93 B801820000                  mov eax, 8201h       ;Read 1 sector
  1306 00000D98 CD33                        int 33h
  1307 00000D9A 724E                        jc .msdInitError
  1308                                  
  1309 00000D9C 488D355C050000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1310 00000DA3 B90F000000                  mov ecx, bpbEx_size/8
  1311 00000DA8 F348A5                      rep movsq   ;Move the BPB data into the right block
  1312                                  
  1313 00000DAB FFC5                        inc ebp
  1314 00000DAD 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1315 00000DB0 75D6                        jne .mi2  ;No? Go again
  1316                                  
  1317 00000DB2 488D3DC6020000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1318 00000DB9 488D15E7020000              lea rdx, qword [.msdBPBblks]
  1319                                  .mi3:
  1320 00000DC0 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1321 00000DC3 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1322 00000DCA FFCD                        dec ebp
  1323 00000DCC 75F2                        jnz .mi3  ;If not zero yet, go again
  1324                                  
  1325 00000DCE 5B                          pop rbx
  1326 00000DCF 488D15A9020000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1327 00000DD6 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1328 00000DDA 488D151E050000              lea rdx, qword [driverDataPtr]
  1329 00000DE1 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1330 00000DE5 E950FFFFFF                  jmp .msdDriverExit
  1331                                  .msdInitError:
  1332 00000DEA 5B                          pop rbx
  1333 00000DEB E94AFFFFFF                  jmp .msdDriverExit
  1334                                  .msdMedChk:          ;Function 1
  1335                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1336                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1337                                  ; suffice.
  1338 00000DF0 B005                        mov al, 05h ;Bad request structure length
  1339 00000DF2 803B17                      cmp byte [rbx + drvReqHdr.hdrlen], mediaCheckReqPkt_size
  1340 00000DF5 0F8539FFFFFF                jne .msdWriteErrorCode
  1341                                  
  1342 00000DFB 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1343 00000E00 8A90[75100000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1344 00000E06 F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1345 00000E09 754D                        jnz .mmcNoChange
  1346                                  ;Now we do a BIOS changeline check. If it returns 80h or 86h then check med desc
  1347 00000E0B B416                        mov ah, 16h 
  1348 00000E0D CD33                        int 33h
  1349 00000E0F 0F82B2FEFFFF                jc .msdGenDiskError
  1350 00000E15 80FC80                      cmp ah, 80h
  1351 00000E18 740E                        je .mmcNoChangeLine
  1352 00000E1A 80FC86                      cmp ah, 86h
  1353 00000E1D 7409                        je .mmcNoChangeLine
  1354 00000E1F 84E4                        test ah, ah ;No change?
  1355 00000E21 7435                        jz .mmcNoChange
  1356 00000E23 F6C401                      test ah, 1  ;Neither 80h or 86h have bit 0 set
  1357 00000E26 7513                        jnz .mmcChange
  1358                                  ;If nothing, fall through and test manually, should never happen though
  1359                                  .mmcNoChangeLine:
  1360                                  ;Now we test Media Descriptor
  1361 00000E28 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1362 00000E2B 488B3CC5[7F100000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1363 00000E33 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1364 00000E36 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1365 00000E39 7414                        je .mmcUnsure
  1366                                  .mmcChange:
  1367 00000E3B C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1368 00000E3F 488D0525020000              lea rax, qword [.msdDefLabel]           ;Temp, ret def label
  1369 00000E46 4889430F                    mov qword [rbx + mediaCheckReqPkt.desptr], rax 
  1370 00000E4A E9EBFEFFFF                  jmp .msdDriverExit
  1371                                  .mmcUnsure:
  1372 00000E4F C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1373 00000E53 E9E2FEFFFF                  jmp .msdDriverExit
  1374                                  .mmcNoChange:
  1375 00000E58 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1376 00000E5C E9D9FEFFFF                  jmp .msdDriverExit
  1377                                  
  1378                                  .msdBuildBPB:        ;Function 2
  1379 00000E61 B005                        mov al, 05h ;Bad request structure length
  1380 00000E63 803B1E                      cmp byte [rbx + drvReqHdr.hdrlen], bpbBuildReqPkt_size
  1381 00000E66 0F85C8FEFFFF                jne .msdWriteErrorCode
  1382                                  
  1383 00000E6C 4889DE                      mov rsi, rbx
  1384 00000E6F 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1385 00000E74 8A90[75100000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1386 00000E7A 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1387 00000E7E 31C9                        xor ecx, ecx    ;Read Sector 0
  1388 00000E80 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1389 00000E85 CD33                        int 33h
  1390 00000E87 0F823AFEFFFF                jc .msdGenDiskError
  1391                                  ;Check Media Descriptor, must be F0h or F8h-FFh or unknown media
  1392 00000E8D 807B15F0                    cmp byte [rbx + bpb.media], 0F0h    ;3.5" FDD standard
  1393 00000E91 7418                        je .mbbpb0
  1394 00000E93 807B15F8                    cmp byte [rbx + bpb.media], 0F8h    ;FDD/Large Media Standard
  1395 00000E97 7412                        je .mbbpb0
  1396 00000E99 807B15F9                    cmp byte [rbx + bpb.media], 0F9h    ;5.25" & 720K 3.5" Media Standard
  1397 00000E9D 740C                        je .mbbpb0
  1398 00000E9F 807B15FC                    cmp byte [rbx + bpb.media], 0FCh    ;Very Obsolete Media Standards
  1399 00000EA3 B007                        mov al, 07h ;Unknown media error code
  1400 00000EA5 0F8289FEFFFF                jb .msdWriteErrorCode
  1401                                  .mbbpb0:
  1402 00000EAB 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1403 00000EAE 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1404 00000EB3 488B3CC5[7F100000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1405 00000EBB 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1406 00000EBE 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1407 00000EC2 B90F000000                  mov ecx, bpbEx_size/8
  1408 00000EC7 F348A5                      rep movsq   ;Move the BPB data into the right space
  1409 00000ECA E96BFEFFFF                  jmp .msdDriverExit
  1410                                  .msdIOCTLRead:       ;Function 3, returns done
  1411 00000ECF B005                        mov al, 05h ;Bad request structure length
  1412 00000ED1 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1413 00000ED4 0F855AFEFFFF                jne .msdWriteErrorCode
  1414                                  
  1415 00000EDA E95BFEFFFF                  jmp .msdDriverExit
  1416                                  .msdRead:            ;Function 4
  1417                                  ;Will read one sector at a time.
  1418 00000EDF B005                        mov al, 05h ;Bad request structure length
  1419 00000EE1 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1420 00000EE4 0F854AFEFFFF                jne .msdWriteErrorCode
  1421                                  
  1422 00000EEA 4889DD                      mov rbp, rbx
  1423 00000EED 31F6                        xor esi, esi  ;Set sector read counter to zero
  1424                                  .msdr0:
  1425 00000EEF B682                        mov dh, 82h ;LBA Read Sectors
  1426 00000EF1 E85B010000                  call .msdBlkIOCommon
  1427 00000EF6 0F82C0FDFFFF                jc .msdIOError
  1428 00000EFC 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1429 00000F04 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1430 00000F0C FFC6                        inc esi
  1431 00000F0E 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1432 00000F11 75DC                        jne .msdr0
  1433 00000F13 4889EB                      mov rbx, rbp
  1434 00000F16 E91FFEFFFF                  jmp .msdDriverExit
  1435                                  .msdWrite:           ;Function 8
  1436                                  ;Will write one sector at a time.
  1437 00000F1B B005                        mov al, 05h ;Bad request structure length
  1438 00000F1D 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1439 00000F20 0F850EFEFFFF                jne .msdWriteErrorCode
  1440                                  
  1441 00000F26 4889DD                      mov rbp, rbx
  1442 00000F29 31F6                        xor esi, esi  ;Set counter to zero
  1443                                  .msdw0:
  1444 00000F2B B683                        mov dh, 83h ;LBA Write Sectors
  1445 00000F2D E81F010000                  call .msdBlkIOCommon
  1446 00000F32 0F8284FDFFFF                jc .msdIOError
  1447 00000F38 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1448 00000F40 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1449 00000F48 FFC6                        inc esi
  1450 00000F4A 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1451 00000F4D 75DC                        jne .msdw0
  1452 00000F4F 4889EB                      mov rbx, rbp
  1453 00000F52 E9E3FDFFFF                  jmp .msdDriverExit
  1454                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1455                                  ;Will write one sector at a time and then verify it.
  1456 00000F57 B005                        mov al, 05h ;Bad request structure length
  1457 00000F59 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1458 00000F5C 0F85D2FDFFFF                jne .msdWriteErrorCode
  1459                                  
  1460 00000F62 4889DD                      mov rbp, rbx
  1461 00000F65 31F6                        xor esi, esi  ;Set counter to zero
  1462                                  .msdwv0:
  1463 00000F67 B683                        mov dh, 83h ;LBA Write Sectors
  1464 00000F69 E8E3000000                  call .msdBlkIOCommon
  1465 00000F6E 0F8248FDFFFF                jc .msdIOError    ;Error handler needs to add to esi the value in al
  1466 00000F74 B684                        mov dh, 84h ;LBA Verify Sectors
  1467 00000F76 E8D6000000                  call .msdBlkIOCommon
  1468 00000F7B 0F823BFDFFFF                jc .msdIOError    ;Error handler needs to add to esi the value in al
  1469 00000F81 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1470 00000F89 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1471 00000F91 FFC6                        inc esi
  1472 00000F93 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1473 00000F96 75CF                        jne .msdwv0
  1474 00000F98 4889EB                      mov rbx, rbp
  1475 00000F9B E99AFDFFFF                  jmp .msdDriverExit
  1476                                  .msdIOCTLWrite:      ;Function 12, returns done
  1477 00000FA0 B005                        mov al, 05h ;Bad request structure length
  1478 00000FA2 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1479 00000FA5 0F8589FDFFFF                jne .msdWriteErrorCode
  1480                                  
  1481 00000FAB E98AFDFFFF                  jmp .msdDriverExit
  1482                                  .msdDevOpen:         ;Function 13
  1483 00000FB0 B005                        mov al, 05h ;Bad request structure length
  1484 00000FB2 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], openReqPkt_size
  1485 00000FB5 0F8579FDFFFF                jne .msdWriteErrorCode
  1486                                  
  1487 00000FBB 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1488 00000FC0 FE80[7A100000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1489 00000FC6 E96FFDFFFF                  jmp .msdDriverExit
  1490                                  .msdDevClose:        ;Function 14
  1491 00000FCB B005                        mov al, 05h ;Bad request structure length
  1492 00000FCD 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], closeReqPkt_size
  1493 00000FD0 0F855EFDFFFF                jne .msdWriteErrorCode
  1494                                  
  1495 00000FD6 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1496 00000FDB FE88[7A100000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1497 00000FE1 E954FDFFFF                  jmp .msdDriverExit
  1498                                  .msdRemovableMedia:  ;Function 15
  1499 00000FE6 B005                        mov al, 05h ;Bad request structure length
  1500 00000FE8 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], remMediaReqPkt_size
  1501 00000FEB 0F8543FDFFFF                jne .msdWriteErrorCode
  1502                                  
  1503 00000FF1 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1504 00000FF6 8A80[75100000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1505 00000FFC A880                        test al, 80h
  1506 00000FFE 0F8436FDFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1507 00001004 66C743030002                mov word [rbx + remMediaReqPkt.status], 0200h ;Set Busy bit
  1508 0000100A E92BFDFFFF                  jmp .msdDriverExit
  1509                                  .msdGenericIOCTL:    ;Function 19
  1510 0000100F B005                        mov al, 05h ;Bad request structure length
  1511 00001011 803B27                      cmp byte [rbx + drvReqHdr.hdrlen], ioctlReqPkt_size
  1512 00001014 0F851AFDFFFF                jne .msdWriteErrorCode
  1513                                  
  1514 0000101A E91BFDFFFF                  jmp .msdDriverExit
  1515                                  .msdGetLogicalDev:   ;Function 23
  1516 0000101F B005                        mov al, 05h ;Bad request structure length
  1517 00001021 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], getDevReqPkt_size
  1518 00001024 0F850AFDFFFF                jne .msdWriteErrorCode
  1519                                  
  1520 0000102A 8A0544000000                mov al, byte [.msdCurDev]
  1521 00001030 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1522 00001033 E902FDFFFF                  jmp .msdDriverExit
  1523                                  .msdSetLogicalDev:   ;Function 24
  1524 00001038 B005                        mov al, 05h ;Bad request structure length
  1525 0000103A 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], setDevReqPkt_size
  1526 0000103D 0F85F1FCFFFF                jne .msdWriteErrorCode
  1527                                  
  1528 00001043 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1529 00001046 880528000000                mov byte [.msdCurDev], al
  1530 0000104C E9E9FCFFFF                  jmp .msdDriverExit
  1531                                  
  1532                                  .msdBlkIOCommon:  ;Does block IO
  1533                                  ;Called with rbp containing old rbx value and ah with function number
  1534                                  ;Error handled by caller
  1535                                  ;Sector count handled by caller
  1536                                  ;Called with dh = BIOS function number
  1537 00001051 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1538 00001056 8A90[75100000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req in dl
  1539 0000105C 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1540 00001060 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1541 00001064 88F4                        mov ah, dh
  1542 00001066 B001                        mov al, 01h ;Do one sector at a time 
  1543 00001068 CD33                        int 33h
  1544 0000106A C3                          ret
  1545                                  
  1546 0000106B 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1547                                  ;LASTDRIVE default is 5
  1548 00001074 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1549                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1550 00001075 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1551 0000107A 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1552 0000107F 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1552 00001088 000000000000000000-
  1552 00001091 000000000000000000-
  1552 0000109A 000000000000000000-
  1552 000010A3 00000000           
  1553 000010A7 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1553 000010B0 000000000000000000-
  1553 000010B9 000000000000000000-
  1553 000010C2 000000000000000000-
  1553 000010CB 000000000000000000-
  1553 000010D4 000000000000000000-
  1553 000010DD 000000000000000000-
  1553 000010E6 000000000000000000-
  1553 000010EF 000000000000000000-
  1553 000010F8 000000000000000000-
  1553 00001101 000000000000000000-
  1553 0000110A 000000000000000000-
  1553 00001113 000000000000000000-
  1553 0000111C 000000000000000000-
  1553 00001125 000000000000000000-
  1553 0000112E 000000000000000000-
  1553 00001137 000000000000000000-
  1553 00001140 000000000000000000-
  1553 00001149 000000000000000000-
  1553 00001152 000000000000000000-
  1553 0000115B 000000000000000000-
  1553 00001164 000000000000000000-
  1553 0000116D 000000000000000000-
  1553 00001176 000000000000000000-
  1553 0000117F 000000000000000000-
  1553 00001188 000000000000000000-
  1553 00001191 000000000000000000-
  1553 0000119A 000000000000000000-
  1553 000011A3 000000000000000000-
  1553 000011AC 000000000000000000-
  1553 000011B5 000000000000000000-
  1553 000011BE 000000000000000000-
  1553 000011C7 000000000000000000-
  1553 000011D0 000000000000000000-
  1553 000011D9 000000000000000000-
  1553 000011E2 000000000000000000-
  1553 000011EB 000000000000000000-
  1553 000011F4 000000000000000000-
  1553 000011FD 000000000000000000-
  1553 00001206 000000000000000000-
  1553 0000120F 000000000000000000-
  1553 00001218 000000000000000000-
  1553 00001221 000000000000000000-
  1553 0000122A 000000000000000000-
  1553 00001233 000000000000000000-
  1553 0000123C 000000000000000000-
  1553 00001245 000000000000000000-
  1553 0000124E 000000000000000000-
  1553 00001257 000000000000000000-
  1553 00001260 000000000000000000-
  1553 00001269 000000000000000000-
  1553 00001272 000000000000000000-
  1553 0000127B 000000000000000000-
  1553 00001284 000000000000000000-
  1553 0000128D 000000000000000000-
  1553 00001296 000000000000000000-
  1553 0000129F 000000000000000000-
  1553 000012A8 000000000000000000-
  1553 000012B1 000000000000000000-
  1553 000012BA 000000000000000000-
  1553 000012C3 000000000000000000-
  1553 000012CC 000000000000000000-
  1553 000012D5 000000000000000000-
  1553 000012DE 000000000000000000-
  1553 000012E7 000000000000000000-
  1553 000012F0 000000000000000000-
  1553 000012F9 000000000000       
  1554                                  
  1555                                  driverDataPtr:
