     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame   
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, rbp + 0
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> endstruc
   186                              <1> 
   187                              <1> %macro pushDOS 0
   188                              <1>     push r9
   189                              <1>     push r8
   190                              <1>     push rbp
   191                              <1>     push rdi
   192                              <1>     push rsi
   193                              <1>     push rdx
   194                              <1>     push rcx
   195                              <1>     push rbx
   196                              <1>     push rax
   197                              <1> %endmacro
   198                              <1> 
   199                              <1> %macro popDOS 0
   200                              <1>     pop rax
   201                              <1>     pop rbx
   202                              <1>     pop rcx
   203                              <1>     pop rdx
   204                              <1>     pop rsi
   205                              <1>     pop rdi
   206                              <1>     pop r8
   207                              <1>     pop r9
   208                              <1> %endmacro
   209                              <1> 
   210                              <1> struc psp
   211 00000000 ????                <1>     .return     resb 2  ;Should always be CDh 40h
   212 00000002 ????????????????    <1>     .startSeg   resq 1
   213 0000000A ????????????????    <1>     .oldInt42h  resq 1
   214 00000012 ????????????????    <1>     .oldInt43h  resq 1
   215 0000001A ????????????????    <1>     .oldInt44h  resq 1
   216 00000022 ????????????????    <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   217 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   218 0000003E ????????????????    <1>     .envPtr     resq 1  ;Pointer to the environment
   219 00000046 ????????????????    <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to int 41h
   220 0000004E ????                <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   221 00000050 ??????              <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   222 00000053 ????????????????    <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   223 0000005B ????????????????    <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   224 00000063 <res 1Dh>           <1>     .reserved   resb 29
   225 00000080 ??                  <1>     .charCount  resb 1
   226 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   227                              <1> endstruc
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   charReqHdr  resb ioReqPkt_size  ;Character IO Request header
    12 00000033 <res 2Ah>                   diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
    13                                      ;The device driver header with space for the largest possible packet
    14 0000005D ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    15 00000065 ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    16 0000006D ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    17 00000075 ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    18 0000007D ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    19                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    20 00000085 ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    21                                      ;                    The last driver loaded with the STDIN bit[0] set
    22 0000008D ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    23 0000008F ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    24 00000097 ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    25 0000009F ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    26 000000A7 ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    27 000000A9 ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    28 000000AA ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    29 000000AB ??                          numJoinDrv  resb 1      ;Number of Joined Drives
    30 000000AC <res 22h>                   nulDevHdr   resb drvHdr_size
    31                                  
    32                                  ;Swappable, process related data here
    33 000000CE ??                          inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    34 000000CF ??                          breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    35 000000D0 ??                          defaultDrv  resb 1  ;Default, last accessed drive
    36 000000D1 ????????????????            currentPSP  resq 1  ;Address of current PSP
    37 000000D9 ????????????????            oldRSP      resq 1  ;RSP value before stack switch
    38                                  
    39 000000E1 ??                          errorCode   resb 1  ;Regular Error Code
    40 000000E2 ????                        exErrorCode resw 1  ;Extended Error Code
    41 000000E4 ??                          errorClass  resb 1  ;Error Class
    42 000000E5 ??                          errSuggestn resb 1  ;Suggested action for error
    43 000000E6 ??                          errorLocus  resb 1  ;Where the error took place    
    44                                  
    45                                  
    46 000000E7 <res 528h>                  critStack   resq 165
    47 0000060F ????????????????            critStakTop resq 1
    48 00000617 <res 638h>                  IOStack     resq 199
    49 00000C4F ????????????????            IOStakTop   resq 1
    50 00000C57 <res 638h>                  DiskStack   resq 199
    51 0000128F ????????????????            DiskStakTop resq 1
    52                                      dSegLen     equ     $
    53                                  
    54                                  Segment .text align=1
    55                                  ; We arrive here with the following values in the registers.
    56                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    57                                  ; dx  = Int 33h boot device number
    58                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    59 00000000 55AA                        dw 0AA55h           ;Initial signature
    60 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    61                                  
    62 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    63 0000000F 0F32                        rdmsr
    64 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    65 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    66 00000017 89C7                        mov edi, eax        ;Get the low dword in
    67                                  
    68 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    68 0000001E [00000000]         
    69 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    70 00000025 4881C7[97120000]            add rdi, dSegLen ;Move destination past end of data area
    71 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    72 00000033 B900100000                  mov ecx, 1000h
    73 00000038 F348A5                      rep movsq
    74                                  
    75                                  ;Modify the pointers in nData before putting them in the data area
    76 0000003B 48012D7A010000              add qword [nData + drvHdr.nxtPtr], rbp
    77 00000042 48012D7D010000              add qword [nData + drvHdr.strPtr], rbp
    78 00000049 48012D7E010000              add qword [nData + drvHdr.intPtr], rbp
    79                                  ;Copy the Null driver to its location in Sysvars
    80 00000050 B922000000                  mov ecx, drvHdr_size
    81 00000055 488D3560010000              lea rsi, qword [nData]
    82 0000005C 488DBD[AC000000]            lea rdi, qword [rbp + nulDevHdr]
    83 00000063 F3A4                        rep movsb   
    84                                  
    85                                  ;Adjust the addresses in the other driver headers 
    86 00000065 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    86 00000067 [B106000000000000] 
    87 0000006F B90C000000                  mov ecx, 12      ;12 drivers in data area
    88 00000074 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    89                                  adjDrivers:
    90 00000078 E8C4000000                  call adjustDrvHdr
    91 0000007D E2F9                        loop adjDrivers
    92                                  
    93                                      ;Open NUL
    94 0000007F 488D9D[B6000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    95 00000086 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    96 00000089 30C0                        xor al, al
    97 0000008B FFD3                        call rbx
    98                                  
    99                                      ;Open CON
   100 0000008D 48BB-                       mov rbx, conDriver
   100 0000008F [6008000000000000] 
   101 00000097 488D5C1D00                  lea rbx, qword [rbp+rbx]
   102 0000009C 30C0                        xor al, al
   103 0000009E FFD3                        call rbx
   104                                  
   105                                      ;Open Mass Storage
   106 000000A0 48BB-                       mov rbx, msdDriver
   106 000000A2 [C609000000000000] 
   107 000000AA 488D5C1D00                  lea rbx, qword [rbp+rbx]
   108 000000AF 30C0                        xor al, al
   109 000000B1 FFD3                        call rbx
   110                                  ;Adjust Int 41h address table
   111                                  
   112                                  adjInt41h:
   113 000000B3 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
   114 000000B8 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
   114 000000BA [9600000000000000] 
   115 000000C2 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
   116                                  .ai41h:
   117 000000C7 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
   118 000000CA 4881C308000000              add rbx, 8              ;Each entry is size 8
   119 000000D1 FFC9                        dec ecx
   120 000000D3 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
   121                                  
   122                                  ;Adjust Interrupt Entries Int 40h-49h
   123                                  adjInts:
   124 000000D5 B340                        mov bl, 40h
   125 000000D7 B807F00000                  mov eax, 0F007h ;Get the descriptor
   126 000000DC CD35                        int 35h
   127 000000DE B940000000                  mov ecx, 40h    ;Start from interrupt 40h
   128 000000E3 488D3D82000000              lea rdi, intData
   129 000000EA 89C6                        mov esi, eax    ;Move segment selector info to esi
   130                                  .ai0:
   131 000000EC B808F00000                  mov eax, 0F008h ;Set the descriptor
   132 000000F1 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
   133 000000F4 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
   134 000000F7 CD35                        int 35h
   135 000000F9 4881C708000000              add rdi, 8
   136 00000100 FFC1                        inc ecx
   137 00000102 81F94A000000                cmp ecx, 4Ah
   138 00000108 75E2                        jne .ai0
   139                                  
   140                                  ;Test Error Case
   141 0000010A B430                        mov ah, 00110000b
   142 0000010C B000                        mov al, 00h
   143 0000010E BF06000000                  mov edi, 06h
   144 00000113 CD44                        int 44h
   145 00000115 6687DB                      xchg bx, bx
   146                                  
   147 00000118 488D2D35000000              lea rbp, qword [startmsg]   ;Get the absolute address of message
   148 0000011F B804130000                  mov eax, 1304h
   149 00000124 CD30                        int 30h
   150                                  
   151 00000126 64488B3425-                 mov rsi, fs:[nulDevHdr]
   151 0000012B [AC000000]         
   152 0000012F B801C50000                  mov eax, 0C501h ;Connect debugger
   153 00000134 CD35                        int 35h
   154                                  l1:
   155 00000136 6631C0                      xor ax, ax
   156 00000139 CD36                        int 36h
   157 0000013B B40E                        mov ah, 0Eh
   158 0000013D CD30                        int 30h
   159 0000013F EBF5                        jmp short l1
   160                                  adjustDrvHdr:
   161                                  ;Input: rsi = Effective address of driver in DOS segment
   162                                  ;       rbp = Ptr to the start of the DOS segment
   163                                  ;Output: rsi = EA of next header in DOS segment
   164 00000141 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   165 00000144 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   166 00000148 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   167 0000014C 4881C622000000              add rsi, drvHdr_size
   168 00000153 C3                          ret
   169                                  
   170 00000154 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,0
   170 0000015D 67205343502F444F53-
   170 00000166 2E2E2E0A0D00       
   171                                  intData:
   172 0000016C [5900000000000000]          dq terminateProcess ;Int 40h
   173 00000174 [5900000000000000]          dq functionDispatch ;Int 41h
   174 0000017C [E603000000000000]          dq terminateHandler ;Int 42h
   175 00000184 [E603000000000000]          dq ctrlCHandler     ;Int 43h
   176 0000018C [E603000000000000]          dq critErrorHandler ;Int 44h
   177 00000194 [7906000000000000]          dq absDiskRead      ;Int 45h
   178 0000019C [8E06000000000000]          dq absDiskWrite     ;Int 46h
   179 000001A4 [A306000000000000]          dq terminateResident    ;Int 47h
   180 000001AC [A306000000000000]          dq inDosHandler     ;Int 48h
   181 000001B4 [A506000000000000]          dq fastOutput       ;Int 49h
   182                                  nData:
   183 000001BC [B106000000000000]          dq conHdr
   184 000001C4 0480                        dw 08004h
   185 000001C6 [5908000000000000]          dq nulStrat
   186 000001CE [5F08000000000000]          dq nulIntr
   187 000001D6 4E554C2020202020            db "NUL     " ;Default NUL data
   188                                  
   189                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   190                                  ;-----------------------------------:
   191                                  ;       Misc System routines        :
   192                                  ;-----------------------------------:
   193                                  findLRUBuffer: 
   194                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   195                                  ;Input: Nothing
   196                                  ;Output: rbx = Pointer to the buffer to use
   197 00000000 52                          push rdx
   198 00000001 488B1D(8F000000)            mov rbx, qword [bufHeadPtr]
   199 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   200 0000000F 7502                        jne .flb1
   201 00000011 5A                          pop rdx
   202 00000012 C3                          ret
   203                                  .flb1:
   204 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   205 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   206 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   207 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   208 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   209 00000029 488B15(8F000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   210 00000030 48891D(8F000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   211 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   212 0000003A 5A                          pop rdx
   213 0000003B C3                          ret
   214                                  
   215                                  findDPB:
   216                                  ;Finds the DPB for a given drive
   217                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   218                                  ;Output: al = 00, rbx = Pointer to the DPB
   219                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   220 0000003C 488B1D(6D000000)            mov rbx, qword [dpbHeadPtr]
   221                                  .fd1:
   222 00000043 30C0                        xor al, al
   223 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   224 00000047 740F                        je .fd2
   225 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   226 0000004D B0FF                        mov al, -1
   227 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   228 00000056 75EB                        jne .fd1
   229                                  .fd2:
   230 00000058 C3                          ret
   231                                  callCritError:
   232                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   233                                  ;-----------------------------------:
   234                                  ;       File System routines        :
   235                                  ;-----------------------------------:
   236                                  fatProc:
   237                                  ;-----------------------------------:
   238                                  ;        Interrupt routines         :
   239                                  ;-----------------------------------:
   240                                  terminateProcess:   ;Int 40h
   241                                  
   242                                  functionDispatch:   ;Int 41h Main function dispatcher
   243                                  ;ah = Function number, all other registers have various meanings
   244 00000059 FA                          cli ;Halt external interrupts
   245 0000005A 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   246 0000005D 7711                        ja .fdExitBad
   247 0000005F 80FC01                      cmp ah, 01h
   248 00000062 740E                        je .stdinReadEcho
   249 00000064 80FC02                      cmp ah, 02h
   250 00000067 7411                        je .stdoutWrite
   251 00000069 80FC09                      cmp ah, 09h
   252 0000006C 7414                        je .printString
   253 0000006E 48CF                        iretq
   254                                  .fdExit:
   255                                  .fdExitBad:
   256 00000070 48CF                        iretq
   257                                  .dispTerminate:     ;ah = 00h
   258                                  .stdinReadEcho:     ;ah = 01h
   259 00000072 30E4                        xor ah, ah
   260 00000074 CD36                        int 36h
   261 00000076 CD49                        int 49h ;Pass al to fast output
   262 00000078 48CF                        iretq
   263                                  .stdoutWrite:       ;ah = 02h
   264                                  ;Bspace is regular cursor left, does not insert a blank
   265 0000007A 50                          push rax
   266 0000007B 88D0                        mov al, dl
   267 0000007D CD49                        int 49h
   268 0000007F 58                          pop rax
   269 00000080 48CF                        iretq
   270                                  .stdauxRead:        ;ah = 03h
   271                                  .stdauxWrite:       ;ah = 04h
   272                                  .stdprnWrite:       ;ah = 05h
   273                                  .directCONIO:       ;ah = 06h
   274                                  .waitDirectInNoEcho:;ah = 07h
   275                                  .waitStdinNoEcho:   ;ah = 08h
   276                                  .printString:       ;ah = 09h
   277 00000082 50                          push rax
   278 00000083 52                          push rdx
   279                                  .ps0:
   280 00000084 8A02                        mov al, byte [rdx]
   281 00000086 3C24                        cmp al, "$"
   282 00000088 7407                        je .ps1
   283 0000008A 48FFC2                      inc rdx ;Goto next char
   284 0000008D CD49                        int 49h ;Print char in al
   285 0000008F EBF3                        jmp short .ps0
   286                                  .ps1:
   287 00000091 5A                          pop rdx
   288 00000092 58                          pop rax
   289 00000093 48CF                        iretq
   290                                  .buffStdinInput:    ;ah = 0Ah
   291                                  .checkStdinStatus:  ;ah = 0Bh
   292                                  .clearbuffDoFunc:   ;ah = 0Ch
   293                                  .diskReset:         ;ah = 0Dh
   294                                  .selectDisk:        ;ah = 0Eh
   295                                  .openFileFCB:       ;ah = 0Fh
   296                                  .closeFileFCB:      ;ah = 10h
   297                                  .findFirstFileFCB:  ;ah = 11h
   298                                  .findNextFileFCB:   ;ah = 12h
   299                                  .deleteFileFCB:     ;ah = 13h
   300                                  .sequentialReadFCB: ;ah = 14h
   301                                  .sequentialWriteFCB:;ah = 15h
   302                                  .createFileFCB:     ;ah = 16h
   303                                  .renameFileFCB:     ;ah = 17h
   304                                                      ;ah = 18h unused
   305                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   306                                  .setDTA:            ;ah = 1Ah
   307                                  .FATinfoDefault:    ;ah = 1Bh
   308                                  .FatinfoDevice:     ;ah = 1Ch
   309                                                      ;ah = 1Dh unused
   310                                                      ;ah = 1Eh unused
   311                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   312                                                      ;ah = 20h unused
   313                                  .randomReadFCB:     ;ah = 21h
   314                                  .randomWriteFCB:    ;ah = 22h
   315                                  .getFileSizeFCB:    ;ah = 23h
   316                                  .setRelRecordFCB:   ;ah = 24h
   317                                  .setIntVector:      ;ah = 25h
   318                                  .createNewPSP:      ;ah = 26h
   319                                  .randBlockReadFCB:  ;ah = 27h
   320                                  .randBlockWriteFCB: ;ah = 28h
   321                                  .parseFilenameFCB:  ;ah = 29h
   322                                  .getDate:           ;ah = 2Ah
   323                                  .setDate:           ;ah = 2Bh
   324                                  .getTime:           ;ah = 2Ch
   325                                  .setTime:           ;ah = 2Dh
   326                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   327                                  .getDTA:            ;ah = 2Fh
   328                                  .getDOSversion:     ;ah = 30h
   329                                  .terminateStayRes:  ;ah = 31h
   330                                  .getDeviceDPBptr:   ;ah = 32h
   331                                  .ctrlBreakCheck:    ;ah = 33h
   332                                  .getInDOSflagPtr:   ;ah = 34h
   333                                  .getIntVector:      ;ah = 35h
   334                                  .getDiskFreeSpace:  ;ah = 36h
   335                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   336                                  .getsetCountryInfo: ;ah = 38h, localisation info
   337                                  .makeDIR:           ;ah = 39h
   338                                  .removeDIR:         ;ah = 3Ah
   339                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   340                                  .createFileHdl:     ;ah = 3Ch, handle function
   341                                  .openFileHdl:       ;ah = 3Dh, handle function
   342                                  .closeFileHdl:      ;ah = 3Eh, handle function
   343                                  .readFileHdl:       ;ah = 3Fh, handle function
   344                                  .writeFileHdl:      ;ah = 40h, handle function
   345                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   346                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   347                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   348                                  .ioctrl:            ;ah = 44h, handle function
   349                                  .duplicateHandle:   ;ah = 45h, handle function
   350                                  .forceDuplicateHdl: ;ah = 46h, handle function
   351                                  .getCurrentDIR:     ;ah = 47h
   352                                  .allocateMemory:    ;ah = 48h
   353                                  .freeMemory:        ;ah = 49h
   354                                  .reallocMemory:     ;ah = 4Ah
   355                                  .loadExecChild:     ;ah = 4Bh, EXEC
   356                                  .terminateClean:    ;ah = 4Ch, EXIT
   357                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   358                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   359                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   360                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   361                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   362                                  .getSysVarsPtr:     ;ah = 52h
   363                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   364                                  .getVerifySetting:  ;ah = 54h
   365                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   366                                  .renameFile:        ;ah = 56h
   367                                  .getSetFileDateTime:;ah = 57h
   368                                  .getsetMallocStrat: ;ah = 58h
   369                                  .getExtendedError:  ;ah = 59h
   370                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   371                                  .createNewFile:     ;ah = 5Bh
   372                                  .lockUnlockFile:    ;ah = 5Ch
   373                                  .getCritErrorInfo:  ;ah = 5Dh
   374                                  .networkServices:   ;ah = 5Eh, do nothing
   375                                  .networkRedirection:;ah = 5Fh, do nothing
   376                                  .trueName:          ;ah = 60h, get fully qualified name
   377                                                      ;ah = 61h, reserved
   378                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   379                                                      ;ah = 63h, reserved
   380                                  .setDriverLookahead:;ah = 64h, reserved
   381                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   382                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   383                                  .setHandleCount:    ;ah = 67h
   384                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   385                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   386                                  .return:
   387 00000095 C3                          ret
   388                                  
   389                                  
   390                                  .dispatchTable:
   391 00000096 [7200000000000000]          dq .dispTerminate       ;AH = 00H, PROCESS MANAGEMENT
   392 0000009E [7200000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   393 000000A6 [7A00000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   394 000000AE [8200000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   395 000000B6 [8200000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   396 000000BE [8200000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   397 000000C6 [8200000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   398 000000CE [8200000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   399 000000D6 [8200000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   400 000000DE [8200000000000000]          dq .printString         ;AH = 09H, CHAR IO
   401 000000E6 [9500000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   402 000000EE [9500000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   403 000000F6 [9500000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   404 000000FE [9500000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   405 00000106 [9500000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   406 0000010E [9500000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   407 00000116 [9500000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   408 0000011E [9500000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   409 00000126 [9500000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   410 0000012E [9500000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   411 00000136 [9500000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   412 0000013E [9500000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   413 00000146 [9500000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   414 0000014E [9500000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   415 00000156 [9500000000000000]          dq .return              ;AH = 18H, RESERVED
   416 0000015E [9500000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   417 00000166 [9500000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   418 0000016E [9500000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   419 00000176 [9500000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   420 0000017E [9500000000000000]          dq .return              ;AH = 1DH, RESERVED
   421 00000186 [9500000000000000]          dq .return              ;AH = 1EH, RESERVED
   422 0000018E [9500000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   423 00000196 [9500000000000000]          dq .return              ;AH = 20H, RESERVED
   424 0000019E [9500000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   425 000001A6 [9500000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   426 000001AE [9500000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   427 000001B6 [9500000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   428 000001BE [9500000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   429 000001C6 [9500000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   430 000001CE [9500000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   431 000001D6 [9500000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   432 000001DE [9500000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   433 000001E6 [9500000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   434 000001EE [9500000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   435 000001F6 [9500000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   436 000001FE [9500000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   437 00000206 [9500000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   438 0000020E [9500000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   439 00000216 [9500000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   440 0000021E [9500000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   441 00000226 [9500000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   442 0000022E [9500000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   443 00000236 [9500000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   444 0000023E [9500000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   445 00000246 [9500000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   446 0000024E [9500000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   447 00000256 [9500000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   448 0000025E [9500000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   449 00000266 [9500000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   450 0000026E [9500000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   451 00000276 [9500000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   452 0000027E [9500000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   453 00000286 [9500000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   454 0000028E [9500000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   455 00000296 [9500000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   456 0000029E [9500000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   457 000002A6 [9500000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   458 000002AE [9500000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   459 000002B6 [9500000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   460 000002BE [9500000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   461 000002C6 [9500000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   462 000002CE [9500000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   463 000002D6 [9500000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   464 000002DE [9500000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   465 000002E6 [9500000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   466 000002EE [9500000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   467 000002F6 [9500000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   468 000002FE [9500000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   469 00000306 [9500000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   470 0000030E [9500000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   471 00000316 [9500000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   472 0000031E [9500000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   473 00000326 [9500000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   474 0000032E [9500000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   475 00000336 [9500000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   476 0000033E [9500000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   477 00000346 [9500000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   478 0000034E [9500000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   479 00000356 [9500000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   480 0000035E [9500000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   481 00000366 [9500000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   482 0000036E [9500000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   483 00000376 [9500000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   484 0000037E [9500000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   485 00000386 [9500000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   486 0000038E [9500000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   487 00000396 [9500000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   488 0000039E [9500000000000000]          dq .return              ;AH = 61H, RESERVED
   489 000003A6 [9500000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   490 000003AE [9500000000000000]          dq .return              ;AH = 63H, RESERVED
   491 000003B6 [9500000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   492 000003BE [9500000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   493 000003C6 [9500000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   494 000003CE [9500000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   495 000003D6 [9500000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   496 000003DE [9500000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   497                                  dispatchTableL  equ $ - .dispatchTable 
   498                                  
   499                                  terminateHandler:   ;Int 42h
   500                                  ctrlCHandler:       ;Int 43h
   501                                  critErrorHandler:   ;Int 44h
   502                                  ;User Stack in usage here, must be swapped to before this is called
   503                                  ;Entered with:  
   504                                  ;               AH = Critical Error Bitfield
   505                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   506                                  ;               Bit 6 - Reserved
   507                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   508                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   509                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   510                                  ;               Bits [2-1] = Affected Disk Error
   511                                  ;                     0 0   DOS area
   512                                  ;                     0 1   FAT area
   513                                  ;                     1 0   Directory area
   514                                  ;                     1 1   Data area
   515                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   516                                  ;               AL  = Failing drive number if AH[7] = 0
   517                                  ;               DIL = Error code for errorMsg
   518                                  ;               RSI = EA of Device Header for which device the error occured
   519                                  ;Return:
   520                                  ;               AL = 0 - Ignore the Error       (Ignore)
   521                                  ;                  = 1 - Retry the Operation    (Retry)
   522                                  ;                  = 2 - Terminate the Program  (Abort)
   523                                  ;                  = 3 - Fail the DOS call      (Fail)
   524 000003E6 53                          push rbx
   525 000003E7 51                          push rcx
   526 000003E8 52                          push rdx
   527 000003E9 57                          push rdi
   528 000003EA 56                          push rsi
   529 000003EB FC                          cld         ;Make String ops go forward
   530                                  
   531 000003EC 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   532 000003EF 488D155E020000              lea rdx, qword [.crlf]
   533 000003F6 B409                        mov ah, 09h ;Print String
   534 000003F8 CD41                        int 41h     ;Call DOS to print CRLF part of message
   535                                  
   536 000003FA 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   537 00000400 B90C000000                  mov ecx, 0Ch
   538 00000405 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   539 00000407 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   540 0000040A 480FB7FF                    movzx rdi, di
   541 0000040E 4889FA                      mov rdx, rdi    ;Copy error code
   542 00000411 48C1E704                    shl rdi, 4  ;Multiply by 16
   543 00000415 48D1E2                      shl rdx, 1  ;Multiply by 2
   544 00000418 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   545 0000041B 488D1523010000              lea rdx, qword [.errorMsgTable]
   546 00000422 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   547 00000426 B409                        mov ah, 09h ;Print String
   548 00000428 CD41                        int 41h     ;Call DOS to print first part of message
   549                                  
   550 0000042A 488D1505020000              lea rdx, qword [.readmsg]
   551 00000431 488D3D0D020000              lea rdi, qword [.writemsg]
   552 00000438 F6C701                      test bh, 1  ;Bit 0 is set if write operation
   553 0000043B 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   554 0000043F B409                        mov ah, 09h ;Print String
   555 00000441 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   556                                  
   557 00000443 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   558 00000446 0F85DF000000                jnz .charError
   559                                  ;Disk error continues here
   560 0000044C 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   561 00000453 B409                        mov ah, 09h
   562 00000455 CD41                        int 41h
   563 00000457 88DA                        mov dl, bl  ;Get zero based drive number into dl
   564 00000459 80C241                      add dl, "A" ;Add ASCII code
   565 0000045C B402                        mov ah, 02h ;Print char in dl
   566 0000045E CD41                        int 41h
   567                                  .userInput:
   568 00000460 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   569 00000467 B409                        mov ah, 09h
   570 00000469 CD41                        int 41h
   571                                  ;Abort, Retry, Ignore, Fail is word order
   572                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   573                                  .userAbort:
   574                                  ;Abort is always an option
   575 0000046B 488D15E5010000              lea rdx, qword [.abortmsg]
   576 00000472 B409                        mov ah, 09h
   577 00000474 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   578                                  .userRetry:
   579 00000476 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   580 00000479 7416                        jz .userIgnore    ;If clear, dont print message
   581 0000047B 488D15ED010000              lea rdx, qword [.betweenMsg]
   582 00000482 B409                        mov ah, 09h
   583 00000484 CD41                        int 41h
   584 00000486 488D15D7010000              lea rdx, qword [.retrymsg]
   585 0000048D B409                        mov ah, 09h
   586 0000048F CD41                        int 41h
   587                                  .userIgnore:
   588 00000491 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   589 00000494 7416                        jz .userFail
   590 00000496 488D15D2010000              lea rdx, qword [.betweenMsg]
   591 0000049D B409                        mov ah, 09h
   592 0000049F CD41                        int 41h
   593 000004A1 488D15B5010000              lea rdx, qword [.ignoremsg]
   594 000004A8 B409                        mov ah, 09h
   595 000004AA CD41                        int 41h
   596                                  .userFail:
   597 000004AC F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   598 000004AF 7416                        jz .userMsgEnd
   599 000004B1 488D15B7010000              lea rdx, qword [.betweenMsg]
   600 000004B8 B409                        mov ah, 09h
   601 000004BA CD41                        int 41h
   602 000004BC 488D15A7010000              lea rdx, qword [.failmsg]
   603 000004C3 B409                        mov ah, 09h
   604 000004C5 CD41                        int 41h
   605                                  .userMsgEnd:
   606 000004C7 488D15A4010000              lea rdx, qword [.endMsg]
   607 000004CE B409                        mov ah, 09h
   608 000004D0 CD41                        int 41h
   609                                  ;Get user input now 
   610 000004D2 31C9                        xor ecx, ecx  ;4 Possible Responses
   611 000004D4 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   612 000004DB B401                        mov ah, 01h ;STDIN without Console Echo
   613 000004DD CD41                        int 41h ;Get char in al
   614 000004DF 3C61                        cmp al, "a" ;Chack if lowercase
   615 000004E1 7202                        jb .uip1    ;If the value is below, ignore subtraction
   616 000004E3 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   617                                  .uip1:
   618 000004E5 AE                          scasb   ;Compare char to list, offset gives return code
   619 000004E6 740F                        je .validInput  ;If they are equal, ecx has return code
   620 000004E8 FFC1                        inc ecx
   621 000004EA 81F904000000                cmp ecx, 4
   622 000004F0 75F3                        jne .uip1
   623 000004F2 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   624                                  .validInput:
   625 000004F7 88C8                        mov al, cl  ;Move the offset into .responses into al
   626                                  ;Now check if the input is permitted
   627 000004F9 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   628 000004FB 7427                        je .cehExit
   629 000004FD 84C0                        test al, al ;Check if 0 => Ignore
   630 000004FF 740F                        je .viIgnore
   631 00000501 3C01                        cmp al, 1   ;Check if 1 => Retry
   632 00000503 7416                        je .viRetry
   633                                  .viFail:    ;Fallthrough for fail (al = 3)
   634 00000505 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   635 00000508 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   636 0000050E EB14                        jmp short .cehExit
   637                                  .viIgnore:
   638 00000510 F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   639 00000513 0F8447FFFFFF                jz .userInput
   640 00000519 EB09                        jmp short .cehExit
   641                                  .viRetry:
   642 0000051B F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   643 0000051E 0F843CFFFFFF                jz .userInput
   644                                  .cehExit:
   645 00000524 5E                          pop rsi
   646 00000525 5F                          pop rdi
   647 00000526 5A                          pop rdx
   648 00000527 59                          pop rcx
   649 00000528 5B                          pop rbx
   650 00000529 48CF                        iretq
   651                                  .charError:
   652 0000052B B908000000                  mov ecx, 8  ;8 chars in device name
   653 00000530 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   654                                  .ce1:
   655 00000537 AC                          lodsb   ;Get a string char into al and inc rsi
   656 00000538 88C2                        mov dl, al  ;Move char into dl
   657 0000053A B402                        mov ah, 02h
   658 0000053C CD41                        int 41h ;Print char
   659 0000053E E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   660 00000540 E91BFFFFFF                  jmp .userInput
   661                                  
   662                                  .errorMsgTable: ;Each table entry is 18 chars long
   663 00000545 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   663 0000054E 746563742024202020 
   664 00000557 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   664 00000560 6E6974202420202020 
   665 00000569 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   665 00000572 202420202020202020 
   666 0000057B 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   666 00000584 6F6D6D616E64202420 
   667 0000058D 446174612024202020-                 db "Data $            "       ;Error 4
   667 00000596 202020202020202020 
   668 0000059F 426164205265717565-                 db "Bad Request $     "       ;Error 5
   668 000005A8 737420242020202020 
   669 000005B1 5365656B2024202020-                 db "Seek $            "       ;Error 6
   669 000005BA 202020202020202020 
   670 000005C3 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   670 000005CC 656469612024202020 
   671 000005D5 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   671 000005DE 7420466F756E642024 
   672 000005E7 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   672 000005F0 706572202420202020 
   673 000005F9 577269746520466175-                 db "Write Fault $     "       ;Error A
   673 00000602 6C7420242020202020 
   674 0000060B 52656164204661756C-                 db "Read Fault $      "       ;Error B
   674 00000614 742024202020202020 
   675 0000061D 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   675 00000626 61696C757265202420 
   676                                  
   677 0000062F 64726976652024          .drive      db "drive $"
   678 00000636 6572726F7220726561-     .readmsg    db "error reading $"
   678 0000063F 64696E672024       
   679 00000645 6572726F7220777269-     .writemsg   db "error writing $"
   679 0000064E 74696E672024       
   680 00000654 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   681 00000657 41626F727424            .abortmsg   db "Abort$" 
   682 0000065D 49676E6F726524          .ignoremsg  db "Ignore$"
   683 00000664 526574727924            .retrymsg   db "Retry$"
   684 0000066A 4661696C24              .failmsg    db "Fail$"
   685 0000066F 2C2024                  .betweenMsg db ", $"
   686 00000672 3F2024                  .endMsg     db "? $"
   687 00000675 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   688                                  absDiskRead:        ;Int 45h
   689                                  ;al = Drive number
   690                                  ;rbx = Memory Buffer address
   691                                  ;ecx = Number of sectors to read (max 255 for now)
   692                                  ;rdx = Start LBA to read from
   693 00000679 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   694 0000067D 8A80[3B0C0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   695 00000683 4891                        xchg rax, rcx
   696 00000685 4887CA                      xchg rcx, rdx
   697 00000688 B482                        mov ah, 82h
   698 0000068A CD33                        int 33h
   699 0000068C 48CF                        iretq
   700                                  absDiskWrite:       ;Int 46h
   701 0000068E 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   702 00000692 8A80[3B0C0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   703 00000698 4891                        xchg rax, rcx
   704 0000069A 4887CA                      xchg rcx, rdx
   705 0000069D B483                        mov ah, 83h
   706 0000069F CD33                        int 33h
   707 000006A1 48CF                        iretq
   708                                  terminateResident:  ;Int 47h
   709                                  inDosHandler:       ;Int 48h
   710                                  ;Called when DOS idle
   711 000006A3 48CF                        iretq
   712                                  fastOutput:         ;Int 49h
   713                                  ;Called with char to transfer in al
   714 000006A5 50                          push rax
   715 000006A6 B40E                        mov ah, 0Eh
   716 000006A8 CD30                        int 30h
   717 000006AA 58                          pop rax
   718 000006AB 48CF                        iretq
   719                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   720 000006AD 48CF                        iretq
   721                                  multiplex:          ;Int 4Fh, kept as iretq for now
   722 000006AF 48CF                        iretq
   723                                  ;-----------------------------------:
   724                                  ;          Driver routines          :
   725                                  ;-----------------------------------:
   726                                  drivers:
   727                                  conHdr:
   728 000006B1 [D306000000000000]          dq auxHdr
   729 000006B9 1308                        dw 0813h
   730 000006BB [4908000000000000]          dq commonStrat
   731 000006C3 [6008000000000000]          dq conDriver
   732 000006CB 434F4E2020202020            db "CON     "
   733                                  auxHdr:
   734 000006D3 [F506000000000000]          dq prnHdr
   735 000006DB 0080                        dw 08000h
   736 000006DD [4908000000000000]          dq commonStrat
   737 000006E5 [1B09000000000000]          dq com1Intr
   738 000006ED 4155582020202020            db "AUX     "
   739                                  prnHdr:
   740 000006F5 [1707000000000000]          dq clkHdr
   741 000006FD 40A0                        dw 0A040h
   742 000006FF [4908000000000000]          dq commonStrat
   743 00000707 [E307000000000000]          dq lpt1Hdr
   744 0000070F 50524E2020202020            db "PRN     "
   745                                  clkHdr:
   746 00000717 [3907000000000000]          dq msdHdr
   747 0000071F 0880                        dw 08008h
   748 00000721 [4908000000000000]          dq commonStrat
   749 00000729 [1B09000000000000]          dq clkDriver
   750 00000731 434C4F434B242020            db "CLOCK$  "
   751                                  msdHdr:
   752 00000739 [5B07000000000000]          dq com1Hdr
   753 00000741 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   754 00000743 [4908000000000000]          dq commonStrat
   755 0000074B [C609000000000000]          dq msdDriver
   756 00000753 0000000000000000            db 0,0,0,0,0,0,0,0
   757                                  com1Hdr:
   758 0000075B [7D07000000000000]          dq com2Hdr
   759 00000763 0080                        dw 08000h
   760 00000765 [4908000000000000]          dq commonStrat
   761 0000076D [1B09000000000000]          dq com1Intr
   762 00000775 434F4D3120202020            db "COM1    "
   763                                  com2Hdr:
   764 0000077D [9F07000000000000]          dq com3Hdr
   765 00000785 0080                        dw 08000h
   766 00000787 [4908000000000000]          dq commonStrat
   767 0000078F [2409000000000000]          dq com2Intr
   768 00000797 434F4D3220202020            db "COM2    "
   769                                  com3Hdr:
   770 0000079F [C107000000000000]          dq com4Hdr
   771 000007A7 0080                        dw 08000h
   772 000007A9 [4908000000000000]          dq commonStrat
   773 000007B1 [2D09000000000000]          dq com3Intr
   774 000007B9 434F4D3320202020            db "COM3    "
   775                                  com4Hdr:
   776 000007C1 [E307000000000000]          dq lpt1Hdr
   777 000007C9 0080                        dw 08000h
   778 000007CB [4908000000000000]          dq commonStrat
   779 000007D3 [3609000000000000]          dq com4Intr
   780 000007DB 434F4D3420202020            db "COM4    "
   781                                  lpt1Hdr:
   782 000007E3 [0508000000000000]          dq lpt2Hdr
   783 000007EB 40A0                        dw 0A040h
   784 000007ED [4908000000000000]          dq commonStrat
   785 000007F5 [B609000000000000]          dq lptDriver
   786 000007FD 4C50543120202020            db "LPT1    "
   787                                  lpt2Hdr:
   788 00000805 [2708000000000000]          dq lpt3Hdr
   789 0000080D 40A0                        dw 0A040h
   790 0000080F [4908000000000000]          dq commonStrat
   791 00000817 [B609000000000000]          dq lptDriver
   792 0000081F 4C50543220202020            db "LPT2    "
   793                                  lpt3Hdr:
   794 00000827 FFFFFFFFFFFFFFFF            dq -1
   795 0000082F 40A0                        dw 0A040h
   796 00000831 [4908000000000000]          dq commonStrat
   797 00000839 [B609000000000000]          dq lptDriver
   798 00000841 4C50543320202020            dq "LPT3    "
   799                                  
   800                                  commonStrat:
   801                                  ;DOS calls this function with rbx=Ptr to request header
   802 00000849 48891D01000000              mov qword [reqHdrPtr], rbx
   803 00000850 C3                          ret
   804 00000851 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   805                                  
   806                                  nulStrat:
   807 00000859 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   808                                  nulIntr:
   809 0000085F C3                          ret
   810                                  
   811                                  conDriver:
   812 00000860 50                          push rax
   813 00000861 53                          push rbx
   814 00000862 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   815 00000869 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   816 0000086C 84C0                        test al, al
   817 0000086E 7421                        jz conInit
   818 00000870 3C04                        cmp al, 4
   819 00000872 744D                        jz conRead
   820 00000874 3C05                        cmp al, 5
   821 00000876 7466                        jz conNondestructiveRead
   822 00000878 3C06                        cmp al, 6
   823 0000087A 740C                        jz conExit
   824 0000087C 3C07                        cmp al, 7
   825 0000087E 7471                        jz conFlushInputBuffers
   826 00000880 3C08                        cmp al, 8
   827 00000882 7479                        jz conWrite
   828 00000884 3C09                        cmp al, 9
   829 00000886 7475                        jz conWrite
   830                                  ;All other cases fall through here
   831                                  conExit:
   832 00000888 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   833 0000088E 5B                          pop rbx
   834 0000088F 58                          pop rax
   835 00000890 C3                          ret
   836                                  conInit:    ;Function 0
   837 00000891 52                          push rdx
   838                                      ;Flush keyboard buffer
   839                                  .ci0:
   840 00000892 B401                        mov ah, 01      ;Get buffer status
   841 00000894 CD36                        int 36h
   842 00000896 7406                        jz .ci1      ;If zero clear => no more keys to read
   843 00000898 30E4                        xor ah, ah
   844 0000089A CD36                        int 36h ;Read key to flush from buffer
   845 0000089C EBF4                        jmp short .ci0
   846                                  .ci1:
   847 0000089E B800050000                  mov eax, 0500h  ;Set page zero as the default page
   848 000008A3 CD30                        int 30h
   849 000008A5 B402                        mov ah, 02h
   850 000008A7 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   851 000008A9 88D7                        mov bh, dl      ;Set cursor for page 0
   852 000008AB CD30                        int 30h
   853 000008AD B707                        mov bh, 07h     ;Grey/Black attribs
   854 000008AF B800060000                  mov eax, 0600h  ;Clear whole screen
   855 000008B4 CD30                        int 30h
   856 000008B6 5A                          pop rdx
   857 000008B7 EBCF                        jmp short conExit
   858                                  conIORead:
   859 000008B9 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   860 000008BF EBC7                        jmp short conExit
   861                                  conRead:    ;Function 4
   862 000008C1 57                          push rdi
   863 000008C2 51                          push rcx
   864 000008C3 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   865 000008C7 31C9                        xor ecx, ecx    ;Zero the char counter
   866                                  .cr1:
   867 000008C9 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   868 000008CC 7409                        je .cre2
   869 000008CE 31C0                        xor eax, eax
   870 000008D0 CD36                        int 36h
   871 000008D2 AA                          stosb   ;Store char in al into buffer and inc rdi
   872 000008D3 FFC1                        inc ecx
   873 000008D5 EBF2                        jmp short .cr1
   874                                  .cre2:
   875 000008D7 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   876 000008DA 59                          pop rcx
   877 000008DB 5F                          pop rdi
   878 000008DC EBAA                        jmp short conExit
   879                                  conNondestructiveRead:  ;Function 5
   880 000008DE B401                        mov ah, 01h     ;Get key if exists
   881 000008E0 CD36                        int 36h
   882 000008E2 7405                        jz .cnr           ;If zero clear => no key, go forwards
   883                                      ;Keystroke available
   884 000008E4 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   885 000008E7 EB9F                        jmp short conExit
   886                                  .cnr: ;No keystroke available
   887 000008E9 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   888 000008EF EB97                        jmp short conExit
   889                                  conFlushInputBuffers:   ;Function 7
   890 000008F1 B401                        mov ah, 01      ;Get buffer status
   891 000008F3 CD36                        int 36h
   892 000008F5 7491                        jz conExit      ;If zero clear => no more keys to read
   893 000008F7 30E4                        xor ah, ah
   894 000008F9 CD36                        int 36h ;Read key to flush from buffer
   895 000008FB EBF4                        jmp short conFlushInputBuffers
   896                                  conWrite:   ;Function 8 and 9
   897 000008FD 56                          push rsi
   898 000008FE 51                          push rcx
   899 000008FF 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   900 00000903 31C9                        xor ecx, ecx    ;Zero the char counter
   901                                  .cw1: 
   902 00000905 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   903 00000908 7407                        je .cw2
   904 0000090A AC                          lodsb   ;Get char into al, and inc rsi
   905 0000090B CD49                        int 49h ;Fast print char
   906 0000090D FFC1                        inc ecx
   907 0000090F EBF4                        jmp short .cw1 ;keep printing until all chars printed
   908                                  .cw2:
   909 00000911 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   910 00000914 59                          pop rcx
   911 00000915 5E                          pop rsi
   912 00000916 E96DFFFFFF                  jmp conExit
   913                                  
   914                                  clkDriver:
   915                                  
   916                                  comDriver:
   917                                  com1Intr:
   918 0000091B C6059300000000              mov byte [comDevice], 0
   919 00000922 EB19                        jmp short comIntr
   920                                  com2Intr:
   921 00000924 C6058A00000001              mov byte [comDevice], 1
   922 0000092B EB10                        jmp short comIntr
   923                                  com3Intr:
   924 0000092D C6058100000002              mov byte [comDevice], 2
   925 00000934 EB07                        jmp short comIntr
   926                                  com4Intr:
   927 00000936 C6057800000003              mov byte [comDevice], 3
   928                                  comIntr:
   929 0000093D 50                          push rax
   930 0000093E 53                          push rbx
   931 0000093F 51                          push rcx
   932 00000940 52                          push rdx
   933 00000941 56                          push rsi
   934 00000942 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   935 00000949 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   936 0000094C 3C04                        cmp al, 4
   937 0000094E 7418                        jz comRead
   938 00000950 3C05                        cmp al, 5
   939 00000952 7439                        jz comNondestructiveRead
   940 00000954 3C08                        cmp al, 8
   941 00000956 743D                        jz comWrite
   942 00000958 3C09                        cmp al, 9
   943 0000095A 7439                        jz comWrite
   944                                  ;All other cases fall through here
   945                                  comExit:
   946 0000095C 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   947 00000962 5E                          pop rsi
   948 00000963 5A                          pop rdx
   949 00000964 59                          pop rcx
   950 00000965 5B                          pop rbx
   951 00000966 58                          pop rax
   952 00000967 C3                          ret
   953                                  comRead:
   954 00000968 57                          push rdi
   955 00000969 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   956 0000096D 31C9                        xor ecx, ecx    ;Zero the char counter
   957                                  .cr1:
   958 0000096F 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   959 00000972 7413                        je .cre2
   960 00000974 B802000000                  mov eax, 02h    ;Recieve 
   961 00000979 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   962 00000980 CD34                        int 34h ;Recieve Char
   963 00000982 AA                          stosb   ;Store char in al into buffer and inc rdi
   964 00000983 FFC1                        inc ecx
   965 00000985 EBE8                        jmp short .cr1
   966                                  .cre2:
   967 00000987 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   968 0000098A 5F                          pop rdi
   969 0000098B EBCF                        jmp short comExit
   970                                  comNondestructiveRead:
   971 0000098D 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
   972 00000993 EBC7                        jmp short comExit
   973                                  comWrite:
   974 00000995 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   975 00000999 31C9                        xor ecx, ecx    ;Zero the char counter
   976                                  .cw1: 
   977 0000099B 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   978 0000099E 7410                        je .cw2
   979 000009A0 AC                          lodsb   ;Get char into al, and inc rsi
   980 000009A1 B401                        mov ah, 01h ;Move function number into ah
   981 000009A3 668B150B000000              mov dx, word [comDevice]
   982 000009AA CD34                        int 34h ;Transmit char
   983 000009AC FFC1                        inc ecx
   984 000009AE EBEB                        jmp short .cw1 ;keep printing until all chars printed
   985                                  .cw2:
   986 000009B0 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   987 000009B3 EBA7                        jmp short comExit
   988 000009B5 00                      comDevice   db 0
   989                                  
   990                                  lptDriver:    ;Drivers for LPT 1, 2, 3
   991 000009B6 57                          push rdi
   992 000009B7 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
   993 000009BE 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
   994 000009C4 5F                          pop rdi
   995 000009C5 C3                          ret
   996                                  
   997                                  msdDriver:
   998 000009C6 50                          push rax
   999 000009C7 53                          push rbx
  1000 000009C8 51                          push rcx
  1001 000009C9 52                          push rdx
  1002 000009CA 56                          push rsi
  1003 000009CB 57                          push rdi
  1004 000009CC 55                          push rbp
  1005 000009CD 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1006 000009D4 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1007 000009D7 3C18                        cmp al, 24  ;Check cmd num is valid
  1008 000009D9 776C                        ja .msdError
  1009 000009DB 84C0                        test al, al
  1010 000009DD 7476                        jz .msdInit
  1011 000009DF 3C01                        cmp al, 01
  1012 000009E1 0F8409010000                jz .msdMedChk
  1013 000009E7 3C02                        cmp al, 02
  1014 000009E9 0F8442010000                jz .msdBuildBPB
  1015 000009EF 3C03                        cmp al, 03
  1016 000009F1 0F847B010000                jz .msdIOCTLRead
  1017 000009F7 3C04                        cmp al, 04
  1018 000009F9 0F8478010000                jz .msdRead
  1019 000009FF 3C08                        cmp al, 08
  1020 00000A01 0F8482010000                jz .msdWrite
  1021 00000A07 3C09                        cmp al, 09
  1022 00000A09 0F848C010000                jz .msdWriteVerify
  1023 00000A0F 3C0C                        cmp al, 12
  1024 00000A11 0F849D010000                jz .msdIOCTLWrite
  1025 00000A17 3C0D                        cmp al, 13
  1026 00000A19 0F849A010000                jz .msdDevOpen
  1027 00000A1F 3C0E                        cmp al, 14
  1028 00000A21 0F84A2010000                jz .msdDevClose
  1029 00000A27 3C0F                        cmp al, 15
  1030 00000A29 0F84AA010000                jz .msdRemovableMedia
  1031 00000A2F 3C13                        cmp al, 19
  1032 00000A31 0F84C0010000                jz .msdGenericIOCTL
  1033 00000A37 3C17                        cmp al, 23
  1034 00000A39 0F84BD010000                jz .msdGetLogicalDev
  1035 00000A3F 3C18                        cmp al, 24
  1036 00000A41 0F84C3010000                jz .msdSetLogicalDev
  1037                                  .msdError:
  1038                                  .msdDriverExit:
  1039 00000A47 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1040 00000A4D 5D                          pop rbp
  1041 00000A4E 5F                          pop rdi
  1042 00000A4F 5E                          pop rsi
  1043 00000A50 5A                          pop rdx
  1044 00000A51 59                          pop rcx
  1045 00000A52 5B                          pop rbx
  1046 00000A53 58                          pop rax
  1047 00000A54 C3                          ret
  1048                                  .msdInit:            ;Function 0
  1049 00000A55 CD31                        int 31h ;Get number of Int 33h devices in r8b
  1050 00000A57 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1051 00000A5B 4489C0                      mov eax, r8d
  1052 00000A5E 3C01                        cmp al, 1
  1053 00000A60 7702                        ja .mi1
  1054 00000A62 FEC0                        inc al ;Make it two
  1055                                  .mi1:
  1056 00000A64 BA05000000                  mov edx, 5
  1057 00000A69 39D0                        cmp eax, edx
  1058 00000A6B 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1059 00000A6E 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1060 00000A74 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1061 00000A77 440005(A9000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1062 00000A7E 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1063 00000A80 488D3DE6010000              lea rdi, qword [.msdBPBblks]
  1064 00000A87 53                          push rbx
  1065                                  .mi2:
  1066 00000A88 89EA                        mov edx, ebp
  1067 00000A8A 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1068 00000A91 31C9                        xor ecx, ecx    ;Sector 0
  1069 00000A93 B801820000                  mov eax, 8201h       ;Read 1 sector
  1070 00000A98 CD33                        int 33h
  1071 00000A9A 724E                        jc .msdInitError
  1072                                  
  1073 00000A9C 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1074 00000AA3 B90F000000                  mov ecx, bpbEx_size/8
  1075 00000AA8 F348A5                      rep movsq   ;Move the BPB data into the right block
  1076                                  
  1077 00000AAB FFC5                        inc ebp
  1078 00000AAD 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1079 00000AB0 75D6                        jne .mi2  ;No? Go again
  1080                                  
  1081 00000AB2 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1082 00000AB9 488D15AD010000              lea rdx, qword [.msdBPBblks]
  1083                                  .mi3:
  1084 00000AC0 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1085 00000AC3 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1086 00000ACA FFCD                        dec ebp
  1087 00000ACC 75F2                        jnz .mi3  ;If not zero yet, go again
  1088                                  
  1089 00000ACE 5B                          pop rbx
  1090 00000ACF 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1091 00000AD6 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1092 00000ADA 488D15E4030000              lea rdx, qword [driverDataPtr]
  1093 00000AE1 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1094 00000AE5 E95DFFFFFF                  jmp .msdDriverExit
  1095                                  .msdInitError:
  1096 00000AEA 5B                          pop rbx
  1097 00000AEB E957FFFFFF                  jmp .msdDriverExit
  1098                                  .msdMedChk:          ;Function 1
  1099                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1100                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1101                                  ; suffice.
  1102 00000AF0 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1103 00000AF5 8A90[3B0C0000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1104 00000AFB F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1105 00000AFE 7528                        jnz .mmcNoChange
  1106                                  ;Now we test Media Descriptor
  1107 00000B00 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1108 00000B03 488B3CC5[450C0000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1109 00000B0B 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1110 00000B0E 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1111 00000B11 740C                        je .mmcUnsure
  1112                                  .mmcChange: ;Fail safe, always assume the device has changed
  1113 00000B13 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1114 00000B17 48C7430F[310C0000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
  1115                                  .mmcUnsure:
  1116 00000B1F C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1117 00000B23 E91FFFFFFF                  jmp .msdDriverExit
  1118                                  .mmcNoChange:
  1119 00000B28 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1120 00000B2C E916FFFFFF                  jmp .msdDriverExit
  1121                                  
  1122                                  .msdBuildBPB:        ;Function 2
  1123 00000B31 4889DE                      mov rsi, rbx
  1124 00000B34 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1125 00000B39 8A90[3B0C0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1126 00000B3F 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1127 00000B43 31C9                        xor ecx, ecx    ;Read Sector 0
  1128 00000B45 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1129 00000B4A CD33                        int 33h
  1130 00000B4C 7224                        jc .mbbpbError
  1131 00000B4E 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1132 00000B51 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1133 00000B56 488B3CC5[450C0000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1134 00000B5E 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1135 00000B61 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1136 00000B65 B90F000000                  mov ecx, bpbEx_size/8
  1137 00000B6A F348A5                      rep movsq   ;Move the BPB data into the right space
  1138 00000B6D E9D5FEFFFF                  jmp .msdDriverExit
  1139                                  .mbbpbError:
  1140                                  .msdIOCTLRead:       ;Function 3, returns done
  1141 00000B72 E9D0FEFFFF                  jmp .msdDriverExit
  1142                                  .msdRead:            ;Function 4
  1143 00000B77 4889DD                      mov rbp, rbx
  1144 00000B7A B482                        mov ah, 82h ;LBA Read Sectors
  1145 00000B7C E897000000                  call .msdBlkIOCommon
  1146 00000B81 4889EB                      mov rbx, rbp
  1147 00000B84 E9BEFEFFFF                  jmp .msdDriverExit
  1148                                  .msdWrite:           ;Function 8
  1149 00000B89 4889DD                      mov rbp, rbx
  1150 00000B8C B483                        mov ah, 83h ;LBA Write Sectors
  1151 00000B8E E885000000                  call .msdBlkIOCommon
  1152 00000B93 4889EB                      mov rbx, rbp
  1153 00000B96 E9ACFEFFFF                  jmp .msdDriverExit
  1154                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1155 00000B9B 4889DD                      mov rbp, rbx
  1156 00000B9E B483                        mov ah, 83h ;LBA Write Sectors
  1157 00000BA0 E873000000                  call .msdBlkIOCommon
  1158 00000BA5 B484                        mov ah, 84h ;LBA Verify Sectors
  1159 00000BA7 E86C000000                  call .msdBlkIOCommon
  1160 00000BAC 4889EB                      mov rbx, rbp
  1161 00000BAF E993FEFFFF                  jmp .msdDriverExit
  1162                                  .msdIOCTLWrite:      ;Function 12, returns done
  1163 00000BB4 E98EFEFFFF                  jmp .msdDriverExit
  1164                                  .msdDevOpen:         ;Function 13
  1165 00000BB9 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1166 00000BBE FE80[400C0000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1167 00000BC4 E97EFEFFFF                  jmp .msdDriverExit
  1168                                  .msdDevClose:        ;Function 14
  1169 00000BC9 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1170 00000BCE FE88[400C0000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1171 00000BD4 E96EFEFFFF                  jmp .msdDriverExit
  1172                                  .msdRemovableMedia:  ;Function 15
  1173 00000BD9 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1174 00000BDE 8A80[3B0C0000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1175 00000BE4 A880                        test al, 80h
  1176 00000BE6 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1177 00000BEC 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
  1178 00000BF2 E950FEFFFF                  jmp .msdDriverExit
  1179                                  .msdGenericIOCTL:    ;Function 19
  1180 00000BF7 E94BFEFFFF                  jmp .msdDriverExit
  1181                                  .msdGetLogicalDev:   ;Function 23
  1182 00000BFC 8A0538000000                mov al, byte [.msdCurDev]
  1183 00000C02 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1184 00000C05 E93DFEFFFF                  jmp .msdDriverExit
  1185                                  .msdSetLogicalDev:   ;Function 24
  1186 00000C0A 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1187 00000C0D 880527000000                mov byte [.msdCurDev], al
  1188 00000C13 E92FFEFFFF                  jmp .msdDriverExit
  1189                                  
  1190                                  .msdBlkIOCommon:  ;Does block IO
  1191                                  ;Called with rbp containing old rbx value and ah with function number
  1192                                  ;Error handled by caller
  1193 00000C18 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1194 00000C1D 8A90[3B0C0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1195 00000C23 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1196 00000C27 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
  1197 00000C2A 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1198 00000C2E CD33                        int 33h
  1199 00000C30 C3                          ret
  1200                                  
  1201 00000C31 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1202                                  ;LASTDRIVE default is 5
  1203 00000C3A 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1204                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1205 00000C3B 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1206 00000C40 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1207 00000C45 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1207 00000C4E 000000000000000000-
  1207 00000C57 000000000000000000-
  1207 00000C60 000000000000000000-
  1207 00000C69 00000000           
  1208 00000C6D 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1208 00000C76 000000000000000000-
  1208 00000C7F 000000000000000000-
  1208 00000C88 000000000000000000-
  1208 00000C91 000000000000000000-
  1208 00000C9A 000000000000000000-
  1208 00000CA3 000000000000000000-
  1208 00000CAC 000000000000000000-
  1208 00000CB5 000000000000000000-
  1208 00000CBE 000000000000000000-
  1208 00000CC7 000000000000000000-
  1208 00000CD0 000000000000000000-
  1208 00000CD9 000000000000000000-
  1208 00000CE2 000000000000000000-
  1208 00000CEB 000000000000000000-
  1208 00000CF4 000000000000000000-
  1208 00000CFD 000000000000000000-
  1208 00000D06 000000000000000000-
  1208 00000D0F 000000000000000000-
  1208 00000D18 000000000000000000-
  1208 00000D21 000000000000000000-
  1208 00000D2A 000000000000000000-
  1208 00000D33 000000000000000000-
  1208 00000D3C 000000000000000000-
  1208 00000D45 000000000000000000-
  1208 00000D4E 000000000000000000-
  1208 00000D57 000000000000000000-
  1208 00000D60 000000000000000000-
  1208 00000D69 000000000000000000-
  1208 00000D72 000000000000000000-
  1208 00000D7B 000000000000000000-
  1208 00000D84 000000000000000000-
  1208 00000D8D 000000000000000000-
  1208 00000D96 000000000000000000-
  1208 00000D9F 000000000000000000-
  1208 00000DA8 000000000000000000-
  1208 00000DB1 000000000000000000-
  1208 00000DBA 000000000000000000-
  1208 00000DC3 000000000000000000-
  1208 00000DCC 000000000000000000-
  1208 00000DD5 000000000000000000-
  1208 00000DDE 000000000000000000-
  1208 00000DE7 000000000000000000-
  1208 00000DF0 000000000000000000-
  1208 00000DF9 000000000000000000-
  1208 00000E02 000000000000000000-
  1208 00000E0B 000000000000000000-
  1208 00000E14 000000000000000000-
  1208 00000E1D 000000000000000000-
  1208 00000E26 000000000000000000-
  1208 00000E2F 000000000000000000-
  1208 00000E38 000000000000000000-
  1208 00000E41 000000000000000000-
  1208 00000E4A 000000000000000000-
  1208 00000E53 000000000000000000-
  1208 00000E5C 000000000000000000-
  1208 00000E65 000000000000000000-
  1208 00000E6E 000000000000000000-
  1208 00000E77 000000000000000000-
  1208 00000E80 000000000000000000-
  1208 00000E89 000000000000000000-
  1208 00000E92 000000000000000000-
  1208 00000E9B 000000000000000000-
  1208 00000EA4 000000000000000000-
  1208 00000EAD 000000000000000000-
  1208 00000EB6 000000000000000000-
  1208 00000EBF 000000000000       
  1209                                  
  1210                                  driverDataPtr:
