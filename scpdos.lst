     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     4                              <1> ; device driver related structures.                     ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> struc drvHdr  ;Device Driver Header for character and block devices
     8                              <1> 
     9 00000000 <res 8h>            <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    10 00000008 <res 2h>            <1>     .attrib resw 1  ;Attribute Word
    11 0000000A <res 8h>            <1>     .strPtr resq 1  ;Strategy Entry Pointer
    12 00000012 <res 8h>            <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    13 0000001A <res 8h>            <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    14                              <1> 
    15                              <1> endstruc
    16                              <1> 
    17                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    18                              <1> 
    19                              <1>     .hdrlen resb 1  ;Length of the request header
    20                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    21                              <1>     .cmdcde resb 1  ;Command code
    22                              <1>     .status resw 1  ;Status word
    23                              <1>     .devptr resq 1  ;Device queue pointer field
    24                              <1> 
    25                              <1> %endmacro
    26                              <1> 
    27                              <1> struc drvReqHdr
    28                              <1>     drvReqHdrM
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    29                              <1> endstruc
    30                              <1> 
    31                              <1> struc initReqPkt  ;Init Request Packet
    32                              <1> 
    33                              <1>     drvReqHdrM   ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    34 0000000D <res 1h>            <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    35 0000000E <res 8h>            <1>     .endptr resq 1  ;Pointer to first free byte after driver
    36 00000016 <res 8h>            <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    37 0000001E <res 1h>            <1>     .drvnum resb 1  ;Drive number
    38                              <1> 
    39                              <1> endstruc
    40                              <1> 
    41                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    42                              <1> 
    43                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    44 0000000D <res 1h>            <1>     .medesc resb 1  ;DOS media descriptor
    45 0000000E <res 1h>            <1>     .medret resb 1  ;Return byte (Has media been changed?)
    46 0000000F <res 8h>            <1>     .desptr resq 1  ;Pointer to a valid volume id field
    47                              <1> 
    48                              <1> endstruc
    49                              <1> 
    50                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    51                              <1> 
    52                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    53 0000000D <res 1h>            <1>     .medesc resb 1  ;DOS media descriptor
    54 0000000E <res 8h>            <1>     .bufptr resq 1  ;Transfer buffer
    55 00000016 <res 8h>            <1>     .bpbptr resq 1  ;Pointer to the BPB
    56                              <1> 
    57                              <1> endstruc
    58                              <1> 
    59                              <1> struc ioReqPkt   ;IO Request Packet
    60                              <1> 
    61                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    62 0000000D <res 1h>            <1>     .medesc resb 1  ;DOS media descriptor
    63 0000000E <res 8h>            <1>     .bufptr resq 1  ;Transfer buffer
    64 00000016 <res 4h>            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    65 0000001A <res 8h>            <1>     .strtsc resq 1  ;Starting sector for transfer
    66 00000022 <res 8h>            <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    67                              <1> 
    68                              <1> endstruc
    69                              <1> 
    70                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    71                              <1>     
    72                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    73 0000000D <res 1h>            <1>     .retbyt resb 1  ;Byte read non destructively
    74                              <1> 
    75                              <1> endstruc
    76                              <1> 
    77                              <1> struc statusReqPkt   ;Status Request Packet
    78                              <1> 
    79                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    80                              <1> 
    81                              <1> endstruc
    82                              <1> 
    83                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    84                              <1> 
    85                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    86                              <1>      
    87                              <1> endstruc
    88                              <1> 
    89                              <1> struc openReqPkt ;Open Device Request Packet
    90                              <1> 
    91                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    92                              <1>      
    93                              <1> endstruc
    94                              <1> 
    95                              <1> struc closeReqPkt ;Close Device Request Packet
    96                              <1> 
    97                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
    98                              <1>      
    99                              <1> endstruc
   100                              <1> 
   101                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   102                              <1> 
   103                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
   104                              <1>      
   105                              <1> endstruc
   106                              <1> 
   107                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   108                              <1> 
   109                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
   110 0000000D <res 1h>            <1>     .majfun resb 1  ;Major function number
   111 0000000E <res 1h>            <1>     .minfun resb 1  ;Minor function number
   112 0000000F <res 8h>            <1>     .rsival resq 1  ;Contents of RSI
   113 00000017 <res 8h>            <1>     .rdival resq 1  ;Contents of RDI
   114 0000001F <res 8h>            <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   115                              <1> 
   116                              <1> endstruc
   117                              <1> 
   118                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   119                              <1>     
   120                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
   121                              <1> 
   122                              <1> endstruc
   123                              <1> 
   124                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   125                              <1>     
   126                              <1>     drvReqHdrM    ;Common Driver Header Macro
    18                              <2> 
    19 00000000 <res 1h>            <2>  .hdrlen resb 1
    20 00000001 <res 1h>            <2>  .unitnm resb 1
    21 00000002 <res 1h>            <2>  .cmdcde resb 1
    22 00000003 <res 2h>            <2>  .status resw 1
    23 00000005 <res 8h>            <2>  .devptr resq 1
    24                              <2> 
   127                              <1> 
   128                              <1> endstruc
     5                                  %include "fatStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous FAT driver   ;
     4                              <1> ; structures. exFAT will have it's own files at a later ;
     5                              <1> ; stage.                                                ;
     6                              <1> ;-------------------------------------------------------;
     7                              <1> 
     8                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
     9                              <1> 
    10 00000000 <res 3h>            <1>     .jmpBoot    resb 3 
    11 00000003 <res 8h>            <1>     .oemName    resb 8  ;OEM name
    12 0000000B <res 2h>            <1>     .bytsPerSec resw 1  ;Bytes per sector
    13 0000000D <res 1h>            <1>     .secPerClus resb 1  ;Sectors per cluster
    14 0000000E <res 2h>            <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    15 00000010 <res 1h>            <1>     .numFATs    resb 1  ;Number of FATs on media
    16 00000011 <res 2h>            <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    17 00000013 <res 2h>            <1>     .totSec16   resw 1  ;Number of sectors on medium
    18 00000015 <res 1h>            <1>     .media      resb 1  ;Media descriptor byte
    19 00000016 <res 2h>            <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    20 00000018 <res 2h>            <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    21 0000001A <res 2h>            <1>     .numHeads   resw 1  ;Number of read "heads"
    22 0000001C <res 4h>            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    23 00000020 <res 4h>            <1>     .totSec32   resd 1  ;32 bit count of sectors
    24                              <1> 
    25 00000024 <res 1h>            <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    26 00000025 <res 1h>            <1>     .reserved1  resb 1  ;Reserved byte
    27 00000026 <res 1h>            <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    28 00000027 <res 4h>            <1>     .volID      resd 1  ;Volume serial number
    29 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    30 00000036 <res 8h>            <1>     .filSysType resb 8  ;File system type string
    31                              <1> 
    32                              <1> endstruc
    33                              <1> 
    34                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    35                              <1> 
    36 00000000 <res 3h>            <1>     .jmpBoot    resb 3
    37 00000003 <res 8h>            <1>     .oemName    resb 8  ;OEM name
    38 0000000B <res 2h>            <1>     .bytsPerSec resw 1  ;Bytes per sector
    39 0000000D <res 1h>            <1>     .secPerClus resb 1  ;Sectors per cluster
    40 0000000E <res 2h>            <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    41 00000010 <res 1h>            <1>     .numFATs    resb 1  ;Number of FATs on media
    42 00000011 <res 2h>            <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    43 00000013 <res 2h>            <1>     .totSec16   resw 1  ;Number of sectors on medium
    44 00000015 <res 1h>            <1>     .media      resb 1  ;Media descriptor byte
    45 00000016 <res 2h>            <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    46 00000018 <res 2h>            <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    47 0000001A <res 2h>            <1>     .numHeads   resw 1  ;Number of read "heads"
    48 0000001C <res 4h>            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    49 00000020 <res 4h>            <1>     .totSec32   resd 1  ;32 bit count of sectors
    50                              <1> 
    51 00000024 <res 4h>            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    52 00000028 <res 2h>            <1>     .extFlags   resw 1  ;Extended Flags word
    53 0000002A <res 2h>            <1>     .FSver      resw 1  ;File system version word, must be 0
    54 0000002C <res 4h>            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    55 00000030 <res 2h>            <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    56 00000032 <res 2h>            <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    57 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    58                              <1> 
    59 00000040 <res 1h>            <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    60 00000041 <res 1h>            <1>     .reserved1  resb 1  ;Reserved byte
    61 00000042 <res 1h>            <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    62 00000043 <res 4h>            <1>     .volID      resd 1  ;Volume serial number
    63 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    64 00000052 <res 8h>            <1>     .filSysType resb 8  ;File system type string
    65                              <1> 
    66                              <1> endstruc
    67                              <1> 
    68                              <1> struc fatDirEntry
    69                              <1> 
    70 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    71 0000000B <res 1h>            <1>     .attribute  resb 1  ;Usual attributes
    72 0000000C <res 1h>            <1>     .ntRes      resb 1  ;Reserved 0
    73 0000000D <res 1h>            <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    74 0000000E <res 2h>            <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    75 00000010 <res 2h>            <1>     .crtDate    resb 2  ;Creation date
    76 00000012 <res 2h>            <1>     .lastAccDat resb 2  ;Last Read/Write date
    77 00000014 <res 2h>            <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    78 00000016 <res 2h>            <1>     .wrtTime    resb 2  ;Last modification (write) time
    79 00000018 <res 2h>            <1>     .wrtDate    resb 2  ;Last modification (write) date
    80 0000001A <res 2h>            <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    81 0000001C <res 4h>            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    82                              <1> 
    83                              <1> endstruc
    84                              <1> ;Directory attribute equates
    85                              <1>     dirReadOnly     equ 01h
    86                              <1>     dirHidden       equ 02h
    87                              <1>     dirSystem       equ 04h
    88                              <1>     dirVolumeID     equ 08h
    89                              <1>     dirDirectory    equ 10h
    90                              <1>     dirArchive      equ 20h
    91                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    92                              <1> 
    93                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    94                              <1> 
    95 00000000 <res 3h>            <1>     .jmpBoot                resb 3 
    96 00000003 <res 8h>            <1>     .oemName                resb 8  ;OEM name
    97 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
    98 00000040 <res 8h>            <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
    99 00000048 <res 8h>            <1>     .volumeLength           resq 1  ;Volume Length in sectors
   100 00000050 <res 4h>            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   101 00000054 <res 4h>            <1>     .FATlength              resd 1  ;FAT length, in sectors
   102 00000058 <res 4h>            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   103 0000005C <res 4h>            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   104 00000060 <res 4h>            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   105 00000064 <res 4h>            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   106 00000068 <res 2h>            <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   107 0000006A <res 2h>            <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   108 0000006C <res 1h>            <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   109 0000006D <res 1h>            <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   110 0000006E <res 1h>            <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   111 0000006F <res 1h>            <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   112 00000070 <res 1h>            <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   113 00000071 <res 7h>            <1>     .reserved               resb 7  ;Reserved for alignment
   114                              <1> 
   115                              <1> endstruc
   116                              <1> 
   117                              <1> struc FSInfo
   118                              <1> 
   119 00000000 <res 4h>            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   120 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   121 000001E4 <res 4h>            <1>     .strucSig   resb 4  ;Should be 061417272h
   122 000001E8 <res 4h>            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   123 000001EC <res 4h>            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   124 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   125 000001FC <res 4h>            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   126                              <1> 
   127                              <1> endstruc
     6                                  %include "dosStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous internal     ;
     4                              <1> ; SCP/DOS structures.                                   ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> ;------------------------------------------------------------------------;
     8                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
     9                              <1> ; its file system structure. This is used to locate files and structures
    10                              <1> ; on the device itself and to translate file requests to cluster chains
    11                              <1> ; to LBAs to pass to the disk driver..
    12                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    13                              <1> ; drivers Initialise routine has been called.
    14                              <1> ;------------------------------------------------------------------------;
    15                              <1> struc dpb        ;Drive Parameter Block
    16                              <1> 
    17 00000000 <res 1h>            <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    18 00000001 <res 1h>            <1>     .bUnitNumber             resb 1  ;Unit number in device
    19 00000002 <res 1h>            <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    20 00000003 <res 1h>            <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    21                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    22 00000004 <res 1h>            <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    23 00000005 <res 4h>            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    24 00000009 <res 1h>            <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    25 0000000A <res 2h>            <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    26 0000000C <res 4h>            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    27 00000010 <res 4h>            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    28 00000014 <res 4h>            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    29 00000018 <res 4h>            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    30 0000001C <res 8h>            <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    31 00000024 <res 1h>            <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    32 00000025 <res 1h>            <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    33 00000026 <res 8h>            <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    34 0000002E <res 4h>            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    35 00000032 <res 4h>            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> ;------------------------------------------------------------------------;
    40                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    41                              <1> ; All disk pathing requests go via the CDS for that drive.
    42                              <1> ; The default drive is the last accessed drive, this number is stored
    43                              <1> ; in the DOS data area.
    44                              <1> ; The CDS is stored as an array with the offset into the array being 
    45                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    46                              <1> ;
    47                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    48                              <1> ;------------------------------------------------------------------------;
    49                              <1> struc cds       ;Current Directory structure
    50 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    51 00000043 <res 2h>            <1>     .wFlags              resw 1 ;CDS Flags - 
    52 00000045 <res 8h>            <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    53 0000004D <res 4h>            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    54 00000051 <res 8h>            <1>     .qReserved           resq 1 ;Reserved for future expansions
    55 00000059 <res 2h>            <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    56                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    57                              <1> ; another, we save the number of chars to skip to that deep level).
    58                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    59                              <1> ; Flags: Bit 15 set = Network drive
    60                              <1> ;        Bit 14 set = Physical drive
    61                              <1> ;        Bit 13 set = JOIN'ed drive
    62                              <1> ;        Bit 12 set = SUBST'ed drive
    63                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    64                              <1> endstruc
    65                              <1> ;CDS equates
    66                              <1>     cdsNetDrive     equ 8000h
    67                              <1>     cdsPhysDrive    equ 4000h
    68                              <1>     cdsJoinDrive    equ 2000h
    69                              <1>     cdsSubstDrive   equ 1000h
    70                              <1>     cdsRedirDrive   equ 0080h
    71                              <1> ;------------------------------------------------------------------------;
    72                              <1> ; The SFT is a way to allow applications to open file handles to files 
    73                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    74                              <1> ; under the first header, and then a second header will be linked to the 
    75                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    76                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    77                              <1> ; using the FCBS= command. Default FCBS=5.
    78                              <1> ;
    79                              <1> ; A file handle describes the file, and the location within the file that
    80                              <1> ; we are reading. The file handle can be manipulated without the file
    81                              <1> ; being in memory, thus allowing the user to access data without needing 
    82                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    83                              <1> ; accessing devices, by treating them as files with their drivers 
    84                              <1> ; responding and translating the manipulations of the file handle itself.
    85                              <1> ; Neither the driver nor the application should see or use the SFT for
    86                              <1> ; the handle, as it is subject to change (and will change when file 
    87                              <1> ; sharing provisions are included). The DOS will make requests to the 
    88                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    89                              <1> ; track of the information in the SFT entry for that handle. 
    90                              <1> ;
    91                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    92                              <1> ; can point to the same file. It all depends on what the applications 
    93                              <1> ; want to do with the File.
    94                              <1> ;
    95                              <1> ; !!!!IMPORTANT!!!!
    96                              <1> ; Currently there are plans for File Sharing, but I include minimal 
    97                              <1> ; provisions for it. I really just wanna get a DOS out the door.
    98                              <1> ;
    99                              <1> ;Each SFT may look like this:
   100                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   101                              <1> ;            |                |
   102                              <1> ;       wNumFiles*sft    wNumFiles*sft
   103                              <1> ;
   104                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   105                              <1> ; System FCBs.
   106                              <1> ;
   107                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   108                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   109                              <1> ;
<<<<<<< HEAD
   110                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   111                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   112                              <1> ;------------------------------------------------------------------------;
   113                              <1> struc sfth   ;System file table header
   114                              <1> ; This is the SFT header.
   115                              <1> ; This structure comes before the start of the first file in the array/table.
   116 00000000 <res 8h>            <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   117 00000008 <res 2h>            <1>     .wNumFiles   resw 1    ;Number of files in this table
   118                              <1> endstruc
   119                              <1> 
   120                              <1> struc sft
   121                              <1> ;This is the file struc itself
   122 00000000 <res 2h>            <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   123 00000002 <res 2h>            <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   124 00000004 <res 1h>            <1>     .bFileAttrib resb 1    ;Regular File Attributes
   125 00000005 <res 2h>            <1>     .wDeviceInfo resw 1    ;Includes Device number
   126 00000007 <res 8h>            <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   127 0000000F <res 4h>            <1>     .dStartClust resd 1    ;Start cluster of file
   128 00000013 <res 2h>            <1>     .wTime       resw 1    ;File Time
   129 00000015 <res 2h>            <1>     .wDate       resw 1    ;File Date
   130 00000017 <res 4h>            <1>     .dFileSize   resd 1    ;File Size, in bytes
   131 0000001B <res 4h>            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   132 0000001F <res 2h>            <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   133 00000021 <res 4h>            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   134 00000025 <res 1h>            <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   135 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   136 00000031 <res 8h>            <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   137 00000039 <res 4h>            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   138                              <1> endstruc
   139                              <1> 
   140                              <1> ;------------------------------------------------------------------------;
   141                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   142                              <1> ; to an internal buffer, and then copying it to the specified location
   143                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   144                              <1> ; another request for the same sector from the same device is made, so 
   145                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   146                              <1> ; size, selected according to the largest detected sector size during 
   147                              <1> ; the initial loadup.
   148                              <1> ;
   149                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   150                              <1> ;
   151                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   152                              <1> ;------------------------------------------------------------------------;
   153                              <1> 
   154                              <1> struc bufferHdr
   155 00000000 <res 8h>            <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   156 00000008 <res 1h>            <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   157 00000009 <res 1h>            <1>     .bufferFlags resb  1   ;Standard Flags
   158 0000000A <res 4h>            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   159 0000000E <res 1h>            <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   160 0000000F <res 1h>            <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   161 00000010 <res 8h>            <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   162                              <1> endstruc
   163                              <1> 
   164                              <1> ;------------------------------------------------------------------------;
   165                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   166                              <1> ; following order, thus allowing for return values to be placed in the 
   167                              <1> ; registers by accessing the caller register stack frame.
   168                              <1> ;------------------------------------------------------------------------;
   169                              <1> struc callerFrame
   170 00000000 <res 8h>            <1>     .rax    resq 1  ;Bottom of frame, pointer to rax saved in oldRSP
   171 00000008 <res 8h>            <1>     .rbx    resq 1    
   172 00000010 <res 8h>            <1>     .rcx    resq 1
   173 00000018 <res 8h>            <1>     .rdx    resq 1
   174 00000020 <res 8h>            <1>     .rsi    resq 1
   175 00000028 <res 8h>            <1>     .rdi    resq 1
   176 00000030 <res 8h>            <1>     .rbp    resq 1
   177 00000038 <res 8h>            <1>     .r8     resq 1  ;To be removed if truly not needed
   178 00000040 <res 8h>            <1>     .r9     resq 1
   179                              <1> ;Pushed by Processor when invoked via Interrupt
   180 00000048 <res 8h>            <1>     .rip    resq 1
   181 00000050 <res 8h>            <1>     .cs     resq 1
   182 00000058 <res 8h>            <1>     .flags  resq 1
   183                              <1> endstruc
   184                              <1> 
   185                              <1> %macro pushDOS 0
   186                              <1>     push r9
   187                              <1>     push r8
   188                              <1>     push rbp
   189                              <1>     push rdi
   190                              <1>     push rsi
   191                              <1>     push rdx
   192                              <1>     push rcx
   193                              <1>     push rbx
   194                              <1>     push rax
   195                              <1> %endmacro
   196                              <1> 
   197                              <1> %macro popDOS 0
   198                              <1>     pop rax
   199                              <1>     pop rbx
   200                              <1>     pop rcx
   201                              <1>     pop rdx
   202                              <1>     pop rsi
   203                              <1>     pop rdi
   204                              <1>     pop rbp
   205                              <1>     pop r8
   206                              <1>     pop r9
   207                              <1> %endmacro
   208                              <1> 
   209                              <1> struc psp
   210 00000000 <res 2h>            <1>     .return     resb 2  ;Should always be CDh 40h
   211 00000002 <res 8h>            <1>     .startSeg   resq 1  ;Pointer to the start of the PSP
   212 0000000A <res 8h>            <1>     .oldInt42h  resq 1  ;Int 42h pointer on overlay load
   213 00000012 <res 8h>            <1>     .oldInt43h  resq 1  ;Int 43h pointer on overlay load
   214 0000001A <res 8h>            <1>     .oldInt44h  resq 1  ;Int 44h pointer on overlay load
   215 00000022 <res 8h>            <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   216 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   217 0000003E <res 8h>            <1>     .envPtr     resq 1  ;Pointer to the environment
   218 00000046 <res 8h>            <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to Int 41h
   219 0000004E <res 2h>            <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   220 00000050 <res 3h>            <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   221 00000053 <res 8h>            <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   222 0000005B <res 8h>            <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   223 00000063 <res 8h>            <1>     .fcbPtr1    resq 1  ;Pointer to the first OS allocated FCB
   224 0000006B <res 15h>           <1>     .reserved   resb 21
   225 00000080 <res 1h>            <1>     .charCount  resb 1  ;Number of characters in command tail
   226 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   227                              <1> endstruc
   228                              <1> 
   229                              <1> struc mcb
   230 00000000 <res 1h>            <1>     .mzbyte     resb 1  ;M=In use, Z=Free
   231 00000001 <res 8h>            <1>     .processPtr resq 1  ;Points to the start of the process PSP
   232 00000009 <res 4h>            <1>     .paragraphs resd 1  ;Gives the number of paras allocated to this process
   233 0000000D <res 3h>            <1>     .reserved   resb 3
   234                              <1>     .program:
   235                              <1> endstruc
     7                                  %include "dosSeg.asm"
     1                              <1> ; This file contains the DOS data segment structure
     2                              <1> 
     3                              <1> Segment dSeg nobits align=1 
     4 00000000 <res 8h>            <1>     dosSegPtr   resq 1    ;Pointer to the data Segment itself
     5 00000008 <res 1h>            <1>     bootDrive   resb 1    ;The Int 33h device we booted from
     6 00000009 <res 2Ah>           <1>     charReqHdr  resb ioReqPkt_size  ;Character IO Request header
     7 00000033 <res 2Ah>           <1>     diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
     8                              <1>     ;The device driver header with space for the largest possible packet
     9 0000005D <res 8h>            <1>     sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    10 00000065 <res 8h>            <1>     mcbChainPtr resq 1    ;Pointer to the MCB chain
    11 0000006D <res 8h>            <1>     dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    12 00000075 <res 8h>            <1>     sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    13 0000007D <res 8h>            <1>     clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    14                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
    15 00000085 <res 8h>            <1>     conPtr      resq 1    ;Pointer to the current active CON device header 
    16                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
    17 0000008D <res 2h>            <1>     maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    18 0000008F <res 8h>            <1>     bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    19 00000097 <res 8h>            <1>     cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    20 0000009F <res 8h>            <1>     sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    21 000000A7 <res 2h>            <1>     numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    22 000000A9 <res 1h>            <1>     numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    23 000000AA <res 1h>            <1>     lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    24 000000AB <res 1h>            <1>     numJoinDrv  resb 1    ;Number of Joined Drives
    25 000000AC <res 22h>           <1>     nulDevHdr   resb drvHdr_size
    26                              <1> 
    27                              <1> ;Start of Swappable Data Area, this bit can remain static
    28 000000CE <res 1h>            <1>     critErrFlag resb 1  ;Critical error flag, set on entry to INT 44h
    29 000000CF <res 1h>            <1>     inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    30 000000D0 <res 1h>            <1>     errorDrv    resb 1  ;Drive on which error occured or FFh
    31 000000D1 <res 1h>            <1>     errorLocus  resb 1  ;Where the error took place  
    32 000000D2 <res 2h>            <1>     errorExt    resw 1  ;Extended Error Code
    33 000000D4 <res 1h>            <1>     errorAction resb 1  ;Suggested action for error  
    34 000000D5 <res 1h>            <1>     errorClass  resb 1  ;Error Class
    35                              <1> 
    36 000000D6 <res 8h>            <1>     currentDTA  resq 1  ;Address of the current DTA
    37 000000DE <res 8h>            <1>     currentPSP  resq 1  ;Address of current PSP
    38 000000E6 <res 8h>            <1>     rdiErrorPtr resq 1  ;Saves RDI value of last error
    39 000000EE <res 8h>            <1>     xInt43hRSP  resq 1  ;Saves RSP across an Int 43h call
    40 000000F6 <res 2h>            <1>     lastRetCode resw 1  ;Last return code returned by Int 41h/4Ch
    41 000000F8 <res 1h>            <1>     currentDrv  resb 1  ;Default, last accessed drive
    42 000000F9 <res 1h>            <1>     breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    43                              <1> ;SDA, needs to be replaced between processes
    44 000000FA <res 8h>            <1>     xInt44hRSP  resq 1  ;RSP across an Int 44h call
    45                              <1> 
    46 00000102 <res 1h>            <1>     Int44RetVal resb 1  ;Saves a copy of the Int 44 return value
    47 00000103 <res 1h>            <1>     Int44bitfld resb 1  ;Copies the bit field given to the Int 44h handler
    48 00000104 <res 1h>            <1>     int48Flag   resb 1  ;If set, Int 48h should be called, if clear no
    49 00000105 <res 8h>            <1>     oldoldRSP   resq 1  ;RSP at prev Int 41h entry if called from within Int 41h
    50 0000010D <res 8h>            <1>     oldRSP      resq 1  ;RSP when entering Int 41h
    51 00000115 <res 8h>            <1>     oldRBX      resq 1  ;Temp var to save value of rbx during an Int 41 call
    52                              <1> ;Time stuff
    53 0000011D <res 6h>            <1>     CLOCKrecrd  resb 6  ;Clock driver record
    54 00000123 <res 1h>            <1>     dayOfMonth  resb 1  ;1 - 31 BCD
    55 00000124 <res 1h>            <1>     monthOfYear resb 1  ;1 - 12 BCD
    56 00000125 <res 2h>            <1>     years       resw 1  ;0000 - 9999 BCD
    57 00000127 <res 2h>            <1>     yearsOffset resw 1  ;Current Year - 1980
    58 00000129 <res 4h>            <1>     daysOffset  resd 1  ;Days since 1-1-1980
    59 0000012D <res 1h>            <1>     dayOfWeek   resb 1  ;0 = Sunday <-> 6 = Saturday
    60                              <1> 
    61                              <1> ;Stacks
    62 0000012E <res 528h>          <1>     critStack   resq 165
    63 00000656 <res 8h>            <1>     critStakTop resq 1
    64 0000065E <res 638h>          <1>     IOStack     resq 199
    65 00000C96 <res 8h>            <1>     IOStakTop   resq 1
    66 00000C9E <res 638h>          <1>     DiskStack   resq 199
    67 000012D6 <res 8h>            <1>     DiskStakTop resq 1
    68                              <1>     dSegLen     equ     $
     8                                  
     9                                  Segment .text align=1
    10                                  ; We arrive here with the following values in the registers.
    11                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    12                                  ; dx  = Int 33h boot device number
    13                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    14                                  tempPSP:    ;Here to allow the loader to use Int 41h once it is loaded high
    15 00000000 55AA                        dw 0AA55h           ;Initial signature
    16 00000002 000000000000000000-         db (100h-2) dup (0)
    16 0000000B 000000000000000000-
    16 00000014 000000000000000000-
    16 0000001D 000000000000000000-
    16 00000026 000000000000000000-
    16 0000002F 000000000000000000-
    16 00000038 000000000000000000-
    16 00000041 000000000000000000-
    16 0000004A 000000000000000000-
    16 00000053 000000000000000000-
    16 0000005C 000000000000000000-
    16 00000065 000000000000000000-
    16 0000006E 000000000000000000-
    16 00000077 000000000000000000-
    16 00000080 000000000000000000-
    16 00000089 000000000000000000-
    16 00000092 000000000000000000-
    16 0000009B 000000000000000000-
    16 000000A4 000000000000000000-
    16 000000AD 000000000000000000-
    16 000000B6 000000000000000000-
    16 000000BF 000000000000000000-
    16 000000C8 000000000000000000-
    16 000000D1 000000000000000000-
    16 000000DA 000000000000000000-
    16 000000E3 000000000000000000-
    16 000000EC 000000000000000000-
    16 000000F5 000000000000000000-
    16 000000FE 0000               
    17 00000100 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    18 00000108 488D15F1FEFFFF              lea rdx, qword [tempPSP]    ;Get the address of the tempPSP
    19 0000010F 6448891425-                 mov qword fs:[currentPSP], rdx
    19 00000114 [DE000000]         
    20                                  ;DOS allows for non-PARA aligned PSPs but DOS aligns all programs on PARA bndry
    21 00000118 B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    22 0000011D 0F32                        rdmsr
    23 0000011F 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    24 00000121 48C1E720                    shl rdi, 20h        ;Shift high
    25 00000125 89C7                        mov edi, eax        ;Get the low dword in
    26                                  
    27 00000127 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    27 0000012C [00000000]         
    28 00000130 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    29 00000133 4881C7[DE120000]            add rdi, dSegLen ;Move destination past end of data area
    30 0000013A 488D3425[00000000]          lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    31 00000142 B900100000                  mov ecx, 1000h
    32 00000147 F348A5                      rep movsq
    33                                  
    34                                  ;Modify the pointers in nData before putting them in the data area
    35 0000014A 48012D73010000              add qword [nData + drvHdr.nxtPtr], rbp
    36 00000151 48012D76010000              add qword [nData + drvHdr.strPtr], rbp
    37 00000158 48012D77010000              add qword [nData + drvHdr.intPtr], rbp
    38                                  ;Copy the Null driver to its location in Sysvars
    39 0000015F B922000000                  mov ecx, drvHdr_size
    40 00000164 488D3559010000              lea rsi, qword [nData]
    41 0000016B 488DBD[AC000000]            lea rdi, qword [rbp + nulDevHdr]
    42 00000172 F3A4                        rep movsb   
    43                                  
    44                                  ;Adjust the addresses in the other driver headers 
    45 00000174 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    45 00000176 [B307000000000000] 
    46 0000017E B90C000000                  mov ecx, 12      ;12 drivers in data area
    47 00000183 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    48                                  adjDrivers:
    49 00000187 E8BD000000                  call adjustDrvHdr
    50 0000018C E2F9                        loop adjDrivers
    51                                  
    52                                      ;Open NUL
    53 0000018E 488D9D[B6000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    54 00000195 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    55 00000198 30C0                        xor al, al
    56 0000019A FFD3                        call rbx
    57                                  
    58                                      ;Open CON
    59 0000019C 48BB-                       mov rbx, conDriver
    59 0000019E [6209000000000000] 
    60 000001A6 488D5C1D00                  lea rbx, qword [rbp+rbx]
    61 000001AB 30C0                        xor al, al
    62 000001AD FFD3                        call rbx
    63                                  
    64                                      ;Open Mass Storage
    65 000001AF 48BB-                       mov rbx, msdDriver
    65 000001B1 [C80A000000000000] 
    66 000001B9 488D5C1D00                  lea rbx, qword [rbp+rbx]
    67 000001BE 30C0                        xor al, al
    68 000001C0 FFD3                        call rbx
    69                                  ;Adjust Int 41h address table
    70                                  
    71                                  adjInt41h:
    72 000001C2 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
    73 000001C7 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
    73 000001C9 [9801000000000000] 
    74 000001D1 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
    75                                  .ai41h:
    76 000001D6 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
    77 000001D9 4881C308000000              add rbx, 8              ;Each entry is size 8
    78 000001E0 FFC9                        dec ecx
    79 000001E2 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
    80                                  
    81                                  ;Adjust Interrupt Entries Int 40h-49h
    82                                  adjInts:
    83 000001E4 B340                        mov bl, 40h
    84 000001E6 B807F00000                  mov eax, 0F007h ;Get the descriptor
    85 000001EB CD35                        int 35h
    86 000001ED B940000000                  mov ecx, 40h    ;Start from interrupt 40h
    87 000001F2 488D3C25[74020000]          lea rdi, intData
    88 000001FA 89C6                        mov esi, eax    ;Move segment selector info to esi
    89                                  .ai0:
    90 000001FC B808F00000                  mov eax, 0F008h ;Set the descriptor
    91 00000201 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
    92 00000204 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
    93 00000207 CD35                        int 35h
    94 00000209 4881C708000000              add rdi, 8
    95 00000210 FFC1                        inc ecx
    96 00000212 81F94A000000                cmp ecx, 4Ah
    97 00000218 75E2                        jne .ai0
    98                                  
    99                                  ;Test Error Case
   100 0000021A B430                        mov ah, 00110000b
   101 0000021C B000                        mov al, 00h
   102 0000021E BF0C000000                  mov edi, 0Ch
   103 00000223 CD44                        int 44h
   104                                  
   105                                  
   106 00000225 488D1530000000              lea rdx, qword [startmsg]   ;Get the absolute address of message
   107 0000022C B409                        mov ah, 09h
   108 0000022E CD41                        int 41h
   109                                  
   110 00000230 64488B3425-                 mov rsi, fs:[nulDevHdr]
   110 00000235 [AC000000]         
   111 00000239 B801C50000                  mov eax, 0C501h ;Connect debugger
   112 0000023E CD35                        int 35h
   113 00000240 6687DB                      xchg bx, bx
   114                                  l1:
   115 00000243 B401                        mov ah, 01h  ;Write with echo
   116 00000245 CD41                        int 41h
   117 00000247 EBFA                        jmp short l1
   118                                  adjustDrvHdr:
   119                                  ;Input: rsi = Effective address of driver in DOS segment
   120                                  ;       rbp = Ptr to the start of the DOS segment
   121                                  ;Output: rsi = EA of next header in DOS segment
   122 00000249 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   123 0000024C 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   124 00000250 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   125 00000254 4881C622000000              add rsi, drvHdr_size
   126 0000025B C3                          ret
   127                                  
   128 0000025C 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,"$"
   128 00000265 67205343502F444F53-
   128 0000026E 2E2E2E0A0D24       
   129                                  intData:
   130 00000274 [5900000000000000]          dq terminateProcess ;Int 40h
   131 0000027C [5900000000000000]          dq functionDispatch ;Int 41h
   132 00000284 [E804000000000000]          dq terminateHandler ;Int 42h
   133 0000028C [E804000000000000]          dq ctrlCHandler     ;Int 43h
   134 00000294 [E804000000000000]          dq critErrorHandler ;Int 44h
   135 0000029C [7B07000000000000]          dq absDiskRead      ;Int 45h
   136 000002A4 [9007000000000000]          dq absDiskWrite     ;Int 46h
   137 000002AC [A507000000000000]          dq terminateResident    ;Int 47h
   138 000002B4 [A507000000000000]          dq inDosHandler     ;Int 48h
   139 000002BC [A707000000000000]          dq fastOutput       ;Int 49h
   140                                  nData:
   141 000002C4 [B307000000000000]          dq conHdr
   142 000002CC 0480                        dw 08004h
   143 000002CE [5B09000000000000]          dq nulStrat
   144 000002D6 [6109000000000000]          dq nulIntr
   145 000002DE 4E554C2020202020            db "NUL     " ;Default NUL data
   146                                  
   147                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   148                                  ;-----------------------------------:
   149                                  ;       Misc System routines        :
   150                                  ;-----------------------------------:
   151                                  findLRUBuffer: 
   152                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   153                                  ;Input: Nothing
   154                                  ;Output: rbx = Pointer to the buffer to use
   155 00000000 52                          push rdx
   156 00000001 488B1D(8F000000)            mov rbx, qword [bufHeadPtr]
   157 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   158 0000000F 7502                        jne .flb1
   159 00000011 5A                          pop rdx
   160 00000012 C3                          ret
   161                                  .flb1:
   162 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   163 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   164 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   165 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   166 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   167 00000029 488B15(8F000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   168 00000030 48891D(8F000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   169 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   170 0000003A 5A                          pop rdx
   171 0000003B C3                          ret
   172                                  
   173                                  findDPB:
   174                                  ;Finds the DPB for a given drive
   175                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   176                                  ;Output: al = 00, rbx = Pointer to the DPB
   177                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   178 0000003C 488B1D(6D000000)            mov rbx, qword [dpbHeadPtr]
   179                                  .fd1:
   180 00000043 30C0                        xor al, al
   181 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   182 00000047 740F                        je .fd2
   183 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   184 0000004D B0FF                        mov al, -1
   185 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   186 00000056 75EB                        jne .fd1
   187                                  .fd2:
   188 00000058 C3                          ret
   189                                  callCritError:
   190                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   191                                  ;-----------------------------------:
   192                                  ;       File System routines        :
   193                                  ;-----------------------------------:
   194                                  name2Clust:
   195                                  ;Converts a file name to a first cluster number
   196                                  ;-----------------------------------:
   197                                  ;        Interrupt routines         :
   198                                  ;-----------------------------------:
   199                                  terminateProcess:   ;Int 40h
   200                                  
   201                                  functionDispatch:   ;Int 41h Main function dispatcher
   202                                  ;ah = Function number, all other registers have various meanings
   203 00000059 FA                          cli ;Halt external interrupts
   204 0000005A FC                          cld ;Ensure all string ops occur in the right direction
   205 0000005B 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   206 0000005E 0F870D010000                ja .fdExitBad
   207                                      ;Cherry pick functions
   208 00000064 80FC33                      cmp ah, 33h ;CTRL+BREAK check
   209 00000067 722C                        jb .fdInInt41   ;If below skip these checks
   210 00000069 0F8428010000                je .ctrlBreakCheck
   211 0000006F 80FC64                      cmp ah, 64h
   212 00000072 0F841F010000                je .setDriverLookahead  ;Reserved, but avoids usual Int 41h spiel
   213 00000078 771B                        ja .fdInInt41   ;If above, do usual Int41 entry
   214 0000007A 80FC51                      cmp ah, 51h
   215 0000007D 0F8414010000                je .getCurrProcessID    ;This an below are exactly the same
   216 00000083 80FC62                      cmp ah, 62h
   217 00000086 0F840B010000                je .getPSPaddr          ;Calls the above function
   218 0000008C 80FC50                      cmp ah, 50h
   219 0000008F 0F8402010000                je .setCurrProcessID
   220                                  .fdInInt41:
   221                                      pushDOS ;Push the usual prologue registers
   186 00000095 4151                <1>  push r9
   187 00000097 4150                <1>  push r8
   188 00000099 55                  <1>  push rbp
   189 0000009A 57                  <1>  push rdi
   190 0000009B 56                  <1>  push rsi
   191 0000009C 52                  <1>  push rdx
   192 0000009D 51                  <1>  push rcx
   193 0000009E 53                  <1>  push rbx
   194 0000009F 50                  <1>  push rax
   222 000000A0 488B05(0D010000)            mov rax, qword [oldRSP]
   223 000000A7 488905(05010000)            mov qword [oldoldRSP], rax
   224 000000AE FE05(CF000000)              inc byte [inDOS]    ;Increment in DOS flag
   225 000000B4 488925(0D010000)            mov qword [oldRSP], rsp
   226 000000BB 58                          pop rax     ;Get old rax back
   227 000000BC 50                          push rax    ;and push it back onto the stack
   228                                      ;Here, we want to save oldRSP in the callers PSP
   229 000000BD 488D2425[56060000]          lea rsp, critStakTop
   230 000000C5 FB                          sti         ;Reenable interrupts
   231                                  
   232 000000C6 C605(04010000)01            mov byte [int48Flag], 1 ;Make it ok to trigger Int 48h
   233                                  
   234 000000CD 48891D(15010000)            mov qword [oldRBX], rbx ;Need to do this as I might switch stacks later
   235 000000D4 0FB6DC                      movzx ebx, ah   ;Move the function number bl zero extended to rbx
   236 000000D7 C1E303                      shl ebx, 3      ;Multiply the function number by 8 for offset into table
   237 000000DA 50                          push rax        ;Push rax onto the stack
   238 000000DB 488D05B6000000              lea rax, qword [.dispatchTable]
   239 000000E2 4801C3                      add rbx, rax    ;Add dispatch table offset into rbx
   240 000000E5 58                          pop rax
   241 000000E6 488B1B                      mov rbx, qword [rbx]    ;Get the address from the dispatch table
   242                                  
   243 000000E9 84E4                        test ah, ah     ;Simple Terminate function?
   244 000000EB 741D                        jz .fddiskOp
   245 000000ED 80FC59                      cmp ah, 59h     ;Extended Error report?
   246 000000F0 7445                        je .fdGoToFunction  ;Bypass code that clears the error report
   247 000000F2 80FC0C                      cmp ah, 0Ch     ;Are we a char function?
   248 000000F5 7713                        ja .fddiskOp
   249                                  ;Char operations here
   250 000000F7 F605(CE000000)01            test byte [critErrFlag], 1  ;Are we in critical error?
   251 000000FE 7537                        jnz .fdGoToFunction         ;If we are, stay on Critical Error Stack
   252 00000100 488D2425[960C0000]          lea rsp, IOStakTop          ;Otherwise, switch to IO stack
   253 00000108 EB2D                        jmp short .fdGoToFunction
   254                                  .fddiskOp:
   255                                      ;Disk operations go here
   256                                      ;Clear up error info
   257 0000010A C605(D1000000)01            mov byte [errorLocus], 1    ;Reset to generic, unknown locus
   258 00000111 C605(CE000000)00            mov byte [critErrFlag], 0   ;Clear the Critical Error Flag
   259 00000118 C605(D0000000)FF            mov byte [errorDrv], -1     ;Set the drive which caused the error to none
   260                                  
   261 0000011F C605(04010000)00            mov byte [int48Flag], 0     ;Turn off the ability to trigger Int 48h
   262 00000126 488D2425[D6120000]          lea rsp, DiskStakTop        ;Swap the stack to the Disk Transfer Stack
   263 0000012E F605(F9000000)FF            test byte [breakFlag], -1   ;Test if set
   264 00000135 7400                        jz .fdGoToFunction
   265                                  ; HANDLE CTRL+BREAK HERE!
   266                                  .fdGoToFunction:
   267 00000137 48871D(15010000)            xchg rbx, qword [oldRBX]    ;Put the call addr in oldRBX and get oldRBX back
   268                                      ;Potentially point rbp to caller reg frame for easy access of registers 
   269                                      ;mov rbp, qword [oldRSP]    ;Move rsp on entry into rbp
   270 0000013E FF15(15010000)              call qword [oldRBX]     ;Call the desired function, rax contains ret code
   271                                  .fdExit:
   272 00000144 FA                          cli     ;Redisable interrupts
   273                                      ;???
   274 00000145 FE0D(CF000000)              dec byte [inDOS]            ;Decrement the inDOS count
   275 0000014B 488B25(0D010000)            mov rsp, qword [oldRSP]     ;Point rsp to old stack
   276 00000152 48890424                    mov qword [rsp], rax    ;Put the ret code into its pos on the register frame
   277 00000156 488B05(05010000)            mov rax, qword [oldoldRSP]
   278 0000015D 488905(0D010000)            mov qword [oldRSP], rax
   279                                      popDOS  ;Pop the frame
   198 00000164 58                  <1>  pop rax
   199 00000165 5B                  <1>  pop rbx
   200 00000166 59                  <1>  pop rcx
   201 00000167 5A                  <1>  pop rdx
   202 00000168 5E                  <1>  pop rsi
   203 00000169 5F                  <1>  pop rdi
   204 0000016A 5D                  <1>  pop rbp
   205 0000016B 4158                <1>  pop r8
   206 0000016D 4159                <1>  pop r9
   280 0000016F 48CF                        iretq
   281                                  .fdExitBad:
   282 00000171 B400                        mov ah, 0
   283 00000173 48CF                        iretq
   284                                  .simpleTerminate:     ;ah = 00h
   285 00000175 C3                          ret
   286                                  .stdinReadEcho:     ;ah = 01h
   287 00000176 30E4                        xor ah, ah
   288 00000178 CD36                        int 36h
   289 0000017A CD49                        int 49h ;Pass al to fast output
   290 0000017C C3                          ret
   291                                  .stdoutWrite:       ;ah = 02h
   292                                  ;Bspace is regular cursor left, does not insert a blank
   293 0000017D 50                          push rax
   294 0000017E 88D0                        mov al, dl
   295 00000180 CD49                        int 49h
   296 00000182 58                          pop rax
   297 00000183 C3                          ret
   298                                  .stdauxRead:        ;ah = 03h
   299                                  .stdauxWrite:       ;ah = 04h
   300                                  .stdprnWrite:       ;ah = 05h
   301                                  .directCONIO:       ;ah = 06h
   302                                  .waitDirectInNoEcho:;ah = 07h
   303                                  .waitStdinNoEcho:   ;ah = 08h
   304 00000184 C3                          ret
   305                                  .printString:       ;ah = 09h
   306 00000185 50                          push rax
   307 00000186 52                          push rdx
   308                                  .ps0:
   309 00000187 8A02                        mov al, byte [rdx]
   310 00000189 3C24                        cmp al, "$"
   311 0000018B 7407                        je .ps1
   312 0000018D 48FFC2                      inc rdx ;Goto next char
   313 00000190 CD49                        int 49h ;Print char in al
   314 00000192 EBF3                        jmp short .ps0
   315                                  .ps1:
   316 00000194 5A                          pop rdx
   317 00000195 58                          pop rax
   318 00000196 C3                          ret
   319                                  .buffStdinInput:    ;ah = 0Ah
   320                                  .checkStdinStatus:  ;ah = 0Bh
   321                                  .clearbuffDoFunc:   ;ah = 0Ch
   322                                  .diskReset:         ;ah = 0Dh
   323                                  .selectDisk:        ;ah = 0Eh
   324                                  .openFileFCB:       ;ah = 0Fh
   325                                  .closeFileFCB:      ;ah = 10h
   326                                  .findFirstFileFCB:  ;ah = 11h
   327                                  .findNextFileFCB:   ;ah = 12h
   328                                  .deleteFileFCB:     ;ah = 13h
   329                                  .sequentialReadFCB: ;ah = 14h
   330                                  .sequentialWriteFCB:;ah = 15h
   331                                  .createFileFCB:     ;ah = 16h
   332                                  .renameFileFCB:     ;ah = 17h
   333                                                      ;ah = 18h unused
   334                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   335                                  .setDTA:            ;ah = 1Ah
   336                                  .FATinfoDefault:    ;ah = 1Bh
   337                                  .FatinfoDevice:     ;ah = 1Ch
   338                                                      ;ah = 1Dh unused
   339                                                      ;ah = 1Eh unused
   340                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   341                                                      ;ah = 20h unused
   342                                  .randomReadFCB:     ;ah = 21h
   343                                  .randomWriteFCB:    ;ah = 22h
   344                                  .getFileSizeFCB:    ;ah = 23h
   345                                  .setRelRecordFCB:   ;ah = 24h
   346                                  .setIntVector:      ;ah = 25h
   347                                  .createNewPSP:      ;ah = 26h
   348                                  .randBlockReadFCB:  ;ah = 27h
   349                                  .randBlockWriteFCB: ;ah = 28h
   350                                  .parseFilenameFCB:  ;ah = 29h
   351                                  .getDate:           ;ah = 2Ah
   352                                  .setDate:           ;ah = 2Bh
   353                                  .getTime:           ;ah = 2Ch
   354                                  .setTime:           ;ah = 2Dh
   355                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   356                                  .getDTA:            ;ah = 2Fh
   357                                  .getDOSversion:     ;ah = 30h
   358                                  .terminateStayRes:  ;ah = 31h
   359                                  .getDeviceDPBptr:   ;ah = 32h
   360                                  .ctrlBreakCheck:    ;ah = 33h
   361                                  .getInDOSflagPtr:   ;ah = 34h
   362                                  .getIntVector:      ;ah = 35h
   363                                  .getDiskFreeSpace:  ;ah = 36h
   364                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   365                                  .getsetCountryInfo: ;ah = 38h, localisation info
   366                                  .makeDIR:           ;ah = 39h
   367                                  .removeDIR:         ;ah = 3Ah
   368                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   369                                  .createFileHdl:     ;ah = 3Ch, handle function
   370                                  .openFileHdl:       ;ah = 3Dh, handle function
   371                                  .closeFileHdl:      ;ah = 3Eh, handle function
   372                                  .readFileHdl:       ;ah = 3Fh, handle function
   373                                  .writeFileHdl:      ;ah = 40h, handle function
   374                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   375                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   376                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   377                                  .ioctrl:            ;ah = 44h, handle function
   378                                  .duplicateHandle:   ;ah = 45h, handle function
   379                                  .forceDuplicateHdl: ;ah = 46h, handle function
   380                                  .getCurrentDIR:     ;ah = 47h
   381                                  .allocateMemory:    ;ah = 48h
   382                                  .freeMemory:        ;ah = 49h
   383                                  .reallocMemory:     ;ah = 4Ah
   384                                  .loadExecChild:     ;ah = 4Bh, EXEC
   385                                  .terminateClean:    ;ah = 4Ch, EXIT
   386                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   387                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   388                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   389                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   390                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   391                                  .getSysVarsPtr:     ;ah = 52h
   392                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   393                                  .getVerifySetting:  ;ah = 54h
   394                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   395                                  .renameFile:        ;ah = 56h
   396                                  .getSetFileDateTime:;ah = 57h
   397                                  .getsetMallocStrat: ;ah = 58h
   398                                  .getExtendedError:  ;ah = 59h
   399                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   400                                  .createNewFile:     ;ah = 5Bh
   401                                  .lockUnlockFile:    ;ah = 5Ch
   402                                  .getCritErrorInfo:  ;ah = 5Dh
   403                                  .networkServices:   ;ah = 5Eh, do nothing
   404                                  .networkRedirection:;ah = 5Fh, do nothing
   405                                  .trueName:          ;ah = 60h, get fully qualified name
   406                                                      ;ah = 61h, reserved
   407                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   408                                                      ;ah = 63h, reserved
   409                                  .setDriverLookahead:;ah = 64h, reserved
   410                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   411                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   412                                  .setHandleCount:    ;ah = 67h
   413                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   414                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   415                                  .return:
   416 00000197 C3                          ret
   417                                  
   418                                  
   419                                  .dispatchTable:
   420 00000198 [7501000000000000]          dq .simpleTerminate     ;AH = 00H, PROCESS MANAGEMENT
   421 000001A0 [7601000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   422 000001A8 [7D01000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   423 000001B0 [8401000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   424 000001B8 [8401000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   425 000001C0 [8401000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   426 000001C8 [8401000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   427 000001D0 [8401000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   428 000001D8 [8401000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   429 000001E0 [8501000000000000]          dq .printString         ;AH = 09H, CHAR IO
   430 000001E8 [9701000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   431 000001F0 [9701000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   432 000001F8 [9701000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   433 00000200 [9701000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   434 00000208 [9701000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   435 00000210 [9701000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   436 00000218 [9701000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   437 00000220 [9701000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   438 00000228 [9701000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   439 00000230 [9701000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   440 00000238 [9701000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   441 00000240 [9701000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   442 00000248 [9701000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   443 00000250 [9701000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   444 00000258 [9701000000000000]          dq .return              ;AH = 18H, RESERVED
   445 00000260 [9701000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   446 00000268 [9701000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   447 00000270 [9701000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   448 00000278 [9701000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   449 00000280 [9701000000000000]          dq .return              ;AH = 1DH, RESERVED
   450 00000288 [9701000000000000]          dq .return              ;AH = 1EH, RESERVED
   451 00000290 [9701000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   452 00000298 [9701000000000000]          dq .return              ;AH = 20H, RESERVED
   453 000002A0 [9701000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   454 000002A8 [9701000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   455 000002B0 [9701000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   456 000002B8 [9701000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   457 000002C0 [9701000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   458 000002C8 [9701000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   459 000002D0 [9701000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   460 000002D8 [9701000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   461 000002E0 [9701000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   462 000002E8 [9701000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   463 000002F0 [9701000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   464 000002F8 [9701000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   465 00000300 [9701000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   466 00000308 [9701000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   467 00000310 [9701000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   468 00000318 [9701000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   469 00000320 [9701000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   470 00000328 [9701000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   471 00000330 [9701000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   472 00000338 [9701000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   473 00000340 [9701000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   474 00000348 [9701000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   475 00000350 [9701000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   476 00000358 [9701000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   477 00000360 [9701000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   478 00000368 [9701000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   479 00000370 [9701000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   480 00000378 [9701000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   481 00000380 [9701000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   482 00000388 [9701000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   483 00000390 [9701000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   484 00000398 [9701000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   485 000003A0 [9701000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   486 000003A8 [9701000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   487 000003B0 [9701000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   488 000003B8 [9701000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   489 000003C0 [9701000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   490 000003C8 [9701000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   491 000003D0 [9701000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   492 000003D8 [9701000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   493 000003E0 [9701000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   494 000003E8 [9701000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   495 000003F0 [9701000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   496 000003F8 [9701000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   497 00000400 [9701000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   498 00000408 [9701000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   499 00000410 [9701000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   500 00000418 [9701000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   501 00000420 [9701000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   502 00000428 [9701000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   503 00000430 [9701000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   504 00000438 [9701000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   505 00000440 [9701000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   506 00000448 [9701000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   507 00000450 [9701000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   508 00000458 [9701000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   509 00000460 [9701000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   510 00000468 [9701000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   511 00000470 [9701000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   512 00000478 [9701000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   513 00000480 [9701000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   514 00000488 [9701000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   515 00000490 [9701000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   516 00000498 [9701000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   517 000004A0 [9701000000000000]          dq .return              ;AH = 61H, RESERVED
   518 000004A8 [9701000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   519 000004B0 [9701000000000000]          dq .return              ;AH = 63H, RESERVED
   520 000004B8 [9701000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   521 000004C0 [9701000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   522 000004C8 [9701000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   523 000004D0 [9701000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   524 000004D8 [9701000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   525 000004E0 [9701000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   526                                  dispatchTableL  equ $ - .dispatchTable 
   527                                  
   528                                  terminateHandler:   ;Int 42h
   529                                  ctrlCHandler:       ;Int 43h
   530                                  critErrorHandler:   ;Int 44h
   531                                  ;User Stack in usage here, must be swapped to before this is called
   532                                  ;Entered with:  
   533                                  ;               AH = Critical Error Bitfield
   534                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   535                                  ;               Bit 6 - Reserved
   536                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   537                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   538                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   539                                  ;               Bits [2-1] = Affected Disk Error
   540                                  ;                     0 0   DOS area
   541                                  ;                     0 1   FAT area
   542                                  ;                     1 0   Directory area
   543                                  ;                     1 1   Data area
   544                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   545                                  ;               AL  = Failing drive number if AH[7] = 0
   546                                  ;               DIL = Error code for errorMsg
   547                                  ;               RSI = EA of Device Header for which device the error occured
   548                                  ;Return:
   549                                  ;               AL = 0 - Ignore the Error       (Ignore)
   550                                  ;                  = 1 - Retry the Operation    (Retry)
   551                                  ;                  = 2 - Terminate the Program  (Abort)
   552                                  ;                  = 3 - Fail the DOS call      (Fail)
   553 000004E8 53                          push rbx
   554 000004E9 51                          push rcx
   555 000004EA 52                          push rdx
   556 000004EB 57                          push rdi
   557 000004EC 56                          push rsi
   558 000004ED FC                          cld         ;Make String ops go forward
   559                                  
   560 000004EE 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   561 000004F1 488D155E020000              lea rdx, qword [.crlf]
   562 000004F8 B409                        mov ah, 09h ;Print String
   563 000004FA CD41                        int 41h     ;Call DOS to print CRLF part of message
   564                                  
   565 000004FC 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   566 00000502 B90C000000                  mov ecx, 0Ch
   567 00000507 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   568 00000509 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   569 0000050C 480FB7FF                    movzx rdi, di
   570 00000510 4889FA                      mov rdx, rdi    ;Copy error code
   571 00000513 48C1E704                    shl rdi, 4  ;Multiply by 16
   572 00000517 48D1E2                      shl rdx, 1  ;Multiply by 2
   573 0000051A 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   574 0000051D 488D1523010000              lea rdx, qword [.errorMsgTable]
   575 00000524 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   576 00000528 B409                        mov ah, 09h ;Print String
   577 0000052A CD41                        int 41h     ;Call DOS to print first part of message
   578                                  
   579 0000052C 488D1505020000              lea rdx, qword [.readmsg]
   580 00000533 488D3D0D020000              lea rdi, qword [.writemsg]
   581 0000053A F6C701                      test bh, 1  ;Bit 0 is set if write operation
   582 0000053D 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   583 00000541 B409                        mov ah, 09h ;Print String
   584 00000543 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   585                                  
   586 00000545 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   587 00000548 0F85DF000000                jnz .charError
   588                                  ;Disk error continues here
   589 0000054E 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   590 00000555 B409                        mov ah, 09h
   591 00000557 CD41                        int 41h
   592 00000559 88DA                        mov dl, bl  ;Get zero based drive number into dl
   593 0000055B 80C241                      add dl, "A" ;Add ASCII code
   594 0000055E B402                        mov ah, 02h ;Print char in dl
   595 00000560 CD41                        int 41h
   596                                  .userInput:
   597 00000562 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   598 00000569 B409                        mov ah, 09h
   599 0000056B CD41                        int 41h
   600                                  ;Abort, Retry, Ignore, Fail is word order
   601                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   602                                  .userAbort:
   603                                  ;Abort is always an option
   604 0000056D 488D15E5010000              lea rdx, qword [.abortmsg]
   605 00000574 B409                        mov ah, 09h
   606 00000576 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   607                                  .userRetry:
   608 00000578 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   609 0000057B 7416                        jz .userIgnore    ;If clear, dont print message
   610 0000057D 488D15ED010000              lea rdx, qword [.betweenMsg]
   611 00000584 B409                        mov ah, 09h
   612 00000586 CD41                        int 41h
   613 00000588 488D15D7010000              lea rdx, qword [.retrymsg]
   614 0000058F B409                        mov ah, 09h
   615 00000591 CD41                        int 41h
   616                                  .userIgnore:
   617 00000593 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   618 00000596 7416                        jz .userFail
   619 00000598 488D15D2010000              lea rdx, qword [.betweenMsg]
   620 0000059F B409                        mov ah, 09h
   621 000005A1 CD41                        int 41h
   622 000005A3 488D15B5010000              lea rdx, qword [.ignoremsg]
   623 000005AA B409                        mov ah, 09h
   624 000005AC CD41                        int 41h
   625                                  .userFail:
   626 000005AE F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   627 000005B1 7416                        jz .userMsgEnd
   628 000005B3 488D15B7010000              lea rdx, qword [.betweenMsg]
   629 000005BA B409                        mov ah, 09h
   630 000005BC CD41                        int 41h
   631 000005BE 488D15A7010000              lea rdx, qword [.failmsg]
   632 000005C5 B409                        mov ah, 09h
   633 000005C7 CD41                        int 41h
   634                                  .userMsgEnd:
   635 000005C9 488D15A4010000              lea rdx, qword [.endMsg]
   636 000005D0 B409                        mov ah, 09h
   637 000005D2 CD41                        int 41h
   638                                  ;Get user input now 
   639 000005D4 31C9                        xor ecx, ecx  ;4 Possible Responses
   640 000005D6 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   641 000005DD B401                        mov ah, 01h ;STDIN without Console Echo
   642 000005DF CD41                        int 41h ;Get char in al
   643 000005E1 3C61                        cmp al, "a" ;Chack if lowercase
   644 000005E3 7202                        jb .uip1    ;If the value is below, ignore subtraction
   645 000005E5 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   646                                  .uip1:
   647 000005E7 AE                          scasb   ;Compare char to list, offset gives return code
   648 000005E8 740F                        je .validInput  ;If they are equal, ecx has return code
   649 000005EA FFC1                        inc ecx
   650 000005EC 81F904000000                cmp ecx, 4
   651 000005F2 75F3                        jne .uip1
   652 000005F4 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   653                                  .validInput:
   654 000005F9 88C8                        mov al, cl  ;Move the offset into .responses into al
   655                                  ;Now check if the input is permitted
   656 000005FB 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   657 000005FD 7427                        je .cehExit
   658 000005FF 84C0                        test al, al ;Check if 0 => Ignore
   659 00000601 740F                        je .viIgnore
   660 00000603 3C01                        cmp al, 1   ;Check if 1 => Retry
   661 00000605 7416                        je .viRetry
   662                                  .viFail:    ;Fallthrough for fail (al = 3)
   663 00000607 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   664 0000060A 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   665 00000610 EB14                        jmp short .cehExit
   666                                  .viIgnore:
   667 00000612 F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   668 00000615 0F8447FFFFFF                jz .userInput
   669 0000061B EB09                        jmp short .cehExit
   670                                  .viRetry:
   671 0000061D F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   672 00000620 0F843CFFFFFF                jz .userInput
   673                                  .cehExit:
   674 00000626 5E                          pop rsi
   675 00000627 5F                          pop rdi
   676 00000628 5A                          pop rdx
   677 00000629 59                          pop rcx
   678 0000062A 5B                          pop rbx
   679 0000062B 48CF                        iretq
   680                                  .charError:
   681 0000062D B908000000                  mov ecx, 8  ;8 chars in device name
   682 00000632 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   683                                  .ce1:
   684 00000639 AC                          lodsb   ;Get a string char into al and inc rsi
   685 0000063A 88C2                        mov dl, al  ;Move char into dl
   686 0000063C B402                        mov ah, 02h
   687 0000063E CD41                        int 41h ;Print char
   688 00000640 E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   689 00000642 E91BFFFFFF                  jmp .userInput
   690                                  
   691                                  .errorMsgTable: ;Each table entry is 18 chars long
   692 00000647 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   692 00000650 746563742024202020 
   693 00000659 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   693 00000662 6E6974202420202020 
   694 0000066B 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   694 00000674 202420202020202020 
   695 0000067D 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   695 00000686 6F6D6D616E64202420 
   696 0000068F 446174612024202020-                 db "Data $            "       ;Error 4
   696 00000698 202020202020202020 
   697 000006A1 426164205265717565-                 db "Bad Request $     "       ;Error 5
   697 000006AA 737420242020202020 
   698 000006B3 5365656B2024202020-                 db "Seek $            "       ;Error 6
   698 000006BC 202020202020202020 
   699 000006C5 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   699 000006CE 656469612024202020 
   700 000006D7 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   700 000006E0 7420466F756E642024 
   701 000006E9 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   701 000006F2 706572202420202020 
   702 000006FB 577269746520466175-                 db "Write Fault $     "       ;Error A
   702 00000704 6C7420242020202020 
   703 0000070D 52656164204661756C-                 db "Read Fault $      "       ;Error B
   703 00000716 742024202020202020 
   704 0000071F 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   704 00000728 61696C757265202420 
   705                                  
   706 00000731 64726976652024          .drive      db "drive $"
   707 00000738 6572726F7220726561-     .readmsg    db "error reading $"
   707 00000741 64696E672024       
   708 00000747 6572726F7220777269-     .writemsg   db "error writing $"
   708 00000750 74696E672024       
   709 00000756 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   710 00000759 41626F727424            .abortmsg   db "Abort$" 
   711 0000075F 49676E6F726524          .ignoremsg  db "Ignore$"
   712 00000766 526574727924            .retrymsg   db "Retry$"
   713 0000076C 4661696C24              .failmsg    db "Fail$"
   714 00000771 2C2024                  .betweenMsg db ", $"
   715 00000774 3F2024                  .endMsg     db "? $"
   716 00000777 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   717                                  absDiskRead:        ;Int 45h
   718                                  ;al = Drive number
   719                                  ;rbx = Memory Buffer address
   720                                  ;ecx = Number of sectors to read (max 255 for now)
   721                                  ;rdx = Start LBA to read from
   722 0000077B 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   723 0000077F 8A80[3D0D0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   724 00000785 4891                        xchg rax, rcx
   725 00000787 4887CA                      xchg rcx, rdx
   726 0000078A B482                        mov ah, 82h
   727 0000078C CD33                        int 33h
   728 0000078E 48CF                        iretq
   729                                  absDiskWrite:       ;Int 46h
   730 00000790 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   731 00000794 8A80[3D0D0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   732 0000079A 4891                        xchg rax, rcx
   733 0000079C 4887CA                      xchg rcx, rdx
   734 0000079F B483                        mov ah, 83h
   735 000007A1 CD33                        int 33h
   736 000007A3 48CF                        iretq
   737                                  terminateResident:  ;Int 47h
   738                                  inDosHandler:       ;Int 48h
   739                                  ;Called when DOS idle
   740 000007A5 48CF                        iretq
   741                                  fastOutput:         ;Int 49h
   742                                  ;Called with char to transfer in al
   743 000007A7 50                          push rax
   744 000007A8 B40E                        mov ah, 0Eh
   745 000007AA CD30                        int 30h
   746 000007AC 58                          pop rax
   747 000007AD 48CF                        iretq
   748                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   749 000007AF 48CF                        iretq
   750                                  multiplex:          ;Int 4Fh, kept as iretq for now
   751 000007B1 48CF                        iretq
   752                                  ;-----------------------------------:
   753                                  ;          Driver routines          :
   754                                  ;-----------------------------------:
   755                                  drivers:
   756                                  conHdr:
   757 000007B3 [D507000000000000]          dq auxHdr
   758 000007BB 1308                        dw 0813h
   759 000007BD [4B09000000000000]          dq commonStrat
   760 000007C5 [6209000000000000]          dq conDriver
   761 000007CD 434F4E2020202020            db "CON     "
   762                                  auxHdr:
   763 000007D5 [F707000000000000]          dq prnHdr
   764 000007DD 0080                        dw 08000h
   765 000007DF [4B09000000000000]          dq commonStrat
   766 000007E7 [1D0A000000000000]          dq com1Intr
   767 000007EF 4155582020202020            db "AUX     "
   768                                  prnHdr:
   769 000007F7 [1908000000000000]          dq clkHdr
   770 000007FF 40A0                        dw 0A040h
   771 00000801 [4B09000000000000]          dq commonStrat
   772 00000809 [E508000000000000]          dq lpt1Hdr
   773 00000811 50524E2020202020            db "PRN     "
   774                                  clkHdr:
   775 00000819 [3B08000000000000]          dq msdHdr
   776 00000821 0880                        dw 08008h
   777 00000823 [4B09000000000000]          dq commonStrat
   778 0000082B [1D0A000000000000]          dq clkDriver
   779 00000833 434C4F434B242020            db "CLOCK$  "
   780                                  msdHdr:
   781 0000083B [5D08000000000000]          dq com1Hdr
   782 00000843 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   783 00000845 [4B09000000000000]          dq commonStrat
   784 0000084D [C80A000000000000]          dq msdDriver
   785 00000855 0000000000000000            db 0,0,0,0,0,0,0,0
   786                                  com1Hdr:
   787 0000085D [7F08000000000000]          dq com2Hdr
   788 00000865 0080                        dw 08000h
   789 00000867 [4B09000000000000]          dq commonStrat
   790 0000086F [1D0A000000000000]          dq com1Intr
   791 00000877 434F4D3120202020            db "COM1    "
   792                                  com2Hdr:
   793 0000087F [A108000000000000]          dq com3Hdr
   794 00000887 0080                        dw 08000h
   795 00000889 [4B09000000000000]          dq commonStrat
   796 00000891 [260A000000000000]          dq com2Intr
   797 00000899 434F4D3220202020            db "COM2    "
   798                                  com3Hdr:
   799 000008A1 [C308000000000000]          dq com4Hdr
   800 000008A9 0080                        dw 08000h
   801 000008AB [4B09000000000000]          dq commonStrat
   802 000008B3 [2F0A000000000000]          dq com3Intr
   803 000008BB 434F4D3320202020            db "COM3    "
   804                                  com4Hdr:
   805 000008C3 [E508000000000000]          dq lpt1Hdr
   806 000008CB 0080                        dw 08000h
   807 000008CD [4B09000000000000]          dq commonStrat
   808 000008D5 [380A000000000000]          dq com4Intr
   809 000008DD 434F4D3420202020            db "COM4    "
   810                                  lpt1Hdr:
   811 000008E5 [0709000000000000]          dq lpt2Hdr
   812 000008ED 40A0                        dw 0A040h
   813 000008EF [4B09000000000000]          dq commonStrat
   814 000008F7 [B80A000000000000]          dq lptDriver
   815 000008FF 4C50543120202020            db "LPT1    "
   816                                  lpt2Hdr:
   817 00000907 [2909000000000000]          dq lpt3Hdr
   818 0000090F 40A0                        dw 0A040h
   819 00000911 [4B09000000000000]          dq commonStrat
   820 00000919 [B80A000000000000]          dq lptDriver
   821 00000921 4C50543220202020            db "LPT2    "
   822                                  lpt3Hdr:
   823 00000929 FFFFFFFFFFFFFFFF            dq -1
   824 00000931 40A0                        dw 0A040h
   825 00000933 [4B09000000000000]          dq commonStrat
   826 0000093B [B80A000000000000]          dq lptDriver
   827 00000943 4C50543320202020            dq "LPT3    "
   828                                  
   829                                  commonStrat:
   830                                  ;DOS calls this function with rbx=Ptr to request header
   831 0000094B 48891D01000000              mov qword [reqHdrPtr], rbx
   832 00000952 C3                          ret
   833 00000953 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   834                                  
   835                                  nulStrat:
   836 0000095B 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   837                                  nulIntr:
   838 00000961 C3                          ret
   839                                  
   840                                  conDriver:
   841 00000962 50                          push rax
   842 00000963 53                          push rbx
   843 00000964 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   844 0000096B 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   845 0000096E 84C0                        test al, al
   846 00000970 7421                        jz conInit
   847 00000972 3C04                        cmp al, 4
   848 00000974 744D                        jz conRead
   849 00000976 3C05                        cmp al, 5
   850 00000978 7466                        jz conNondestructiveRead
   851 0000097A 3C06                        cmp al, 6
   852 0000097C 740C                        jz conExit
   853 0000097E 3C07                        cmp al, 7
   854 00000980 7471                        jz conFlushInputBuffers
   855 00000982 3C08                        cmp al, 8
   856 00000984 7479                        jz conWrite
   857 00000986 3C09                        cmp al, 9
   858 00000988 7475                        jz conWrite
   859                                  ;All other cases fall through here
   860                                  conExit:
   861 0000098A 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   862 00000990 5B                          pop rbx
   863 00000991 58                          pop rax
   864 00000992 C3                          ret
   865                                  conInit:    ;Function 0
   866 00000993 52                          push rdx
   867                                      ;Flush keyboard buffer
   868                                  .ci0:
   869 00000994 B401                        mov ah, 01      ;Get buffer status
   870 00000996 CD36                        int 36h
   871 00000998 7406                        jz .ci1      ;If zero clear => no more keys to read
   872 0000099A 30E4                        xor ah, ah
   873 0000099C CD36                        int 36h ;Read key to flush from buffer
   874 0000099E EBF4                        jmp short .ci0
   875                                  .ci1:
   876 000009A0 B800050000                  mov eax, 0500h  ;Set page zero as the default page
   877 000009A5 CD30                        int 30h
   878 000009A7 B402                        mov ah, 02h
   879 000009A9 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   880 000009AB 88D7                        mov bh, dl      ;Set cursor for page 0
   881 000009AD CD30                        int 30h
   882 000009AF B707                        mov bh, 07h     ;Grey/Black attribs
   883 000009B1 B800060000                  mov eax, 0600h  ;Clear whole screen
   884 000009B6 CD30                        int 30h
   885 000009B8 5A                          pop rdx
   886 000009B9 EBCF                        jmp short conExit
   887                                  conIORead:
   888 000009BB 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   889 000009C1 EBC7                        jmp short conExit
   890                                  conRead:    ;Function 4
   891 000009C3 57                          push rdi
   892 000009C4 51                          push rcx
   893 000009C5 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   894 000009C9 31C9                        xor ecx, ecx    ;Zero the char counter
   895                                  .cr1:
   896 000009CB 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   897 000009CE 7409                        je .cre2
   898 000009D0 31C0                        xor eax, eax
   899 000009D2 CD36                        int 36h
   900 000009D4 AA                          stosb   ;Store char in al into buffer and inc rdi
   901 000009D5 FFC1                        inc ecx
   902 000009D7 EBF2                        jmp short .cr1
   903                                  .cre2:
   904 000009D9 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   905 000009DC 59                          pop rcx
   906 000009DD 5F                          pop rdi
   907 000009DE EBAA                        jmp short conExit
   908                                  conNondestructiveRead:  ;Function 5
   909 000009E0 B401                        mov ah, 01h     ;Get key if exists
   910 000009E2 CD36                        int 36h
   911 000009E4 7405                        jz .cnr           ;If zero clear => no key, go forwards
   912                                      ;Keystroke available
   913 000009E6 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   914 000009E9 EB9F                        jmp short conExit
   915                                  .cnr: ;No keystroke available
   916 000009EB 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   917 000009F1 EB97                        jmp short conExit
   918                                  conFlushInputBuffers:   ;Function 7
   919 000009F3 B401                        mov ah, 01      ;Get buffer status
   920 000009F5 CD36                        int 36h
   921 000009F7 7491                        jz conExit      ;If zero clear => no more keys to read
   922 000009F9 30E4                        xor ah, ah
   923 000009FB CD36                        int 36h ;Read key to flush from buffer
   924 000009FD EBF4                        jmp short conFlushInputBuffers
   925                                  conWrite:   ;Function 8 and 9
   926 000009FF 56                          push rsi
   927 00000A00 51                          push rcx
   928 00000A01 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   929 00000A05 31C9                        xor ecx, ecx    ;Zero the char counter
   930                                  .cw1: 
   931 00000A07 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   932 00000A0A 7407                        je .cw2
   933 00000A0C AC                          lodsb   ;Get char into al, and inc rsi
   934 00000A0D CD49                        int 49h ;Fast print char
   935 00000A0F FFC1                        inc ecx
   936 00000A11 EBF4                        jmp short .cw1 ;keep printing until all chars printed
   937                                  .cw2:
   938 00000A13 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   939 00000A16 59                          pop rcx
   940 00000A17 5E                          pop rsi
   941 00000A18 E96DFFFFFF                  jmp conExit
   942                                  
   943                                  clkDriver:
   944                                  
   945                                  comDriver:
   946                                  com1Intr:
   947 00000A1D C6059300000000              mov byte [comDevice], 0
   948 00000A24 EB19                        jmp short comIntr
   949                                  com2Intr:
   950 00000A26 C6058A00000001              mov byte [comDevice], 1
   951 00000A2D EB10                        jmp short comIntr
   952                                  com3Intr:
   953 00000A2F C6058100000002              mov byte [comDevice], 2
   954 00000A36 EB07                        jmp short comIntr
   955                                  com4Intr:
   956 00000A38 C6057800000003              mov byte [comDevice], 3
   957                                  comIntr:
   958 00000A3F 50                          push rax
   959 00000A40 53                          push rbx
   960 00000A41 51                          push rcx
   961 00000A42 52                          push rdx
   962 00000A43 56                          push rsi
   963 00000A44 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   964 00000A4B 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   965 00000A4E 3C04                        cmp al, 4
   966 00000A50 7418                        jz comRead
   967 00000A52 3C05                        cmp al, 5
   968 00000A54 7439                        jz comNondestructiveRead
   969 00000A56 3C08                        cmp al, 8
   970 00000A58 743D                        jz comWrite
   971 00000A5A 3C09                        cmp al, 9
   972 00000A5C 7439                        jz comWrite
   973                                  ;All other cases fall through here
   974                                  comExit:
   975 00000A5E 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   976 00000A64 5E                          pop rsi
   977 00000A65 5A                          pop rdx
   978 00000A66 59                          pop rcx
   979 00000A67 5B                          pop rbx
   980 00000A68 58                          pop rax
   981 00000A69 C3                          ret
   982                                  comRead:
   983 00000A6A 57                          push rdi
   984 00000A6B 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   985 00000A6F 31C9                        xor ecx, ecx    ;Zero the char counter
   986                                  .cr1:
   987 00000A71 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   988 00000A74 7413                        je .cre2
   989 00000A76 B802000000                  mov eax, 02h    ;Recieve 
   990 00000A7B 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   991 00000A82 CD34                        int 34h ;Recieve Char
   992 00000A84 AA                          stosb   ;Store char in al into buffer and inc rdi
   993 00000A85 FFC1                        inc ecx
   994 00000A87 EBE8                        jmp short .cr1
   995                                  .cre2:
   996 00000A89 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   997 00000A8C 5F                          pop rdi
   998 00000A8D EBCF                        jmp short comExit
   999                                  comNondestructiveRead:
  1000 00000A8F 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
  1001 00000A95 EBC7                        jmp short comExit
  1002                                  comWrite:
  1003 00000A97 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1004 00000A9B 31C9                        xor ecx, ecx    ;Zero the char counter
  1005                                  .cw1: 
  1006 00000A9D 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1007 00000AA0 7410                        je .cw2
  1008 00000AA2 AC                          lodsb   ;Get char into al, and inc rsi
  1009 00000AA3 B401                        mov ah, 01h ;Move function number into ah
  1010 00000AA5 668B150B000000              mov dx, word [comDevice]
  1011 00000AAC CD34                        int 34h ;Transmit char
  1012 00000AAE FFC1                        inc ecx
  1013 00000AB0 EBEB                        jmp short .cw1 ;keep printing until all chars printed
  1014                                  .cw2:
  1015 00000AB2 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1016 00000AB5 EBA7                        jmp short comExit
  1017 00000AB7 00                      comDevice   db 0
  1018                                  
  1019                                  lptDriver:    ;Drivers for LPT 1, 2, 3
  1020 00000AB8 57                          push rdi
  1021 00000AB9 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
  1022 00000AC0 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
  1023 00000AC6 5F                          pop rdi
  1024 00000AC7 C3                          ret
  1025                                  
  1026                                  msdDriver:
  1027 00000AC8 50                          push rax
  1028 00000AC9 53                          push rbx
  1029 00000ACA 51                          push rcx
  1030 00000ACB 52                          push rdx
  1031 00000ACC 56                          push rsi
  1032 00000ACD 57                          push rdi
  1033 00000ACE 55                          push rbp
  1034 00000ACF 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1035 00000AD6 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1036 00000AD9 3C18                        cmp al, 24  ;Check cmd num is valid
  1037 00000ADB 776C                        ja .msdError
  1038 00000ADD 84C0                        test al, al
  1039 00000ADF 7476                        jz .msdInit
  1040 00000AE1 3C01                        cmp al, 01
  1041 00000AE3 0F8409010000                jz .msdMedChk
  1042 00000AE9 3C02                        cmp al, 02
  1043 00000AEB 0F8442010000                jz .msdBuildBPB
  1044 00000AF1 3C03                        cmp al, 03
  1045 00000AF3 0F847B010000                jz .msdIOCTLRead
  1046 00000AF9 3C04                        cmp al, 04
  1047 00000AFB 0F8478010000                jz .msdRead
  1048 00000B01 3C08                        cmp al, 08
  1049 00000B03 0F8482010000                jz .msdWrite
  1050 00000B09 3C09                        cmp al, 09
  1051 00000B0B 0F848C010000                jz .msdWriteVerify
  1052 00000B11 3C0C                        cmp al, 12
  1053 00000B13 0F849D010000                jz .msdIOCTLWrite
  1054 00000B19 3C0D                        cmp al, 13
  1055 00000B1B 0F849A010000                jz .msdDevOpen
  1056 00000B21 3C0E                        cmp al, 14
  1057 00000B23 0F84A2010000                jz .msdDevClose
  1058 00000B29 3C0F                        cmp al, 15
  1059 00000B2B 0F84AA010000                jz .msdRemovableMedia
  1060 00000B31 3C13                        cmp al, 19
  1061 00000B33 0F84C0010000                jz .msdGenericIOCTL
  1062 00000B39 3C17                        cmp al, 23
  1063 00000B3B 0F84BD010000                jz .msdGetLogicalDev
  1064 00000B41 3C18                        cmp al, 24
  1065 00000B43 0F84C3010000                jz .msdSetLogicalDev
  1066                                  .msdError:
  1067                                  .msdDriverExit:
  1068 00000B49 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1069 00000B4F 5D                          pop rbp
  1070 00000B50 5F                          pop rdi
  1071 00000B51 5E                          pop rsi
  1072 00000B52 5A                          pop rdx
  1073 00000B53 59                          pop rcx
  1074 00000B54 5B                          pop rbx
  1075 00000B55 58                          pop rax
  1076 00000B56 C3                          ret
  1077                                  .msdInit:            ;Function 0
  1078 00000B57 CD31                        int 31h ;Get number of Int 33h devices in r8b
  1079 00000B59 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1080 00000B5D 4489C0                      mov eax, r8d
  1081 00000B60 3C01                        cmp al, 1
  1082 00000B62 7702                        ja .mi1
  1083 00000B64 FEC0                        inc al ;Make it two
  1084                                  .mi1:
  1085 00000B66 BA05000000                  mov edx, 5
  1086 00000B6B 39D0                        cmp eax, edx
  1087 00000B6D 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1088 00000B70 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1089 00000B76 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1090 00000B79 440005(A9000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1091 00000B80 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1092 00000B82 488D3DE6010000              lea rdi, qword [.msdBPBblks]
  1093 00000B89 53                          push rbx
  1094                                  .mi2:
  1095 00000B8A 89EA                        mov edx, ebp
  1096 00000B8C 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1097 00000B93 31C9                        xor ecx, ecx    ;Sector 0
  1098 00000B95 B801820000                  mov eax, 8201h       ;Read 1 sector
  1099 00000B9A CD33                        int 33h
  1100 00000B9C 724E                        jc .msdInitError
  1101                                  
  1102 00000B9E 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1103 00000BA5 B90F000000                  mov ecx, bpbEx_size/8
  1104 00000BAA F348A5                      rep movsq   ;Move the BPB data into the right block
  1105                                  
  1106 00000BAD FFC5                        inc ebp
  1107 00000BAF 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1108 00000BB2 75D6                        jne .mi2  ;No? Go again
  1109                                  
  1110 00000BB4 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1111 00000BBB 488D15AD010000              lea rdx, qword [.msdBPBblks]
  1112                                  .mi3:
  1113 00000BC2 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1114 00000BC5 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1115 00000BCC FFCD                        dec ebp
  1116 00000BCE 75F2                        jnz .mi3  ;If not zero yet, go again
  1117                                  
  1118 00000BD0 5B                          pop rbx
  1119 00000BD1 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1120 00000BD8 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1121 00000BDC 488D15E4030000              lea rdx, qword [driverDataPtr]
  1122 00000BE3 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1123 00000BE7 E95DFFFFFF                  jmp .msdDriverExit
  1124                                  .msdInitError:
  1125 00000BEC 5B                          pop rbx
  1126 00000BED E957FFFFFF                  jmp .msdDriverExit
  1127                                  .msdMedChk:          ;Function 1
  1128                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1129                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1130                                  ; suffice.
  1131 00000BF2 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1132 00000BF7 8A90[3D0D0000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1133 00000BFD F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1134 00000C00 7528                        jnz .mmcNoChange
  1135                                  ;Now we test Media Descriptor
  1136 00000C02 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1137 00000C05 488B3CC5[470D0000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1138 00000C0D 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1139 00000C10 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1140 00000C13 740C                        je .mmcUnsure
  1141                                  .mmcChange: ;Fail safe, always assume the device has changed
  1142 00000C15 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1143 00000C19 48C7430F[330D0000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
  1144                                  .mmcUnsure:
  1145 00000C21 C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1146 00000C25 E91FFFFFFF                  jmp .msdDriverExit
  1147                                  .mmcNoChange:
  1148 00000C2A C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1149 00000C2E E916FFFFFF                  jmp .msdDriverExit
  1150                                  
  1151                                  .msdBuildBPB:        ;Function 2
  1152 00000C33 4889DE                      mov rsi, rbx
  1153 00000C36 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1154 00000C3B 8A90[3D0D0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1155 00000C41 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1156 00000C45 31C9                        xor ecx, ecx    ;Read Sector 0
  1157 00000C47 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1158 00000C4C CD33                        int 33h
  1159 00000C4E 7224                        jc .mbbpbError
  1160 00000C50 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1161 00000C53 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1162 00000C58 488B3CC5[470D0000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1163 00000C60 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1164 00000C63 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1165 00000C67 B90F000000                  mov ecx, bpbEx_size/8
  1166 00000C6C F348A5                      rep movsq   ;Move the BPB data into the right space
  1167 00000C6F E9D5FEFFFF                  jmp .msdDriverExit
  1168                                  .mbbpbError:
  1169                                  .msdIOCTLRead:       ;Function 3, returns done
  1170 00000C74 E9D0FEFFFF                  jmp .msdDriverExit
  1171                                  .msdRead:            ;Function 4
  1172 00000C79 4889DD                      mov rbp, rbx
  1173 00000C7C B482                        mov ah, 82h ;LBA Read Sectors
  1174 00000C7E E897000000                  call .msdBlkIOCommon
  1175 00000C83 4889EB                      mov rbx, rbp
  1176 00000C86 E9BEFEFFFF                  jmp .msdDriverExit
  1177                                  .msdWrite:           ;Function 8
  1178 00000C8B 4889DD                      mov rbp, rbx
  1179 00000C8E B483                        mov ah, 83h ;LBA Write Sectors
  1180 00000C90 E885000000                  call .msdBlkIOCommon
  1181 00000C95 4889EB                      mov rbx, rbp
  1182 00000C98 E9ACFEFFFF                  jmp .msdDriverExit
  1183                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1184 00000C9D 4889DD                      mov rbp, rbx
  1185 00000CA0 B483                        mov ah, 83h ;LBA Write Sectors
  1186 00000CA2 E873000000                  call .msdBlkIOCommon
  1187 00000CA7 B484                        mov ah, 84h ;LBA Verify Sectors
  1188 00000CA9 E86C000000                  call .msdBlkIOCommon
  1189 00000CAE 4889EB                      mov rbx, rbp
  1190 00000CB1 E993FEFFFF                  jmp .msdDriverExit
  1191                                  .msdIOCTLWrite:      ;Function 12, returns done
  1192 00000CB6 E98EFEFFFF                  jmp .msdDriverExit
  1193                                  .msdDevOpen:         ;Function 13
  1194 00000CBB 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1195 00000CC0 FE80[420D0000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1196 00000CC6 E97EFEFFFF                  jmp .msdDriverExit
  1197                                  .msdDevClose:        ;Function 14
  1198 00000CCB 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1199 00000CD0 FE88[420D0000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1200 00000CD6 E96EFEFFFF                  jmp .msdDriverExit
  1201                                  .msdRemovableMedia:  ;Function 15
  1202 00000CDB 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1203 00000CE0 8A80[3D0D0000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1204 00000CE6 A880                        test al, 80h
  1205 00000CE8 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1206 00000CEE 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
  1207 00000CF4 E950FEFFFF                  jmp .msdDriverExit
  1208                                  .msdGenericIOCTL:    ;Function 19
  1209 00000CF9 E94BFEFFFF                  jmp .msdDriverExit
  1210                                  .msdGetLogicalDev:   ;Function 23
  1211 00000CFE 8A0538000000                mov al, byte [.msdCurDev]
  1212 00000D04 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1213 00000D07 E93DFEFFFF                  jmp .msdDriverExit
  1214                                  .msdSetLogicalDev:   ;Function 24
  1215 00000D0C 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1216 00000D0F 880527000000                mov byte [.msdCurDev], al
  1217 00000D15 E92FFEFFFF                  jmp .msdDriverExit
  1218                                  
  1219                                  .msdBlkIOCommon:  ;Does block IO
  1220                                  ;Called with rbp containing old rbx value and ah with function number
  1221                                  ;Error handled by caller
  1222 00000D1A 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1223 00000D1F 8A90[3D0D0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1224 00000D25 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1225 00000D29 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
  1226 00000D2C 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1227 00000D30 CD33                        int 33h
  1228 00000D32 C3                          ret
  1229                                  
  1230 00000D33 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1231                                  ;LASTDRIVE default is 5
  1232 00000D3C 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1233                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1234 00000D3D 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1235 00000D42 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1236 00000D47 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1236 00000D50 000000000000000000-
  1236 00000D59 000000000000000000-
  1236 00000D62 000000000000000000-
  1236 00000D6B 00000000           
  1237 00000D6F 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1237 00000D78 000000000000000000-
  1237 00000D81 000000000000000000-
  1237 00000D8A 000000000000000000-
  1237 00000D93 000000000000000000-
  1237 00000D9C 000000000000000000-
  1237 00000DA5 000000000000000000-
  1237 00000DAE 000000000000000000-
  1237 00000DB7 000000000000000000-
  1237 00000DC0 000000000000000000-
  1237 00000DC9 000000000000000000-
  1237 00000DD2 000000000000000000-
  1237 00000DDB 000000000000000000-
  1237 00000DE4 000000000000000000-
  1237 00000DED 000000000000000000-
  1237 00000DF6 000000000000000000-
  1237 00000DFF 000000000000000000-
  1237 00000E08 000000000000000000-
  1237 00000E11 000000000000000000-
  1237 00000E1A 000000000000000000-
  1237 00000E23 000000000000000000-
  1237 00000E2C 000000000000000000-
  1237 00000E35 000000000000000000-
  1237 00000E3E 000000000000000000-
  1237 00000E47 000000000000000000-
  1237 00000E50 000000000000000000-
  1237 00000E59 000000000000000000-
  1237 00000E62 000000000000000000-
  1237 00000E6B 000000000000000000-
  1237 00000E74 000000000000000000-
  1237 00000E7D 000000000000000000-
  1237 00000E86 000000000000000000-
  1237 00000E8F 000000000000000000-
  1237 00000E98 000000000000000000-
  1237 00000EA1 000000000000000000-
  1237 00000EAA 000000000000000000-
  1237 00000EB3 000000000000000000-
  1237 00000EBC 000000000000000000-
  1237 00000EC5 000000000000000000-
  1237 00000ECE 000000000000000000-
  1237 00000ED7 000000000000000000-
  1237 00000EE0 000000000000000000-
  1237 00000EE9 000000000000000000-
  1237 00000EF2 000000000000000000-
  1237 00000EFB 000000000000000000-
  1237 00000F04 000000000000000000-
  1237 00000F0D 000000000000000000-
  1237 00000F16 000000000000000000-
  1237 00000F1F 000000000000000000-
  1237 00000F28 000000000000000000-
  1237 00000F31 000000000000000000-
  1237 00000F3A 000000000000000000-
  1237 00000F43 000000000000000000-
  1237 00000F4C 000000000000000000-
  1237 00000F55 000000000000000000-
  1237 00000F5E 000000000000000000-
  1237 00000F67 000000000000000000-
  1237 00000F70 000000000000000000-
  1237 00000F79 000000000000000000-
  1237 00000F82 000000000000000000-
  1237 00000F8B 000000000000000000-
  1237 00000F94 000000000000000000-
  1237 00000F9D 000000000000000000-
  1237 00000FA6 000000000000000000-
  1237 00000FAF 000000000000000000-
  1237 00000FB8 000000000000000000-
  1237 00000FC1 000000000000       
  1238                                  
  1239                                  driverDataPtr:
=======
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, pointer to rax saved in oldRSP
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> ;Pushed by Processor when invoked via Interrupt
   186 00000048 ????????????????    <1>     .rip    resq 1
   187 00000050 ????????????????    <1>     .cs     resq 1
   188 00000058 ????????????????    <1>     .flags  resq 1
   189                              <1> endstruc
   190                              <1> 
   191                              <1> %macro pushDOS 0
   192                              <1>     push r9
   193                              <1>     push r8
   194                              <1>     push rbp
   195                              <1>     push rdi
   196                              <1>     push rsi
   197                              <1>     push rdx
   198                              <1>     push rcx
   199                              <1>     push rbx
   200                              <1>     push rax
   201                              <1> %endmacro
   202                              <1> 
   203                              <1> %macro popDOS 0
   204                              <1>     pop rax
   205                              <1>     pop rbx
   206                              <1>     pop rcx
   207                              <1>     pop rdx
   208                              <1>     pop rsi
   209                              <1>     pop rdi
   210                              <1>     pop rbp
   211                              <1>     pop r8
   212                              <1>     pop r9
   213                              <1> %endmacro
   214                              <1> 
   215                              <1> struc psp
   216 00000000 ????                <1>     .return     resb 2  ;Should always be CDh 40h
   217 00000002 ????????????????    <1>     .startSeg   resq 1
   218 0000000A ????????????????    <1>     .oldInt42h  resq 1
   219 00000012 ????????????????    <1>     .oldInt43h  resq 1
   220 0000001A ????????????????    <1>     .oldInt44h  resq 1
   221 00000022 ????????????????    <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   222 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   223 0000003E ????????????????    <1>     .envPtr     resq 1  ;Pointer to the environment
   224 00000046 ????????????????    <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to int 41h
   225 0000004E ????                <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   226 00000050 ??????              <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   227 00000053 ????????????????    <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   228 0000005B ????????????????    <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   229 00000063 ????????????????    <1>     .fcbPtr1    resq 1  ;Pointer to the first OS allocated FCB
   230 0000006B <res 15h>           <1>     .reserved   resb 21
   231 00000080 ??                  <1>     .charCount  resb 1
   232 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   233                              <1> endstruc
   234                              <1> 
   235                              <1> struc mcb
   236 00000000 ??                  <1>     .mzbyte     resb 1  ;M=In use, Z=Free
   237 00000001 ????????????????    <1>     .processPtr resq 1  ;Points to the start of the process PSP
   238 00000009 ????????            <1>     .paragraphs resd 1  ;Gives the number of paras allocated to this process
   239 0000000D ??????              <1>     .reserved   resb 3
   240                              <1>     .program:
   241                              <1> endstruc
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   charReqHdr  resb ioReqPkt_size  ;Character IO Request header
    12 00000033 <res 2Ah>                   diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
    13                                      ;The device driver header with space for the largest possible packet
    14 0000005D ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    15 00000065 ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    16 0000006D ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    17 00000075 ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    18 0000007D ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    19                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    20 00000085 ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    21                                      ;                    The last driver loaded with the STDIN bit[0] set
    22 0000008D ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    23 0000008F ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    24 00000097 ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    25 0000009F ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    26 000000A7 ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    27 000000A9 ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    28 000000AA ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    29 000000AB ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    30 000000AC <res 22h>                   nulDevHdr   resb drvHdr_size
    31                                  
    32                                  ;Start of Swappable Data Area, this bit can remain static
    33 000000CE ??                          critErrFlag resb 1  ;Critical error flag, set on entry to INT 44h
    34 000000CF ??                          inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    35 000000D0 ??                          errorDrv    resb 1  ;Drive on which error occured or FFh
    36 000000D1 ??                          errorLocus  resb 1  ;Where the error took place  
    37 000000D2 ????                        errorExt    resw 1  ;Extended Error Code
    38 000000D4 ??                          errorAction resb 1  ;Suggested action for error  
    39 000000D5 ??                          errorClass  resb 1  ;Error Class
    40                                  
    41 000000D6 ????????????????            currentDTA  resq 1  ;Address of the current DTA
    42 000000DE ????????????????            currentPSP  resq 1  ;Address of current PSP
    43 000000E6 ????????????????            rdiErrorPtr resq 1  ;Saves RDI value of last error
    44 000000EE ????????????????            xInt43hRSP  resq 1  ;Saves RSP across an Int 43h call
    45 000000F6 ????                        lastRetCode resw 1  ;Last return code returned by Int 41h/4Ch
    46 000000F8 ??                          currentDrv  resb 1  ;Default, last accessed drive
    47 000000F9 ??                          breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    48                                  ;SDA, needs to be replaced between processes
    49 000000FA ????????????????            xInt44hRSP  resq 1  ;RSP across an Int 44h call
    50                                  
    51 00000102 ??                          Int44RetVal resb 1  ;Saves a copy of the Int 44 return value
    52 00000103 ??                          Int44bitfld resb 1  ;Copies the bit field given to the Int 44h handler
    53 00000104 ??                          int48Flag   resb 1  ;If set, Int 48h should be called, if clear no
    54 00000105 ????????????????            oldoldRSP   resq 1  ;RSP at prev Int 41h entry if called from within Int 41h
    55 0000010D ????????????????            oldRSP      resq 1  ;RSP when entering Int 41h
    56 00000115 ????????????????            oldRBX      resq 1  ;Temp var to save value of rbx during an Int 41 call
    57                                  ;Time stuff
    58 0000011D ????????????                CLOCKrecrd  resb 6  ;Clock driver record
    59 00000123 ??                          dayOfMonth  resb 1  ;1 - 31 BCD
    60 00000124 ??                          monthOfYear resb 1  ;1 - 12 BCD
    61 00000125 ????                        years       resw 1  ;0000 - 9999 BCD
    62 00000127 ????                        yearsOffset resw 1  ;Current Year - 1980
    63 00000129 ????????                    daysOffset  resd 1  ;Days since 1-1-1980
    64 0000012D ??                          dayOfWeek   resb 1  ;0 = Sunday <-> 6 = Saturday
    65                                  
    66                                  ;Stacks
    67 0000012E <res 528h>                  critStack   resq 165
    68 00000656 ????????????????            critStakTop resq 1
    69 0000065E <res 638h>                  IOStack     resq 199
    70 00000C96 ????????????????            IOStakTop   resq 1
    71 00000C9E <res 638h>                  DiskStack   resq 199
    72 000012D6 ????????????????            DiskStakTop resq 1
    73                                      dSegLen     equ     $
    74                                  
    75                                  Segment .text align=1
    76                                  ; We arrive here with the following values in the registers.
    77                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    78                                  ; dx  = Int 33h boot device number
    79                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    80 00000000 55AA                        dw 0AA55h           ;Initial signature
    81 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    82                                  
    83 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    84 0000000F 0F32                        rdmsr
    85 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    86 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    87 00000017 89C7                        mov edi, eax        ;Get the low dword in
    88                                  
    89 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    89 0000001E [00000000]         
    90 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    91 00000025 4881C7[DE120000]            add rdi, dSegLen ;Move destination past end of data area
    92 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    93 00000033 B900100000                  mov ecx, 1000h
    94 00000038 F348A5                      rep movsq
    95                                  
    96                                  ;Modify the pointers in nData before putting them in the data area
    97 0000003B 48012D72010000              add qword [nData + drvHdr.nxtPtr], rbp
    98 00000042 48012D75010000              add qword [nData + drvHdr.strPtr], rbp
    99 00000049 48012D76010000              add qword [nData + drvHdr.intPtr], rbp
   100                                  ;Copy the Null driver to its location in Sysvars
   101 00000050 B922000000                  mov ecx, drvHdr_size
   102 00000055 488D3558010000              lea rsi, qword [nData]
   103 0000005C 488DBD[AC000000]            lea rdi, qword [rbp + nulDevHdr]
   104 00000063 F3A4                        rep movsb   
   105                                  
   106                                  ;Adjust the addresses in the other driver headers 
   107 00000065 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
   107 00000067 [B007000000000000] 
   108 0000006F B90C000000                  mov ecx, 12      ;12 drivers in data area
   109 00000074 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
   110                                  adjDrivers:
   111 00000078 E8BC000000                  call adjustDrvHdr
   112 0000007D E2F9                        loop adjDrivers
   113                                  
   114                                      ;Open NUL
   115 0000007F 488D9D[B6000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
   116 00000086 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
   117 00000089 30C0                        xor al, al
   118 0000008B FFD3                        call rbx
   119                                  
   120                                      ;Open CON
   121 0000008D 48BB-                       mov rbx, conDriver
   121 0000008F [5F09000000000000] 
   122 00000097 488D5C1D00                  lea rbx, qword [rbp+rbx]
   123 0000009C 30C0                        xor al, al
   124 0000009E FFD3                        call rbx
   125                                  
   126                                      ;Open Mass Storage
   127 000000A0 48BB-                       mov rbx, msdDriver
   127 000000A2 [C50A000000000000] 
   128 000000AA 488D5C1D00                  lea rbx, qword [rbp+rbx]
   129 000000AF 30C0                        xor al, al
   130 000000B1 FFD3                        call rbx
   131                                  ;Adjust Int 41h address table
   132                                  
   133                                  adjInt41h:
   134 000000B3 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
   135 000000B8 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
   135 000000BA [9501000000000000] 
   136 000000C2 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
   137                                  .ai41h:
   138 000000C7 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
   139 000000CA 4881C308000000              add rbx, 8              ;Each entry is size 8
   140 000000D1 FFC9                        dec ecx
   141 000000D3 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
   142                                  
   143                                  ;Adjust Interrupt Entries Int 40h-49h
   144                                  adjInts:
   145 000000D5 B340                        mov bl, 40h
   146 000000D7 B807F00000                  mov eax, 0F007h ;Get the descriptor
   147 000000DC CD35                        int 35h
   148 000000DE B940000000                  mov ecx, 40h    ;Start from interrupt 40h
   149 000000E3 488D3D7A000000              lea rdi, intData
   150 000000EA 89C6                        mov esi, eax    ;Move segment selector info to esi
   151                                  .ai0:
   152 000000EC B808F00000                  mov eax, 0F008h ;Set the descriptor
   153 000000F1 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
   154 000000F4 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
   155 000000F7 CD35                        int 35h
   156 000000F9 4881C708000000              add rdi, 8
   157 00000100 FFC1                        inc ecx
   158 00000102 81F94A000000                cmp ecx, 4Ah
   159 00000108 75E2                        jne .ai0
   160                                  
   161                                  ;Test Error Case
   162 0000010A B430                        mov ah, 00110000b
   163 0000010C B000                        mov al, 00h
   164 0000010E BF0C000000                  mov edi, 0Ch
   165 00000113 CD44                        int 44h
   166                                  
   167                                  
   168 00000115 488D1530000000              lea rdx, qword [startmsg]   ;Get the absolute address of message
   169 0000011C B409                        mov ah, 09h
   170 0000011E CD41                        int 41h
   171                                  
   172 00000120 64488B3425-                 mov rsi, fs:[nulDevHdr]
   172 00000125 [AC000000]         
   173 00000129 B801C50000                  mov eax, 0C501h ;Connect debugger
   174 0000012E CD35                        int 35h
   175 00000130 6687DB                      xchg bx, bx
   176                                  l1:
   177 00000133 B401                        mov ah, 01h  ;Write with echo
   178 00000135 CD41                        int 41h
   179 00000137 EBFA                        jmp short l1
   180                                  adjustDrvHdr:
   181                                  ;Input: rsi = Effective address of driver in DOS segment
   182                                  ;       rbp = Ptr to the start of the DOS segment
   183                                  ;Output: rsi = EA of next header in DOS segment
   184 00000139 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   185 0000013C 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   186 00000140 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   187 00000144 4881C622000000              add rsi, drvHdr_size
   188 0000014B C3                          ret
   189                                  
   190 0000014C 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,"$"
   190 00000155 67205343502F444F53-
   190 0000015E 2E2E2E0A0D24       
   191                                  intData:
   192 00000164 [5900000000000000]          dq terminateProcess ;Int 40h
   193 0000016C [5900000000000000]          dq functionDispatch ;Int 41h
   194 00000174 [E504000000000000]          dq terminateHandler ;Int 42h
   195 0000017C [E504000000000000]          dq ctrlCHandler     ;Int 43h
   196 00000184 [E504000000000000]          dq critErrorHandler ;Int 44h
   197 0000018C [7807000000000000]          dq absDiskRead      ;Int 45h
   198 00000194 [8D07000000000000]          dq absDiskWrite     ;Int 46h
   199 0000019C [A207000000000000]          dq terminateResident    ;Int 47h
   200 000001A4 [A207000000000000]          dq inDosHandler     ;Int 48h
   201 000001AC [A407000000000000]          dq fastOutput       ;Int 49h
   202                                  nData:
   203 000001B4 [B007000000000000]          dq conHdr
   204 000001BC 0480                        dw 08004h
   205 000001BE [5809000000000000]          dq nulStrat
   206 000001C6 [5E09000000000000]          dq nulIntr
   207 000001CE 4E554C2020202020            db "NUL     " ;Default NUL data
   208                                  
   209                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   210                                  ;-----------------------------------:
   211                                  ;       Misc System routines        :
   212                                  ;-----------------------------------:
   213                                  findLRUBuffer: 
   214                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   215                                  ;Input: Nothing
   216                                  ;Output: rbx = Pointer to the buffer to use
   217 00000000 52                          push rdx
   218 00000001 488B1D(8F000000)            mov rbx, qword [bufHeadPtr]
   219 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   220 0000000F 7502                        jne .flb1
   221 00000011 5A                          pop rdx
   222 00000012 C3                          ret
   223                                  .flb1:
   224 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   225 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   226 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   227 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   228 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   229 00000029 488B15(8F000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   230 00000030 48891D(8F000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   231 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   232 0000003A 5A                          pop rdx
   233 0000003B C3                          ret
   234                                  
   235                                  findDPB:
   236                                  ;Finds the DPB for a given drive
   237                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   238                                  ;Output: al = 00, rbx = Pointer to the DPB
   239                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   240 0000003C 488B1D(6D000000)            mov rbx, qword [dpbHeadPtr]
   241                                  .fd1:
   242 00000043 30C0                        xor al, al
   243 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   244 00000047 740F                        je .fd2
   245 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   246 0000004D B0FF                        mov al, -1
   247 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   248 00000056 75EB                        jne .fd1
   249                                  .fd2:
   250 00000058 C3                          ret
   251                                  callCritError:
   252                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   253                                  ;-----------------------------------:
   254                                  ;       File System routines        :
   255                                  ;-----------------------------------:
   256                                  name2Clust:
   257                                  ;Converts a file name to a first cluster number
   258                                  ;-----------------------------------:
   259                                  ;        Interrupt routines         :
   260                                  ;-----------------------------------:
   261                                  terminateProcess:   ;Int 40h
   262                                  
   263                                  functionDispatch:   ;Int 41h Main function dispatcher
   264                                  ;ah = Function number, all other registers have various meanings
   265 00000059 FA                          cli ;Halt external interrupts
   266 0000005A FC                          cld ;Ensure all string ops occur in the right direction
   267 0000005B 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   268 0000005E 0F870A010000                ja .fdExitBad
   269                                      ;Cherry pick functions
   270 00000064 80FC33                      cmp ah, 33h ;CTRL+BREAK check
   271 00000067 722C                        jb .fdInInt41   ;If below skip these checks
   272 00000069 0F8425010000                je .ctrlBreakCheck
   273 0000006F 80FC64                      cmp ah, 64h
   274 00000072 0F841C010000                je .setDriverLookahead  ;Reserved, but avoids usual Int 41h spiel
   275 00000078 771B                        ja .fdInInt41   ;If above, do usual Int41 entry
   276 0000007A 80FC51                      cmp ah, 51h
   277 0000007D 0F8411010000                je .getCurrProcessID    ;This an below are exactly the same
   278 00000083 80FC62                      cmp ah, 62h
   279 00000086 0F8408010000                je .getPSPaddr          ;Calls the above function
   280 0000008C 80FC50                      cmp ah, 50h
   281 0000008F 0F84FF000000                je .setCurrProcessID
   282                                  .fdInInt41:
   283                                      pushDOS ;Push the usual prologue registers
   192 00000095 4151                <1>  push r9
   193 00000097 4150                <1>  push r8
   194 00000099 55                  <1>  push rbp
   195 0000009A 57                  <1>  push rdi
   196 0000009B 56                  <1>  push rsi
   197 0000009C 52                  <1>  push rdx
   198 0000009D 51                  <1>  push rcx
   199 0000009E 53                  <1>  push rbx
   200 0000009F 50                  <1>  push rax
   284 000000A0 488B05(0D010000)            mov rax, qword [oldRSP]
   285 000000A7 488905(05010000)            mov qword [oldoldRSP], rax
   286 000000AE FE05(CF000000)              inc byte [inDOS]    ;Increment in DOS flag
   287 000000B4 488925(0D010000)            mov qword [oldRSP], rsp
   288 000000BB 58                          pop rax     ;Get old rax back
   289 000000BC 50                          push rax    ;and push it back onto the stack
   290                                      ;Here, we want to save oldRSP in the callers PSP
   291 000000BD 488D25(56060000)            lea rsp, critStakTop
   292 000000C4 FB                          sti         ;Reenable interrupts
   293                                  
   294 000000C5 C605(04010000)01            mov byte [int48Flag], 1 ;Make it ok to trigger Int 48h
   295                                  
   296 000000CC 48891D(15010000)            mov qword [oldRBX], rbx ;Need to do this as I might switch stacks later
   297 000000D3 0FB6DC                      movzx ebx, ah   ;Move the function number bl zero extended to rbx
   298 000000D6 C1E303                      shl ebx, 3      ;Multiply the function number by 8 for offset into table
   299 000000D9 50                          push rax        ;Push rax onto the stack
   300 000000DA 488D05B4000000              lea rax, qword [.dispatchTable]
   301 000000E1 4801C3                      add rbx, rax    ;Add dispatch table offset into rbx
   302 000000E4 58                          pop rax
   303 000000E5 488B1B                      mov rbx, qword [rbx]    ;Get the address from the dispatch table
   304                                  
   305 000000E8 84E4                        test ah, ah     ;Simple Terminate function?
   306 000000EA 741C                        jz .fddiskOp
   307 000000EC 80FC59                      cmp ah, 59h     ;Extended Error report?
   308 000000EF 7443                        je .fdGoToFunction  ;Bypass code that clears the error report
   309 000000F1 80FC0C                      cmp ah, 0Ch     ;Are we a char function?
   310 000000F4 7712                        ja .fddiskOp
   311                                  ;Char operations here
   312 000000F6 F605(CE000000)01            test byte [critErrFlag], 1  ;Are we in critical error?
   313 000000FD 7535                        jnz .fdGoToFunction         ;If we are, stay on Critical Error Stack
   314 000000FF 488D25(960C0000)            lea rsp, IOStakTop          ;Otherwise, switch to IO stack
   315 00000106 EB2C                        jmp short .fdGoToFunction
   316                                  .fddiskOp:
   317                                      ;Disk operations go here
   318                                      ;Clear up error info
   319 00000108 C605(D1000000)01            mov byte [errorLocus], 1    ;Reset to generic, unknown locus
   320 0000010F C605(CE000000)00            mov byte [critErrFlag], 0   ;Clear the Critical Error Flag
   321 00000116 C605(D0000000)FF            mov byte [errorDrv], -1     ;Set the drive which caused the error to none
   322                                  
   323 0000011D C605(04010000)00            mov byte [int48Flag], 0     ;Turn off the ability to trigger Int 48h
   324 00000124 488D25(D6120000)            lea rsp, DiskStakTop        ;Swap the stack to the Disk Transfer Stack
   325 0000012B F605(F9000000)FF            test byte [breakFlag], -1   ;Test if set
   326 00000132 7400                        jz .fdGoToFunction
   327                                  ; HANDLE CTRL+BREAK HERE!
   328                                  .fdGoToFunction:
   329 00000134 48871D(15010000)            xchg rbx, qword [oldRBX]    ;Put the call addr in oldRBX and get oldRBX back
   330                                      ;Potentially point rbp to caller reg frame for easy access of registers 
   331                                      ;mov rbp, qword [oldRSP]    ;Move rsp on entry into rbp
   332 0000013B FF15(15010000)              call qword [oldRBX]     ;Call the desired function, rax contains ret code
   333                                  .fdExit:
   334 00000141 FA                          cli     ;Redisable interrupts
   335                                      ;???
   336 00000142 FE0D(CF000000)              dec byte [inDOS]            ;Decrement the inDOS count
   337 00000148 488B25(0D010000)            mov rsp, qword [oldRSP]     ;Point rsp to old stack
   338 0000014F 48890424                    mov qword [rsp], rax    ;Put the ret code into its pos on the register frame
   339 00000153 488B05(05010000)            mov rax, qword [oldoldRSP]
   340 0000015A 488905(0D010000)            mov qword [oldRSP], rax
   341                                      popDOS  ;Pop the frame
   204 00000161 58                  <1>  pop rax
   205 00000162 5B                  <1>  pop rbx
   206 00000163 59                  <1>  pop rcx
   207 00000164 5A                  <1>  pop rdx
   208 00000165 5E                  <1>  pop rsi
   209 00000166 5F                  <1>  pop rdi
   210 00000167 5D                  <1>  pop rbp
   211 00000168 4158                <1>  pop r8
   212 0000016A 4159                <1>  pop r9
   342 0000016C 48CF                        iretq
   343                                  .fdExitBad:
   344 0000016E B400                        mov ah, 0
   345 00000170 48CF                        iretq
   346                                  .simpleTerminate:     ;ah = 00h
   347 00000172 C3                          ret
   348                                  .stdinReadEcho:     ;ah = 01h
   349 00000173 30E4                        xor ah, ah
   350 00000175 CD36                        int 36h
   351 00000177 CD49                        int 49h ;Pass al to fast output
   352 00000179 C3                          ret
   353                                  .stdoutWrite:       ;ah = 02h
   354                                  ;Bspace is regular cursor left, does not insert a blank
   355 0000017A 50                          push rax
   356 0000017B 88D0                        mov al, dl
   357 0000017D CD49                        int 49h
   358 0000017F 58                          pop rax
   359 00000180 C3                          ret
   360                                  .stdauxRead:        ;ah = 03h
   361                                  .stdauxWrite:       ;ah = 04h
   362                                  .stdprnWrite:       ;ah = 05h
   363                                  .directCONIO:       ;ah = 06h
   364                                  .waitDirectInNoEcho:;ah = 07h
   365                                  .waitStdinNoEcho:   ;ah = 08h
   366 00000181 C3                          ret
   367                                  .printString:       ;ah = 09h
   368 00000182 50                          push rax
   369 00000183 52                          push rdx
   370                                  .ps0:
   371 00000184 8A02                        mov al, byte [rdx]
   372 00000186 3C24                        cmp al, "$"
   373 00000188 7407                        je .ps1
   374 0000018A 48FFC2                      inc rdx ;Goto next char
   375 0000018D CD49                        int 49h ;Print char in al
   376 0000018F EBF3                        jmp short .ps0
   377                                  .ps1:
   378 00000191 5A                          pop rdx
   379 00000192 58                          pop rax
   380 00000193 C3                          ret
   381                                  .buffStdinInput:    ;ah = 0Ah
   382                                  .checkStdinStatus:  ;ah = 0Bh
   383                                  .clearbuffDoFunc:   ;ah = 0Ch
   384                                  .diskReset:         ;ah = 0Dh
   385                                  .selectDisk:        ;ah = 0Eh
   386                                  .openFileFCB:       ;ah = 0Fh
   387                                  .closeFileFCB:      ;ah = 10h
   388                                  .findFirstFileFCB:  ;ah = 11h
   389                                  .findNextFileFCB:   ;ah = 12h
   390                                  .deleteFileFCB:     ;ah = 13h
   391                                  .sequentialReadFCB: ;ah = 14h
   392                                  .sequentialWriteFCB:;ah = 15h
   393                                  .createFileFCB:     ;ah = 16h
   394                                  .renameFileFCB:     ;ah = 17h
   395                                                      ;ah = 18h unused
   396                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   397                                  .setDTA:            ;ah = 1Ah
   398                                  .FATinfoDefault:    ;ah = 1Bh
   399                                  .FatinfoDevice:     ;ah = 1Ch
   400                                                      ;ah = 1Dh unused
   401                                                      ;ah = 1Eh unused
   402                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   403                                                      ;ah = 20h unused
   404                                  .randomReadFCB:     ;ah = 21h
   405                                  .randomWriteFCB:    ;ah = 22h
   406                                  .getFileSizeFCB:    ;ah = 23h
   407                                  .setRelRecordFCB:   ;ah = 24h
   408                                  .setIntVector:      ;ah = 25h
   409                                  .createNewPSP:      ;ah = 26h
   410                                  .randBlockReadFCB:  ;ah = 27h
   411                                  .randBlockWriteFCB: ;ah = 28h
   412                                  .parseFilenameFCB:  ;ah = 29h
   413                                  .getDate:           ;ah = 2Ah
   414                                  .setDate:           ;ah = 2Bh
   415                                  .getTime:           ;ah = 2Ch
   416                                  .setTime:           ;ah = 2Dh
   417                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   418                                  .getDTA:            ;ah = 2Fh
   419                                  .getDOSversion:     ;ah = 30h
   420                                  .terminateStayRes:  ;ah = 31h
   421                                  .getDeviceDPBptr:   ;ah = 32h
   422                                  .ctrlBreakCheck:    ;ah = 33h
   423                                  .getInDOSflagPtr:   ;ah = 34h
   424                                  .getIntVector:      ;ah = 35h
   425                                  .getDiskFreeSpace:  ;ah = 36h
   426                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   427                                  .getsetCountryInfo: ;ah = 38h, localisation info
   428                                  .makeDIR:           ;ah = 39h
   429                                  .removeDIR:         ;ah = 3Ah
   430                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   431                                  .createFileHdl:     ;ah = 3Ch, handle function
   432                                  .openFileHdl:       ;ah = 3Dh, handle function
   433                                  .closeFileHdl:      ;ah = 3Eh, handle function
   434                                  .readFileHdl:       ;ah = 3Fh, handle function
   435                                  .writeFileHdl:      ;ah = 40h, handle function
   436                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   437                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   438                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   439                                  .ioctrl:            ;ah = 44h, handle function
   440                                  .duplicateHandle:   ;ah = 45h, handle function
   441                                  .forceDuplicateHdl: ;ah = 46h, handle function
   442                                  .getCurrentDIR:     ;ah = 47h
   443                                  .allocateMemory:    ;ah = 48h
   444                                  .freeMemory:        ;ah = 49h
   445                                  .reallocMemory:     ;ah = 4Ah
   446                                  .loadExecChild:     ;ah = 4Bh, EXEC
   447                                  .terminateClean:    ;ah = 4Ch, EXIT
   448                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   449                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   450                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   451                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   452                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   453                                  .getSysVarsPtr:     ;ah = 52h
   454                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   455                                  .getVerifySetting:  ;ah = 54h
   456                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   457                                  .renameFile:        ;ah = 56h
   458                                  .getSetFileDateTime:;ah = 57h
   459                                  .getsetMallocStrat: ;ah = 58h
   460                                  .getExtendedError:  ;ah = 59h
   461                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   462                                  .createNewFile:     ;ah = 5Bh
   463                                  .lockUnlockFile:    ;ah = 5Ch
   464                                  .getCritErrorInfo:  ;ah = 5Dh
   465                                  .networkServices:   ;ah = 5Eh, do nothing
   466                                  .networkRedirection:;ah = 5Fh, do nothing
   467                                  .trueName:          ;ah = 60h, get fully qualified name
   468                                                      ;ah = 61h, reserved
   469                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   470                                                      ;ah = 63h, reserved
   471                                  .setDriverLookahead:;ah = 64h, reserved
   472                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   473                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   474                                  .setHandleCount:    ;ah = 67h
   475                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   476                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   477                                  .return:
   478 00000194 C3                          ret
   479                                  
   480                                  
   481                                  .dispatchTable:
   482 00000195 [7201000000000000]          dq .simpleTerminate     ;AH = 00H, PROCESS MANAGEMENT
   483 0000019D [7301000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   484 000001A5 [7A01000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   485 000001AD [8101000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   486 000001B5 [8101000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   487 000001BD [8101000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   488 000001C5 [8101000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   489 000001CD [8101000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   490 000001D5 [8101000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   491 000001DD [8201000000000000]          dq .printString         ;AH = 09H, CHAR IO
   492 000001E5 [9401000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   493 000001ED [9401000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   494 000001F5 [9401000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   495 000001FD [9401000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   496 00000205 [9401000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   497 0000020D [9401000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   498 00000215 [9401000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   499 0000021D [9401000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   500 00000225 [9401000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   501 0000022D [9401000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   502 00000235 [9401000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   503 0000023D [9401000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   504 00000245 [9401000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   505 0000024D [9401000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   506 00000255 [9401000000000000]          dq .return              ;AH = 18H, RESERVED
   507 0000025D [9401000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   508 00000265 [9401000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   509 0000026D [9401000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   510 00000275 [9401000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   511 0000027D [9401000000000000]          dq .return              ;AH = 1DH, RESERVED
   512 00000285 [9401000000000000]          dq .return              ;AH = 1EH, RESERVED
   513 0000028D [9401000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   514 00000295 [9401000000000000]          dq .return              ;AH = 20H, RESERVED
   515 0000029D [9401000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   516 000002A5 [9401000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   517 000002AD [9401000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   518 000002B5 [9401000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   519 000002BD [9401000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   520 000002C5 [9401000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   521 000002CD [9401000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   522 000002D5 [9401000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   523 000002DD [9401000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   524 000002E5 [9401000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   525 000002ED [9401000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   526 000002F5 [9401000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   527 000002FD [9401000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   528 00000305 [9401000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   529 0000030D [9401000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   530 00000315 [9401000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   531 0000031D [9401000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   532 00000325 [9401000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   533 0000032D [9401000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   534 00000335 [9401000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   535 0000033D [9401000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   536 00000345 [9401000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   537 0000034D [9401000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   538 00000355 [9401000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   539 0000035D [9401000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   540 00000365 [9401000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   541 0000036D [9401000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   542 00000375 [9401000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   543 0000037D [9401000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   544 00000385 [9401000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   545 0000038D [9401000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   546 00000395 [9401000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   547 0000039D [9401000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   548 000003A5 [9401000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   549 000003AD [9401000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   550 000003B5 [9401000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   551 000003BD [9401000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   552 000003C5 [9401000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   553 000003CD [9401000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   554 000003D5 [9401000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   555 000003DD [9401000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   556 000003E5 [9401000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   557 000003ED [9401000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   558 000003F5 [9401000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   559 000003FD [9401000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   560 00000405 [9401000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   561 0000040D [9401000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   562 00000415 [9401000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   563 0000041D [9401000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   564 00000425 [9401000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   565 0000042D [9401000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   566 00000435 [9401000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   567 0000043D [9401000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   568 00000445 [9401000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   569 0000044D [9401000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   570 00000455 [9401000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   571 0000045D [9401000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   572 00000465 [9401000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   573 0000046D [9401000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   574 00000475 [9401000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   575 0000047D [9401000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   576 00000485 [9401000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   577 0000048D [9401000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   578 00000495 [9401000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   579 0000049D [9401000000000000]          dq .return              ;AH = 61H, RESERVED
   580 000004A5 [9401000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   581 000004AD [9401000000000000]          dq .return              ;AH = 63H, RESERVED
   582 000004B5 [9401000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   583 000004BD [9401000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   584 000004C5 [9401000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   585 000004CD [9401000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   586 000004D5 [9401000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   587 000004DD [9401000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   588                                  dispatchTableL  equ $ - .dispatchTable 
   589                                  
   590                                  terminateHandler:   ;Int 42h
   591                                  ctrlCHandler:       ;Int 43h
   592                                  critErrorHandler:   ;Int 44h
   593                                  ;User Stack in usage here, must be swapped to before this is called
   594                                  ;Entered with:  
   595                                  ;               AH = Critical Error Bitfield
   596                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   597                                  ;               Bit 6 - Reserved
   598                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   599                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   600                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   601                                  ;               Bits [2-1] = Affected Disk Error
   602                                  ;                     0 0   DOS area
   603                                  ;                     0 1   FAT area
   604                                  ;                     1 0   Directory area
   605                                  ;                     1 1   Data area
   606                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   607                                  ;               AL  = Failing drive number if AH[7] = 0
   608                                  ;               DIL = Error code for errorMsg
   609                                  ;               RSI = EA of Device Header for which device the error occured
   610                                  ;Return:
   611                                  ;               AL = 0 - Ignore the Error       (Ignore)
   612                                  ;                  = 1 - Retry the Operation    (Retry)
   613                                  ;                  = 2 - Terminate the Program  (Abort)
   614                                  ;                  = 3 - Fail the DOS call      (Fail)
   615 000004E5 53                          push rbx
   616 000004E6 51                          push rcx
   617 000004E7 52                          push rdx
   618 000004E8 57                          push rdi
   619 000004E9 56                          push rsi
   620 000004EA FC                          cld         ;Make String ops go forward
   621                                  
   622 000004EB 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   623 000004EE 488D155E020000              lea rdx, qword [.crlf]
   624 000004F5 B409                        mov ah, 09h ;Print String
   625 000004F7 CD41                        int 41h     ;Call DOS to print CRLF part of message
   626                                  
   627 000004F9 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   628 000004FF B90C000000                  mov ecx, 0Ch
   629 00000504 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   630 00000506 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   631 00000509 480FB7FF                    movzx rdi, di
   632 0000050D 4889FA                      mov rdx, rdi    ;Copy error code
   633 00000510 48C1E704                    shl rdi, 4  ;Multiply by 16
   634 00000514 48D1E2                      shl rdx, 1  ;Multiply by 2
   635 00000517 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   636 0000051A 488D1523010000              lea rdx, qword [.errorMsgTable]
   637 00000521 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   638 00000525 B409                        mov ah, 09h ;Print String
   639 00000527 CD41                        int 41h     ;Call DOS to print first part of message
   640                                  
   641 00000529 488D1505020000              lea rdx, qword [.readmsg]
   642 00000530 488D3D0D020000              lea rdi, qword [.writemsg]
   643 00000537 F6C701                      test bh, 1  ;Bit 0 is set if write operation
   644 0000053A 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   645 0000053E B409                        mov ah, 09h ;Print String
   646 00000540 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   647                                  
   648 00000542 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   649 00000545 0F85DF000000                jnz .charError
   650                                  ;Disk error continues here
   651 0000054B 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   652 00000552 B409                        mov ah, 09h
   653 00000554 CD41                        int 41h
   654 00000556 88DA                        mov dl, bl  ;Get zero based drive number into dl
   655 00000558 80C241                      add dl, "A" ;Add ASCII code
   656 0000055B B402                        mov ah, 02h ;Print char in dl
   657 0000055D CD41                        int 41h
   658                                  .userInput:
   659 0000055F 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   660 00000566 B409                        mov ah, 09h
   661 00000568 CD41                        int 41h
   662                                  ;Abort, Retry, Ignore, Fail is word order
   663                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   664                                  .userAbort:
   665                                  ;Abort is always an option
   666 0000056A 488D15E5010000              lea rdx, qword [.abortmsg]
   667 00000571 B409                        mov ah, 09h
   668 00000573 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   669                                  .userRetry:
   670 00000575 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   671 00000578 7416                        jz .userIgnore    ;If clear, dont print message
   672 0000057A 488D15ED010000              lea rdx, qword [.betweenMsg]
   673 00000581 B409                        mov ah, 09h
   674 00000583 CD41                        int 41h
   675 00000585 488D15D7010000              lea rdx, qword [.retrymsg]
   676 0000058C B409                        mov ah, 09h
   677 0000058E CD41                        int 41h
   678                                  .userIgnore:
   679 00000590 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   680 00000593 7416                        jz .userFail
   681 00000595 488D15D2010000              lea rdx, qword [.betweenMsg]
   682 0000059C B409                        mov ah, 09h
   683 0000059E CD41                        int 41h
   684 000005A0 488D15B5010000              lea rdx, qword [.ignoremsg]
   685 000005A7 B409                        mov ah, 09h
   686 000005A9 CD41                        int 41h
   687                                  .userFail:
   688 000005AB F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   689 000005AE 7416                        jz .userMsgEnd
   690 000005B0 488D15B7010000              lea rdx, qword [.betweenMsg]
   691 000005B7 B409                        mov ah, 09h
   692 000005B9 CD41                        int 41h
   693 000005BB 488D15A7010000              lea rdx, qword [.failmsg]
   694 000005C2 B409                        mov ah, 09h
   695 000005C4 CD41                        int 41h
   696                                  .userMsgEnd:
   697 000005C6 488D15A4010000              lea rdx, qword [.endMsg]
   698 000005CD B409                        mov ah, 09h
   699 000005CF CD41                        int 41h
   700                                  ;Get user input now 
   701 000005D1 31C9                        xor ecx, ecx  ;4 Possible Responses
   702 000005D3 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   703 000005DA B401                        mov ah, 01h ;STDIN without Console Echo
   704 000005DC CD41                        int 41h ;Get char in al
   705 000005DE 3C61                        cmp al, "a" ;Chack if lowercase
   706 000005E0 7202                        jb .uip1    ;If the value is below, ignore subtraction
   707 000005E2 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   708                                  .uip1:
   709 000005E4 AE                          scasb   ;Compare char to list, offset gives return code
   710 000005E5 740F                        je .validInput  ;If they are equal, ecx has return code
   711 000005E7 FFC1                        inc ecx
   712 000005E9 81F904000000                cmp ecx, 4
   713 000005EF 75F3                        jne .uip1
   714 000005F1 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   715                                  .validInput:
   716 000005F6 88C8                        mov al, cl  ;Move the offset into .responses into al
   717                                  ;Now check if the input is permitted
   718 000005F8 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   719 000005FA 7427                        je .cehExit
   720 000005FC 84C0                        test al, al ;Check if 0 => Ignore
   721 000005FE 740F                        je .viIgnore
   722 00000600 3C01                        cmp al, 1   ;Check if 1 => Retry
   723 00000602 7416                        je .viRetry
   724                                  .viFail:    ;Fallthrough for fail (al = 3)
   725 00000604 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   726 00000607 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   727 0000060D EB14                        jmp short .cehExit
   728                                  .viIgnore:
   729 0000060F F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   730 00000612 0F8447FFFFFF                jz .userInput
   731 00000618 EB09                        jmp short .cehExit
   732                                  .viRetry:
   733 0000061A F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   734 0000061D 0F843CFFFFFF                jz .userInput
   735                                  .cehExit:
   736 00000623 5E                          pop rsi
   737 00000624 5F                          pop rdi
   738 00000625 5A                          pop rdx
   739 00000626 59                          pop rcx
   740 00000627 5B                          pop rbx
   741 00000628 48CF                        iretq
   742                                  .charError:
   743 0000062A B908000000                  mov ecx, 8  ;8 chars in device name
   744 0000062F 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   745                                  .ce1:
   746 00000636 AC                          lodsb   ;Get a string char into al and inc rsi
   747 00000637 88C2                        mov dl, al  ;Move char into dl
   748 00000639 B402                        mov ah, 02h
   749 0000063B CD41                        int 41h ;Print char
   750 0000063D E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   751 0000063F E91BFFFFFF                  jmp .userInput
   752                                  
   753                                  .errorMsgTable: ;Each table entry is 18 chars long
   754 00000644 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   754 0000064D 746563742024202020 
   755 00000656 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   755 0000065F 6E6974202420202020 
   756 00000668 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   756 00000671 202420202020202020 
   757 0000067A 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   757 00000683 6F6D6D616E64202420 
   758 0000068C 446174612024202020-                 db "Data $            "       ;Error 4
   758 00000695 202020202020202020 
   759 0000069E 426164205265717565-                 db "Bad Request $     "       ;Error 5
   759 000006A7 737420242020202020 
   760 000006B0 5365656B2024202020-                 db "Seek $            "       ;Error 6
   760 000006B9 202020202020202020 
   761 000006C2 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   761 000006CB 656469612024202020 
   762 000006D4 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   762 000006DD 7420466F756E642024 
   763 000006E6 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   763 000006EF 706572202420202020 
   764 000006F8 577269746520466175-                 db "Write Fault $     "       ;Error A
   764 00000701 6C7420242020202020 
   765 0000070A 52656164204661756C-                 db "Read Fault $      "       ;Error B
   765 00000713 742024202020202020 
   766 0000071C 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   766 00000725 61696C757265202420 
   767                                  
   768 0000072E 64726976652024          .drive      db "drive $"
   769 00000735 6572726F7220726561-     .readmsg    db "error reading $"
   769 0000073E 64696E672024       
   770 00000744 6572726F7220777269-     .writemsg   db "error writing $"
   770 0000074D 74696E672024       
   771 00000753 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   772 00000756 41626F727424            .abortmsg   db "Abort$" 
   773 0000075C 49676E6F726524          .ignoremsg  db "Ignore$"
   774 00000763 526574727924            .retrymsg   db "Retry$"
   775 00000769 4661696C24              .failmsg    db "Fail$"
   776 0000076E 2C2024                  .betweenMsg db ", $"
   777 00000771 3F2024                  .endMsg     db "? $"
   778 00000774 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   779                                  absDiskRead:        ;Int 45h
   780                                  ;al = Drive number
   781                                  ;rbx = Memory Buffer address
   782                                  ;ecx = Number of sectors to read (max 255 for now)
   783                                  ;rdx = Start LBA to read from
   784 00000778 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   785 0000077C 8A80[3A0D0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   786 00000782 4891                        xchg rax, rcx
   787 00000784 4887CA                      xchg rcx, rdx
   788 00000787 B482                        mov ah, 82h
   789 00000789 CD33                        int 33h
   790 0000078B 48CF                        iretq
   791                                  absDiskWrite:       ;Int 46h
   792 0000078D 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   793 00000791 8A80[3A0D0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   794 00000797 4891                        xchg rax, rcx
   795 00000799 4887CA                      xchg rcx, rdx
   796 0000079C B483                        mov ah, 83h
   797 0000079E CD33                        int 33h
   798 000007A0 48CF                        iretq
   799                                  terminateResident:  ;Int 47h
   800                                  inDosHandler:       ;Int 48h
   801                                  ;Called when DOS idle
   802 000007A2 48CF                        iretq
   803                                  fastOutput:         ;Int 49h
   804                                  ;Called with char to transfer in al
   805 000007A4 50                          push rax
   806 000007A5 B40E                        mov ah, 0Eh
   807 000007A7 CD30                        int 30h
   808 000007A9 58                          pop rax
   809 000007AA 48CF                        iretq
   810                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   811 000007AC 48CF                        iretq
   812                                  multiplex:          ;Int 4Fh, kept as iretq for now
   813 000007AE 48CF                        iretq
   814                                  ;-----------------------------------:
   815                                  ;          Driver routines          :
   816                                  ;-----------------------------------:
   817                                  drivers:
   818                                  conHdr:
   819 000007B0 [D207000000000000]          dq auxHdr
   820 000007B8 1308                        dw 0813h
   821 000007BA [4809000000000000]          dq commonStrat
   822 000007C2 [5F09000000000000]          dq conDriver
   823 000007CA 434F4E2020202020            db "CON     "
   824                                  auxHdr:
   825 000007D2 [F407000000000000]          dq prnHdr
   826 000007DA 0080                        dw 08000h
   827 000007DC [4809000000000000]          dq commonStrat
   828 000007E4 [1A0A000000000000]          dq com1Intr
   829 000007EC 4155582020202020            db "AUX     "
   830                                  prnHdr:
   831 000007F4 [1608000000000000]          dq clkHdr
   832 000007FC 40A0                        dw 0A040h
   833 000007FE [4809000000000000]          dq commonStrat
   834 00000806 [E208000000000000]          dq lpt1Hdr
   835 0000080E 50524E2020202020            db "PRN     "
   836                                  clkHdr:
   837 00000816 [3808000000000000]          dq msdHdr
   838 0000081E 0880                        dw 08008h
   839 00000820 [4809000000000000]          dq commonStrat
   840 00000828 [1A0A000000000000]          dq clkDriver
   841 00000830 434C4F434B242020            db "CLOCK$  "
   842                                  msdHdr:
   843 00000838 [5A08000000000000]          dq com1Hdr
   844 00000840 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   845 00000842 [4809000000000000]          dq commonStrat
   846 0000084A [C50A000000000000]          dq msdDriver
   847 00000852 0000000000000000            db 0,0,0,0,0,0,0,0
   848                                  com1Hdr:
   849 0000085A [7C08000000000000]          dq com2Hdr
   850 00000862 0080                        dw 08000h
   851 00000864 [4809000000000000]          dq commonStrat
   852 0000086C [1A0A000000000000]          dq com1Intr
   853 00000874 434F4D3120202020            db "COM1    "
   854                                  com2Hdr:
   855 0000087C [9E08000000000000]          dq com3Hdr
   856 00000884 0080                        dw 08000h
   857 00000886 [4809000000000000]          dq commonStrat
   858 0000088E [230A000000000000]          dq com2Intr
   859 00000896 434F4D3220202020            db "COM2    "
   860                                  com3Hdr:
   861 0000089E [C008000000000000]          dq com4Hdr
   862 000008A6 0080                        dw 08000h
   863 000008A8 [4809000000000000]          dq commonStrat
   864 000008B0 [2C0A000000000000]          dq com3Intr
   865 000008B8 434F4D3320202020            db "COM3    "
   866                                  com4Hdr:
   867 000008C0 [E208000000000000]          dq lpt1Hdr
   868 000008C8 0080                        dw 08000h
   869 000008CA [4809000000000000]          dq commonStrat
   870 000008D2 [350A000000000000]          dq com4Intr
   871 000008DA 434F4D3420202020            db "COM4    "
   872                                  lpt1Hdr:
   873 000008E2 [0409000000000000]          dq lpt2Hdr
   874 000008EA 40A0                        dw 0A040h
   875 000008EC [4809000000000000]          dq commonStrat
   876 000008F4 [B50A000000000000]          dq lptDriver
   877 000008FC 4C50543120202020            db "LPT1    "
   878                                  lpt2Hdr:
   879 00000904 [2609000000000000]          dq lpt3Hdr
   880 0000090C 40A0                        dw 0A040h
   881 0000090E [4809000000000000]          dq commonStrat
   882 00000916 [B50A000000000000]          dq lptDriver
   883 0000091E 4C50543220202020            db "LPT2    "
   884                                  lpt3Hdr:
   885 00000926 FFFFFFFFFFFFFFFF            dq -1
   886 0000092E 40A0                        dw 0A040h
   887 00000930 [4809000000000000]          dq commonStrat
   888 00000938 [B50A000000000000]          dq lptDriver
   889 00000940 4C50543320202020            dq "LPT3    "
   890                                  
   891                                  commonStrat:
   892                                  ;DOS calls this function with rbx=Ptr to request header
   893 00000948 48891D01000000              mov qword [reqHdrPtr], rbx
   894 0000094F C3                          ret
   895 00000950 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   896                                  
   897                                  nulStrat:
   898 00000958 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   899                                  nulIntr:
   900 0000095E C3                          ret
   901                                  
   902                                  conDriver:
   903 0000095F 50                          push rax
   904 00000960 53                          push rbx
   905 00000961 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   906 00000968 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   907 0000096B 84C0                        test al, al
   908 0000096D 7421                        jz conInit
   909 0000096F 3C04                        cmp al, 4
   910 00000971 744D                        jz conRead
   911 00000973 3C05                        cmp al, 5
   912 00000975 7466                        jz conNondestructiveRead
   913 00000977 3C06                        cmp al, 6
   914 00000979 740C                        jz conExit
   915 0000097B 3C07                        cmp al, 7
   916 0000097D 7471                        jz conFlushInputBuffers
   917 0000097F 3C08                        cmp al, 8
   918 00000981 7479                        jz conWrite
   919 00000983 3C09                        cmp al, 9
   920 00000985 7475                        jz conWrite
   921                                  ;All other cases fall through here
   922                                  conExit:
   923 00000987 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   924 0000098D 5B                          pop rbx
   925 0000098E 58                          pop rax
   926 0000098F C3                          ret
   927                                  conInit:    ;Function 0
   928 00000990 52                          push rdx
   929                                      ;Flush keyboard buffer
   930                                  .ci0:
   931 00000991 B401                        mov ah, 01      ;Get buffer status
   932 00000993 CD36                        int 36h
   933 00000995 7406                        jz .ci1      ;If zero clear => no more keys to read
   934 00000997 30E4                        xor ah, ah
   935 00000999 CD36                        int 36h ;Read key to flush from buffer
   936 0000099B EBF4                        jmp short .ci0
   937                                  .ci1:
   938 0000099D B800050000                  mov eax, 0500h  ;Set page zero as the default page
   939 000009A2 CD30                        int 30h
   940 000009A4 B402                        mov ah, 02h
   941 000009A6 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   942 000009A8 88D7                        mov bh, dl      ;Set cursor for page 0
   943 000009AA CD30                        int 30h
   944 000009AC B707                        mov bh, 07h     ;Grey/Black attribs
   945 000009AE B800060000                  mov eax, 0600h  ;Clear whole screen
   946 000009B3 CD30                        int 30h
   947 000009B5 5A                          pop rdx
   948 000009B6 EBCF                        jmp short conExit
   949                                  conIORead:
   950 000009B8 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   951 000009BE EBC7                        jmp short conExit
   952                                  conRead:    ;Function 4
   953 000009C0 57                          push rdi
   954 000009C1 51                          push rcx
   955 000009C2 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   956 000009C6 31C9                        xor ecx, ecx    ;Zero the char counter
   957                                  .cr1:
   958 000009C8 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   959 000009CB 7409                        je .cre2
   960 000009CD 31C0                        xor eax, eax
   961 000009CF CD36                        int 36h
   962 000009D1 AA                          stosb   ;Store char in al into buffer and inc rdi
   963 000009D2 FFC1                        inc ecx
   964 000009D4 EBF2                        jmp short .cr1
   965                                  .cre2:
   966 000009D6 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   967 000009D9 59                          pop rcx
   968 000009DA 5F                          pop rdi
   969 000009DB EBAA                        jmp short conExit
   970                                  conNondestructiveRead:  ;Function 5
   971 000009DD B401                        mov ah, 01h     ;Get key if exists
   972 000009DF CD36                        int 36h
   973 000009E1 7405                        jz .cnr           ;If zero clear => no key, go forwards
   974                                      ;Keystroke available
   975 000009E3 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   976 000009E6 EB9F                        jmp short conExit
   977                                  .cnr: ;No keystroke available
   978 000009E8 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   979 000009EE EB97                        jmp short conExit
   980                                  conFlushInputBuffers:   ;Function 7
   981 000009F0 B401                        mov ah, 01      ;Get buffer status
   982 000009F2 CD36                        int 36h
   983 000009F4 7491                        jz conExit      ;If zero clear => no more keys to read
   984 000009F6 30E4                        xor ah, ah
   985 000009F8 CD36                        int 36h ;Read key to flush from buffer
   986 000009FA EBF4                        jmp short conFlushInputBuffers
   987                                  conWrite:   ;Function 8 and 9
   988 000009FC 56                          push rsi
   989 000009FD 51                          push rcx
   990 000009FE 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   991 00000A02 31C9                        xor ecx, ecx    ;Zero the char counter
   992                                  .cw1: 
   993 00000A04 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   994 00000A07 7407                        je .cw2
   995 00000A09 AC                          lodsb   ;Get char into al, and inc rsi
   996 00000A0A CD49                        int 49h ;Fast print char
   997 00000A0C FFC1                        inc ecx
   998 00000A0E EBF4                        jmp short .cw1 ;keep printing until all chars printed
   999                                  .cw2:
  1000 00000A10 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1001 00000A13 59                          pop rcx
  1002 00000A14 5E                          pop rsi
  1003 00000A15 E96DFFFFFF                  jmp conExit
  1004                                  
  1005                                  clkDriver:
  1006                                  
  1007                                  comDriver:
  1008                                  com1Intr:
  1009 00000A1A C6059300000000              mov byte [comDevice], 0
  1010 00000A21 EB19                        jmp short comIntr
  1011                                  com2Intr:
  1012 00000A23 C6058A00000001              mov byte [comDevice], 1
  1013 00000A2A EB10                        jmp short comIntr
  1014                                  com3Intr:
  1015 00000A2C C6058100000002              mov byte [comDevice], 2
  1016 00000A33 EB07                        jmp short comIntr
  1017                                  com4Intr:
  1018 00000A35 C6057800000003              mov byte [comDevice], 3
  1019                                  comIntr:
  1020 00000A3C 50                          push rax
  1021 00000A3D 53                          push rbx
  1022 00000A3E 51                          push rcx
  1023 00000A3F 52                          push rdx
  1024 00000A40 56                          push rsi
  1025 00000A41 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
  1026 00000A48 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
  1027 00000A4B 3C04                        cmp al, 4
  1028 00000A4D 7418                        jz comRead
  1029 00000A4F 3C05                        cmp al, 5
  1030 00000A51 7439                        jz comNondestructiveRead
  1031 00000A53 3C08                        cmp al, 8
  1032 00000A55 743D                        jz comWrite
  1033 00000A57 3C09                        cmp al, 9
  1034 00000A59 7439                        jz comWrite
  1035                                  ;All other cases fall through here
  1036                                  comExit:
  1037 00000A5B 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
  1038 00000A61 5E                          pop rsi
  1039 00000A62 5A                          pop rdx
  1040 00000A63 59                          pop rcx
  1041 00000A64 5B                          pop rbx
  1042 00000A65 58                          pop rax
  1043 00000A66 C3                          ret
  1044                                  comRead:
  1045 00000A67 57                          push rdi
  1046 00000A68 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
  1047 00000A6C 31C9                        xor ecx, ecx    ;Zero the char counter
  1048                                  .cr1:
  1049 00000A6E 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1050 00000A71 7413                        je .cre2
  1051 00000A73 B802000000                  mov eax, 02h    ;Recieve 
  1052 00000A78 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
  1053 00000A7F CD34                        int 34h ;Recieve Char
  1054 00000A81 AA                          stosb   ;Store char in al into buffer and inc rdi
  1055 00000A82 FFC1                        inc ecx
  1056 00000A84 EBE8                        jmp short .cr1
  1057                                  .cre2:
  1058 00000A86 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1059 00000A89 5F                          pop rdi
  1060 00000A8A EBCF                        jmp short comExit
  1061                                  comNondestructiveRead:
  1062 00000A8C 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
  1063 00000A92 EBC7                        jmp short comExit
  1064                                  comWrite:
  1065 00000A94 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1066 00000A98 31C9                        xor ecx, ecx    ;Zero the char counter
  1067                                  .cw1: 
  1068 00000A9A 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1069 00000A9D 7410                        je .cw2
  1070 00000A9F AC                          lodsb   ;Get char into al, and inc rsi
  1071 00000AA0 B401                        mov ah, 01h ;Move function number into ah
  1072 00000AA2 668B150B000000              mov dx, word [comDevice]
  1073 00000AA9 CD34                        int 34h ;Transmit char
  1074 00000AAB FFC1                        inc ecx
  1075 00000AAD EBEB                        jmp short .cw1 ;keep printing until all chars printed
  1076                                  .cw2:
  1077 00000AAF 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1078 00000AB2 EBA7                        jmp short comExit
  1079 00000AB4 00                      comDevice   db 0
  1080                                  
  1081                                  lptDriver:    ;Drivers for LPT 1, 2, 3
  1082 00000AB5 57                          push rdi
  1083 00000AB6 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
  1084 00000ABD 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
  1085 00000AC3 5F                          pop rdi
  1086 00000AC4 C3                          ret
  1087                                  
  1088                                  msdDriver:
  1089 00000AC5 50                          push rax
  1090 00000AC6 53                          push rbx
  1091 00000AC7 51                          push rcx
  1092 00000AC8 52                          push rdx
  1093 00000AC9 56                          push rsi
  1094 00000ACA 57                          push rdi
  1095 00000ACB 55                          push rbp
  1096 00000ACC 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1097 00000AD3 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1098 00000AD6 3C18                        cmp al, 24  ;Check cmd num is valid
  1099 00000AD8 776C                        ja .msdError
  1100 00000ADA 84C0                        test al, al
  1101 00000ADC 7476                        jz .msdInit
  1102 00000ADE 3C01                        cmp al, 01
  1103 00000AE0 0F8409010000                jz .msdMedChk
  1104 00000AE6 3C02                        cmp al, 02
  1105 00000AE8 0F8442010000                jz .msdBuildBPB
  1106 00000AEE 3C03                        cmp al, 03
  1107 00000AF0 0F847B010000                jz .msdIOCTLRead
  1108 00000AF6 3C04                        cmp al, 04
  1109 00000AF8 0F8478010000                jz .msdRead
  1110 00000AFE 3C08                        cmp al, 08
  1111 00000B00 0F8482010000                jz .msdWrite
  1112 00000B06 3C09                        cmp al, 09
  1113 00000B08 0F848C010000                jz .msdWriteVerify
  1114 00000B0E 3C0C                        cmp al, 12
  1115 00000B10 0F849D010000                jz .msdIOCTLWrite
  1116 00000B16 3C0D                        cmp al, 13
  1117 00000B18 0F849A010000                jz .msdDevOpen
  1118 00000B1E 3C0E                        cmp al, 14
  1119 00000B20 0F84A2010000                jz .msdDevClose
  1120 00000B26 3C0F                        cmp al, 15
  1121 00000B28 0F84AA010000                jz .msdRemovableMedia
  1122 00000B2E 3C13                        cmp al, 19
  1123 00000B30 0F84C0010000                jz .msdGenericIOCTL
  1124 00000B36 3C17                        cmp al, 23
  1125 00000B38 0F84BD010000                jz .msdGetLogicalDev
  1126 00000B3E 3C18                        cmp al, 24
  1127 00000B40 0F84C3010000                jz .msdSetLogicalDev
  1128                                  .msdError:
  1129                                  .msdDriverExit:
  1130 00000B46 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1131 00000B4C 5D                          pop rbp
  1132 00000B4D 5F                          pop rdi
  1133 00000B4E 5E                          pop rsi
  1134 00000B4F 5A                          pop rdx
  1135 00000B50 59                          pop rcx
  1136 00000B51 5B                          pop rbx
  1137 00000B52 58                          pop rax
  1138 00000B53 C3                          ret
  1139                                  .msdInit:            ;Function 0
  1140 00000B54 CD31                        int 31h ;Get number of Int 33h devices in r8b
  1141 00000B56 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1142 00000B5A 4489C0                      mov eax, r8d
  1143 00000B5D 3C01                        cmp al, 1
  1144 00000B5F 7702                        ja .mi1
  1145 00000B61 FEC0                        inc al ;Make it two
  1146                                  .mi1:
  1147 00000B63 BA05000000                  mov edx, 5
  1148 00000B68 39D0                        cmp eax, edx
  1149 00000B6A 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1150 00000B6D 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1151 00000B73 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1152 00000B76 440005(A9000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1153 00000B7D 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1154 00000B7F 488D3DE6010000              lea rdi, qword [.msdBPBblks]
  1155 00000B86 53                          push rbx
  1156                                  .mi2:
  1157 00000B87 89EA                        mov edx, ebp
  1158 00000B89 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1159 00000B90 31C9                        xor ecx, ecx    ;Sector 0
  1160 00000B92 B801820000                  mov eax, 8201h       ;Read 1 sector
  1161 00000B97 CD33                        int 33h
  1162 00000B99 724E                        jc .msdInitError
  1163                                  
  1164 00000B9B 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1165 00000BA2 B90F000000                  mov ecx, bpbEx_size/8
  1166 00000BA7 F348A5                      rep movsq   ;Move the BPB data into the right block
  1167                                  
  1168 00000BAA FFC5                        inc ebp
  1169 00000BAC 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1170 00000BAF 75D6                        jne .mi2  ;No? Go again
  1171                                  
  1172 00000BB1 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1173 00000BB8 488D15AD010000              lea rdx, qword [.msdBPBblks]
  1174                                  .mi3:
  1175 00000BBF 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1176 00000BC2 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1177 00000BC9 FFCD                        dec ebp
  1178 00000BCB 75F2                        jnz .mi3  ;If not zero yet, go again
  1179                                  
  1180 00000BCD 5B                          pop rbx
  1181 00000BCE 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1182 00000BD5 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1183 00000BD9 488D15E4030000              lea rdx, qword [driverDataPtr]
  1184 00000BE0 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1185 00000BE4 E95DFFFFFF                  jmp .msdDriverExit
  1186                                  .msdInitError:
  1187 00000BE9 5B                          pop rbx
  1188 00000BEA E957FFFFFF                  jmp .msdDriverExit
  1189                                  .msdMedChk:          ;Function 1
  1190                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1191                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1192                                  ; suffice.
  1193 00000BEF 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1194 00000BF4 8A90[3A0D0000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1195 00000BFA F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1196 00000BFD 7528                        jnz .mmcNoChange
  1197                                  ;Now we test Media Descriptor
  1198 00000BFF 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1199 00000C02 488B3CC5[440D0000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1200 00000C0A 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1201 00000C0D 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1202 00000C10 740C                        je .mmcUnsure
  1203                                  .mmcChange: ;Fail safe, always assume the device has changed
  1204 00000C12 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1205 00000C16 48C7430F[300D0000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
  1206                                  .mmcUnsure:
  1207 00000C1E C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1208 00000C22 E91FFFFFFF                  jmp .msdDriverExit
  1209                                  .mmcNoChange:
  1210 00000C27 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1211 00000C2B E916FFFFFF                  jmp .msdDriverExit
  1212                                  
  1213                                  .msdBuildBPB:        ;Function 2
  1214 00000C30 4889DE                      mov rsi, rbx
  1215 00000C33 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1216 00000C38 8A90[3A0D0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1217 00000C3E 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1218 00000C42 31C9                        xor ecx, ecx    ;Read Sector 0
  1219 00000C44 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1220 00000C49 CD33                        int 33h
  1221 00000C4B 7224                        jc .mbbpbError
  1222 00000C4D 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1223 00000C50 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1224 00000C55 488B3CC5[440D0000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1225 00000C5D 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1226 00000C60 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1227 00000C64 B90F000000                  mov ecx, bpbEx_size/8
  1228 00000C69 F348A5                      rep movsq   ;Move the BPB data into the right space
  1229 00000C6C E9D5FEFFFF                  jmp .msdDriverExit
  1230                                  .mbbpbError:
  1231                                  .msdIOCTLRead:       ;Function 3, returns done
  1232 00000C71 E9D0FEFFFF                  jmp .msdDriverExit
  1233                                  .msdRead:            ;Function 4
  1234 00000C76 4889DD                      mov rbp, rbx
  1235 00000C79 B482                        mov ah, 82h ;LBA Read Sectors
  1236 00000C7B E897000000                  call .msdBlkIOCommon
  1237 00000C80 4889EB                      mov rbx, rbp
  1238 00000C83 E9BEFEFFFF                  jmp .msdDriverExit
  1239                                  .msdWrite:           ;Function 8
  1240 00000C88 4889DD                      mov rbp, rbx
  1241 00000C8B B483                        mov ah, 83h ;LBA Write Sectors
  1242 00000C8D E885000000                  call .msdBlkIOCommon
  1243 00000C92 4889EB                      mov rbx, rbp
  1244 00000C95 E9ACFEFFFF                  jmp .msdDriverExit
  1245                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1246 00000C9A 4889DD                      mov rbp, rbx
  1247 00000C9D B483                        mov ah, 83h ;LBA Write Sectors
  1248 00000C9F E873000000                  call .msdBlkIOCommon
  1249 00000CA4 B484                        mov ah, 84h ;LBA Verify Sectors
  1250 00000CA6 E86C000000                  call .msdBlkIOCommon
  1251 00000CAB 4889EB                      mov rbx, rbp
  1252 00000CAE E993FEFFFF                  jmp .msdDriverExit
  1253                                  .msdIOCTLWrite:      ;Function 12, returns done
  1254 00000CB3 E98EFEFFFF                  jmp .msdDriverExit
  1255                                  .msdDevOpen:         ;Function 13
  1256 00000CB8 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1257 00000CBD FE80[3F0D0000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1258 00000CC3 E97EFEFFFF                  jmp .msdDriverExit
  1259                                  .msdDevClose:        ;Function 14
  1260 00000CC8 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1261 00000CCD FE88[3F0D0000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1262 00000CD3 E96EFEFFFF                  jmp .msdDriverExit
  1263                                  .msdRemovableMedia:  ;Function 15
  1264 00000CD8 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1265 00000CDD 8A80[3A0D0000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1266 00000CE3 A880                        test al, 80h
  1267 00000CE5 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1268 00000CEB 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
  1269 00000CF1 E950FEFFFF                  jmp .msdDriverExit
  1270                                  .msdGenericIOCTL:    ;Function 19
  1271 00000CF6 E94BFEFFFF                  jmp .msdDriverExit
  1272                                  .msdGetLogicalDev:   ;Function 23
  1273 00000CFB 8A0538000000                mov al, byte [.msdCurDev]
  1274 00000D01 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1275 00000D04 E93DFEFFFF                  jmp .msdDriverExit
  1276                                  .msdSetLogicalDev:   ;Function 24
  1277 00000D09 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1278 00000D0C 880527000000                mov byte [.msdCurDev], al
  1279 00000D12 E92FFEFFFF                  jmp .msdDriverExit
  1280                                  
  1281                                  .msdBlkIOCommon:  ;Does block IO
  1282                                  ;Called with rbp containing old rbx value and ah with function number
  1283                                  ;Error handled by caller
  1284 00000D17 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1285 00000D1C 8A90[3A0D0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1286 00000D22 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1287 00000D26 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
  1288 00000D29 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1289 00000D2D CD33                        int 33h
  1290 00000D2F C3                          ret
  1291                                  
  1292 00000D30 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1293                                  ;LASTDRIVE default is 5
  1294 00000D39 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1295                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1296 00000D3A 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1297 00000D3F 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1298 00000D44 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1298 00000D4D 000000000000000000-
  1298 00000D56 000000000000000000-
  1298 00000D5F 000000000000000000-
  1298 00000D68 00000000           
  1299 00000D6C 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1299 00000D75 000000000000000000-
  1299 00000D7E 000000000000000000-
  1299 00000D87 000000000000000000-
  1299 00000D90 000000000000000000-
  1299 00000D99 000000000000000000-
  1299 00000DA2 000000000000000000-
  1299 00000DAB 000000000000000000-
  1299 00000DB4 000000000000000000-
  1299 00000DBD 000000000000000000-
  1299 00000DC6 000000000000000000-
  1299 00000DCF 000000000000000000-
  1299 00000DD8 000000000000000000-
  1299 00000DE1 000000000000000000-
  1299 00000DEA 000000000000000000-
  1299 00000DF3 000000000000000000-
  1299 00000DFC 000000000000000000-
  1299 00000E05 000000000000000000-
  1299 00000E0E 000000000000000000-
  1299 00000E17 000000000000000000-
  1299 00000E20 000000000000000000-
  1299 00000E29 000000000000000000-
  1299 00000E32 000000000000000000-
  1299 00000E3B 000000000000000000-
  1299 00000E44 000000000000000000-
  1299 00000E4D 000000000000000000-
  1299 00000E56 000000000000000000-
  1299 00000E5F 000000000000000000-
  1299 00000E68 000000000000000000-
  1299 00000E71 000000000000000000-
  1299 00000E7A 000000000000000000-
  1299 00000E83 000000000000000000-
  1299 00000E8C 000000000000000000-
  1299 00000E95 000000000000000000-
  1299 00000E9E 000000000000000000-
  1299 00000EA7 000000000000000000-
  1299 00000EB0 000000000000000000-
  1299 00000EB9 000000000000000000-
  1299 00000EC2 000000000000000000-
  1299 00000ECB 000000000000000000-
  1299 00000ED4 000000000000000000-
  1299 00000EDD 000000000000000000-
  1299 00000EE6 000000000000000000-
  1299 00000EEF 000000000000000000-
  1299 00000EF8 000000000000000000-
  1299 00000F01 000000000000000000-
  1299 00000F0A 000000000000000000-
  1299 00000F13 000000000000000000-
  1299 00000F1C 000000000000000000-
  1299 00000F25 000000000000000000-
  1299 00000F2E 000000000000000000-
  1299 00000F37 000000000000000000-
  1299 00000F40 000000000000000000-
  1299 00000F49 000000000000000000-
  1299 00000F52 000000000000000000-
  1299 00000F5B 000000000000000000-
  1299 00000F64 000000000000000000-
  1299 00000F6D 000000000000000000-
  1299 00000F76 000000000000000000-
  1299 00000F7F 000000000000000000-
  1299 00000F88 000000000000000000-
  1299 00000F91 000000000000000000-
  1299 00000F9A 000000000000000000-
  1299 00000FA3 000000000000000000-
  1299 00000FAC 000000000000000000-
  1299 00000FB5 000000000000000000-
  1299 00000FBE 000000000000       
  1300                                  
  1301                                  driverDataPtr:
>>>>>>> parent of c164ed9 (Moved the data segment to a new file "dosSeg.asm")
