     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Unit number byte (Block)
    18                              <1> drvHdrLen equ $ - drvHdr
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1>     
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> 
    74                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    75                              <1> 
    76 00000000 ??????              <1>     .jmpBoot                resb 3 
    77 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
    78 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
    79 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
    80 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
    81 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
    82 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
    83 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
    84 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
    85 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    86 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
    87 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
    88 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
    89 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    90 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
    91 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
    92 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
    93 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
    94 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
    95                              <1> bpbExLen    equ $ - bpbEx
    96                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> 
    72                              <1> ;------------------------------------------------------------------------;
    73                              <1> ; The SFT is a way to allow applications to open file handles to files 
    74                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    75                              <1> ; under the first header, and then a second header will be linked to the 
    76                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    77                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    78                              <1> ; using the FCBS= command. Default FCBS=5.
    79                              <1> ;
    80                              <1> ; A file handle describes the file, and the location within the file that
    81                              <1> ; we are reading. The file handle can be manipulated without the file
    82                              <1> ; being in memory, thus allowing the user to access data without needing 
    83                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    84                              <1> ; accessing devices, by treating them as files with their drivers 
    85                              <1> ; responding and translating the manipulations of the file handle itself.
    86                              <1> ; Neither the driver nor the application should see or use the SFT for
    87                              <1> ; the handle, as it is subject to change (and will change when file 
    88                              <1> ; sharing provisions are included). The DOS will make requests to the 
    89                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    90                              <1> ; track of the information in the SFT entry for that handle. 
    91                              <1> ;
    92                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    93                              <1> ; can point to the same file. It all depends on what the applications 
    94                              <1> ; want to do with the File.
    95                              <1> ;
    96                              <1> ; !!!!IMPORTANT!!!!
    97                              <1> ; Currently there are plans for File Sharing, but I include minimal 
    98                              <1> ; provisions for it. I really just wanna get a DOS out the door.
    99                              <1> ;
   100                              <1> ;Each SFT may look like this:
   101                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   102                              <1> ;            |                |
   103                              <1> ;       wNumFiles*sft    wNumFiles*sft
   104                              <1> ;
   105                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   106                              <1> ; System FCBs.
   107                              <1> ;
   108                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   109                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   110                              <1> ;
   111                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   112                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   113                              <1> ;------------------------------------------------------------------------;
   114                              <1> struc sfth   ;System file table header
   115                              <1> ; This is the SFT header.
   116                              <1> ; This structure comes before the start of the first file in the array/table.
   117 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   118 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   119                              <1> endstruc
   120                              <1> 
   121                              <1> struc sft
   122                              <1> ;This is the file struc itself
   123 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   124 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   125 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   126 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   127 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   128 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   129 00000013 ????                <1>     .wTime       resw 1    ;File Time
   130 00000015 ????                <1>     .wDate       resw 1    ;File Date
   131 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   132 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   133 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   134 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   135 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   136 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   137 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   138 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   139                              <1> endstruc
   140                              <1> 
   141                              <1> ;------------------------------------------------------------------------;
   142                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   143                              <1> ; to an internal buffer, and then copying it to the specified location
   144                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   145                              <1> ; another request for the same sector from the same device is made, so 
   146                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   147                              <1> ; size, selected according to the largest detected sector size during 
   148                              <1> ; the initial loadup.
   149                              <1> ;
   150                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   151                              <1> ;
   152                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   153                              <1> ;------------------------------------------------------------------------;
   154                              <1> 
   155                              <1> struc bufferHdr
   156 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   157 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   158 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   159 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   160 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   161 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   162 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   163                              <1> endstruc
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res Dh>                    requestHdr  resb 13    ;The device driver header
    12 00000016 <res 14h>                               resb 20    ;Reserve xtra space for cmd data, with padding
    13 0000002A ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    14 00000032 ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    15 0000003A ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    16 00000042 ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    17 0000004A ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    18                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    19 00000052 ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    20                                      ;                    The last driver loaded with the STDIN bit[0] set
    21 0000005A ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    22 0000005C ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    23 00000064 ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    24 0000006C ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    25 00000074 ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    26 00000076 ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    27 00000077 ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    28 00000078 ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    29 00000079 <res 22h>                   nulDevHdr   resb drvHdrLen
    30                                  
    31                                  
    32 0000009B ??                          inDOS       resb 1    ;Inc on each DOS call, dec when leaving
    33 0000009C ??                          breakFlag   resb 1    ;If set, check for CTRL+C on all DOS calls
    34 0000009D ??                          defaultDrv  resb 1    ;Default, last accessed drive
    35                                  
    36 0000009E <res 148h>                  critStack   resq 41
    37 000001E6 ????????????????            critStakTop resq 1
    38 000001EE <res 638h>                  IOStack     resq 199
    39 00000826 ????????????????            IOStakTop   resq 1
    40 0000082E <res 638h>                  DiskStack   resq 199
    41 00000E66 ????????????????            DiskStakTop resq 1
    42                                      dSegLen     equ     $
    43                                  
    44                                  Segment .text align=1
    45                                  ; We arrive here with the following values in the registers.
    46                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    47                                  ; dx  = Int 33h boot device number
    48                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    49 00000000 55AA                        dw 0AA55h           ;Initial signature
    50 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    51                                  
    52 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    53 0000000F 0F32                        rdmsr
    54 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    55 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    56 00000017 89C7                        mov edi, eax        ;Get the low dword in
    57                                  
    58 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    58 0000001E [00000000]         
    59 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    60 00000025 4881C7[6E0E0000]            add rdi, dSegLen ;Move destination past end of data area
    61 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    62 00000033 B900100000                  mov ecx, 1000h
    63 00000038 F348A5                      rep movsq
    64                                  
    65                                  ;Modify the pointers in nData before putting them in the data area
    66 0000003B 48012D89000000              add qword [nData + drvHdr.nxtPtr], rbp
    67 00000042 48012D8C000000              add qword [nData + drvHdr.strPtr], rbp
    68 00000049 48012D8D000000              add qword [nData + drvHdr.intPtr], rbp
    69                                  ;Copy the Null driver to its location in Sysvars
    70 00000050 B922000000                  mov ecx, drvHdrLen
    71 00000055 488D356F000000              lea rsi, qword [nData]
    72 0000005C 488DBD[79000000]            lea rdi, qword [rbp + nulDevHdr]
    73 00000063 F3A4                        rep movsb   
    74                                  
    75 00000065 6687DB                      xchg bx, bx
    76                                      ;Open NUL
    77 00000068 488D9D[83000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    78 0000006F 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    79 00000072 30C0                        xor al, al
    80 00000074 FFD3                        call rbx
    81                                  
    82                                      ;Open CON
    83 00000076 48BB-                       mov rbx, conDriver
    83 00000078 [1002000000000000] 
    84 00000080 488D5C1D00                  lea rbx, qword [rbp+rbx]
    85 00000085 30C0                        xor al, al
    86 00000087 FFD3                        call rbx
    87                                  
    88                                      ;Open Mass Storage
    89 00000089 48BB-                       mov rbx, msdDriver
    89 0000008B [7603000000000000] 
    90 00000093 488D5C1D00                  lea rbx, qword [rbp+rbx]
    91 00000098 30C0                        xor al, al
    92 0000009A FFD3                        call rbx
    93                                  
    94 0000009C 488D2D12000000              lea rbp, qword [startmsg]   ;Get the absolute address of message
    95 000000A3 B804130000                  mov eax, 1304h
    96 000000A8 CD30                        int 30h
    97                                  l1:
    98 000000AA 6631C0                      xor ax, ax
    99 000000AD CD36                        int 36h
   100 000000AF B40E                        mov ah, 0Eh
   101 000000B1 CD30                        int 30h
   102 000000B3 EBF5                        jmp short l1
   103                                  
   104 000000B5 5374617274696E6720-     startmsg db "Starting SCP/DOS...",0Ah,0Dh,0
   104 000000BE 5343502F444F532E2E-
   104 000000C7 2E0A0D00           
   105                                  nData:
   106 000000CB [6100000000000000]          dq conHdr
   107 000000D3 0480                        dw 08004h
   108 000000D5 [0902000000000000]          dq nulStrat
   109 000000DD [0F02000000000000]          dq nulIntr
   110 000000E5 4E554C2020202020            db "NUL     " ;Default NUL data
   111                                  
   112                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   113                                  ;-----------------------------------:
   114                                  ;       Misc System routines        :
   115                                  ;-----------------------------------:
   116                                  findLRUBuffer: 
   117                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   118                                  ;Input: Nothing
   119                                  ;Output: rbx = Pointer to the buffer to use
   120 00000000 52                          push rdx
   121 00000001 488B1D(5C000000)            mov rbx, qword [bufHeadPtr]
   122 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   123 0000000F 7502                        jne .flb1
   124 00000011 5A                          pop rdx
   125 00000012 C3                          ret
   126                                  .flb1:
   127 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   128 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   129 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   130 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   131 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   132 00000029 488B15(5C000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   133 00000030 48891D(5C000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   134 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   135 0000003A 5A                          pop rdx
   136 0000003B C3                          ret
   137                                  
   138                                  findDPB:
   139                                  ;Finds the DPB for a given drive
   140                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   141                                  ;Output: al = 00, rbx = Pointer to the DPB
   142                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   143 0000003C 488B1D(3A000000)            mov rbx, qword [dpbHeadPtr]
   144                                  .fd1:
   145 00000043 30C0                        xor al, al
   146 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   147 00000047 740F                        je .fd2
   148 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   149 0000004D B0FF                        mov al, -1
   150 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   151 00000056 75EB                        jne .fd1
   152                                  .fd2:
   153 00000058 C3                          ret
   154                                  ;-----------------------------------:
   155                                  ;       File System routines        :
   156                                  ;-----------------------------------:
   157                                  FATprocs:
   158                                  ;-----------------------------------:
   159                                  ;        Interrupt routines         :
   160                                  ;-----------------------------------:
   161                                  int49hHook:    ;Called with char to transfer in al
   162 00000059 50                          push rax
   163 0000005A B40E                        mov ah, 0Eh
   164 0000005C CD30                        int 30h
   165 0000005E 58                          pop rax
   166 0000005F 48CF                        iretq
   167                                  ;-----------------------------------:
   168                                  ;          Driver routines          :
   169                                  ;-----------------------------------:
   170                                  drivers:
   171                                  conHdr:
   172 00000061 [8300000000000000]          dq auxHdr
   173 00000069 1308                        dw 0813h
   174 0000006B [F901000000000000]          dq commonStrat
   175 00000073 [1002000000000000]          dq conDriver
   176 0000007B 434F4E2020202020            db "CON     "
   177                                  auxHdr:
   178 00000083 [A500000000000000]          dq prnHdr
   179 0000008B 0080                        dw 08000h
   180 0000008D [F901000000000000]          dq commonStrat
   181 00000095 [CB02000000000000]          dq com1Intr
   182 0000009D 4155582020202020            db "AUX     "
   183                                  prnHdr:
   184 000000A5 [C700000000000000]          dq clkHdr
   185 000000AD 40A0                        dw 0A040h
   186 000000AF [F901000000000000]          dq commonStrat
   187 000000B7 [9301000000000000]          dq lpt1Hdr
   188 000000BF 50524E2020202020            db "PRN     "
   189                                  clkHdr:
   190 000000C7 [E900000000000000]          dq msdHdr
   191 000000CF 0880                        dw 08008h
   192 000000D1 [F901000000000000]          dq commonStrat
   193 000000D9 [CB02000000000000]          dq clkDriver
   194 000000E1 434C4F434B242020            db "CLOCK$  "
   195                                  msdHdr:
   196 000000E9 [0B01000000000000]          dq com1Hdr
   197 000000F1 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   198 000000F3 [F901000000000000]          dq commonStrat
   199 000000FB [7603000000000000]          dq msdDriver
   200 00000103 0000000000000000            db 0,0,0,0,0,0,0,0
   201                                  com1Hdr:
   202 0000010B [2D01000000000000]          dq com2Hdr
   203 00000113 0080                        dw 08000h
   204 00000115 [F901000000000000]          dq commonStrat
   205 0000011D [CB02000000000000]          dq com1Intr
   206 00000125 434F4D3120202020            db "COM1    "
   207                                  com2Hdr:
   208 0000012D [4F01000000000000]          dq com3Hdr
   209 00000135 0080                        dw 08000h
   210 00000137 [F901000000000000]          dq commonStrat
   211 0000013F [D402000000000000]          dq com2Intr
   212 00000147 434F4D3220202020            db "COM2    "
   213                                  com3Hdr:
   214 0000014F [7101000000000000]          dq com4Hdr
   215 00000157 0080                        dw 08000h
   216 00000159 [F901000000000000]          dq commonStrat
   217 00000161 [DD02000000000000]          dq com3Intr
   218 00000169 434F4D3320202020            db "COM3    "
   219                                  com4Hdr:
   220 00000171 [9301000000000000]          dq lpt1Hdr
   221 00000179 0080                        dw 08000h
   222 0000017B [F901000000000000]          dq commonStrat
   223 00000183 [E602000000000000]          dq com4Intr
   224 0000018B 434F4D3420202020            db "COM4    "
   225                                  lpt1Hdr:
   226 00000193 [B501000000000000]          dq lpt2Hdr
   227 0000019B 40A0                        dw 0A040h
   228 0000019D [F901000000000000]          dq commonStrat
   229 000001A5 [6603000000000000]          dq lptDriver
   230 000001AD 4C50543120202020            db "LPT1    "
   231                                  lpt2Hdr:
   232 000001B5 [D701000000000000]          dq lpt3Hdr
   233 000001BD 40A0                        dw 0A040h
   234 000001BF [F901000000000000]          dq commonStrat
   235 000001C7 [6603000000000000]          dq lptDriver
   236 000001CF 4C50543220202020            db "LPT2    "
   237                                  lpt3Hdr:
   238 000001D7 FFFFFFFFFFFFFFFF            dq -1
   239 000001DF 40A0                        dw 0A040h
   240 000001E1 [F901000000000000]          dq commonStrat
   241 000001E9 [6603000000000000]          dq lptDriver
   242 000001F1 4C50543320202020            dq "LPT3    "
   243                                  
   244                                  commonStrat:
   245                                  ;DOS calls this function with rbx=Ptr to request header
   246 000001F9 48891D01000000              mov qword [reqHdrPtr], rbx
   247 00000200 C3                          ret
   248 00000201 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   249                                  
   250                                  nulStrat:
   251 00000209 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   252                                  nulIntr:
   253 0000020F C3                          ret
   254                                  
   255                                  conDriver:
   256 00000210 50                          push rax
   257 00000211 53                          push rbx
   258 00000212 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   259 00000219 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   260 0000021C 84C0                        test al, al
   261 0000021E 7421                        jz conInit
   262 00000220 3C04                        cmp al, 4
   263 00000222 744D                        jz conRead
   264 00000224 3C05                        cmp al, 5
   265 00000226 7466                        jz conNondestructiveRead
   266 00000228 3C06                        cmp al, 6
   267 0000022A 740C                        jz conExit
   268 0000022C 3C07                        cmp al, 7
   269 0000022E 7471                        jz conFlushInputBuffers
   270 00000230 3C08                        cmp al, 8
   271 00000232 7479                        jz conWrite
   272 00000234 3C09                        cmp al, 9
   273 00000236 7475                        jz conWrite
   274                                  ;All other cases fall through here
   275                                  conExit:
   276 00000238 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   277 0000023E 5B                          pop rbx
   278 0000023F 58                          pop rax
   279 00000240 C3                          ret
   280                                  conInit:    ;Function 0
   281 00000241 52                          push rdx
   282                                      ;Flush keyboard buffer
   283                                  .ci0:
   284 00000242 B401                        mov ah, 01      ;Get buffer status
   285 00000244 CD36                        int 36h
   286 00000246 7406                        jz .ci1      ;If zero clear => no more keys to read
   287 00000248 30E4                        xor ah, ah
   288 0000024A CD36                        int 36h ;Read key to flush from buffer
   289 0000024C EBF4                        jmp short .ci0
   290                                  .ci1:
   291 0000024E B800050000                  mov eax, 0500h  ;Set page zero as the default page
   292 00000253 CD30                        int 30h
   293 00000255 B402                        mov ah, 02h
   294 00000257 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   295 00000259 88D7                        mov bh, dl      ;Set cursor for page 0
   296 0000025B CD30                        int 30h
   297 0000025D B707                        mov bh, 07h     ;Grey/Black attribs
   298 0000025F B800060000                  mov eax, 0600h  ;Clear whole screen
   299 00000264 CD30                        int 30h
   300 00000266 5A                          pop rdx
   301 00000267 EBCF                        jmp short conExit
   302                                  conIORead:
   303 00000269 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   304 0000026F EBC7                        jmp short conExit
   305                                  conRead:    ;Function 4
   306 00000271 57                          push rdi
   307 00000272 51                          push rcx
   308 00000273 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   309 00000277 31C9                        xor ecx, ecx    ;Zero the char counter
   310                                  .cr1:
   311 00000279 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   312 0000027C 7409                        je .cre2
   313 0000027E 31C0                        xor eax, eax
   314 00000280 CD36                        int 36h
   315 00000282 AA                          stosb   ;Store char in al into buffer and inc rdi
   316 00000283 FFC1                        inc ecx
   317 00000285 EBF2                        jmp short .cr1
   318                                  .cre2:
   319 00000287 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   320 0000028A 59                          pop rcx
   321 0000028B 5F                          pop rdi
   322 0000028C EBAA                        jmp short conExit
   323                                  conNondestructiveRead:  ;Function 5
   324 0000028E B401                        mov ah, 01h     ;Get key if exists
   325 00000290 CD36                        int 36h
   326 00000292 7405                        jz .cnr           ;If zero clear => no key, go forwards
   327                                      ;Keystroke available
   328 00000294 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   329 00000297 EB9F                        jmp short conExit
   330                                  .cnr: ;No keystroke available
   331 00000299 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   332 0000029F EB97                        jmp short conExit
   333                                  conFlushInputBuffers:   ;Function 7
   334 000002A1 B401                        mov ah, 01      ;Get buffer status
   335 000002A3 CD36                        int 36h
   336 000002A5 7491                        jz conExit      ;If zero clear => no more keys to read
   337 000002A7 30E4                        xor ah, ah
   338 000002A9 CD36                        int 36h ;Read key to flush from buffer
   339 000002AB EBF4                        jmp short conFlushInputBuffers
   340                                  conWrite:   ;Function 8 and 9
   341 000002AD 56                          push rsi
   342 000002AE 51                          push rcx
   343 000002AF 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   344 000002B3 31C9                        xor ecx, ecx    ;Zero the char counter
   345                                  .cw1: 
   346 000002B5 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   347 000002B8 7407                        je .cw2
   348 000002BA AC                          lodsb   ;Get char into al, and inc rsi
   349 000002BB CD49                        int 49h ;Fast print char
   350 000002BD FFC1                        inc ecx
   351 000002BF EBF4                        jmp short .cw1 ;keep printing until all chars printed
   352                                  .cw2:
   353 000002C1 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   354 000002C4 59                          pop rcx
   355 000002C5 5E                          pop rsi
   356 000002C6 E96DFFFFFF                  jmp conExit
   357                                  
   358                                  clkDriver:
   359                                  
   360                                  comDriver:
   361                                  com1Intr:
   362 000002CB C6059300000000              mov byte [comDevice], 0
   363 000002D2 EB19                        jmp short comIntr
   364                                  com2Intr:
   365 000002D4 C6058A00000001              mov byte [comDevice], 1
   366 000002DB EB10                        jmp short comIntr
   367                                  com3Intr:
   368 000002DD C6058100000002              mov byte [comDevice], 2
   369 000002E4 EB07                        jmp short comIntr
   370                                  com4Intr:
   371 000002E6 C6057800000003              mov byte [comDevice], 3
   372                                  comIntr:
   373 000002ED 50                          push rax
   374 000002EE 53                          push rbx
   375 000002EF 51                          push rcx
   376 000002F0 52                          push rdx
   377 000002F1 56                          push rsi
   378 000002F2 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   379 000002F9 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   380 000002FC 3C04                        cmp al, 4
   381 000002FE 7418                        jz comRead
   382 00000300 3C05                        cmp al, 5
   383 00000302 7439                        jz comNondestructiveRead
   384 00000304 3C08                        cmp al, 8
   385 00000306 743D                        jz comWrite
   386 00000308 3C09                        cmp al, 9
   387 0000030A 7439                        jz comWrite
   388                                  ;All other cases fall through here
   389                                  comExit:
   390 0000030C 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   391 00000312 5E                          pop rsi
   392 00000313 5A                          pop rdx
   393 00000314 59                          pop rcx
   394 00000315 5B                          pop rbx
   395 00000316 58                          pop rax
   396 00000317 C3                          ret
   397                                  comRead:
   398 00000318 57                          push rdi
   399 00000319 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   400 0000031D 31C9                        xor ecx, ecx    ;Zero the char counter
   401                                  .cr1:
   402 0000031F 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   403 00000322 7413                        je .cre2
   404 00000324 B802000000                  mov eax, 02h    ;Recieve 
   405 00000329 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   406 00000330 CD34                        int 34h ;Recieve Char
   407 00000332 AA                          stosb   ;Store char in al into buffer and inc rdi
   408 00000333 FFC1                        inc ecx
   409 00000335 EBE8                        jmp short .cr1
   410                                  .cre2:
   411 00000337 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   412 0000033A 5F                          pop rdi
   413 0000033B EBCF                        jmp short comExit
   414                                  comNondestructiveRead:
   415 0000033D 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
   416 00000343 EBC7                        jmp short comExit
   417                                  comWrite:
   418 00000345 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   419 00000349 31C9                        xor ecx, ecx    ;Zero the char counter
   420                                  .cw1: 
   421 0000034B 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   422 0000034E 7410                        je .cw2
   423 00000350 AC                          lodsb   ;Get char into al, and inc rsi
   424 00000351 B401                        mov ah, 01h ;Move function number into ah
   425 00000353 668B150B000000              mov dx, word [comDevice]
   426 0000035A CD34                        int 34h ;Transmit char
   427 0000035C FFC1                        inc ecx
   428 0000035E EBEB                        jmp short .cw1 ;keep printing until all chars printed
   429                                  .cw2:
   430 00000360 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   431 00000363 EBA7                        jmp short comExit
   432 00000365 00                      comDevice   db 0
   433                                  
   434                                  lptDriver:    ;Drivers for LPT 1, 2, 3
   435 00000366 57                          push rdi
   436 00000367 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
   437 0000036E 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
   438 00000374 5F                          pop rdi
   439 00000375 C3                          ret
   440                                  
   441                                  msdDriver:
   442 00000376 50                          push rax
   443 00000377 53                          push rbx
   444 00000378 51                          push rcx
   445 00000379 52                          push rdx
   446 0000037A 56                          push rsi
   447 0000037B 57                          push rdi
   448 0000037C 55                          push rbp
   449 0000037D 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
   450 00000384 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
   451 00000387 3C18                        cmp al, 24  ;Check cmd num is valid
   452 00000389 776C                        ja .msdError
   453 0000038B 84C0                        test al, al
   454 0000038D 7476                        jz .msdInit
   455 0000038F 3C01                        cmp al, 01
   456 00000391 0F8409010000                jz .msdMedChk
   457 00000397 3C02                        cmp al, 02
   458 00000399 0F8442010000                jz .msdBuildBPB
   459 0000039F 3C03                        cmp al, 03
   460 000003A1 0F847B010000                jz .msdIOCTLRead
   461 000003A7 3C04                        cmp al, 04
   462 000003A9 0F8478010000                jz .msdRead
   463 000003AF 3C08                        cmp al, 08
   464 000003B1 0F8482010000                jz .msdWrite
   465 000003B7 3C09                        cmp al, 09
   466 000003B9 0F848C010000                jz .msdWriteVerify
   467 000003BF 3C0C                        cmp al, 12
   468 000003C1 0F849D010000                jz .msdIOCTLWrite
   469 000003C7 3C0D                        cmp al, 13
   470 000003C9 0F849A010000                jz .msdDevOpen
   471 000003CF 3C0E                        cmp al, 14
   472 000003D1 0F84A2010000                jz .msdDevClose
   473 000003D7 3C0F                        cmp al, 15
   474 000003D9 0F84AA010000                jz .msdRemovableMedia
   475 000003DF 3C13                        cmp al, 19
   476 000003E1 0F84C0010000                jz .msdGenericIOCTL
   477 000003E7 3C17                        cmp al, 23
   478 000003E9 0F84B8010000                jz .msdGetLogicalDev
   479 000003EF 3C18                        cmp al, 24
   480 000003F1 0F84BE010000                jz .msdSetLogicalDev
   481                                  .msdError:
   482                                  .msdDriverExit:
   483 000003F7 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
   484 000003FD 5D                          pop rbp
   485 000003FE 5F                          pop rdi
   486 000003FF 5E                          pop rsi
   487 00000400 5A                          pop rdx
   488 00000401 59                          pop rcx
   489 00000402 5B                          pop rbx
   490 00000403 58                          pop rax
   491 00000404 C3                          ret
   492                                  .msdInit:            ;Function 0
   493 00000405 CD31                        int 31h ;Get number of Int 33h devices in r8b
   494 00000407 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
   495 0000040B 4489C0                      mov eax, r8d
   496 0000040E 3C01                        cmp al, 1
   497 00000410 7702                        ja .mi1
   498 00000412 FEC0                        inc al ;Make it two
   499                                  .mi1:
   500 00000414 BA05000000                  mov edx, 5
   501 00000419 39D0                        cmp eax, edx
   502 0000041B 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
   503 0000041E 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
   504 00000424 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
   505 00000427 440005(76000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
   506 0000042E 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
   507 00000430 488D3DE1010000              lea rdi, qword [.msdBPBblks]
   508 00000437 53                          push rbx
   509                                  .mi2:
   510 00000438 89EA                        mov edx, ebp
   511 0000043A 488D1D2F040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
   512 00000441 31C9                        xor ecx, ecx    ;Sector 0
   513 00000443 B801820000                  mov eax, 8201h       ;Read 1 sector
   514 00000448 CD33                        int 33h
   515 0000044A 724E                        jc .msdInitError
   516                                  
   517 0000044C 488D351D040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
   518 00000453 B90F000000                  mov ecx, bpbExLen/8
   519 00000458 F348A5                      rep movsq   ;Move the BPB data into the right block
   520                                  
   521 0000045B FFC5                        inc ebp
   522 0000045D 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
   523 00000460 75D6                        jne .mi2  ;No? Go again
   524                                  
   525 00000462 488D3D87010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
   526 00000469 488D15A8010000              lea rdx, qword [.msdBPBblks]
   527                                  .mi3:
   528 00000470 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
   529 00000473 4881C278000000              add rdx, bpbExLen      ;Make rdx point to the next block entry
   530 0000047A FFCD                        dec ebp
   531 0000047C 75F2                        jnz .mi3  ;If not zero yet, go again
   532                                  
   533 0000047E 5B                          pop rbx
   534 0000047F 488D156A010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
   535 00000486 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
   536 0000048A 488D15DF030000              lea rdx, qword [driverDataPtr]
   537 00000491 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
   538 00000495 E95DFFFFFF                  jmp .msdDriverExit
   539                                  .msdInitError:
   540 0000049A 5B                          pop rbx
   541 0000049B E957FFFFFF                  jmp .msdDriverExit
   542                                  .msdMedChk:          ;Function 1
   543                                  ;Once the BIOS function is implmented that reads the changeline, use that!
   544                                  ;For BIOSes that dont support the changeline, the following procedure will 
   545                                  ; suffice.
   546 000004A0 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
   547 000004A5 8A90[E6050000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
   548 000004AB F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
   549 000004AE 7528                        jnz .mmcNoChange
   550                                  ;Now we test Media Descriptor
   551 000004B0 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
   552 000004B3 488B3CC5[F0050000]          mov rdi, qword [.msdBPBTbl + 8*rax]
   553 000004BB 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
   554 000004BE 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
   555 000004C1 740C                        je .mmcUnsure
   556                                  .mmcChange: ;Fail safe, always assume the device has changed
   557 000004C3 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
   558 000004C7 48C7430F[DC050000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
   559                                  .mmcUnsure:
   560 000004CF C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
   561 000004D3 E91FFFFFFF                  jmp .msdDriverExit
   562                                  .mmcNoChange:
   563 000004D8 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
   564 000004DC E916FFFFFF                  jmp .msdDriverExit
   565                                  
   566                                  .msdBuildBPB:        ;Function 2
   567 000004E1 4889DE                      mov rsi, rbx
   568 000004E4 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
   569 000004E9 8A90[E6050000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
   570 000004EF 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
   571 000004F3 31C9                        xor ecx, ecx    ;Read Sector 0
   572 000004F5 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
   573 000004FA CD33                        int 33h
   574 000004FC 7224                        jc .mbbpbError
   575 000004FE 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
   576 00000501 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
   577 00000506 488B3CC5[F0050000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
   578 0000050E 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
   579 00000511 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
   580 00000515 B90F000000                  mov ecx, bpbExLen/8
   581 0000051A F348A5                      rep movsq   ;Move the BPB data into the right space
   582 0000051D E9D5FEFFFF                  jmp .msdDriverExit
   583                                  .mbbpbError:
   584                                  .msdIOCTLRead:       ;Function 3, returns done
   585 00000522 E9D0FEFFFF                  jmp .msdDriverExit
   586                                  .msdRead:            ;Function 4
   587 00000527 4889DD                      mov rbp, rbx
   588 0000052A B482                        mov ah, 82h ;LBA Read Sectors
   589 0000052C E892000000                  call .msdBlkIOCommon
   590 00000531 4889EB                      mov rbx, rbp
   591 00000534 E9BEFEFFFF                  jmp .msdDriverExit
   592                                  .msdWrite:           ;Function 8
   593 00000539 4889DD                      mov rbp, rbx
   594 0000053C B483                        mov ah, 83h ;LBA Write Sectors
   595 0000053E E880000000                  call .msdBlkIOCommon
   596 00000543 4889EB                      mov rbx, rbp
   597 00000546 E9ACFEFFFF                  jmp .msdDriverExit
   598                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
   599 0000054B 4889DD                      mov rbp, rbx
   600 0000054E B483                        mov ah, 83h ;LBA Write Sectors
   601 00000550 E86E000000                  call .msdBlkIOCommon
   602 00000555 B484                        mov ah, 84h ;LBA Verify Sectors
   603 00000557 E867000000                  call .msdBlkIOCommon
   604 0000055C 4889EB                      mov rbx, rbp
   605 0000055F E993FEFFFF                  jmp .msdDriverExit
   606                                  .msdIOCTLWrite:      ;Function 12, returns done
   607 00000564 E98EFEFFFF                  jmp .msdDriverExit
   608                                  .msdDevOpen:         ;Function 13
   609 00000569 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
   610 0000056E FE80[EB050000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
   611 00000574 E97EFEFFFF                  jmp .msdDriverExit
   612                                  .msdDevClose:        ;Function 14
   613 00000579 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
   614 0000057E FE88[EB050000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
   615 00000584 E96EFEFFFF                  jmp .msdDriverExit
   616                                  .msdRemovableMedia:  ;Function 15
   617 00000589 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
   618 0000058E 8A80[E6050000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
   619 00000594 A880                        test al, 80h
   620 00000596 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
   621 0000059C 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
   622 000005A2 E950FEFFFF                  jmp .msdDriverExit
   623                                  .msdGenericIOCTL:    ;Function 19
   624                                  .msdGetLogicalDev:   ;Function 23
   625 000005A7 8A0538000000                mov al, byte [.msdCurDev]
   626 000005AD 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
   627 000005B0 E942FEFFFF                  jmp .msdDriverExit
   628                                  .msdSetLogicalDev:   ;Function 24
   629 000005B5 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
   630 000005B8 880527000000                mov byte [.msdCurDev], al
   631 000005BE E934FEFFFF                  jmp .msdDriverExit
   632                                  
   633                                  .msdBlkIOCommon:  ;Does block IO
   634                                  ;Called with rbp containing old rbx value and ah with function number
   635                                  ;Error handled by caller
   636 000005C3 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
   637 000005C8 8A90[E6050000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
   638 000005CE 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
   639 000005D2 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
   640 000005D5 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
   641 000005D9 CD33                        int 33h
   642 000005DB C3                          ret
   643                                  
   644 000005DC 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
   645                                  ;LASTDRIVE default is 5
   646 000005E5 00                      .msdCurDev   db 0  ;The device to be referenced by the driver is saved here!
   647 000005E6 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
   648 000005EB 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
   649 000005F0 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
   649 000005F9 000000000000000000-
   649 00000602 000000000000000000-
   649 0000060B 000000000000000000-
   649 00000614 00000000           
   650 00000618 000000000000000000-     .msdBPBblks  db 5*bpbExLen dup (0) ;Max 5 bpb records of exFAT bpb size
   650 00000621 000000000000000000-
   650 0000062A 000000000000000000-
   650 00000633 000000000000000000-
   650 0000063C 000000000000000000-
   650 00000645 000000000000000000-
   650 0000064E 000000000000000000-
   650 00000657 000000000000000000-
   650 00000660 000000000000000000-
   650 00000669 000000000000000000-
   650 00000672 000000000000000000-
   650 0000067B 000000000000000000-
   650 00000684 000000000000000000-
   650 0000068D 000000000000000000-
   650 00000696 000000000000000000-
   650 0000069F 000000000000000000-
   650 000006A8 000000000000000000-
   650 000006B1 000000000000000000-
   650 000006BA 000000000000000000-
   650 000006C3 000000000000000000-
   650 000006CC 000000000000000000-
   650 000006D5 000000000000000000-
   650 000006DE 000000000000000000-
   650 000006E7 000000000000000000-
   650 000006F0 000000000000000000-
   650 000006F9 000000000000000000-
   650 00000702 000000000000000000-
   650 0000070B 000000000000000000-
   650 00000714 000000000000000000-
   650 0000071D 000000000000000000-
   650 00000726 000000000000000000-
   650 0000072F 000000000000000000-
   650 00000738 000000000000000000-
   650 00000741 000000000000000000-
   650 0000074A 000000000000000000-
   650 00000753 000000000000000000-
   650 0000075C 000000000000000000-
   650 00000765 000000000000000000-
   650 0000076E 000000000000000000-
   650 00000777 000000000000000000-
   650 00000780 000000000000000000-
   650 00000789 000000000000000000-
   650 00000792 000000000000000000-
   650 0000079B 000000000000000000-
   650 000007A4 000000000000000000-
   650 000007AD 000000000000000000-
   650 000007B6 000000000000000000-
   650 000007BF 000000000000000000-
   650 000007C8 000000000000000000-
   650 000007D1 000000000000000000-
   650 000007DA 000000000000000000-
   650 000007E3 000000000000000000-
   650 000007EC 000000000000000000-
   650 000007F5 000000000000000000-
   650 000007FE 000000000000000000-
   650 00000807 000000000000000000-
   650 00000810 000000000000000000-
   650 00000819 000000000000000000-
   650 00000822 000000000000000000-
   650 0000082B 000000000000000000-
   650 00000834 000000000000000000-
   650 0000083D 000000000000000000-
   650 00000846 000000000000000000-
   650 0000084F 000000000000000000-
   650 00000858 000000000000000000-
   650 00000861 000000000000000000-
   650 0000086A 000000000000       
   651                                  
   652                                  driverDataPtr:
