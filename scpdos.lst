     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame   
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, rbp + 0
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> endstruc
   186                              <1> 
   187                              <1> %macro pushDOS 0
   188                              <1>     push r9
   189                              <1>     push r8
   190                              <1>     push rbp
   191                              <1>     push rdi
   192                              <1>     push rsi
   193                              <1>     push rdx
   194                              <1>     push rcx
   195                              <1>     push rbx
   196                              <1>     push rax
   197                              <1> %endmacro
   198                              <1> 
   199                              <1> %macro popDOS 0
   200                              <1>     pop rax
   201                              <1>     pop rbx
   202                              <1>     pop rcx
   203                              <1>     pop rdx
   204                              <1>     pop rsi
   205                              <1>     pop rdi
   206                              <1>     pop r8
   207                              <1>     pop r9
   208                              <1> %endmacro
   209                              <1> 
   210                              <1> struc psp
   211 00000000 ????                <1>     .return     resb 2  ;Should always be CDh 40h
   212 00000002 ????????????????    <1>     .startSeg   resq 1
   213 0000000A ????????????????    <1>     .oldInt42h  resq 1
   214 00000012 ????????????????    <1>     .oldInt43h  resq 1
   215 0000001A ????????????????    <1>     .oldInt44h  resq 1
   216 00000022 ????????????????    <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   217 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   218 0000003E ????????????????    <1>     .envPtr     resq 1  ;Pointer to the environment
   219 00000046 ????????????????    <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to int 41h
   220 0000004E ????                <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   221 00000050 ??????              <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   222 00000053 ????????????????    <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   223 0000005B ????????????????    <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   224 00000063 <res 1Dh>           <1>     .reserved   resb 29
   225 00000080 ??                  <1>     .charCount  resb 1
   226 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   227                              <1> endstruc
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   charReqHdr  resb ioReqPkt_size  ;Character IO Request header
    12 00000033 <res 2Ah>                   diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
    13                                      ;The device driver header with space for the largest possible packet
    14 0000005D ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    15 00000065 ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    16 0000006D ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    17 00000075 ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    18 0000007D ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    19                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    20 00000085 ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    21                                      ;                    The last driver loaded with the STDIN bit[0] set
    22 0000008D ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    23 0000008F ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    24 00000097 ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    25 0000009F ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    26 000000A7 ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    27 000000A9 ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    28 000000AA ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    29 000000AB ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    30 000000AC <res 22h>                   nulDevHdr   resb drvHdr_size
    31                                  
    32                                  ;Start of Swappable Data Area, this bit can remain static
    33 000000CE ??                          critErrFlag resb 1  ;Critical error flag, set on entry to INT 44h
    34 000000CF ??                          inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    35 000000D0 ??                          errorDrv    resb 1  ;Drive on which error occured or FFh
    36 000000D1 ??                          errorLocus  resb 1  ;Where the error took place  
    37 000000D2 ????                        errorExt    resw 1  ;Extended Error Code
    38 000000D4 ??                          errorAction resb 1  ;Suggested action for error  
    39 000000D5 ??                          errorClass  resb 1  ;Error Class
    40                                  
    41 000000D6 ????????????????            currentDTA  resq 1  ;Address of the current DTA
    42 000000DE ????????????????            currentPSP  resq 1  ;Address of current PSP
    43 000000E6 ????????????????            rdiErrorPtr resq 1  ;Saves RDI value of last error
    44 000000EE ????????????????            xInt43RSP   resq 1  ;Saves RSP across an Int 43h call
    45 000000F6 ????                        lastRetCode resw 1  ;Last return code returned by Int 41h/4Ch
    46 000000F8 ??                          currentDrv  resb 1  ;Default, last accessed drive
    47 000000F9 ??                          breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    48                                  ;SDA, needs to be replaced between PROCESSES (not tasks)
    49 000000FA ????????????????            xInt44hRSP  resq 1  ;RSP across an Int 44h call
    50                                  
    51                                  
    52 00000102 <res 528h>                  critStack   resq 165
    53 0000062A ????????????????            critStakTop resq 1
    54 00000632 <res 638h>                  IOStack     resq 199
    55 00000C6A ????????????????            IOStakTop   resq 1
    56 00000C72 <res 638h>                  DiskStack   resq 199
    57 000012AA ????????????????            DiskStakTop resq 1
    58                                      dSegLen     equ     $
    59                                  
    60                                  Segment .text align=1
    61                                  ; We arrive here with the following values in the registers.
    62                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    63                                  ; dx  = Int 33h boot device number
    64                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    65 00000000 55AA                        dw 0AA55h           ;Initial signature
    66 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    67                                  
    68 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    69 0000000F 0F32                        rdmsr
    70 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    71 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    72 00000017 89C7                        mov edi, eax        ;Get the low dword in
    73                                  
    74 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    74 0000001E [00000000]         
    75 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    76 00000025 4881C7[B2120000]            add rdi, dSegLen ;Move destination past end of data area
    77 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    78 00000033 B900100000                  mov ecx, 1000h
    79 00000038 F348A5                      rep movsq
    80                                  
    81                                  ;Modify the pointers in nData before putting them in the data area
    82 0000003B 48012D77010000              add qword [nData + drvHdr.nxtPtr], rbp
    83 00000042 48012D7A010000              add qword [nData + drvHdr.strPtr], rbp
    84 00000049 48012D7B010000              add qword [nData + drvHdr.intPtr], rbp
    85                                  ;Copy the Null driver to its location in Sysvars
    86 00000050 B922000000                  mov ecx, drvHdr_size
    87 00000055 488D355D010000              lea rsi, qword [nData]
    88 0000005C 488DBD[AC000000]            lea rdi, qword [rbp + nulDevHdr]
    89 00000063 F3A4                        rep movsb   
    90                                  
    91                                  ;Adjust the addresses in the other driver headers 
    92 00000065 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    92 00000067 [B306000000000000] 
    93 0000006F B90C000000                  mov ecx, 12      ;12 drivers in data area
    94 00000074 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    95                                  adjDrivers:
    96 00000078 E8C1000000                  call adjustDrvHdr
    97 0000007D E2F9                        loop adjDrivers
    98                                  
    99                                      ;Open NUL
   100 0000007F 488D9D[B6000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
   101 00000086 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
   102 00000089 30C0                        xor al, al
   103 0000008B FFD3                        call rbx
   104                                  
   105                                      ;Open CON
   106 0000008D 48BB-                       mov rbx, conDriver
   106 0000008F [6208000000000000] 
   107 00000097 488D5C1D00                  lea rbx, qword [rbp+rbx]
   108 0000009C 30C0                        xor al, al
   109 0000009E FFD3                        call rbx
   110                                  
   111                                      ;Open Mass Storage
   112 000000A0 48BB-                       mov rbx, msdDriver
   112 000000A2 [C809000000000000] 
   113 000000AA 488D5C1D00                  lea rbx, qword [rbp+rbx]
   114 000000AF 30C0                        xor al, al
   115 000000B1 FFD3                        call rbx
   116                                  ;Adjust Int 41h address table
   117                                  
   118                                  adjInt41h:
   119 000000B3 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
   120 000000B8 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
   120 000000BA [9800000000000000] 
   121 000000C2 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
   122                                  .ai41h:
   123 000000C7 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
   124 000000CA 4881C308000000              add rbx, 8              ;Each entry is size 8
   125 000000D1 FFC9                        dec ecx
   126 000000D3 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
   127                                  
   128                                  ;Adjust Interrupt Entries Int 40h-49h
   129                                  adjInts:
   130 000000D5 B340                        mov bl, 40h
   131 000000D7 B807F00000                  mov eax, 0F007h ;Get the descriptor
   132 000000DC CD35                        int 35h
   133 000000DE B940000000                  mov ecx, 40h    ;Start from interrupt 40h
   134 000000E3 488D3D7F000000              lea rdi, intData
   135 000000EA 89C6                        mov esi, eax    ;Move segment selector info to esi
   136                                  .ai0:
   137 000000EC B808F00000                  mov eax, 0F008h ;Set the descriptor
   138 000000F1 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
   139 000000F4 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
   140 000000F7 CD35                        int 35h
   141 000000F9 4881C708000000              add rdi, 8
   142 00000100 FFC1                        inc ecx
   143 00000102 81F94A000000                cmp ecx, 4Ah
   144 00000108 75E2                        jne .ai0
   145                                  
   146                                  ;Test Error Case
   147 0000010A B430                        mov ah, 00110000b
   148 0000010C B000                        mov al, 00h
   149 0000010E BF0C000000                  mov edi, 0Ch
   150 00000113 CD44                        int 44h
   151                                  
   152 00000115 488D2D35000000              lea rbp, qword [startmsg]   ;Get the absolute address of message
   153 0000011C B804130000                  mov eax, 1304h
   154 00000121 CD30                        int 30h
   155                                  
   156 00000123 64488B3425-                 mov rsi, fs:[nulDevHdr]
   156 00000128 [AC000000]         
   157 0000012C B801C50000                  mov eax, 0C501h ;Connect debugger
   158 00000131 CD35                        int 35h
   159                                  l1:
   160 00000133 6631C0                      xor ax, ax
   161 00000136 CD36                        int 36h
   162 00000138 B40E                        mov ah, 0Eh
   163 0000013A CD30                        int 30h
   164 0000013C EBF5                        jmp short l1
   165                                  adjustDrvHdr:
   166                                  ;Input: rsi = Effective address of driver in DOS segment
   167                                  ;       rbp = Ptr to the start of the DOS segment
   168                                  ;Output: rsi = EA of next header in DOS segment
   169 0000013E 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   170 00000141 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   171 00000145 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   172 00000149 4881C622000000              add rsi, drvHdr_size
   173 00000150 C3                          ret
   174                                  
   175 00000151 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,0
   175 0000015A 67205343502F444F53-
   175 00000163 2E2E2E0A0D00       
   176                                  intData:
   177 00000169 [5900000000000000]          dq terminateProcess ;Int 40h
   178 00000171 [5900000000000000]          dq functionDispatch ;Int 41h
   179 00000179 [E803000000000000]          dq terminateHandler ;Int 42h
   180 00000181 [E803000000000000]          dq ctrlCHandler     ;Int 43h
   181 00000189 [E803000000000000]          dq critErrorHandler ;Int 44h
   182 00000191 [7B06000000000000]          dq absDiskRead      ;Int 45h
   183 00000199 [9006000000000000]          dq absDiskWrite     ;Int 46h
   184 000001A1 [A506000000000000]          dq terminateResident    ;Int 47h
   185 000001A9 [A506000000000000]          dq inDosHandler     ;Int 48h
   186 000001B1 [A706000000000000]          dq fastOutput       ;Int 49h
   187                                  nData:
   188 000001B9 [B306000000000000]          dq conHdr
   189 000001C1 0480                        dw 08004h
   190 000001C3 [5B08000000000000]          dq nulStrat
   191 000001CB [6108000000000000]          dq nulIntr
   192 000001D3 4E554C2020202020            db "NUL     " ;Default NUL data
   193                                  
   194                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   195                                  ;-----------------------------------:
   196                                  ;       Misc System routines        :
   197                                  ;-----------------------------------:
   198                                  findLRUBuffer: 
   199                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   200                                  ;Input: Nothing
   201                                  ;Output: rbx = Pointer to the buffer to use
   202 00000000 52                          push rdx
   203 00000001 488B1D(8F000000)            mov rbx, qword [bufHeadPtr]
   204 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   205 0000000F 7502                        jne .flb1
   206 00000011 5A                          pop rdx
   207 00000012 C3                          ret
   208                                  .flb1:
   209 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   210 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   211 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   212 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   213 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   214 00000029 488B15(8F000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   215 00000030 48891D(8F000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   216 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   217 0000003A 5A                          pop rdx
   218 0000003B C3                          ret
   219                                  
   220                                  findDPB:
   221                                  ;Finds the DPB for a given drive
   222                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   223                                  ;Output: al = 00, rbx = Pointer to the DPB
   224                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   225 0000003C 488B1D(6D000000)            mov rbx, qword [dpbHeadPtr]
   226                                  .fd1:
   227 00000043 30C0                        xor al, al
   228 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   229 00000047 740F                        je .fd2
   230 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   231 0000004D B0FF                        mov al, -1
   232 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   233 00000056 75EB                        jne .fd1
   234                                  .fd2:
   235 00000058 C3                          ret
   236                                  callCritError:
   237                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   238                                  ;-----------------------------------:
   239                                  ;       File System routines        :
   240                                  ;-----------------------------------:
   241                                  name2Clust:
   242                                  ;Converts a file name to a first cluster number
   243                                  ;-----------------------------------:
   244                                  ;        Interrupt routines         :
   245                                  ;-----------------------------------:
   246                                  terminateProcess:   ;Int 40h
   247                                  
   248                                  functionDispatch:   ;Int 41h Main function dispatcher
   249                                  ;ah = Function number, all other registers have various meanings
   250 00000059 FA                          cli ;Halt external interrupts
   251 0000005A 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   252 0000005D 7711                        ja .fdExitBad
   253 0000005F 80FC01                      cmp ah, 01h
   254 00000062 7410                        je .stdinReadEcho
   255 00000064 80FC02                      cmp ah, 02h
   256 00000067 7413                        je .stdoutWrite
   257 00000069 80FC09                      cmp ah, 09h
   258 0000006C 7416                        je .printString
   259 0000006E 48CF                        iretq
   260                                  .fdExit:
   261                                  .fdExitBad:
   262 00000070 B400                        mov ah, 0
   263 00000072 48CF                        iretq
   264                                  .dispTerminate:     ;ah = 00h
   265                                  .stdinReadEcho:     ;ah = 01h
   266 00000074 30E4                        xor ah, ah
   267 00000076 CD36                        int 36h
   268 00000078 CD49                        int 49h ;Pass al to fast output
   269 0000007A 48CF                        iretq
   270                                  .stdoutWrite:       ;ah = 02h
   271                                  ;Bspace is regular cursor left, does not insert a blank
   272 0000007C 50                          push rax
   273 0000007D 88D0                        mov al, dl
   274 0000007F CD49                        int 49h
   275 00000081 58                          pop rax
   276 00000082 48CF                        iretq
   277                                  .stdauxRead:        ;ah = 03h
   278                                  .stdauxWrite:       ;ah = 04h
   279                                  .stdprnWrite:       ;ah = 05h
   280                                  .directCONIO:       ;ah = 06h
   281                                  .waitDirectInNoEcho:;ah = 07h
   282                                  .waitStdinNoEcho:   ;ah = 08h
   283                                  .printString:       ;ah = 09h
   284 00000084 50                          push rax
   285 00000085 52                          push rdx
   286                                  .ps0:
   287 00000086 8A02                        mov al, byte [rdx]
   288 00000088 3C24                        cmp al, "$"
   289 0000008A 7407                        je .ps1
   290 0000008C 48FFC2                      inc rdx ;Goto next char
   291 0000008F CD49                        int 49h ;Print char in al
   292 00000091 EBF3                        jmp short .ps0
   293                                  .ps1:
   294 00000093 5A                          pop rdx
   295 00000094 58                          pop rax
   296 00000095 48CF                        iretq
   297                                  .buffStdinInput:    ;ah = 0Ah
   298                                  .checkStdinStatus:  ;ah = 0Bh
   299                                  .clearbuffDoFunc:   ;ah = 0Ch
   300                                  .diskReset:         ;ah = 0Dh
   301                                  .selectDisk:        ;ah = 0Eh
   302                                  .openFileFCB:       ;ah = 0Fh
   303                                  .closeFileFCB:      ;ah = 10h
   304                                  .findFirstFileFCB:  ;ah = 11h
   305                                  .findNextFileFCB:   ;ah = 12h
   306                                  .deleteFileFCB:     ;ah = 13h
   307                                  .sequentialReadFCB: ;ah = 14h
   308                                  .sequentialWriteFCB:;ah = 15h
   309                                  .createFileFCB:     ;ah = 16h
   310                                  .renameFileFCB:     ;ah = 17h
   311                                                      ;ah = 18h unused
   312                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   313                                  .setDTA:            ;ah = 1Ah
   314                                  .FATinfoDefault:    ;ah = 1Bh
   315                                  .FatinfoDevice:     ;ah = 1Ch
   316                                                      ;ah = 1Dh unused
   317                                                      ;ah = 1Eh unused
   318                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   319                                                      ;ah = 20h unused
   320                                  .randomReadFCB:     ;ah = 21h
   321                                  .randomWriteFCB:    ;ah = 22h
   322                                  .getFileSizeFCB:    ;ah = 23h
   323                                  .setRelRecordFCB:   ;ah = 24h
   324                                  .setIntVector:      ;ah = 25h
   325                                  .createNewPSP:      ;ah = 26h
   326                                  .randBlockReadFCB:  ;ah = 27h
   327                                  .randBlockWriteFCB: ;ah = 28h
   328                                  .parseFilenameFCB:  ;ah = 29h
   329                                  .getDate:           ;ah = 2Ah
   330                                  .setDate:           ;ah = 2Bh
   331                                  .getTime:           ;ah = 2Ch
   332                                  .setTime:           ;ah = 2Dh
   333                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   334                                  .getDTA:            ;ah = 2Fh
   335                                  .getDOSversion:     ;ah = 30h
   336                                  .terminateStayRes:  ;ah = 31h
   337                                  .getDeviceDPBptr:   ;ah = 32h
   338                                  .ctrlBreakCheck:    ;ah = 33h
   339                                  .getInDOSflagPtr:   ;ah = 34h
   340                                  .getIntVector:      ;ah = 35h
   341                                  .getDiskFreeSpace:  ;ah = 36h
   342                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   343                                  .getsetCountryInfo: ;ah = 38h, localisation info
   344                                  .makeDIR:           ;ah = 39h
   345                                  .removeDIR:         ;ah = 3Ah
   346                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   347                                  .createFileHdl:     ;ah = 3Ch, handle function
   348                                  .openFileHdl:       ;ah = 3Dh, handle function
   349                                  .closeFileHdl:      ;ah = 3Eh, handle function
   350                                  .readFileHdl:       ;ah = 3Fh, handle function
   351                                  .writeFileHdl:      ;ah = 40h, handle function
   352                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   353                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   354                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   355                                  .ioctrl:            ;ah = 44h, handle function
   356                                  .duplicateHandle:   ;ah = 45h, handle function
   357                                  .forceDuplicateHdl: ;ah = 46h, handle function
   358                                  .getCurrentDIR:     ;ah = 47h
   359                                  .allocateMemory:    ;ah = 48h
   360                                  .freeMemory:        ;ah = 49h
   361                                  .reallocMemory:     ;ah = 4Ah
   362                                  .loadExecChild:     ;ah = 4Bh, EXEC
   363                                  .terminateClean:    ;ah = 4Ch, EXIT
   364                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   365                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   366                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   367                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   368                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   369                                  .getSysVarsPtr:     ;ah = 52h
   370                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   371                                  .getVerifySetting:  ;ah = 54h
   372                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   373                                  .renameFile:        ;ah = 56h
   374                                  .getSetFileDateTime:;ah = 57h
   375                                  .getsetMallocStrat: ;ah = 58h
   376                                  .getExtendedError:  ;ah = 59h
   377                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   378                                  .createNewFile:     ;ah = 5Bh
   379                                  .lockUnlockFile:    ;ah = 5Ch
   380                                  .getCritErrorInfo:  ;ah = 5Dh
   381                                  .networkServices:   ;ah = 5Eh, do nothing
   382                                  .networkRedirection:;ah = 5Fh, do nothing
   383                                  .trueName:          ;ah = 60h, get fully qualified name
   384                                                      ;ah = 61h, reserved
   385                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   386                                                      ;ah = 63h, reserved
   387                                  .setDriverLookahead:;ah = 64h, reserved
   388                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   389                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   390                                  .setHandleCount:    ;ah = 67h
   391                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   392                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   393                                  .return:
   394 00000097 C3                          ret
   395                                  
   396                                  
   397                                  .dispatchTable:
   398 00000098 [7400000000000000]          dq .dispTerminate       ;AH = 00H, PROCESS MANAGEMENT
   399 000000A0 [7400000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   400 000000A8 [7C00000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   401 000000B0 [8400000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   402 000000B8 [8400000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   403 000000C0 [8400000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   404 000000C8 [8400000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   405 000000D0 [8400000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   406 000000D8 [8400000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   407 000000E0 [8400000000000000]          dq .printString         ;AH = 09H, CHAR IO
   408 000000E8 [9700000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   409 000000F0 [9700000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   410 000000F8 [9700000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   411 00000100 [9700000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   412 00000108 [9700000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   413 00000110 [9700000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   414 00000118 [9700000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   415 00000120 [9700000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   416 00000128 [9700000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   417 00000130 [9700000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   418 00000138 [9700000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   419 00000140 [9700000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   420 00000148 [9700000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   421 00000150 [9700000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   422 00000158 [9700000000000000]          dq .return              ;AH = 18H, RESERVED
   423 00000160 [9700000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   424 00000168 [9700000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   425 00000170 [9700000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   426 00000178 [9700000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   427 00000180 [9700000000000000]          dq .return              ;AH = 1DH, RESERVED
   428 00000188 [9700000000000000]          dq .return              ;AH = 1EH, RESERVED
   429 00000190 [9700000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   430 00000198 [9700000000000000]          dq .return              ;AH = 20H, RESERVED
   431 000001A0 [9700000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   432 000001A8 [9700000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   433 000001B0 [9700000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   434 000001B8 [9700000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   435 000001C0 [9700000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   436 000001C8 [9700000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   437 000001D0 [9700000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   438 000001D8 [9700000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   439 000001E0 [9700000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   440 000001E8 [9700000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   441 000001F0 [9700000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   442 000001F8 [9700000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   443 00000200 [9700000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   444 00000208 [9700000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   445 00000210 [9700000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   446 00000218 [9700000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   447 00000220 [9700000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   448 00000228 [9700000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   449 00000230 [9700000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   450 00000238 [9700000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   451 00000240 [9700000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   452 00000248 [9700000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   453 00000250 [9700000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   454 00000258 [9700000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   455 00000260 [9700000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   456 00000268 [9700000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   457 00000270 [9700000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   458 00000278 [9700000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   459 00000280 [9700000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   460 00000288 [9700000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   461 00000290 [9700000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   462 00000298 [9700000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   463 000002A0 [9700000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   464 000002A8 [9700000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   465 000002B0 [9700000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   466 000002B8 [9700000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   467 000002C0 [9700000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   468 000002C8 [9700000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   469 000002D0 [9700000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   470 000002D8 [9700000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   471 000002E0 [9700000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   472 000002E8 [9700000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   473 000002F0 [9700000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   474 000002F8 [9700000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   475 00000300 [9700000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   476 00000308 [9700000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   477 00000310 [9700000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   478 00000318 [9700000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   479 00000320 [9700000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   480 00000328 [9700000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   481 00000330 [9700000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   482 00000338 [9700000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   483 00000340 [9700000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   484 00000348 [9700000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   485 00000350 [9700000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   486 00000358 [9700000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   487 00000360 [9700000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   488 00000368 [9700000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   489 00000370 [9700000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   490 00000378 [9700000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   491 00000380 [9700000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   492 00000388 [9700000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   493 00000390 [9700000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   494 00000398 [9700000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   495 000003A0 [9700000000000000]          dq .return              ;AH = 61H, RESERVED
   496 000003A8 [9700000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   497 000003B0 [9700000000000000]          dq .return              ;AH = 63H, RESERVED
   498 000003B8 [9700000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   499 000003C0 [9700000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   500 000003C8 [9700000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   501 000003D0 [9700000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   502 000003D8 [9700000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   503 000003E0 [9700000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   504                                  dispatchTableL  equ $ - .dispatchTable 
   505                                  
   506                                  terminateHandler:   ;Int 42h
   507                                  ctrlCHandler:       ;Int 43h
   508                                  critErrorHandler:   ;Int 44h
   509                                  ;User Stack in usage here, must be swapped to before this is called
   510                                  ;Entered with:  
   511                                  ;               AH = Critical Error Bitfield
   512                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   513                                  ;               Bit 6 - Reserved
   514                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   515                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   516                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   517                                  ;               Bits [2-1] = Affected Disk Error
   518                                  ;                     0 0   DOS area
   519                                  ;                     0 1   FAT area
   520                                  ;                     1 0   Directory area
   521                                  ;                     1 1   Data area
   522                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   523                                  ;               AL  = Failing drive number if AH[7] = 0
   524                                  ;               DIL = Error code for errorMsg
   525                                  ;               RSI = EA of Device Header for which device the error occured
   526                                  ;Return:
   527                                  ;               AL = 0 - Ignore the Error       (Ignore)
   528                                  ;                  = 1 - Retry the Operation    (Retry)
   529                                  ;                  = 2 - Terminate the Program  (Abort)
   530                                  ;                  = 3 - Fail the DOS call      (Fail)
   531 000003E8 53                          push rbx
   532 000003E9 51                          push rcx
   533 000003EA 52                          push rdx
   534 000003EB 57                          push rdi
   535 000003EC 56                          push rsi
   536 000003ED FC                          cld         ;Make String ops go forward
   537                                  
   538 000003EE 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   539 000003F1 488D155E020000              lea rdx, qword [.crlf]
   540 000003F8 B409                        mov ah, 09h ;Print String
   541 000003FA CD41                        int 41h     ;Call DOS to print CRLF part of message
   542                                  
   543 000003FC 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   544 00000402 B90C000000                  mov ecx, 0Ch
   545 00000407 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   546 00000409 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   547 0000040C 480FB7FF                    movzx rdi, di
   548 00000410 4889FA                      mov rdx, rdi    ;Copy error code
   549 00000413 48C1E704                    shl rdi, 4  ;Multiply by 16
   550 00000417 48D1E2                      shl rdx, 1  ;Multiply by 2
   551 0000041A 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   552 0000041D 488D1523010000              lea rdx, qword [.errorMsgTable]
   553 00000424 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   554 00000428 B409                        mov ah, 09h ;Print String
   555 0000042A CD41                        int 41h     ;Call DOS to print first part of message
   556                                  
   557 0000042C 488D1505020000              lea rdx, qword [.readmsg]
   558 00000433 488D3D0D020000              lea rdi, qword [.writemsg]
   559 0000043A F6C701                      test bh, 1  ;Bit 0 is set if write operation
   560 0000043D 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   561 00000441 B409                        mov ah, 09h ;Print String
   562 00000443 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   563                                  
   564 00000445 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   565 00000448 0F85DF000000                jnz .charError
   566                                  ;Disk error continues here
   567 0000044E 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   568 00000455 B409                        mov ah, 09h
   569 00000457 CD41                        int 41h
   570 00000459 88DA                        mov dl, bl  ;Get zero based drive number into dl
   571 0000045B 80C241                      add dl, "A" ;Add ASCII code
   572 0000045E B402                        mov ah, 02h ;Print char in dl
   573 00000460 CD41                        int 41h
   574                                  .userInput:
   575 00000462 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   576 00000469 B409                        mov ah, 09h
   577 0000046B CD41                        int 41h
   578                                  ;Abort, Retry, Ignore, Fail is word order
   579                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   580                                  .userAbort:
   581                                  ;Abort is always an option
   582 0000046D 488D15E5010000              lea rdx, qword [.abortmsg]
   583 00000474 B409                        mov ah, 09h
   584 00000476 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   585                                  .userRetry:
   586 00000478 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   587 0000047B 7416                        jz .userIgnore    ;If clear, dont print message
   588 0000047D 488D15ED010000              lea rdx, qword [.betweenMsg]
   589 00000484 B409                        mov ah, 09h
   590 00000486 CD41                        int 41h
   591 00000488 488D15D7010000              lea rdx, qword [.retrymsg]
   592 0000048F B409                        mov ah, 09h
   593 00000491 CD41                        int 41h
   594                                  .userIgnore:
   595 00000493 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   596 00000496 7416                        jz .userFail
   597 00000498 488D15D2010000              lea rdx, qword [.betweenMsg]
   598 0000049F B409                        mov ah, 09h
   599 000004A1 CD41                        int 41h
   600 000004A3 488D15B5010000              lea rdx, qword [.ignoremsg]
   601 000004AA B409                        mov ah, 09h
   602 000004AC CD41                        int 41h
   603                                  .userFail:
   604 000004AE F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   605 000004B1 7416                        jz .userMsgEnd
   606 000004B3 488D15B7010000              lea rdx, qword [.betweenMsg]
   607 000004BA B409                        mov ah, 09h
   608 000004BC CD41                        int 41h
   609 000004BE 488D15A7010000              lea rdx, qword [.failmsg]
   610 000004C5 B409                        mov ah, 09h
   611 000004C7 CD41                        int 41h
   612                                  .userMsgEnd:
   613 000004C9 488D15A4010000              lea rdx, qword [.endMsg]
   614 000004D0 B409                        mov ah, 09h
   615 000004D2 CD41                        int 41h
   616                                  ;Get user input now 
   617 000004D4 31C9                        xor ecx, ecx  ;4 Possible Responses
   618 000004D6 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   619 000004DD B401                        mov ah, 01h ;STDIN without Console Echo
   620 000004DF CD41                        int 41h ;Get char in al
   621 000004E1 3C61                        cmp al, "a" ;Chack if lowercase
   622 000004E3 7202                        jb .uip1    ;If the value is below, ignore subtraction
   623 000004E5 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   624                                  .uip1:
   625 000004E7 AE                          scasb   ;Compare char to list, offset gives return code
   626 000004E8 740F                        je .validInput  ;If they are equal, ecx has return code
   627 000004EA FFC1                        inc ecx
   628 000004EC 81F904000000                cmp ecx, 4
   629 000004F2 75F3                        jne .uip1
   630 000004F4 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   631                                  .validInput:
   632 000004F9 88C8                        mov al, cl  ;Move the offset into .responses into al
   633                                  ;Now check if the input is permitted
   634 000004FB 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   635 000004FD 7427                        je .cehExit
   636 000004FF 84C0                        test al, al ;Check if 0 => Ignore
   637 00000501 740F                        je .viIgnore
   638 00000503 3C01                        cmp al, 1   ;Check if 1 => Retry
   639 00000505 7416                        je .viRetry
   640                                  .viFail:    ;Fallthrough for fail (al = 3)
   641 00000507 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   642 0000050A 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   643 00000510 EB14                        jmp short .cehExit
   644                                  .viIgnore:
   645 00000512 F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   646 00000515 0F8447FFFFFF                jz .userInput
   647 0000051B EB09                        jmp short .cehExit
   648                                  .viRetry:
   649 0000051D F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   650 00000520 0F843CFFFFFF                jz .userInput
   651                                  .cehExit:
   652 00000526 5E                          pop rsi
   653 00000527 5F                          pop rdi
   654 00000528 5A                          pop rdx
   655 00000529 59                          pop rcx
   656 0000052A 5B                          pop rbx
   657 0000052B 48CF                        iretq
   658                                  .charError:
   659 0000052D B908000000                  mov ecx, 8  ;8 chars in device name
   660 00000532 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   661                                  .ce1:
   662 00000539 AC                          lodsb   ;Get a string char into al and inc rsi
   663 0000053A 88C2                        mov dl, al  ;Move char into dl
   664 0000053C B402                        mov ah, 02h
   665 0000053E CD41                        int 41h ;Print char
   666 00000540 E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   667 00000542 E91BFFFFFF                  jmp .userInput
   668                                  
   669                                  .errorMsgTable: ;Each table entry is 18 chars long
   670 00000547 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   670 00000550 746563742024202020 
   671 00000559 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   671 00000562 6E6974202420202020 
   672 0000056B 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   672 00000574 202420202020202020 
   673 0000057D 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   673 00000586 6F6D6D616E64202420 
   674 0000058F 446174612024202020-                 db "Data $            "       ;Error 4
   674 00000598 202020202020202020 
   675 000005A1 426164205265717565-                 db "Bad Request $     "       ;Error 5
   675 000005AA 737420242020202020 
   676 000005B3 5365656B2024202020-                 db "Seek $            "       ;Error 6
   676 000005BC 202020202020202020 
   677 000005C5 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   677 000005CE 656469612024202020 
   678 000005D7 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   678 000005E0 7420466F756E642024 
   679 000005E9 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   679 000005F2 706572202420202020 
   680 000005FB 577269746520466175-                 db "Write Fault $     "       ;Error A
   680 00000604 6C7420242020202020 
   681 0000060D 52656164204661756C-                 db "Read Fault $      "       ;Error B
   681 00000616 742024202020202020 
   682 0000061F 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   682 00000628 61696C757265202420 
   683                                  
   684 00000631 64726976652024          .drive      db "drive $"
   685 00000638 6572726F7220726561-     .readmsg    db "error reading $"
   685 00000641 64696E672024       
   686 00000647 6572726F7220777269-     .writemsg   db "error writing $"
   686 00000650 74696E672024       
   687 00000656 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   688 00000659 41626F727424            .abortmsg   db "Abort$" 
   689 0000065F 49676E6F726524          .ignoremsg  db "Ignore$"
   690 00000666 526574727924            .retrymsg   db "Retry$"
   691 0000066C 4661696C24              .failmsg    db "Fail$"
   692 00000671 2C2024                  .betweenMsg db ", $"
   693 00000674 3F2024                  .endMsg     db "? $"
   694 00000677 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   695                                  absDiskRead:        ;Int 45h
   696                                  ;al = Drive number
   697                                  ;rbx = Memory Buffer address
   698                                  ;ecx = Number of sectors to read (max 255 for now)
   699                                  ;rdx = Start LBA to read from
   700 0000067B 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   701 0000067F 8A80[3D0C0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   702 00000685 4891                        xchg rax, rcx
   703 00000687 4887CA                      xchg rcx, rdx
   704 0000068A B482                        mov ah, 82h
   705 0000068C CD33                        int 33h
   706 0000068E 48CF                        iretq
   707                                  absDiskWrite:       ;Int 46h
   708 00000690 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   709 00000694 8A80[3D0C0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   710 0000069A 4891                        xchg rax, rcx
   711 0000069C 4887CA                      xchg rcx, rdx
   712 0000069F B483                        mov ah, 83h
   713 000006A1 CD33                        int 33h
   714 000006A3 48CF                        iretq
   715                                  terminateResident:  ;Int 47h
   716                                  inDosHandler:       ;Int 48h
   717                                  ;Called when DOS idle
   718 000006A5 48CF                        iretq
   719                                  fastOutput:         ;Int 49h
   720                                  ;Called with char to transfer in al
   721 000006A7 50                          push rax
   722 000006A8 B40E                        mov ah, 0Eh
   723 000006AA CD30                        int 30h
   724 000006AC 58                          pop rax
   725 000006AD 48CF                        iretq
   726                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   727 000006AF 48CF                        iretq
   728                                  multiplex:          ;Int 4Fh, kept as iretq for now
   729 000006B1 48CF                        iretq
   730                                  ;-----------------------------------:
   731                                  ;          Driver routines          :
   732                                  ;-----------------------------------:
   733                                  drivers:
   734                                  conHdr:
   735 000006B3 [D506000000000000]          dq auxHdr
   736 000006BB 1308                        dw 0813h
   737 000006BD [4B08000000000000]          dq commonStrat
   738 000006C5 [6208000000000000]          dq conDriver
   739 000006CD 434F4E2020202020            db "CON     "
   740                                  auxHdr:
   741 000006D5 [F706000000000000]          dq prnHdr
   742 000006DD 0080                        dw 08000h
   743 000006DF [4B08000000000000]          dq commonStrat
   744 000006E7 [1D09000000000000]          dq com1Intr
   745 000006EF 4155582020202020            db "AUX     "
   746                                  prnHdr:
   747 000006F7 [1907000000000000]          dq clkHdr
   748 000006FF 40A0                        dw 0A040h
   749 00000701 [4B08000000000000]          dq commonStrat
   750 00000709 [E507000000000000]          dq lpt1Hdr
   751 00000711 50524E2020202020            db "PRN     "
   752                                  clkHdr:
   753 00000719 [3B07000000000000]          dq msdHdr
   754 00000721 0880                        dw 08008h
   755 00000723 [4B08000000000000]          dq commonStrat
   756 0000072B [1D09000000000000]          dq clkDriver
   757 00000733 434C4F434B242020            db "CLOCK$  "
   758                                  msdHdr:
   759 0000073B [5D07000000000000]          dq com1Hdr
   760 00000743 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   761 00000745 [4B08000000000000]          dq commonStrat
   762 0000074D [C809000000000000]          dq msdDriver
   763 00000755 0000000000000000            db 0,0,0,0,0,0,0,0
   764                                  com1Hdr:
   765 0000075D [7F07000000000000]          dq com2Hdr
   766 00000765 0080                        dw 08000h
   767 00000767 [4B08000000000000]          dq commonStrat
   768 0000076F [1D09000000000000]          dq com1Intr
   769 00000777 434F4D3120202020            db "COM1    "
   770                                  com2Hdr:
   771 0000077F [A107000000000000]          dq com3Hdr
   772 00000787 0080                        dw 08000h
   773 00000789 [4B08000000000000]          dq commonStrat
   774 00000791 [2609000000000000]          dq com2Intr
   775 00000799 434F4D3220202020            db "COM2    "
   776                                  com3Hdr:
   777 000007A1 [C307000000000000]          dq com4Hdr
   778 000007A9 0080                        dw 08000h
   779 000007AB [4B08000000000000]          dq commonStrat
   780 000007B3 [2F09000000000000]          dq com3Intr
   781 000007BB 434F4D3320202020            db "COM3    "
   782                                  com4Hdr:
   783 000007C3 [E507000000000000]          dq lpt1Hdr
   784 000007CB 0080                        dw 08000h
   785 000007CD [4B08000000000000]          dq commonStrat
   786 000007D5 [3809000000000000]          dq com4Intr
   787 000007DD 434F4D3420202020            db "COM4    "
   788                                  lpt1Hdr:
   789 000007E5 [0708000000000000]          dq lpt2Hdr
   790 000007ED 40A0                        dw 0A040h
   791 000007EF [4B08000000000000]          dq commonStrat
   792 000007F7 [B809000000000000]          dq lptDriver
   793 000007FF 4C50543120202020            db "LPT1    "
   794                                  lpt2Hdr:
   795 00000807 [2908000000000000]          dq lpt3Hdr
   796 0000080F 40A0                        dw 0A040h
   797 00000811 [4B08000000000000]          dq commonStrat
   798 00000819 [B809000000000000]          dq lptDriver
   799 00000821 4C50543220202020            db "LPT2    "
   800                                  lpt3Hdr:
   801 00000829 FFFFFFFFFFFFFFFF            dq -1
   802 00000831 40A0                        dw 0A040h
   803 00000833 [4B08000000000000]          dq commonStrat
   804 0000083B [B809000000000000]          dq lptDriver
   805 00000843 4C50543320202020            dq "LPT3    "
   806                                  
   807                                  commonStrat:
   808                                  ;DOS calls this function with rbx=Ptr to request header
   809 0000084B 48891D01000000              mov qword [reqHdrPtr], rbx
   810 00000852 C3                          ret
   811 00000853 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   812                                  
   813                                  nulStrat:
   814 0000085B 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   815                                  nulIntr:
   816 00000861 C3                          ret
   817                                  
   818                                  conDriver:
   819 00000862 50                          push rax
   820 00000863 53                          push rbx
   821 00000864 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   822 0000086B 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   823 0000086E 84C0                        test al, al
   824 00000870 7421                        jz conInit
   825 00000872 3C04                        cmp al, 4
   826 00000874 744D                        jz conRead
   827 00000876 3C05                        cmp al, 5
   828 00000878 7466                        jz conNondestructiveRead
   829 0000087A 3C06                        cmp al, 6
   830 0000087C 740C                        jz conExit
   831 0000087E 3C07                        cmp al, 7
   832 00000880 7471                        jz conFlushInputBuffers
   833 00000882 3C08                        cmp al, 8
   834 00000884 7479                        jz conWrite
   835 00000886 3C09                        cmp al, 9
   836 00000888 7475                        jz conWrite
   837                                  ;All other cases fall through here
   838                                  conExit:
   839 0000088A 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   840 00000890 5B                          pop rbx
   841 00000891 58                          pop rax
   842 00000892 C3                          ret
   843                                  conInit:    ;Function 0
   844 00000893 52                          push rdx
   845                                      ;Flush keyboard buffer
   846                                  .ci0:
   847 00000894 B401                        mov ah, 01      ;Get buffer status
   848 00000896 CD36                        int 36h
   849 00000898 7406                        jz .ci1      ;If zero clear => no more keys to read
   850 0000089A 30E4                        xor ah, ah
   851 0000089C CD36                        int 36h ;Read key to flush from buffer
   852 0000089E EBF4                        jmp short .ci0
   853                                  .ci1:
   854 000008A0 B800050000                  mov eax, 0500h  ;Set page zero as the default page
   855 000008A5 CD30                        int 30h
   856 000008A7 B402                        mov ah, 02h
   857 000008A9 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   858 000008AB 88D7                        mov bh, dl      ;Set cursor for page 0
   859 000008AD CD30                        int 30h
   860 000008AF B707                        mov bh, 07h     ;Grey/Black attribs
   861 000008B1 B800060000                  mov eax, 0600h  ;Clear whole screen
   862 000008B6 CD30                        int 30h
   863 000008B8 5A                          pop rdx
   864 000008B9 EBCF                        jmp short conExit
   865                                  conIORead:
   866 000008BB 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   867 000008C1 EBC7                        jmp short conExit
   868                                  conRead:    ;Function 4
   869 000008C3 57                          push rdi
   870 000008C4 51                          push rcx
   871 000008C5 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   872 000008C9 31C9                        xor ecx, ecx    ;Zero the char counter
   873                                  .cr1:
   874 000008CB 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   875 000008CE 7409                        je .cre2
   876 000008D0 31C0                        xor eax, eax
   877 000008D2 CD36                        int 36h
   878 000008D4 AA                          stosb   ;Store char in al into buffer and inc rdi
   879 000008D5 FFC1                        inc ecx
   880 000008D7 EBF2                        jmp short .cr1
   881                                  .cre2:
   882 000008D9 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   883 000008DC 59                          pop rcx
   884 000008DD 5F                          pop rdi
   885 000008DE EBAA                        jmp short conExit
   886                                  conNondestructiveRead:  ;Function 5
   887 000008E0 B401                        mov ah, 01h     ;Get key if exists
   888 000008E2 CD36                        int 36h
   889 000008E4 7405                        jz .cnr           ;If zero clear => no key, go forwards
   890                                      ;Keystroke available
   891 000008E6 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   892 000008E9 EB9F                        jmp short conExit
   893                                  .cnr: ;No keystroke available
   894 000008EB 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   895 000008F1 EB97                        jmp short conExit
   896                                  conFlushInputBuffers:   ;Function 7
   897 000008F3 B401                        mov ah, 01      ;Get buffer status
   898 000008F5 CD36                        int 36h
   899 000008F7 7491                        jz conExit      ;If zero clear => no more keys to read
   900 000008F9 30E4                        xor ah, ah
   901 000008FB CD36                        int 36h ;Read key to flush from buffer
   902 000008FD EBF4                        jmp short conFlushInputBuffers
   903                                  conWrite:   ;Function 8 and 9
   904 000008FF 56                          push rsi
   905 00000900 51                          push rcx
   906 00000901 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   907 00000905 31C9                        xor ecx, ecx    ;Zero the char counter
   908                                  .cw1: 
   909 00000907 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   910 0000090A 7407                        je .cw2
   911 0000090C AC                          lodsb   ;Get char into al, and inc rsi
   912 0000090D CD49                        int 49h ;Fast print char
   913 0000090F FFC1                        inc ecx
   914 00000911 EBF4                        jmp short .cw1 ;keep printing until all chars printed
   915                                  .cw2:
   916 00000913 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   917 00000916 59                          pop rcx
   918 00000917 5E                          pop rsi
   919 00000918 E96DFFFFFF                  jmp conExit
   920                                  
   921                                  clkDriver:
   922                                  
   923                                  comDriver:
   924                                  com1Intr:
   925 0000091D C6059300000000              mov byte [comDevice], 0
   926 00000924 EB19                        jmp short comIntr
   927                                  com2Intr:
   928 00000926 C6058A00000001              mov byte [comDevice], 1
   929 0000092D EB10                        jmp short comIntr
   930                                  com3Intr:
   931 0000092F C6058100000002              mov byte [comDevice], 2
   932 00000936 EB07                        jmp short comIntr
   933                                  com4Intr:
   934 00000938 C6057800000003              mov byte [comDevice], 3
   935                                  comIntr:
   936 0000093F 50                          push rax
   937 00000940 53                          push rbx
   938 00000941 51                          push rcx
   939 00000942 52                          push rdx
   940 00000943 56                          push rsi
   941 00000944 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   942 0000094B 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   943 0000094E 3C04                        cmp al, 4
   944 00000950 7418                        jz comRead
   945 00000952 3C05                        cmp al, 5
   946 00000954 7439                        jz comNondestructiveRead
   947 00000956 3C08                        cmp al, 8
   948 00000958 743D                        jz comWrite
   949 0000095A 3C09                        cmp al, 9
   950 0000095C 7439                        jz comWrite
   951                                  ;All other cases fall through here
   952                                  comExit:
   953 0000095E 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   954 00000964 5E                          pop rsi
   955 00000965 5A                          pop rdx
   956 00000966 59                          pop rcx
   957 00000967 5B                          pop rbx
   958 00000968 58                          pop rax
   959 00000969 C3                          ret
   960                                  comRead:
   961 0000096A 57                          push rdi
   962 0000096B 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   963 0000096F 31C9                        xor ecx, ecx    ;Zero the char counter
   964                                  .cr1:
   965 00000971 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   966 00000974 7413                        je .cre2
   967 00000976 B802000000                  mov eax, 02h    ;Recieve 
   968 0000097B 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   969 00000982 CD34                        int 34h ;Recieve Char
   970 00000984 AA                          stosb   ;Store char in al into buffer and inc rdi
   971 00000985 FFC1                        inc ecx
   972 00000987 EBE8                        jmp short .cr1
   973                                  .cre2:
   974 00000989 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   975 0000098C 5F                          pop rdi
   976 0000098D EBCF                        jmp short comExit
   977                                  comNondestructiveRead:
   978 0000098F 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
   979 00000995 EBC7                        jmp short comExit
   980                                  comWrite:
   981 00000997 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   982 0000099B 31C9                        xor ecx, ecx    ;Zero the char counter
   983                                  .cw1: 
   984 0000099D 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   985 000009A0 7410                        je .cw2
   986 000009A2 AC                          lodsb   ;Get char into al, and inc rsi
   987 000009A3 B401                        mov ah, 01h ;Move function number into ah
   988 000009A5 668B150B000000              mov dx, word [comDevice]
   989 000009AC CD34                        int 34h ;Transmit char
   990 000009AE FFC1                        inc ecx
   991 000009B0 EBEB                        jmp short .cw1 ;keep printing until all chars printed
   992                                  .cw2:
   993 000009B2 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   994 000009B5 EBA7                        jmp short comExit
   995 000009B7 00                      comDevice   db 0
   996                                  
   997                                  lptDriver:    ;Drivers for LPT 1, 2, 3
   998 000009B8 57                          push rdi
   999 000009B9 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
  1000 000009C0 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
  1001 000009C6 5F                          pop rdi
  1002 000009C7 C3                          ret
  1003                                  
  1004                                  msdDriver:
  1005 000009C8 50                          push rax
  1006 000009C9 53                          push rbx
  1007 000009CA 51                          push rcx
  1008 000009CB 52                          push rdx
  1009 000009CC 56                          push rsi
  1010 000009CD 57                          push rdi
  1011 000009CE 55                          push rbp
  1012 000009CF 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1013 000009D6 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1014 000009D9 3C18                        cmp al, 24  ;Check cmd num is valid
  1015 000009DB 776C                        ja .msdError
  1016 000009DD 84C0                        test al, al
  1017 000009DF 7476                        jz .msdInit
  1018 000009E1 3C01                        cmp al, 01
  1019 000009E3 0F8409010000                jz .msdMedChk
  1020 000009E9 3C02                        cmp al, 02
  1021 000009EB 0F8442010000                jz .msdBuildBPB
  1022 000009F1 3C03                        cmp al, 03
  1023 000009F3 0F847B010000                jz .msdIOCTLRead
  1024 000009F9 3C04                        cmp al, 04
  1025 000009FB 0F8478010000                jz .msdRead
  1026 00000A01 3C08                        cmp al, 08
  1027 00000A03 0F8482010000                jz .msdWrite
  1028 00000A09 3C09                        cmp al, 09
  1029 00000A0B 0F848C010000                jz .msdWriteVerify
  1030 00000A11 3C0C                        cmp al, 12
  1031 00000A13 0F849D010000                jz .msdIOCTLWrite
  1032 00000A19 3C0D                        cmp al, 13
  1033 00000A1B 0F849A010000                jz .msdDevOpen
  1034 00000A21 3C0E                        cmp al, 14
  1035 00000A23 0F84A2010000                jz .msdDevClose
  1036 00000A29 3C0F                        cmp al, 15
  1037 00000A2B 0F84AA010000                jz .msdRemovableMedia
  1038 00000A31 3C13                        cmp al, 19
  1039 00000A33 0F84C0010000                jz .msdGenericIOCTL
  1040 00000A39 3C17                        cmp al, 23
  1041 00000A3B 0F84BD010000                jz .msdGetLogicalDev
  1042 00000A41 3C18                        cmp al, 24
  1043 00000A43 0F84C3010000                jz .msdSetLogicalDev
  1044                                  .msdError:
  1045                                  .msdDriverExit:
  1046 00000A49 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1047 00000A4F 5D                          pop rbp
  1048 00000A50 5F                          pop rdi
  1049 00000A51 5E                          pop rsi
  1050 00000A52 5A                          pop rdx
  1051 00000A53 59                          pop rcx
  1052 00000A54 5B                          pop rbx
  1053 00000A55 58                          pop rax
  1054 00000A56 C3                          ret
  1055                                  .msdInit:            ;Function 0
  1056 00000A57 CD31                        int 31h ;Get number of Int 33h devices in r8b
  1057 00000A59 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1058 00000A5D 4489C0                      mov eax, r8d
  1059 00000A60 3C01                        cmp al, 1
  1060 00000A62 7702                        ja .mi1
  1061 00000A64 FEC0                        inc al ;Make it two
  1062                                  .mi1:
  1063 00000A66 BA05000000                  mov edx, 5
  1064 00000A6B 39D0                        cmp eax, edx
  1065 00000A6D 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1066 00000A70 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1067 00000A76 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1068 00000A79 440005(A9000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1069 00000A80 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1070 00000A82 488D3DE6010000              lea rdi, qword [.msdBPBblks]
  1071 00000A89 53                          push rbx
  1072                                  .mi2:
  1073 00000A8A 89EA                        mov edx, ebp
  1074 00000A8C 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1075 00000A93 31C9                        xor ecx, ecx    ;Sector 0
  1076 00000A95 B801820000                  mov eax, 8201h       ;Read 1 sector
  1077 00000A9A CD33                        int 33h
  1078 00000A9C 724E                        jc .msdInitError
  1079                                  
  1080 00000A9E 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1081 00000AA5 B90F000000                  mov ecx, bpbEx_size/8
  1082 00000AAA F348A5                      rep movsq   ;Move the BPB data into the right block
  1083                                  
  1084 00000AAD FFC5                        inc ebp
  1085 00000AAF 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1086 00000AB2 75D6                        jne .mi2  ;No? Go again
  1087                                  
  1088 00000AB4 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1089 00000ABB 488D15AD010000              lea rdx, qword [.msdBPBblks]
  1090                                  .mi3:
  1091 00000AC2 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1092 00000AC5 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1093 00000ACC FFCD                        dec ebp
  1094 00000ACE 75F2                        jnz .mi3  ;If not zero yet, go again
  1095                                  
  1096 00000AD0 5B                          pop rbx
  1097 00000AD1 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1098 00000AD8 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1099 00000ADC 488D15E4030000              lea rdx, qword [driverDataPtr]
  1100 00000AE3 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1101 00000AE7 E95DFFFFFF                  jmp .msdDriverExit
  1102                                  .msdInitError:
  1103 00000AEC 5B                          pop rbx
  1104 00000AED E957FFFFFF                  jmp .msdDriverExit
  1105                                  .msdMedChk:          ;Function 1
  1106                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1107                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1108                                  ; suffice.
  1109 00000AF2 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1110 00000AF7 8A90[3D0C0000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1111 00000AFD F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1112 00000B00 7528                        jnz .mmcNoChange
  1113                                  ;Now we test Media Descriptor
  1114 00000B02 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1115 00000B05 488B3CC5[470C0000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1116 00000B0D 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1117 00000B10 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1118 00000B13 740C                        je .mmcUnsure
  1119                                  .mmcChange: ;Fail safe, always assume the device has changed
  1120 00000B15 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1121 00000B19 48C7430F[330C0000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
  1122                                  .mmcUnsure:
  1123 00000B21 C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1124 00000B25 E91FFFFFFF                  jmp .msdDriverExit
  1125                                  .mmcNoChange:
  1126 00000B2A C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1127 00000B2E E916FFFFFF                  jmp .msdDriverExit
  1128                                  
  1129                                  .msdBuildBPB:        ;Function 2
  1130 00000B33 4889DE                      mov rsi, rbx
  1131 00000B36 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1132 00000B3B 8A90[3D0C0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1133 00000B41 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1134 00000B45 31C9                        xor ecx, ecx    ;Read Sector 0
  1135 00000B47 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1136 00000B4C CD33                        int 33h
  1137 00000B4E 7224                        jc .mbbpbError
  1138 00000B50 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1139 00000B53 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1140 00000B58 488B3CC5[470C0000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1141 00000B60 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1142 00000B63 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1143 00000B67 B90F000000                  mov ecx, bpbEx_size/8
  1144 00000B6C F348A5                      rep movsq   ;Move the BPB data into the right space
  1145 00000B6F E9D5FEFFFF                  jmp .msdDriverExit
  1146                                  .mbbpbError:
  1147                                  .msdIOCTLRead:       ;Function 3, returns done
  1148 00000B74 E9D0FEFFFF                  jmp .msdDriverExit
  1149                                  .msdRead:            ;Function 4
  1150 00000B79 4889DD                      mov rbp, rbx
  1151 00000B7C B482                        mov ah, 82h ;LBA Read Sectors
  1152 00000B7E E897000000                  call .msdBlkIOCommon
  1153 00000B83 4889EB                      mov rbx, rbp
  1154 00000B86 E9BEFEFFFF                  jmp .msdDriverExit
  1155                                  .msdWrite:           ;Function 8
  1156 00000B8B 4889DD                      mov rbp, rbx
  1157 00000B8E B483                        mov ah, 83h ;LBA Write Sectors
  1158 00000B90 E885000000                  call .msdBlkIOCommon
  1159 00000B95 4889EB                      mov rbx, rbp
  1160 00000B98 E9ACFEFFFF                  jmp .msdDriverExit
  1161                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1162 00000B9D 4889DD                      mov rbp, rbx
  1163 00000BA0 B483                        mov ah, 83h ;LBA Write Sectors
  1164 00000BA2 E873000000                  call .msdBlkIOCommon
  1165 00000BA7 B484                        mov ah, 84h ;LBA Verify Sectors
  1166 00000BA9 E86C000000                  call .msdBlkIOCommon
  1167 00000BAE 4889EB                      mov rbx, rbp
  1168 00000BB1 E993FEFFFF                  jmp .msdDriverExit
  1169                                  .msdIOCTLWrite:      ;Function 12, returns done
  1170 00000BB6 E98EFEFFFF                  jmp .msdDriverExit
  1171                                  .msdDevOpen:         ;Function 13
  1172 00000BBB 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1173 00000BC0 FE80[420C0000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1174 00000BC6 E97EFEFFFF                  jmp .msdDriverExit
  1175                                  .msdDevClose:        ;Function 14
  1176 00000BCB 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1177 00000BD0 FE88[420C0000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1178 00000BD6 E96EFEFFFF                  jmp .msdDriverExit
  1179                                  .msdRemovableMedia:  ;Function 15
  1180 00000BDB 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1181 00000BE0 8A80[3D0C0000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1182 00000BE6 A880                        test al, 80h
  1183 00000BE8 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1184 00000BEE 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
  1185 00000BF4 E950FEFFFF                  jmp .msdDriverExit
  1186                                  .msdGenericIOCTL:    ;Function 19
  1187 00000BF9 E94BFEFFFF                  jmp .msdDriverExit
  1188                                  .msdGetLogicalDev:   ;Function 23
  1189 00000BFE 8A0538000000                mov al, byte [.msdCurDev]
  1190 00000C04 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1191 00000C07 E93DFEFFFF                  jmp .msdDriverExit
  1192                                  .msdSetLogicalDev:   ;Function 24
  1193 00000C0C 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1194 00000C0F 880527000000                mov byte [.msdCurDev], al
  1195 00000C15 E92FFEFFFF                  jmp .msdDriverExit
  1196                                  
  1197                                  .msdBlkIOCommon:  ;Does block IO
  1198                                  ;Called with rbp containing old rbx value and ah with function number
  1199                                  ;Error handled by caller
  1200 00000C1A 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1201 00000C1F 8A90[3D0C0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1202 00000C25 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1203 00000C29 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
  1204 00000C2C 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1205 00000C30 CD33                        int 33h
  1206 00000C32 C3                          ret
  1207                                  
  1208 00000C33 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1209                                  ;LASTDRIVE default is 5
  1210 00000C3C 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1211                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1212 00000C3D 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1213 00000C42 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1214 00000C47 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1214 00000C50 000000000000000000-
  1214 00000C59 000000000000000000-
  1214 00000C62 000000000000000000-
  1214 00000C6B 00000000           
  1215 00000C6F 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1215 00000C78 000000000000000000-
  1215 00000C81 000000000000000000-
  1215 00000C8A 000000000000000000-
  1215 00000C93 000000000000000000-
  1215 00000C9C 000000000000000000-
  1215 00000CA5 000000000000000000-
  1215 00000CAE 000000000000000000-
  1215 00000CB7 000000000000000000-
  1215 00000CC0 000000000000000000-
  1215 00000CC9 000000000000000000-
  1215 00000CD2 000000000000000000-
  1215 00000CDB 000000000000000000-
  1215 00000CE4 000000000000000000-
  1215 00000CED 000000000000000000-
  1215 00000CF6 000000000000000000-
  1215 00000CFF 000000000000000000-
  1215 00000D08 000000000000000000-
  1215 00000D11 000000000000000000-
  1215 00000D1A 000000000000000000-
  1215 00000D23 000000000000000000-
  1215 00000D2C 000000000000000000-
  1215 00000D35 000000000000000000-
  1215 00000D3E 000000000000000000-
  1215 00000D47 000000000000000000-
  1215 00000D50 000000000000000000-
  1215 00000D59 000000000000000000-
  1215 00000D62 000000000000000000-
  1215 00000D6B 000000000000000000-
  1215 00000D74 000000000000000000-
  1215 00000D7D 000000000000000000-
  1215 00000D86 000000000000000000-
  1215 00000D8F 000000000000000000-
  1215 00000D98 000000000000000000-
  1215 00000DA1 000000000000000000-
  1215 00000DAA 000000000000000000-
  1215 00000DB3 000000000000000000-
  1215 00000DBC 000000000000000000-
  1215 00000DC5 000000000000000000-
  1215 00000DCE 000000000000000000-
  1215 00000DD7 000000000000000000-
  1215 00000DE0 000000000000000000-
  1215 00000DE9 000000000000000000-
  1215 00000DF2 000000000000000000-
  1215 00000DFB 000000000000000000-
  1215 00000E04 000000000000000000-
  1215 00000E0D 000000000000000000-
  1215 00000E16 000000000000000000-
  1215 00000E1F 000000000000000000-
  1215 00000E28 000000000000000000-
  1215 00000E31 000000000000000000-
  1215 00000E3A 000000000000000000-
  1215 00000E43 000000000000000000-
  1215 00000E4C 000000000000000000-
  1215 00000E55 000000000000000000-
  1215 00000E5E 000000000000000000-
  1215 00000E67 000000000000000000-
  1215 00000E70 000000000000000000-
  1215 00000E79 000000000000000000-
  1215 00000E82 000000000000000000-
  1215 00000E8B 000000000000000000-
  1215 00000E94 000000000000000000-
  1215 00000E9D 000000000000000000-
  1215 00000EA6 000000000000000000-
  1215 00000EAF 000000000000000000-
  1215 00000EB8 000000000000000000-
  1215 00000EC1 000000000000       
  1216                                  
  1217                                  driverDataPtr:
