     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Unit number byte (Block)
    18                              <1>     
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> 
    74                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    75                              <1> 
    76 00000000 ??????              <1>     .jmpBoot                resb 3 
    77 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
    78 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
    79 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
    80 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
    81 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
    82 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
    83 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
    84 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
    85 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    86 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
    87 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
    88 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
    89 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    90 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
    91 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
    92 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
    93 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
    94 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
    95                              <1>     
    96                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> 
    72                              <1> ;------------------------------------------------------------------------;
    73                              <1> ; The SFT is a way to allow applications to open file handles to files 
    74                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    75                              <1> ; under the first header, and then a second header will be linked to the 
    76                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    77                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    78                              <1> ; using the FCBS= command. Default FCBS=5.
    79                              <1> ;
    80                              <1> ; A file handle describes the file, and the location within the file that
    81                              <1> ; we are reading. The file handle can be manipulated without the file
    82                              <1> ; being in memory, thus allowing the user to access data without needing 
    83                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    84                              <1> ; accessing devices, by treating them as files with their drivers 
    85                              <1> ; responding and translating the manipulations of the file handle itself.
    86                              <1> ; Neither the driver nor the application should see or use the SFT for
    87                              <1> ; the handle, as it is subject to change (and will change when file 
    88                              <1> ; sharing provisions are included). The DOS will make requests to the 
    89                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    90                              <1> ; track of the information in the SFT entry for that handle. 
    91                              <1> ;
    92                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    93                              <1> ; can point to the same file. It all depends on what the applications 
    94                              <1> ; want to do with the File.
    95                              <1> ;
    96                              <1> ; !!!!IMPORTANT!!!!
    97                              <1> ; Currently there are plans for File Sharing, but I include minimal 
    98                              <1> ; provisions for it. I really just wanna get a DOS out the door.
    99                              <1> ;
   100                              <1> ;Each SFT may look like this:
   101                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   102                              <1> ;            |                |
   103                              <1> ;       wNumFiles*sft    wNumFiles*sft
   104                              <1> ;
   105                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   106                              <1> ; System FCBs.
   107                              <1> ;
   108                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   109                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   110                              <1> ;
   111                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   112                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   113                              <1> ;------------------------------------------------------------------------;
   114                              <1> struc sfth   ;System file table header
   115                              <1> ; This is the SFT header.
   116                              <1> ; This structure comes before the start of the first file in the array/table.
   117 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   118 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   119                              <1> endstruc
   120                              <1> 
   121                              <1> struc sft
   122                              <1> ;This is the file struc itself
   123 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   124 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   125 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   126 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   127 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   128 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   129 00000013 ????                <1>     .wTime       resw 1    ;File Time
   130 00000015 ????                <1>     .wDate       resw 1    ;File Date
   131 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   132 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   133 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   134 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   135 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   136 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   137 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   138 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   139                              <1> endstruc
   140                              <1> 
   141                              <1> ;------------------------------------------------------------------------;
   142                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   143                              <1> ; to an internal buffer, and then copying it to the specified location
   144                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   145                              <1> ; another request for the same sector from the same device is made, so 
   146                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   147                              <1> ; size, selected according to the largest detected sector size during 
   148                              <1> ; the initial loadup.
   149                              <1> ;
   150                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   151                              <1> ;
   152                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   153                              <1> ;------------------------------------------------------------------------;
   154                              <1> 
   155                              <1> struc bufferHdr
   156 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   157 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   158 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   159 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   160 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   161 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   162 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   163                              <1> endstruc
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   requestHdr  resb ioReqPkt_size   
    12                                      ;The device driver header with space for the largest possible packet
    13 00000033 ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    14 0000003B ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    15 00000043 ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    16 0000004B ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    17 00000053 ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    18                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    19 0000005B ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    20                                      ;                    The last driver loaded with the STDIN bit[0] set
    21 00000063 ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    22 00000065 ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    23 0000006D ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    24 00000075 ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    25 0000007D ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    26 0000007F ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    27 00000080 ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    28 00000081 ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    29 00000082 <res 22h>                   nulDevHdr   resb drvHdr_size
    30                                  
    31                                  
    32 000000A4 ??                          inDOS       resb 1    ;Inc on each DOS call, dec when leaving
    33 000000A5 ??                          breakFlag   resb 1    ;If set, check for CTRL+C on all DOS calls
    34 000000A6 ??                          defaultDrv  resb 1    ;Default, last accessed drive
    35 000000A7 ????????????????            currentPSP  resq 1    ;Address of current PSP
    36                                  
    37 000000AF <res 148h>                  critStack   resq 41
    38 000001F7 ????????????????            critStakTop resq 1
    39 000001FF <res 638h>                  IOStack     resq 199
    40 00000837 ????????????????            IOStakTop   resq 1
    41 0000083F <res 638h>                  DiskStack   resq 199
    42 00000E77 ????????????????            DiskStakTop resq 1
    43                                      dSegLen     equ     $
    44                                  
    45                                  Segment .text align=1
    46                                  ; We arrive here with the following values in the registers.
    47                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    48                                  ; dx  = Int 33h boot device number
    49                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    50 00000000 55AA                        dw 0AA55h           ;Initial signature
    51 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    52                                  
    53 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    54 0000000F 0F32                        rdmsr
    55 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    56 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    57 00000017 89C7                        mov edi, eax        ;Get the low dword in
    58                                  
    59 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    59 0000001E [00000000]         
    60 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    61 00000025 4881C7[7F0E0000]            add rdi, dSegLen ;Move destination past end of data area
    62 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    63 00000033 B900100000                  mov ecx, 1000h
    64 00000038 F348A5                      rep movsq
    65                                  
    66                                  ;Modify the pointers in nData before putting them in the data area
    67 0000003B 48012DB6000000              add qword [nData + drvHdr.nxtPtr], rbp
    68 00000042 48012DB9000000              add qword [nData + drvHdr.strPtr], rbp
    69 00000049 48012DBA000000              add qword [nData + drvHdr.intPtr], rbp
    70                                  ;Copy the Null driver to its location in Sysvars
    71 00000050 B922000000                  mov ecx, drvHdr_size
    72 00000055 488D359C000000              lea rsi, qword [nData]
    73 0000005C 488DBD[82000000]            lea rdi, qword [rbp + nulDevHdr]
    74 00000063 F3A4                        rep movsb   
    75                                  ;Adjust the addresses in the driver headers 
    76 00000065 6687DB                      xchg bx, bx
    77 00000068 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    77 0000006A [8D00000000000000] 
    78 00000072 B90C000000                  mov ecx, 12      ;12 drivers in data area
    79 00000077 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    80                                  adjDrivers:
    81 0000007B E84F000000                  call adjustDrvHdr
    82 00000080 E2F9                        loop adjDrivers
    83                                  
    84                                      ;Open NUL
    85 00000082 488D9D[8C000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    86 00000089 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    87 0000008C 30C0                        xor al, al
    88 0000008E FFD3                        call rbx
    89                                  
    90                                      ;Open CON
    91 00000090 48BB-                       mov rbx, conDriver
    91 00000092 [3C02000000000000] 
    92 0000009A 488D5C1D00                  lea rbx, qword [rbp+rbx]
    93 0000009F 30C0                        xor al, al
    94 000000A1 FFD3                        call rbx
    95                                  
    96                                      ;Open Mass Storage
    97 000000A3 48BB-                       mov rbx, msdDriver
    97 000000A5 [A203000000000000] 
    98 000000AD 488D5C1D00                  lea rbx, qword [rbp+rbx]
    99 000000B2 30C0                        xor al, al
   100 000000B4 FFD3                        call rbx
   101                                  
   102 000000B6 488D2D25000000              lea rbp, qword [startmsg]   ;Get the absolute address of message
   103 000000BD B804130000                  mov eax, 1304h
   104 000000C2 CD30                        int 30h
   105                                  l1:
   106 000000C4 6631C0                      xor ax, ax
   107 000000C7 CD36                        int 36h
   108 000000C9 B40E                        mov ah, 0Eh
   109 000000CB CD30                        int 30h
   110 000000CD EBF5                        jmp short l1
   111                                  adjustDrvHdr:
   112                                  ;Input: rsi = Effective address of driver in DOS segment
   113                                  ;       rbp = Ptr to the start of the DOS segment
   114                                  ;Output: rsi = EA of next header in DOS segment
   115 000000CF 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   116 000000D2 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   117 000000D6 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   118 000000DA 4881C622000000              add rsi, drvHdr_size
   119 000000E1 C3                          ret
   120                                  
   121 000000E2 5374617274696E6720-     startmsg db "Starting SCP/DOS...",0Ah,0Dh,0
   121 000000EB 5343502F444F532E2E-
   121 000000F4 2E0A0D00           
   122                                  nData:
   123 000000F8 [8D00000000000000]          dq conHdr
   124 00000100 0480                        dw 08004h
   125 00000102 [3502000000000000]          dq nulStrat
   126 0000010A [3B02000000000000]          dq nulIntr
   127 00000112 4E554C2020202020            db "NUL     " ;Default NUL data
   128                                  
   129                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   130                                  ;-----------------------------------:
   131                                  ;       Misc System routines        :
   132                                  ;-----------------------------------:
   133                                  findLRUBuffer: 
   134                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   135                                  ;Input: Nothing
   136                                  ;Output: rbx = Pointer to the buffer to use
   137 00000000 52                          push rdx
   138 00000001 488B1D(65000000)            mov rbx, qword [bufHeadPtr]
   139 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   140 0000000F 7502                        jne .flb1
   141 00000011 5A                          pop rdx
   142 00000012 C3                          ret
   143                                  .flb1:
   144 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   145 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   146 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   147 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   148 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   149 00000029 488B15(65000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   150 00000030 48891D(65000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   151 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   152 0000003A 5A                          pop rdx
   153 0000003B C3                          ret
   154                                  
   155                                  findDPB:
   156                                  ;Finds the DPB for a given drive
   157                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   158                                  ;Output: al = 00, rbx = Pointer to the DPB
   159                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   160 0000003C 488B1D(43000000)            mov rbx, qword [dpbHeadPtr]
   161                                  .fd1:
   162 00000043 30C0                        xor al, al
   163 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   164 00000047 740F                        je .fd2
   165 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   166 0000004D B0FF                        mov al, -1
   167 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   168 00000056 75EB                        jne .fd1
   169                                  .fd2:
   170 00000058 C3                          ret
   171                                  ;-----------------------------------:
   172                                  ;       File System routines        :
   173                                  ;-----------------------------------:
   174                                  fatProc:
   175                                  ;-----------------------------------:
   176                                  ;        Interrupt routines         :
   177                                  ;-----------------------------------:
   178                                  terminateProcess:   ;Int 40h
   179                                  functionDispatch:   ;Int 41h Main function dispatcher
   180                                  terminateHandler:   ;Int 42h
   181                                  ctrlCHandler:       ;Int 43h
   182                                  critErrorHandler:   ;Int 44h
   183                                  absDiskRead:        ;Int 45h
   184                                  ;al = Drive number
   185                                  ;rbx = Memory Buffer address
   186                                  ;ecx = Number of sectors to read (max 255 for now)
   187                                  ;rdx = Start LBA to read from
   188 00000059 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   189 0000005D 8A80[17060000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   190 00000063 4891                        xchg rax, rcx
   191 00000065 4887CA                      xchg rcx, rdx
   192 00000068 B482                        mov ah, 82h
   193 0000006A CD33                        int 33h
   194 0000006C 48CF                        iretq
   195                                  absDiskWrite:       ;Int 46h
   196 0000006E 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   197 00000072 8A80[17060000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   198 00000078 4891                        xchg rax, rcx
   199 0000007A 4887CA                      xchg rcx, rdx
   200 0000007D B483                        mov ah, 83h
   201 0000007F CD33                        int 33h
   202 00000081 48CF                        iretq
   203                                  terminateResident:  ;Int 47h
   204                                  inDosHandler:       ;Int 48h
   205                                  ;Called when DOS idle
   206 00000083 48CF                        iretq
   207                                  fastOutput:         ;Int 49h
   208                                  ;Called with char to transfer in al
   209 00000085 50                          push rax
   210 00000086 B40E                        mov ah, 0Eh
   211 00000088 CD30                        int 30h
   212 0000008A 58                          pop rax
   213 0000008B 48CF                        iretq
   214                                  passCommand:        ;Int 4Eh
   215                                  multiplex:          ;Int 4Fh
   216                                  ;-----------------------------------:
   217                                  ;          Driver routines          :
   218                                  ;-----------------------------------:
   219                                  drivers:
   220                                  conHdr:
   221 0000008D [AF00000000000000]          dq auxHdr
   222 00000095 1308                        dw 0813h
   223 00000097 [2502000000000000]          dq commonStrat
   224 0000009F [3C02000000000000]          dq conDriver
   225 000000A7 434F4E2020202020            db "CON     "
   226                                  auxHdr:
   227 000000AF [D100000000000000]          dq prnHdr
   228 000000B7 0080                        dw 08000h
   229 000000B9 [2502000000000000]          dq commonStrat
   230 000000C1 [F702000000000000]          dq com1Intr
   231 000000C9 4155582020202020            db "AUX     "
   232                                  prnHdr:
   233 000000D1 [F300000000000000]          dq clkHdr
   234 000000D9 40A0                        dw 0A040h
   235 000000DB [2502000000000000]          dq commonStrat
   236 000000E3 [BF01000000000000]          dq lpt1Hdr
   237 000000EB 50524E2020202020            db "PRN     "
   238                                  clkHdr:
   239 000000F3 [1501000000000000]          dq msdHdr
   240 000000FB 0880                        dw 08008h
   241 000000FD [2502000000000000]          dq commonStrat
   242 00000105 [F702000000000000]          dq clkDriver
   243 0000010D 434C4F434B242020            db "CLOCK$  "
   244                                  msdHdr:
   245 00000115 [3701000000000000]          dq com1Hdr
   246 0000011D 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   247 0000011F [2502000000000000]          dq commonStrat
   248 00000127 [A203000000000000]          dq msdDriver
   249 0000012F 0000000000000000            db 0,0,0,0,0,0,0,0
   250                                  com1Hdr:
   251 00000137 [5901000000000000]          dq com2Hdr
   252 0000013F 0080                        dw 08000h
   253 00000141 [2502000000000000]          dq commonStrat
   254 00000149 [F702000000000000]          dq com1Intr
   255 00000151 434F4D3120202020            db "COM1    "
   256                                  com2Hdr:
   257 00000159 [7B01000000000000]          dq com3Hdr
   258 00000161 0080                        dw 08000h
   259 00000163 [2502000000000000]          dq commonStrat
   260 0000016B [0003000000000000]          dq com2Intr
   261 00000173 434F4D3220202020            db "COM2    "
   262                                  com3Hdr:
   263 0000017B [9D01000000000000]          dq com4Hdr
   264 00000183 0080                        dw 08000h
   265 00000185 [2502000000000000]          dq commonStrat
   266 0000018D [0903000000000000]          dq com3Intr
   267 00000195 434F4D3320202020            db "COM3    "
   268                                  com4Hdr:
   269 0000019D [BF01000000000000]          dq lpt1Hdr
   270 000001A5 0080                        dw 08000h
   271 000001A7 [2502000000000000]          dq commonStrat
   272 000001AF [1203000000000000]          dq com4Intr
   273 000001B7 434F4D3420202020            db "COM4    "
   274                                  lpt1Hdr:
   275 000001BF [E101000000000000]          dq lpt2Hdr
   276 000001C7 40A0                        dw 0A040h
   277 000001C9 [2502000000000000]          dq commonStrat
   278 000001D1 [9203000000000000]          dq lptDriver
   279 000001D9 4C50543120202020            db "LPT1    "
   280                                  lpt2Hdr:
   281 000001E1 [0302000000000000]          dq lpt3Hdr
   282 000001E9 40A0                        dw 0A040h
   283 000001EB [2502000000000000]          dq commonStrat
   284 000001F3 [9203000000000000]          dq lptDriver
   285 000001FB 4C50543220202020            db "LPT2    "
   286                                  lpt3Hdr:
   287 00000203 FFFFFFFFFFFFFFFF            dq -1
   288 0000020B 40A0                        dw 0A040h
   289 0000020D [2502000000000000]          dq commonStrat
   290 00000215 [9203000000000000]          dq lptDriver
   291 0000021D 4C50543320202020            dq "LPT3    "
   292                                  
   293                                  commonStrat:
   294                                  ;DOS calls this function with rbx=Ptr to request header
   295 00000225 48891D01000000              mov qword [reqHdrPtr], rbx
   296 0000022C C3                          ret
   297 0000022D 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   298                                  
   299                                  nulStrat:
   300 00000235 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   301                                  nulIntr:
   302 0000023B C3                          ret
   303                                  
   304                                  conDriver:
   305 0000023C 50                          push rax
   306 0000023D 53                          push rbx
   307 0000023E 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   308 00000245 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   309 00000248 84C0                        test al, al
   310 0000024A 7421                        jz conInit
   311 0000024C 3C04                        cmp al, 4
   312 0000024E 744D                        jz conRead
   313 00000250 3C05                        cmp al, 5
   314 00000252 7466                        jz conNondestructiveRead
   315 00000254 3C06                        cmp al, 6
   316 00000256 740C                        jz conExit
   317 00000258 3C07                        cmp al, 7
   318 0000025A 7471                        jz conFlushInputBuffers
   319 0000025C 3C08                        cmp al, 8
   320 0000025E 7479                        jz conWrite
   321 00000260 3C09                        cmp al, 9
   322 00000262 7475                        jz conWrite
   323                                  ;All other cases fall through here
   324                                  conExit:
   325 00000264 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   326 0000026A 5B                          pop rbx
   327 0000026B 58                          pop rax
   328 0000026C C3                          ret
   329                                  conInit:    ;Function 0
   330 0000026D 52                          push rdx
   331                                      ;Flush keyboard buffer
   332                                  .ci0:
   333 0000026E B401                        mov ah, 01      ;Get buffer status
   334 00000270 CD36                        int 36h
   335 00000272 7406                        jz .ci1      ;If zero clear => no more keys to read
   336 00000274 30E4                        xor ah, ah
   337 00000276 CD36                        int 36h ;Read key to flush from buffer
   338 00000278 EBF4                        jmp short .ci0
   339                                  .ci1:
   340 0000027A B800050000                  mov eax, 0500h  ;Set page zero as the default page
   341 0000027F CD30                        int 30h
   342 00000281 B402                        mov ah, 02h
   343 00000283 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   344 00000285 88D7                        mov bh, dl      ;Set cursor for page 0
   345 00000287 CD30                        int 30h
   346 00000289 B707                        mov bh, 07h     ;Grey/Black attribs
   347 0000028B B800060000                  mov eax, 0600h  ;Clear whole screen
   348 00000290 CD30                        int 30h
   349 00000292 5A                          pop rdx
   350 00000293 EBCF                        jmp short conExit
   351                                  conIORead:
   352 00000295 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   353 0000029B EBC7                        jmp short conExit
   354                                  conRead:    ;Function 4
   355 0000029D 57                          push rdi
   356 0000029E 51                          push rcx
   357 0000029F 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   358 000002A3 31C9                        xor ecx, ecx    ;Zero the char counter
   359                                  .cr1:
   360 000002A5 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   361 000002A8 7409                        je .cre2
   362 000002AA 31C0                        xor eax, eax
   363 000002AC CD36                        int 36h
   364 000002AE AA                          stosb   ;Store char in al into buffer and inc rdi
   365 000002AF FFC1                        inc ecx
   366 000002B1 EBF2                        jmp short .cr1
   367                                  .cre2:
   368 000002B3 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   369 000002B6 59                          pop rcx
   370 000002B7 5F                          pop rdi
   371 000002B8 EBAA                        jmp short conExit
   372                                  conNondestructiveRead:  ;Function 5
   373 000002BA B401                        mov ah, 01h     ;Get key if exists
   374 000002BC CD36                        int 36h
   375 000002BE 7405                        jz .cnr           ;If zero clear => no key, go forwards
   376                                      ;Keystroke available
   377 000002C0 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   378 000002C3 EB9F                        jmp short conExit
   379                                  .cnr: ;No keystroke available
   380 000002C5 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   381 000002CB EB97                        jmp short conExit
   382                                  conFlushInputBuffers:   ;Function 7
   383 000002CD B401                        mov ah, 01      ;Get buffer status
   384 000002CF CD36                        int 36h
   385 000002D1 7491                        jz conExit      ;If zero clear => no more keys to read
   386 000002D3 30E4                        xor ah, ah
   387 000002D5 CD36                        int 36h ;Read key to flush from buffer
   388 000002D7 EBF4                        jmp short conFlushInputBuffers
   389                                  conWrite:   ;Function 8 and 9
   390 000002D9 56                          push rsi
   391 000002DA 51                          push rcx
   392 000002DB 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   393 000002DF 31C9                        xor ecx, ecx    ;Zero the char counter
   394                                  .cw1: 
   395 000002E1 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   396 000002E4 7407                        je .cw2
   397 000002E6 AC                          lodsb   ;Get char into al, and inc rsi
   398 000002E7 CD49                        int 49h ;Fast print char
   399 000002E9 FFC1                        inc ecx
   400 000002EB EBF4                        jmp short .cw1 ;keep printing until all chars printed
   401                                  .cw2:
   402 000002ED 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   403 000002F0 59                          pop rcx
   404 000002F1 5E                          pop rsi
   405 000002F2 E96DFFFFFF                  jmp conExit
   406                                  
   407                                  clkDriver:
   408                                  
   409                                  comDriver:
   410                                  com1Intr:
   411 000002F7 C6059300000000              mov byte [comDevice], 0
   412 000002FE EB19                        jmp short comIntr
   413                                  com2Intr:
   414 00000300 C6058A00000001              mov byte [comDevice], 1
   415 00000307 EB10                        jmp short comIntr
   416                                  com3Intr:
   417 00000309 C6058100000002              mov byte [comDevice], 2
   418 00000310 EB07                        jmp short comIntr
   419                                  com4Intr:
   420 00000312 C6057800000003              mov byte [comDevice], 3
   421                                  comIntr:
   422 00000319 50                          push rax
   423 0000031A 53                          push rbx
   424 0000031B 51                          push rcx
   425 0000031C 52                          push rdx
   426 0000031D 56                          push rsi
   427 0000031E 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   428 00000325 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   429 00000328 3C04                        cmp al, 4
   430 0000032A 7418                        jz comRead
   431 0000032C 3C05                        cmp al, 5
   432 0000032E 7439                        jz comNondestructiveRead
   433 00000330 3C08                        cmp al, 8
   434 00000332 743D                        jz comWrite
   435 00000334 3C09                        cmp al, 9
   436 00000336 7439                        jz comWrite
   437                                  ;All other cases fall through here
   438                                  comExit:
   439 00000338 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   440 0000033E 5E                          pop rsi
   441 0000033F 5A                          pop rdx
   442 00000340 59                          pop rcx
   443 00000341 5B                          pop rbx
   444 00000342 58                          pop rax
   445 00000343 C3                          ret
   446                                  comRead:
   447 00000344 57                          push rdi
   448 00000345 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   449 00000349 31C9                        xor ecx, ecx    ;Zero the char counter
   450                                  .cr1:
   451 0000034B 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   452 0000034E 7413                        je .cre2
   453 00000350 B802000000                  mov eax, 02h    ;Recieve 
   454 00000355 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   455 0000035C CD34                        int 34h ;Recieve Char
   456 0000035E AA                          stosb   ;Store char in al into buffer and inc rdi
   457 0000035F FFC1                        inc ecx
   458 00000361 EBE8                        jmp short .cr1
   459                                  .cre2:
   460 00000363 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   461 00000366 5F                          pop rdi
   462 00000367 EBCF                        jmp short comExit
   463                                  comNondestructiveRead:
   464 00000369 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
   465 0000036F EBC7                        jmp short comExit
   466                                  comWrite:
   467 00000371 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   468 00000375 31C9                        xor ecx, ecx    ;Zero the char counter
   469                                  .cw1: 
   470 00000377 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   471 0000037A 7410                        je .cw2
   472 0000037C AC                          lodsb   ;Get char into al, and inc rsi
   473 0000037D B401                        mov ah, 01h ;Move function number into ah
   474 0000037F 668B150B000000              mov dx, word [comDevice]
   475 00000386 CD34                        int 34h ;Transmit char
   476 00000388 FFC1                        inc ecx
   477 0000038A EBEB                        jmp short .cw1 ;keep printing until all chars printed
   478                                  .cw2:
   479 0000038C 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   480 0000038F EBA7                        jmp short comExit
   481 00000391 00                      comDevice   db 0
   482                                  
   483                                  lptDriver:    ;Drivers for LPT 1, 2, 3
   484 00000392 57                          push rdi
   485 00000393 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
   486 0000039A 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
   487 000003A0 5F                          pop rdi
   488 000003A1 C3                          ret
   489                                  
   490                                  msdDriver:
   491 000003A2 50                          push rax
   492 000003A3 53                          push rbx
   493 000003A4 51                          push rcx
   494 000003A5 52                          push rdx
   495 000003A6 56                          push rsi
   496 000003A7 57                          push rdi
   497 000003A8 55                          push rbp
   498 000003A9 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
   499 000003B0 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
   500 000003B3 3C18                        cmp al, 24  ;Check cmd num is valid
   501 000003B5 776C                        ja .msdError
   502 000003B7 84C0                        test al, al
   503 000003B9 7476                        jz .msdInit
   504 000003BB 3C01                        cmp al, 01
   505 000003BD 0F8409010000                jz .msdMedChk
   506 000003C3 3C02                        cmp al, 02
   507 000003C5 0F8442010000                jz .msdBuildBPB
   508 000003CB 3C03                        cmp al, 03
   509 000003CD 0F847B010000                jz .msdIOCTLRead
   510 000003D3 3C04                        cmp al, 04
   511 000003D5 0F8478010000                jz .msdRead
   512 000003DB 3C08                        cmp al, 08
   513 000003DD 0F8482010000                jz .msdWrite
   514 000003E3 3C09                        cmp al, 09
   515 000003E5 0F848C010000                jz .msdWriteVerify
   516 000003EB 3C0C                        cmp al, 12
   517 000003ED 0F849D010000                jz .msdIOCTLWrite
   518 000003F3 3C0D                        cmp al, 13
   519 000003F5 0F849A010000                jz .msdDevOpen
   520 000003FB 3C0E                        cmp al, 14
   521 000003FD 0F84A2010000                jz .msdDevClose
   522 00000403 3C0F                        cmp al, 15
   523 00000405 0F84AA010000                jz .msdRemovableMedia
   524 0000040B 3C13                        cmp al, 19
   525 0000040D 0F84C0010000                jz .msdGenericIOCTL
   526 00000413 3C17                        cmp al, 23
   527 00000415 0F84BD010000                jz .msdGetLogicalDev
   528 0000041B 3C18                        cmp al, 24
   529 0000041D 0F84C3010000                jz .msdSetLogicalDev
   530                                  .msdError:
   531                                  .msdDriverExit:
   532 00000423 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
   533 00000429 5D                          pop rbp
   534 0000042A 5F                          pop rdi
   535 0000042B 5E                          pop rsi
   536 0000042C 5A                          pop rdx
   537 0000042D 59                          pop rcx
   538 0000042E 5B                          pop rbx
   539 0000042F 58                          pop rax
   540 00000430 C3                          ret
   541                                  .msdInit:            ;Function 0
   542 00000431 CD31                        int 31h ;Get number of Int 33h devices in r8b
   543 00000433 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
   544 00000437 4489C0                      mov eax, r8d
   545 0000043A 3C01                        cmp al, 1
   546 0000043C 7702                        ja .mi1
   547 0000043E FEC0                        inc al ;Make it two
   548                                  .mi1:
   549 00000440 BA05000000                  mov edx, 5
   550 00000445 39D0                        cmp eax, edx
   551 00000447 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
   552 0000044A 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
   553 00000450 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
   554 00000453 440005(7F000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
   555 0000045A 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
   556 0000045C 488D3DE6010000              lea rdi, qword [.msdBPBblks]
   557 00000463 53                          push rbx
   558                                  .mi2:
   559 00000464 89EA                        mov edx, ebp
   560 00000466 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
   561 0000046D 31C9                        xor ecx, ecx    ;Sector 0
   562 0000046F B801820000                  mov eax, 8201h       ;Read 1 sector
   563 00000474 CD33                        int 33h
   564 00000476 724E                        jc .msdInitError
   565                                  
   566 00000478 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
   567 0000047F B90F000000                  mov ecx, bpbEx_size/8
   568 00000484 F348A5                      rep movsq   ;Move the BPB data into the right block
   569                                  
   570 00000487 FFC5                        inc ebp
   571 00000489 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
   572 0000048C 75D6                        jne .mi2  ;No? Go again
   573                                  
   574 0000048E 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
   575 00000495 488D15AD010000              lea rdx, qword [.msdBPBblks]
   576                                  .mi3:
   577 0000049C 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
   578 0000049F 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
   579 000004A6 FFCD                        dec ebp
   580 000004A8 75F2                        jnz .mi3  ;If not zero yet, go again
   581                                  
   582 000004AA 5B                          pop rbx
   583 000004AB 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
   584 000004B2 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
   585 000004B6 488D15E4030000              lea rdx, qword [driverDataPtr]
   586 000004BD 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
   587 000004C1 E95DFFFFFF                  jmp .msdDriverExit
   588                                  .msdInitError:
   589 000004C6 5B                          pop rbx
   590 000004C7 E957FFFFFF                  jmp .msdDriverExit
   591                                  .msdMedChk:          ;Function 1
   592                                  ;Once the BIOS function is implmented that reads the changeline, use that!
   593                                  ;For BIOSes that dont support the changeline, the following procedure will 
   594                                  ; suffice.
   595 000004CC 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
   596 000004D1 8A90[17060000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
   597 000004D7 F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
   598 000004DA 7528                        jnz .mmcNoChange
   599                                  ;Now we test Media Descriptor
   600 000004DC 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
   601 000004DF 488B3CC5[21060000]          mov rdi, qword [.msdBPBTbl + 8*rax]
   602 000004E7 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
   603 000004EA 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
   604 000004ED 740C                        je .mmcUnsure
   605                                  .mmcChange: ;Fail safe, always assume the device has changed
   606 000004EF C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
   607 000004F3 48C7430F[0D060000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
   608                                  .mmcUnsure:
   609 000004FB C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
   610 000004FF E91FFFFFFF                  jmp .msdDriverExit
   611                                  .mmcNoChange:
   612 00000504 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
   613 00000508 E916FFFFFF                  jmp .msdDriverExit
   614                                  
   615                                  .msdBuildBPB:        ;Function 2
   616 0000050D 4889DE                      mov rsi, rbx
   617 00000510 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
   618 00000515 8A90[17060000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
   619 0000051B 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
   620 0000051F 31C9                        xor ecx, ecx    ;Read Sector 0
   621 00000521 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
   622 00000526 CD33                        int 33h
   623 00000528 7224                        jc .mbbpbError
   624 0000052A 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
   625 0000052D 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
   626 00000532 488B3CC5[21060000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
   627 0000053A 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
   628 0000053D 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
   629 00000541 B90F000000                  mov ecx, bpbEx_size/8
   630 00000546 F348A5                      rep movsq   ;Move the BPB data into the right space
   631 00000549 E9D5FEFFFF                  jmp .msdDriverExit
   632                                  .mbbpbError:
   633                                  .msdIOCTLRead:       ;Function 3, returns done
   634 0000054E E9D0FEFFFF                  jmp .msdDriverExit
   635                                  .msdRead:            ;Function 4
   636 00000553 4889DD                      mov rbp, rbx
   637 00000556 B482                        mov ah, 82h ;LBA Read Sectors
   638 00000558 E897000000                  call .msdBlkIOCommon
   639 0000055D 4889EB                      mov rbx, rbp
   640 00000560 E9BEFEFFFF                  jmp .msdDriverExit
   641                                  .msdWrite:           ;Function 8
   642 00000565 4889DD                      mov rbp, rbx
   643 00000568 B483                        mov ah, 83h ;LBA Write Sectors
   644 0000056A E885000000                  call .msdBlkIOCommon
   645 0000056F 4889EB                      mov rbx, rbp
   646 00000572 E9ACFEFFFF                  jmp .msdDriverExit
   647                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
   648 00000577 4889DD                      mov rbp, rbx
   649 0000057A B483                        mov ah, 83h ;LBA Write Sectors
   650 0000057C E873000000                  call .msdBlkIOCommon
   651 00000581 B484                        mov ah, 84h ;LBA Verify Sectors
   652 00000583 E86C000000                  call .msdBlkIOCommon
   653 00000588 4889EB                      mov rbx, rbp
   654 0000058B E993FEFFFF                  jmp .msdDriverExit
   655                                  .msdIOCTLWrite:      ;Function 12, returns done
   656 00000590 E98EFEFFFF                  jmp .msdDriverExit
   657                                  .msdDevOpen:         ;Function 13
   658 00000595 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
   659 0000059A FE80[1C060000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
   660 000005A0 E97EFEFFFF                  jmp .msdDriverExit
   661                                  .msdDevClose:        ;Function 14
   662 000005A5 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
   663 000005AA FE88[1C060000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
   664 000005B0 E96EFEFFFF                  jmp .msdDriverExit
   665                                  .msdRemovableMedia:  ;Function 15
   666 000005B5 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
   667 000005BA 8A80[17060000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
   668 000005C0 A880                        test al, 80h
   669 000005C2 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
   670 000005C8 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
   671 000005CE E950FEFFFF                  jmp .msdDriverExit
   672                                  .msdGenericIOCTL:    ;Function 19
   673 000005D3 E94BFEFFFF                  jmp .msdDriverExit
   674                                  .msdGetLogicalDev:   ;Function 23
   675 000005D8 8A0538000000                mov al, byte [.msdCurDev]
   676 000005DE 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
   677 000005E1 E93DFEFFFF                  jmp .msdDriverExit
   678                                  .msdSetLogicalDev:   ;Function 24
   679 000005E6 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
   680 000005E9 880527000000                mov byte [.msdCurDev], al
   681 000005EF E92FFEFFFF                  jmp .msdDriverExit
   682                                  
   683                                  .msdBlkIOCommon:  ;Does block IO
   684                                  ;Called with rbp containing old rbx value and ah with function number
   685                                  ;Error handled by caller
   686 000005F4 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
   687 000005F9 8A90[17060000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
   688 000005FF 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
   689 00000603 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
   690 00000606 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
   691 0000060A CD33                        int 33h
   692 0000060C C3                          ret
   693                                  
   694 0000060D 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
   695                                  ;LASTDRIVE default is 5
   696 00000616 00                      .msdCurDev   db 0  ;The device to be referenced by the driver is saved here!
   697 00000617 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
   698 0000061C 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
   699 00000621 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
   699 0000062A 000000000000000000-
   699 00000633 000000000000000000-
   699 0000063C 000000000000000000-
   699 00000645 00000000           
   700 00000649 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
   700 00000652 000000000000000000-
   700 0000065B 000000000000000000-
   700 00000664 000000000000000000-
   700 0000066D 000000000000000000-
   700 00000676 000000000000000000-
   700 0000067F 000000000000000000-
   700 00000688 000000000000000000-
   700 00000691 000000000000000000-
   700 0000069A 000000000000000000-
   700 000006A3 000000000000000000-
   700 000006AC 000000000000000000-
   700 000006B5 000000000000000000-
   700 000006BE 000000000000000000-
   700 000006C7 000000000000000000-
   700 000006D0 000000000000000000-
   700 000006D9 000000000000000000-
   700 000006E2 000000000000000000-
   700 000006EB 000000000000000000-
   700 000006F4 000000000000000000-
   700 000006FD 000000000000000000-
   700 00000706 000000000000000000-
   700 0000070F 000000000000000000-
   700 00000718 000000000000000000-
   700 00000721 000000000000000000-
   700 0000072A 000000000000000000-
   700 00000733 000000000000000000-
   700 0000073C 000000000000000000-
   700 00000745 000000000000000000-
   700 0000074E 000000000000000000-
   700 00000757 000000000000000000-
   700 00000760 000000000000000000-
   700 00000769 000000000000000000-
   700 00000772 000000000000000000-
   700 0000077B 000000000000000000-
   700 00000784 000000000000000000-
   700 0000078D 000000000000000000-
   700 00000796 000000000000000000-
   700 0000079F 000000000000000000-
   700 000007A8 000000000000000000-
   700 000007B1 000000000000000000-
   700 000007BA 000000000000000000-
   700 000007C3 000000000000000000-
   700 000007CC 000000000000000000-
   700 000007D5 000000000000000000-
   700 000007DE 000000000000000000-
   700 000007E7 000000000000000000-
   700 000007F0 000000000000000000-
   700 000007F9 000000000000000000-
   700 00000802 000000000000000000-
   700 0000080B 000000000000000000-
   700 00000814 000000000000000000-
   700 0000081D 000000000000000000-
   700 00000826 000000000000000000-
   700 0000082F 000000000000000000-
   700 00000838 000000000000000000-
   700 00000841 000000000000000000-
   700 0000084A 000000000000000000-
   700 00000853 000000000000000000-
   700 0000085C 000000000000000000-
   700 00000865 000000000000000000-
   700 0000086E 000000000000000000-
   700 00000877 000000000000000000-
   700 00000880 000000000000000000-
   700 00000889 000000000000000000-
   700 00000892 000000000000000000-
   700 0000089B 000000000000       
   701                                  
   702                                  driverDataPtr:
