     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, pointer to rax saved in oldRSP
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> ;Pushed by Processor when invoked via Interrupt
   186 00000048 ????????????????    <1>     .rip    resq 1
   187 00000050 ????????????????    <1>     .cs     resq 1
   188 00000058 ????????????????    <1>     .flags  resq 1
   189                              <1> endstruc
   190                              <1> 
   191                              <1> %macro pushDOS 0
   192                              <1>     push r9
   193                              <1>     push r8
   194                              <1>     push rbp
   195                              <1>     push rdi
   196                              <1>     push rsi
   197                              <1>     push rdx
   198                              <1>     push rcx
   199                              <1>     push rbx
   200                              <1>     push rax
   201                              <1> %endmacro
   202                              <1> 
   203                              <1> %macro popDOS 0
   204                              <1>     pop rax
   205                              <1>     pop rbx
   206                              <1>     pop rcx
   207                              <1>     pop rdx
   208                              <1>     pop rsi
   209                              <1>     pop rdi
   210                              <1>     pop rbp
   211                              <1>     pop r8
   212                              <1>     pop r9
   213                              <1> %endmacro
   214                              <1> 
   215                              <1> struc psp
   216 00000000 ????                <1>     .return     resb 2  ;Should always be CDh 40h
   217 00000002 ????????????????    <1>     .startSeg   resq 1  ;Pointer to the start of the PSP
   218 0000000A ????????????????    <1>     .oldInt42h  resq 1  ;Int 42h pointer on overlay load
   219 00000012 ????????????????    <1>     .oldInt43h  resq 1  ;Int 43h pointer on overlay load
   220 0000001A ????????????????    <1>     .oldInt44h  resq 1  ;Int 44h pointer on overlay load
   221 00000022 ????????????????    <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   222 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   223 0000003E ????????????????    <1>     .envPtr     resq 1  ;Pointer to the environment
   224 00000046 ????????????????    <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to Int 41h
   225 0000004E ????                <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   226 00000050 ??????              <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   227 00000053 ????????????????    <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   228 0000005B ????????????????    <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   229 00000063 ????????????????    <1>     .fcbPtr1    resq 1  ;Pointer to the first OS allocated FCB
   230 0000006B <res 15h>           <1>     .reserved   resb 21
   231 00000080 ??                  <1>     .charCount  resb 1  ;Number of characters in command tail
   232 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   233                              <1> endstruc
   234                              <1> 
   235                              <1> struc mcb
   236 00000000 ??                  <1>     .mzbyte     resb 1  ;M=In use, Z=Free
   237 00000001 ????????????????    <1>     .processPtr resq 1  ;Points to the start of the process PSP
   238 00000009 ????????            <1>     .paragraphs resd 1  ;Gives the number of paras allocated to this process
   239 0000000D ??????              <1>     .reserved   resb 3
   240                              <1>     .program:
   241                              <1> endstruc
     7                                  %include "dosSeg.asm"
     8                              <1> ;This file contains the main DOS data segment
     9                              <1> 
    10                              <1> Segment dSeg nobits align=1 
    11 00000000 ????????????????    <1>     dosSegPtr   resq 1    ;Pointer to the data Segment itself
    12 00000008 ??                  <1>     bootDrive   resb 1    ;The Int 33h device we booted from
    13 00000009 <res 2Ah>           <1>     charReqHdr  resb ioReqPkt_size  ;Character IO Request header
    14 00000033 <res 2Ah>           <1>     diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
    15                              <1>     ;The device driver header with space for the largest possible packet
    16 0000005D ????????????????    <1>     sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    17 00000065 ????????????????    <1>     mcbChainPtr resq 1    ;Pointer to the MCB chain
    18 0000006D ????????????????    <1>     dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    19 00000075 ????????????????    <1>     sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    20 0000007D ????????????????    <1>     clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    21                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
    22 00000085 ????????????????    <1>     conPtr      resq 1    ;Pointer to the current active CON device header 
    23                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
    24 0000008D ????                <1>     maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    25 0000008F ????????????????    <1>     bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    26 00000097 ????????????????    <1>     cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    27 0000009F ????????????????    <1>     sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    28 000000A7 ????                <1>     numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    29 000000A9 ??                  <1>     numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    30 000000AA ??                  <1>     lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    31 000000AB ??                  <1>     numJoinDrv  resb 1    ;Number of Joined Drives
    32 000000AC <res 22h>           <1>     nulDevHdr   resb drvHdr_size
    33                              <1> 
    34                              <1> ;Start of Swappable Data Area, this bit can remain static
    35 000000CE ??                  <1>     critErrFlag resb 1  ;Critical error flag, set on entry to INT 44h
    36 000000CF ??                  <1>     inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    37 000000D0 ??                  <1>     errorDrv    resb 1  ;Drive on which error occured or FFh
    38 000000D1 ??                  <1>     errorLocus  resb 1  ;Where the error took place  
    39 000000D2 ????                <1>     errorExt    resw 1  ;Extended Error Code
    40 000000D4 ??                  <1>     errorAction resb 1  ;Suggested action for error  
    41 000000D5 ??                  <1>     errorClass  resb 1  ;Error Class
    42                              <1> 
    43 000000D6 ????????????????    <1>     currentDTA  resq 1  ;Address of the current DTA
    44 000000DE ????????????????    <1>     currentPSP  resq 1  ;Address of current PSP
    45 000000E6 ????????????????    <1>     rdiErrorPtr resq 1  ;Saves RDI value of last error
    46 000000EE ????????????????    <1>     xInt43hRSP  resq 1  ;Saves RSP across an Int 43h call
    47 000000F6 ????                <1>     lastRetCode resw 1  ;Last return code returned by Int 41h/4Ch
    48 000000F8 ??                  <1>     currentDrv  resb 1  ;Default, last accessed drive
    49 000000F9 ??                  <1>     breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    50                              <1> ;SDA, needs to be replaced between processes
    51 000000FA ????????????????    <1>     xInt44hRSP  resq 1  ;RSP across an Int 44h call
    52                              <1> 
    53 00000102 ??                  <1>     Int44RetVal resb 1  ;Saves a copy of the Int 44 return value
    54 00000103 ??                  <1>     Int44bitfld resb 1  ;Copies the bit field given to the Int 44h handler
    55 00000104 ??                  <1>     int48Flag   resb 1  ;If set, Int 48h should be called, if clear no
    56 00000105 ????????????????    <1>     oldoldRSP   resq 1  ;RSP at prev Int 41h entry if called from within Int 41h
    57 0000010D ????????????????    <1>     oldRSP      resq 1  ;RSP when entering Int 41h
    58 00000115 ????????????????    <1>     oldRBX      resq 1  ;Temp var to save value of rbx during an Int 41 call
    59                              <1> ;Time stuff
    60 0000011D ????????????        <1>     CLOCKrecrd  resb 6  ;Clock driver record
    61 00000123 ??                  <1>     dayOfMonth  resb 1  ;1 - 31 BCD
    62 00000124 ??                  <1>     monthOfYear resb 1  ;1 - 12 BCD
    63 00000125 ????                <1>     years       resw 1  ;0000 - 9999 BCD
    64 00000127 ????                <1>     yearsOffset resw 1  ;Current Year - 1980
    65 00000129 ????????            <1>     daysOffset  resd 1  ;Days since 1-1-1980
    66 0000012D ??                  <1>     dayOfWeek   resb 1  ;0 = Sunday <-> 6 = Saturday
    67                              <1> 
    68                              <1> ;Stacks
    69 0000012E <res 528h>          <1>     critStack   resq 165
    70 00000656 ????????????????    <1>     critStakTop resq 1
    71 0000065E <res 638h>          <1>     IOStack     resq 199
    72 00000C96 ????????????????    <1>     IOStakTop   resq 1
    73 00000C9E <res 638h>          <1>     DiskStack   resq 199
    74 000012D6 ????????????????    <1>     DiskStakTop resq 1
    75                              <1>     dSegLen     equ     $
     8                                  
     9                                  Segment .text align=1
    10                                  ; We arrive here with the following values in the registers.
    11                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    12                                  ; dx  = Int 33h boot device number
    13                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    14                                  tempPSP:    ;Here to allow the loader to use Int 41h once it is loaded high
    15 00000000 55AA                        dw 0AA55h           ;Initial signature
    16 00000002 909090909090909090-         db (100h-2) dup (90h)   ;Duplicate NOPs for the PSP
    16 0000000B 909090909090909090-
    16 00000014 909090909090909090-
    16 0000001D 909090909090909090-
    16 00000026 909090909090909090-
    16 0000002F 909090909090909090-
    16 00000038 909090909090909090-
    16 00000041 909090909090909090-
    16 0000004A 909090909090909090-
    16 00000053 909090909090909090-
    16 0000005C 909090909090909090-
    16 00000065 909090909090909090-
    16 0000006E 909090909090909090-
    16 00000077 909090909090909090-
    16 00000080 909090909090909090-
    16 00000089 909090909090909090-
    16 00000092 909090909090909090-
    16 0000009B 909090909090909090-
    16 000000A4 909090909090909090-
    16 000000AD 909090909090909090-
    16 000000B6 909090909090909090-
    16 000000BF 909090909090909090-
    16 000000C8 909090909090909090-
    16 000000D1 909090909090909090-
    16 000000DA 909090909090909090-
    16 000000E3 909090909090909090-
    16 000000EC 909090909090909090-
    16 000000F5 909090909090909090-
    16 000000FE 9090               
    17 00000100 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    18 00000108 488D15F1FEFFFF              lea rdx, qword [tempPSP]    ;Get the address of the tempPSP
    19 0000010F 6448891425-                 mov qword fs:[currentPSP], rdx
    19 00000114 [DE000000]         
    20                                  ;DOS allows for non-PARA aligned PSPs but DOS aligns all programs on PARA bndry
    21 00000118 B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    22 0000011D 0F32                        rdmsr
    23 0000011F 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    24 00000121 48C1E720                    shl rdi, 20h        ;Shift high
    25 00000125 89C7                        mov edi, eax        ;Get the low dword in
    26                                  
    27 00000127 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    27 0000012C [00000000]         
    28 00000130 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    29 00000133 4881C7[DE120000]            add rdi, dSegLen ;Move destination past end of data area
    30 0000013A 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    31 00000141 B900100000                  mov ecx, 1000h
    32 00000146 F348A5                      rep movsq
    33                                  
    34                                  ;Modify the pointers in nData before putting them in the data area
    35 00000149 48012D80010000              add qword [nData + drvHdr.nxtPtr], rbp
    36 00000150 48012D83010000              add qword [nData + drvHdr.strPtr], rbp
    37 00000157 48012D84010000              add qword [nData + drvHdr.intPtr], rbp
    38                                  ;Copy the Null driver to its location in Sysvars
    39 0000015E B922000000                  mov ecx, drvHdr_size
    40 00000163 488D3566010000              lea rsi, qword [nData]
    41 0000016A 488DBD[AC000000]            lea rdi, qword [rbp + nulDevHdr]
    42 00000171 F3A4                        rep movsb   
    43                                  
    44                                  ;Adjust the addresses in the other driver headers 
    45 00000173 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    45 00000175 [8C08000000000000] 
    46 0000017D B90C000000                  mov ecx, 12      ;12 drivers in data area
    47 00000182 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    48                                  adjDrivers:
    49 00000186 E8CA000000                  call adjustDrvHdr
    50 0000018B E2F9                        loop adjDrivers
    51                                  
    52                                      ;Open NUL
    53 0000018D 488D9D[B6000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    54 00000194 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    55 00000197 30C0                        xor al, al
    56 00000199 FFD3                        call rbx
    57                                  
    58                                  ;Open CON
    59                                  conInit:    ;Rather than keeping this resident... do it here
    60                                  .ci0:
    61 0000019B B401                        mov ah, 01      ;Get buffer status
    62 0000019D CD36                        int 36h
    63 0000019F 7406                        jz .ci1      ;If zero clear => no more keys to read
    64 000001A1 30E4                        xor ah, ah
    65 000001A3 CD36                        int 36h ;Read key to flush from buffer
    66 000001A5 EBF4                        jmp short .ci0
    67                                  .ci1:
    68 000001A7 B800050000                  mov eax, 0500h  ;Set page zero as the default page
    69 000001AC CD30                        int 30h
    70 000001AE B402                        mov ah, 02h
    71 000001B0 31D2                        xor edx, edx    ;Set screen cursor to top right corner
    72 000001B2 88D7                        mov bh, dl      ;Set cursor for page 0
    73 000001B4 CD30                        int 30h
    74 000001B6 B707                        mov bh, 07h     ;Grey/Black attribs
    75 000001B8 B800060000                  mov eax, 0600h  ;Clear whole screen
    76 000001BD CD30                        int 30h
    77                                  
    78                                      ;Open Mass Storage
    79 000001BF 48BB-                       mov rbx, msdDriver
    79 000001C1 [690E000000000000] 
    80 000001C9 488D5C1D00                  lea rbx, qword [rbp+rbx]
    81 000001CE 30C0                        xor al, al
    82 000001D0 FFD3                        call rbx
    83                                  ;Adjust Int 41h address table
    84                                  
    85                                  adjInt41h:
    86 000001D2 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
    87 000001D7 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
    87 000001D9 [7102000000000000] 
    88 000001E1 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
    89                                  .ai41h:
    90 000001E6 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
    91 000001E9 4881C308000000              add rbx, 8              ;Each entry is size 8
    92 000001F0 FFC9                        dec ecx
    93 000001F2 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
    94                                  
    95                                  ;Adjust Interrupt Entries Int 40h-49h
    96                                  adjInts:
    97 000001F4 B340                        mov bl, 40h
    98 000001F6 B807F00000                  mov eax, 0F007h ;Get the descriptor
    99 000001FB CD35                        int 35h
   100 000001FD B940000000                  mov ecx, 40h    ;Start from interrupt 40h
   101 00000202 488D3D77000000              lea rdi, intData
   102 00000209 89C6                        mov esi, eax    ;Move segment selector info to esi
   103                                  .ai0:
   104 0000020B B808F00000                  mov eax, 0F008h ;Set the descriptor
   105 00000210 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
   106 00000213 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
   107 00000216 CD35                        int 35h
   108 00000218 4881C708000000              add rdi, 8
   109 0000021F FFC1                        inc ecx
   110 00000221 81F94A000000                cmp ecx, 4Ah
   111 00000227 75E2                        jne .ai0
   112                                  
   113                                  ;Test Error Case
   114 00000229 B430                        mov ah, 00110000b
   115 0000022B B000                        mov al, 00h
   116 0000022D BF0C000000                  mov edi, 0Ch
   117 00000232 CD44                        int 44h
   118                                  
   119                                  
   120 00000234 488D152D000000              lea rdx, qword [startmsg]   ;Get the absolute address of message
   121 0000023B B409                        mov ah, 09h
   122 0000023D CD41                        int 41h
   123                                  
   124 0000023F 64488B3425-                 mov rsi, fs:[nulDevHdr]
   124 00000244 [AC000000]         
   125 00000248 B801C50000                  mov eax, 0C501h ;Connect debugger
   126 0000024D CD35                        int 35h
   127                                  l1:
   128 0000024F B401                        mov ah, 01h  ;Write with echo
   129 00000251 CD41                        int 41h
   130 00000253 EBFA                        jmp short l1
   131                                  adjustDrvHdr:
   132                                  ;Input: rsi = Effective address of driver in DOS segment
   133                                  ;       rbp = Ptr to the start of the DOS segment
   134                                  ;Output: rsi = EA of next header in DOS segment
   135 00000255 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   136 00000258 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   137 0000025C 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   138 00000260 4881C622000000              add rsi, drvHdr_size
   139 00000267 C3                          ret
   140                                  
   141 00000268 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,"$"
   141 00000271 67205343502F444F53-
   141 0000027A 2E2E2E0A0D24       
   142                                  intData:
   143 00000280 [5900000000000000]          dq terminateProcess ;Int 40h
   144 00000288 [5900000000000000]          dq functionDispatch ;Int 41h
   145 00000290 [C105000000000000]          dq terminateHandler ;Int 42h
   146 00000298 [C105000000000000]          dq ctrlCHandler     ;Int 43h
   147 000002A0 [C105000000000000]          dq critErrorHandler ;Int 44h
   148 000002A8 [5408000000000000]          dq absDiskRead      ;Int 45h
   149 000002B0 [6908000000000000]          dq absDiskWrite     ;Int 46h
   150 000002B8 [7E08000000000000]          dq terminateResident    ;Int 47h
   151 000002C0 [7E08000000000000]          dq inDosHandler     ;Int 48h
   152 000002C8 [8008000000000000]          dq fastOutput       ;Int 49h
   153                                  nData:
   154 000002D0 [8C08000000000000]          dq conHdr
   155 000002D8 0480                        dw 08004h
   156 000002DA [340A000000000000]          dq nulStrat
   157 000002E2 [3A0A000000000000]          dq nulIntr
   158 000002EA 4E554C2020202020            db "NUL     " ;Default NUL data
   159                                  
   160                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   161                                  ;-----------------------------------:
   162                                  ;       Misc System routines        :
   163                                  ;-----------------------------------:
   164                                  findLRUBuffer: 
   165                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   166                                  ;Input: Nothing
   167                                  ;Output: rbx = Pointer to the buffer to use
   168 00000000 52                          push rdx
   169 00000001 488B1D(8F000000)            mov rbx, qword [bufHeadPtr]
   170 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   171 0000000F 7502                        jne .flb1
   172 00000011 5A                          pop rdx
   173 00000012 C3                          ret
   174                                  .flb1:
   175 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   176 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   177 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   178 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   179 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   180 00000029 488B15(8F000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   181 00000030 48891D(8F000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   182 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   183 0000003A 5A                          pop rdx
   184 0000003B C3                          ret
   185                                  
   186                                  findDPB:
   187                                  ;Finds the DPB for a given drive
   188                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   189                                  ;Output: al = 00, rbx = Pointer to the DPB
   190                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   191 0000003C 488B1D(6D000000)            mov rbx, qword [dpbHeadPtr]
   192                                  .fd1:
   193 00000043 30C0                        xor al, al
   194 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   195 00000047 740F                        je .fd2
   196 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   197 0000004D B0FF                        mov al, -1
   198 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   199 00000056 75EB                        jne .fd1
   200                                  .fd2:
   201 00000058 C3                          ret
   202                                  callCritError:
   203                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   204                                  ;-----------------------------------:
   205                                  ;       File System routines        :
   206                                  ;-----------------------------------:
   207                                  name2Clust:
   208                                  ;Converts a file name to a first cluster number
   209                                  ;-----------------------------------:
   210                                  ;        Interrupt routines         :
   211                                  ;-----------------------------------:
   212                                  terminateProcess:   ;Int 40h
   213                                  
   214                                  functionDispatch:   ;Int 41h Main function dispatcher
   215                                  ;ah = Function number, all other registers have various meanings
   216 00000059 FA                          cli ;Halt external interrupts
   217 0000005A FC                          cld ;Ensure all string ops occur in the right direction
   218 0000005B 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   219 0000005E 0F871E010000                ja .fdExitBad
   220                                      ;Cherry pick functions
   221 00000064 80FC33                      cmp ah, 33h ;CTRL+BREAK check
   222 00000067 722C                        jb .fsbegin   ;If below skip these checks
   223 00000069 0F8401020000                je .ctrlBreakCheck
   224 0000006F 80FC64                      cmp ah, 64h
   225 00000072 0F84F8010000                je .setDriverLookahead  ;Reserved, but avoids usual Int 41h spiel
   226 00000078 771B                        ja .fsbegin   ;If above, do usual Int41 entry
   227 0000007A 80FC51                      cmp ah, 51h
   228 0000007D 0F84ED010000                je .getCurrProcessID    ;This an below are exactly the same
   229 00000083 80FC62                      cmp ah, 62h
   230 00000086 0F84E4010000                je .getPSPaddr          ;Calls the above function
   231 0000008C 80FC50                      cmp ah, 50h
   232 0000008F 0F84DB010000                je .setCurrProcessID
   233                                  .fsbegin:
   234                                      pushDOS ;Push the usual prologue registers
   192 00000095 4151                <1>  push r9
   193 00000097 4150                <1>  push r8
   194 00000099 55                  <1>  push rbp
   195 0000009A 57                  <1>  push rdi
   196 0000009B 56                  <1>  push rsi
   197 0000009C 52                  <1>  push rdx
   198 0000009D 51                  <1>  push rcx
   199 0000009E 53                  <1>  push rbx
   200 0000009F 50                  <1>  push rax
   235 000000A0 488B05(0D010000)            mov rax, qword [oldRSP]
   236 000000A7 488905(05010000)            mov qword [oldoldRSP], rax
   237 000000AE FE05(CF000000)              inc byte [inDOS]    ;Increment in DOS flag
   238 000000B4 488925(0D010000)            mov qword [oldRSP], rsp
   239                                  ;Here, we want to save oldRSP in the callers PSP
   240 000000BB 803D(CF000000)01            cmp byte [inDOS], 1 ;Check how many times we are in DOS
   241 000000C2 750B                        jne .fsb1   ;If this is first entry, save rsp in callers PSP
   242 000000C4 488B05(DE000000)            mov rax, qword [currentPSP] ;Get current PSP address
   243 000000CB 48896046                    mov qword [rax + psp.rspPtr], rsp    ;Save rsp on callers stack
   244                                  .fsb1:
   245 000000CF 58                          pop rax     ;Get old rax back
   246 000000D0 50                          push rax    ;and push it back onto the stack
   247 000000D1 488D25(56060000)            lea rsp, critStakTop
   248 000000D8 FB                          sti         ;Reenable interrupts
   249                                  
   250 000000D9 C605(04010000)01            mov byte [int48Flag], 1 ;Make it ok to trigger Int 48h
   251                                  
   252 000000E0 48891D(15010000)            mov qword [oldRBX], rbx ;Need to do this as I might switch stacks later
   253 000000E7 0FB6DC                      movzx ebx, ah   ;Move the function number bl zero extended to rbx
   254 000000EA C1E303                      shl ebx, 3      ;Multiply the function number by 8 for offset into table
   255 000000ED 50                          push rax        ;Push rax onto the stack
   256 000000EE 488D057C010000              lea rax, qword [.dispatchTable]
   257 000000F5 4801C3                      add rbx, rax    ;Add dispatch table offset into rbx
   258 000000F8 58                          pop rax
   259 000000F9 488B1B                      mov rbx, qword [rbx]    ;Get the address from the dispatch table
   260                                  
   261 000000FC 84E4                        test ah, ah     ;Simple Terminate function?
   262 000000FE 741C                        jz .fddiskOp
   263 00000100 80FC59                      cmp ah, 59h     ;Extended Error report?
   264 00000103 7443                        je .fdGoToFunction  ;Bypass code that clears the error report
   265 00000105 80FC0C                      cmp ah, 0Ch     ;Are we a char function?
   266 00000108 7712                        ja .fddiskOp
   267                                  ;Char operations here
   268 0000010A F605(CE000000)01            test byte [critErrFlag], 1  ;Are we in critical error?
   269 00000111 7535                        jnz .fdGoToFunction         ;If we are, stay on Critical Error Stack
   270 00000113 488D25(960C0000)            lea rsp, IOStakTop          ;Otherwise, switch to IO stack
   271 0000011A EB2C                        jmp short .fdGoToFunction
   272                                  .fddiskOp:
   273                                      ;Disk operations go here
   274                                      ;Clear up error info
   275 0000011C C605(D1000000)01            mov byte [errorLocus], 1    ;Reset to generic, unknown locus
   276 00000123 C605(CE000000)00            mov byte [critErrFlag], 0   ;Clear the Critical Error Flag
   277 0000012A C605(D0000000)FF            mov byte [errorDrv], -1     ;Set the drive which caused the error to none
   278                                  
   279 00000131 C605(04010000)00            mov byte [int48Flag], 0     ;Turn off the ability to trigger Int 48h
   280 00000138 488D25(D6120000)            lea rsp, DiskStakTop        ;Swap the stack to the Disk Transfer Stack
   281 0000013F F605(F9000000)FF            test byte [breakFlag], -1   ;Test if set
   282 00000146 7400                        jz .fdGoToFunction
   283                                  ; HANDLE CTRL+BREAK HERE!
   284                                  .fdGoToFunction:
   285 00000148 48871D(15010000)            xchg rbx, qword [oldRBX]    ;Put the call addr in oldRBX and get oldRBX back
   286                                      ;Potentially point rbp to caller reg frame for easy access of registers 
   287                                      ;mov rbp, qword [oldRSP]    ;Move rsp on entry into rbp
   288 0000014F FF15(15010000)              call qword [oldRBX]     ;Call the desired function, rax contains ret code
   289                                  .fdExit:
   290 00000155 FA                          cli     ;Redisable interrupts
   291                                      ;???
   292 00000156 FE0D(CF000000)              dec byte [inDOS]            ;Decrement the inDOS count
   293 0000015C 488B25(0D010000)            mov rsp, qword [oldRSP]     ;Point rsp to old stack
   294 00000163 48890424                    mov qword [rsp], rax    ;Put the ret code into its pos on the register frame
   295 00000167 488B05(05010000)            mov rax, qword [oldoldRSP]
   296 0000016E 488905(0D010000)            mov qword [oldRSP], rax
   297                                      popDOS  ;Pop the frame
   204 00000175 58                  <1>  pop rax
   205 00000176 5B                  <1>  pop rbx
   206 00000177 59                  <1>  pop rcx
   207 00000178 5A                  <1>  pop rdx
   208 00000179 5E                  <1>  pop rsi
   209 0000017A 5F                  <1>  pop rdi
   210 0000017B 5D                  <1>  pop rbp
   211 0000017C 4158                <1>  pop r8
   212 0000017E 4159                <1>  pop r9
   298 00000180 48CF                        iretq
   299                                  .fdExitBad:
   300 00000182 B400                        mov ah, 0
   301 00000184 48CF                        iretq
   302                                  .simpleTerminate:     ;ah = 00h
   303 00000186 C3                          ret
   304                                  .stdinReadEcho:     ;ah = 01h
   305 00000187 488D1D(09000000)            lea rbx, charReqHdr ;Get the address of this request block
   306 0000018E 488D0566000000              lea rax, .stdinReadEchoBuffer
   307 00000195 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   308 00000198 C6430204                    mov byte [rbx + ioReqPkt.cmdcde], 04h   ;Read a byte
   309 0000019C 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   310 000001A2 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   311 000001A6 C7431601000000              mov dword [rbx + ioReqPkt.tfrlen], 01
   312 000001AD FF15E3060000                call qword [conHdr + drvHdr.strPtr]
   313 000001B3 FF15E5060000                call qword [conHdr + drvHdr.intPtr]
   314 000001B9 803D3B00000000              cmp byte [.stdinReadEchoBuffer], 00h
   315 000001C0 74C5                        jz .stdinReadEcho
   316 000001C2 488D1D(09000000)            lea rbx, charReqHdr ;Get the address of this request block
   317 000001C9 488D052B000000              lea rax, .stdinReadEchoBuffer
   318 000001D0 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   319 000001D3 C6430208                    mov byte [rbx + ioReqPkt.cmdcde], 08h   ;Write a byte
   320 000001D7 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   321 000001DD 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   322 000001E1 C7431601000000              mov dword [rbx + ioReqPkt.tfrlen], 01
   323 000001E8 FF15A8060000                call qword [conHdr + drvHdr.strPtr]
   324 000001EE FF15AA060000                call qword [conHdr + drvHdr.intPtr]
   325 000001F4 8A0501000000                mov al, byte [.stdinReadEchoBuffer]
   326 000001FA C3                          ret
   327 000001FB 00                      .stdinReadEchoBuffer    db 0
   328                                  .stdoutWrite:       ;ah = 02h
   329                                  ;Bspace is regular cursor left, does not insert a blank
   330 000001FC 881533000000                mov byte [.stdoutWriteBuffer], dl
   331 00000202 488D1D(09000000)            lea rbx, charReqHdr ;Get the address of this request block
   332 00000209 488D0525000000              lea rax, .stdoutWriteBuffer
   333 00000210 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   334 00000213 C6430208                    mov byte [rbx + ioReqPkt.cmdcde], 08h   ;Write a byte
   335 00000217 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   336 0000021D 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   337 00000221 C7431601000000              mov dword [rbx + ioReqPkt.tfrlen], 01
   338 00000228 FF1568060000                call qword [conHdr + drvHdr.strPtr]
   339 0000022E FF156A060000                call qword [conHdr + drvHdr.intPtr]
   340 00000234 C3                          ret
   341 00000235 00                      .stdoutWriteBuffer db 0
   342                                  .stdauxRead:        ;ah = 03h
   343                                  .stdauxWrite:       ;ah = 04h
   344                                  .stdprnWrite:       ;ah = 05h
   345                                  .directCONIO:       ;ah = 06h
   346                                  .waitDirectInNoEcho:;ah = 07h
   347                                  .waitStdinNoEcho:   ;ah = 08h
   348 00000236 C3                          ret
   349                                  .printString:       ;ah = 09h
   350 00000237 31C9                        xor ecx, ecx    ;Clear char counter
   351 00000239 B824000000                  mov eax, "$"    ;Terminating char
   352 0000023E 4889D7                      mov rdi, rdx    ;Set up for scasb
   353                                  .ps0:   ;Search for $ to get count of chars
   354 00000241 AE                          scasb
   355 00000242 7404                        je .ps1
   356 00000244 FFC1                        inc ecx
   357 00000246 EBF9                        jmp short .ps0
   358                                  .ps1:   ;Use handle 
   359 00000248 488D1D(09000000)            lea rbx, charReqHdr ;Get the address of this request block
   360 0000024F C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   361 00000252 C6430208                    mov byte [rbx + ioReqPkt.cmdcde], 08h   ;Write a byte
   362 00000256 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   363 0000025C 4889530E                    mov qword [rbx + ioReqPkt.bufptr], rdx
   364 00000260 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx
   365 00000263 FF152D060000                call qword [conHdr + drvHdr.strPtr]
   366 00000269 FF152F060000                call qword [conHdr + drvHdr.intPtr]
   367 0000026F C3                          ret
   368                                  .buffStdinInput:    ;ah = 0Ah
   369                                  .checkStdinStatus:  ;ah = 0Bh
   370                                  .clearbuffDoFunc:   ;ah = 0Ch
   371                                  .diskReset:         ;ah = 0Dh
   372                                  .selectDisk:        ;ah = 0Eh
   373                                  .openFileFCB:       ;ah = 0Fh
   374                                  .closeFileFCB:      ;ah = 10h
   375                                  .findFirstFileFCB:  ;ah = 11h
   376                                  .findNextFileFCB:   ;ah = 12h
   377                                  .deleteFileFCB:     ;ah = 13h
   378                                  .sequentialReadFCB: ;ah = 14h
   379                                  .sequentialWriteFCB:;ah = 15h
   380                                  .createFileFCB:     ;ah = 16h
   381                                  .renameFileFCB:     ;ah = 17h
   382                                                      ;ah = 18h unused
   383                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   384                                  .setDTA:            ;ah = 1Ah
   385                                  .FATinfoDefault:    ;ah = 1Bh
   386                                  .FatinfoDevice:     ;ah = 1Ch
   387                                                      ;ah = 1Dh unused
   388                                                      ;ah = 1Eh unused
   389                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   390                                                      ;ah = 20h unused
   391                                  .randomReadFCB:     ;ah = 21h
   392                                  .randomWriteFCB:    ;ah = 22h
   393                                  .getFileSizeFCB:    ;ah = 23h
   394                                  .setRelRecordFCB:   ;ah = 24h
   395                                  .setIntVector:      ;ah = 25h
   396                                  .createNewPSP:      ;ah = 26h
   397                                  .randBlockReadFCB:  ;ah = 27h
   398                                  .randBlockWriteFCB: ;ah = 28h
   399                                  .parseFilenameFCB:  ;ah = 29h
   400                                  .getDate:           ;ah = 2Ah
   401                                  .setDate:           ;ah = 2Bh
   402                                  .getTime:           ;ah = 2Ch
   403                                  .setTime:           ;ah = 2Dh
   404                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   405                                  .getDTA:            ;ah = 2Fh
   406                                  .getDOSversion:     ;ah = 30h
   407                                  .terminateStayRes:  ;ah = 31h
   408                                  .getDeviceDPBptr:   ;ah = 32h
   409                                  .ctrlBreakCheck:    ;ah = 33h
   410                                  .getInDOSflagPtr:   ;ah = 34h
   411                                  .getIntVector:      ;ah = 35h
   412                                  .getDiskFreeSpace:  ;ah = 36h
   413                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   414                                  .getsetCountryInfo: ;ah = 38h, localisation info
   415                                  .makeDIR:           ;ah = 39h
   416                                  .removeDIR:         ;ah = 3Ah
   417                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   418                                  .createFileHdl:     ;ah = 3Ch, handle function
   419                                  .openFileHdl:       ;ah = 3Dh, handle function
   420                                  .closeFileHdl:      ;ah = 3Eh, handle function
   421                                  .readFileHdl:       ;ah = 3Fh, handle function
   422                                  .writeFileHdl:      ;ah = 40h, handle function
   423                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   424                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   425                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   426                                  .ioctrl:            ;ah = 44h, handle function
   427                                  .duplicateHandle:   ;ah = 45h, handle function
   428                                  .forceDuplicateHdl: ;ah = 46h, handle function
   429                                  .getCurrentDIR:     ;ah = 47h
   430                                  .allocateMemory:    ;ah = 48h
   431                                  .freeMemory:        ;ah = 49h
   432                                  .reallocMemory:     ;ah = 4Ah
   433                                  .loadExecChild:     ;ah = 4Bh, EXEC
   434                                  .terminateClean:    ;ah = 4Ch, EXIT
   435                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   436                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   437                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   438                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   439                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   440                                  .getSysVarsPtr:     ;ah = 52h
   441                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   442                                  .getVerifySetting:  ;ah = 54h
   443                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   444                                  .renameFile:        ;ah = 56h
   445                                  .getSetFileDateTime:;ah = 57h
   446                                  .getsetMallocStrat: ;ah = 58h
   447                                  .getExtendedError:  ;ah = 59h
   448                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   449                                  .createNewFile:     ;ah = 5Bh
   450                                  .lockUnlockFile:    ;ah = 5Ch
   451                                  .getCritErrorInfo:  ;ah = 5Dh
   452                                  .networkServices:   ;ah = 5Eh, do nothing
   453                                  .networkRedirection:;ah = 5Fh, do nothing
   454                                  .trueName:          ;ah = 60h, get fully qualified name
   455                                                      ;ah = 61h, reserved
   456                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   457                                                      ;ah = 63h, reserved
   458                                  .setDriverLookahead:;ah = 64h, reserved
   459                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   460                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   461                                  .setHandleCount:    ;ah = 67h
   462                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   463                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   464                                  .return:
   465 00000270 C3                          ret
   466                                  
   467                                  
   468                                  .dispatchTable:
   469 00000271 [8601000000000000]          dq .simpleTerminate     ;AH = 00H, PROCESS MANAGEMENT
   470 00000279 [8701000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   471 00000281 [FC01000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   472 00000289 [3602000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   473 00000291 [3602000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   474 00000299 [3602000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   475 000002A1 [3602000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   476 000002A9 [3602000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   477 000002B1 [3602000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   478 000002B9 [3702000000000000]          dq .printString         ;AH = 09H, CHAR IO
   479 000002C1 [7002000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   480 000002C9 [7002000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   481 000002D1 [7002000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   482 000002D9 [7002000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   483 000002E1 [7002000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   484 000002E9 [7002000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   485 000002F1 [7002000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   486 000002F9 [7002000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   487 00000301 [7002000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   488 00000309 [7002000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   489 00000311 [7002000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   490 00000319 [7002000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   491 00000321 [7002000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   492 00000329 [7002000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   493 00000331 [7002000000000000]          dq .return              ;AH = 18H, RESERVED
   494 00000339 [7002000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   495 00000341 [7002000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   496 00000349 [7002000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   497 00000351 [7002000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   498 00000359 [7002000000000000]          dq .return              ;AH = 1DH, RESERVED
   499 00000361 [7002000000000000]          dq .return              ;AH = 1EH, RESERVED
   500 00000369 [7002000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   501 00000371 [7002000000000000]          dq .return              ;AH = 20H, RESERVED
   502 00000379 [7002000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   503 00000381 [7002000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   504 00000389 [7002000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   505 00000391 [7002000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   506 00000399 [7002000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   507 000003A1 [7002000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   508 000003A9 [7002000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   509 000003B1 [7002000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   510 000003B9 [7002000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   511 000003C1 [7002000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   512 000003C9 [7002000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   513 000003D1 [7002000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   514 000003D9 [7002000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   515 000003E1 [7002000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   516 000003E9 [7002000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   517 000003F1 [7002000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   518 000003F9 [7002000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   519 00000401 [7002000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   520 00000409 [7002000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   521 00000411 [7002000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   522 00000419 [7002000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   523 00000421 [7002000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   524 00000429 [7002000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   525 00000431 [7002000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   526 00000439 [7002000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   527 00000441 [7002000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   528 00000449 [7002000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   529 00000451 [7002000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   530 00000459 [7002000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   531 00000461 [7002000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   532 00000469 [7002000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   533 00000471 [7002000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   534 00000479 [7002000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   535 00000481 [7002000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   536 00000489 [7002000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   537 00000491 [7002000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   538 00000499 [7002000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   539 000004A1 [7002000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   540 000004A9 [7002000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   541 000004B1 [7002000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   542 000004B9 [7002000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   543 000004C1 [7002000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   544 000004C9 [7002000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   545 000004D1 [7002000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   546 000004D9 [7002000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   547 000004E1 [7002000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   548 000004E9 [7002000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   549 000004F1 [7002000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   550 000004F9 [7002000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   551 00000501 [7002000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   552 00000509 [7002000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   553 00000511 [7002000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   554 00000519 [7002000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   555 00000521 [7002000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   556 00000529 [7002000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   557 00000531 [7002000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   558 00000539 [7002000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   559 00000541 [7002000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   560 00000549 [7002000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   561 00000551 [7002000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   562 00000559 [7002000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   563 00000561 [7002000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   564 00000569 [7002000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   565 00000571 [7002000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   566 00000579 [7002000000000000]          dq .return              ;AH = 61H, RESERVED
   567 00000581 [7002000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   568 00000589 [7002000000000000]          dq .return              ;AH = 63H, RESERVED
   569 00000591 [7002000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   570 00000599 [7002000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   571 000005A1 [7002000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   572 000005A9 [7002000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   573 000005B1 [7002000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   574 000005B9 [7002000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   575                                  dispatchTableL  equ $ - .dispatchTable 
   576                                  
   577                                  terminateHandler:   ;Int 42h
   578                                  ctrlCHandler:       ;Int 43h
   579                                  critErrorHandler:   ;Int 44h
   580                                  ;User Stack in usage here, must be swapped to before this is called
   581                                  ;Entered with:  
   582                                  ;               AH = Critical Error Bitfield
   583                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   584                                  ;               Bit 6 - Reserved
   585                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   586                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   587                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   588                                  ;               Bits [2-1] = Affected Disk Error
   589                                  ;                     0 0   DOS area
   590                                  ;                     0 1   FAT area
   591                                  ;                     1 0   Directory area
   592                                  ;                     1 1   Data area
   593                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   594                                  ;               AL  = Failing drive number if AH[7] = 0
   595                                  ;               DIL = Error code for errorMsg
   596                                  ;               RSI = EA of Device Header for which device the error occured
   597                                  ;Return:
   598                                  ;               AL = 0 - Ignore the Error       (Ignore)
   599                                  ;                  = 1 - Retry the Operation    (Retry)
   600                                  ;                  = 2 - Terminate the Program  (Abort)
   601                                  ;                  = 3 - Fail the DOS call      (Fail)
   602 000005C1 53                          push rbx
   603 000005C2 51                          push rcx
   604 000005C3 52                          push rdx
   605 000005C4 57                          push rdi
   606 000005C5 56                          push rsi
   607 000005C6 FC                          cld         ;Make String ops go forward
   608                                  
   609 000005C7 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   610 000005CA 488D155E020000              lea rdx, qword [.crlf]
   611 000005D1 B409                        mov ah, 09h ;Print String
   612 000005D3 CD41                        int 41h     ;Call DOS to print CRLF part of message
   613                                  
   614 000005D5 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   615 000005DB B90C000000                  mov ecx, 0Ch
   616 000005E0 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   617 000005E2 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   618 000005E5 480FB7FF                    movzx rdi, di
   619 000005E9 4889FA                      mov rdx, rdi    ;Copy error code
   620 000005EC 48C1E704                    shl rdi, 4  ;Multiply by 16
   621 000005F0 48D1E2                      shl rdx, 1  ;Multiply by 2
   622 000005F3 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   623 000005F6 488D1523010000              lea rdx, qword [.errorMsgTable]
   624 000005FD 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   625 00000601 B409                        mov ah, 09h ;Print String
   626 00000603 CD41                        int 41h     ;Call DOS to print first part of message
   627                                  
   628 00000605 488D1505020000              lea rdx, qword [.readmsg]
   629 0000060C 488D3D0D020000              lea rdi, qword [.writemsg]
   630 00000613 F6C701                      test bh, 1  ;Bit 0 is set if write operation
   631 00000616 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   632 0000061A B409                        mov ah, 09h ;Print String
   633 0000061C CD41                        int 41h     ;Call DOS to print error reading/writing portion
   634                                  
   635 0000061E F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   636 00000621 0F85DF000000                jnz .charError
   637                                  ;Disk error continues here
   638 00000627 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   639 0000062E B409                        mov ah, 09h
   640 00000630 CD41                        int 41h
   641 00000632 88DA                        mov dl, bl  ;Get zero based drive number into dl
   642 00000634 80C241                      add dl, "A" ;Add ASCII code
   643 00000637 B402                        mov ah, 02h ;Print char in dl
   644 00000639 CD41                        int 41h
   645                                  .userInput:
   646 0000063B 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   647 00000642 B409                        mov ah, 09h
   648 00000644 CD41                        int 41h
   649                                  ;Abort, Retry, Ignore, Fail is word order
   650                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   651                                  .userAbort:
   652                                  ;Abort is always an option
   653 00000646 488D15E5010000              lea rdx, qword [.abortmsg]
   654 0000064D B409                        mov ah, 09h
   655 0000064F CD41                        int 41h ;Call DOS to prompt user for ABORT option
   656                                  .userRetry:
   657 00000651 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   658 00000654 7416                        jz .userIgnore    ;If clear, dont print message
   659 00000656 488D15ED010000              lea rdx, qword [.betweenMsg]
   660 0000065D B409                        mov ah, 09h
   661 0000065F CD41                        int 41h
   662 00000661 488D15D7010000              lea rdx, qword [.retrymsg]
   663 00000668 B409                        mov ah, 09h
   664 0000066A CD41                        int 41h
   665                                  .userIgnore:
   666 0000066C F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   667 0000066F 7416                        jz .userFail
   668 00000671 488D15D2010000              lea rdx, qword [.betweenMsg]
   669 00000678 B409                        mov ah, 09h
   670 0000067A CD41                        int 41h
   671 0000067C 488D15B5010000              lea rdx, qword [.ignoremsg]
   672 00000683 B409                        mov ah, 09h
   673 00000685 CD41                        int 41h
   674                                  .userFail:
   675 00000687 F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   676 0000068A 7416                        jz .userMsgEnd
   677 0000068C 488D15B7010000              lea rdx, qword [.betweenMsg]
   678 00000693 B409                        mov ah, 09h
   679 00000695 CD41                        int 41h
   680 00000697 488D15A7010000              lea rdx, qword [.failmsg]
   681 0000069E B409                        mov ah, 09h
   682 000006A0 CD41                        int 41h
   683                                  .userMsgEnd:
   684 000006A2 488D15A4010000              lea rdx, qword [.endMsg]
   685 000006A9 B409                        mov ah, 09h
   686 000006AB CD41                        int 41h
   687                                  ;Get user input now 
   688 000006AD 31C9                        xor ecx, ecx  ;4 Possible Responses
   689 000006AF 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   690 000006B6 B401                        mov ah, 01h ;STDIN without Console Echo
   691 000006B8 CD41                        int 41h ;Get char in al
   692 000006BA 3C61                        cmp al, "a" ;Chack if lowercase
   693 000006BC 7202                        jb .uip1    ;If the value is below, ignore subtraction
   694 000006BE 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   695                                  .uip1:
   696 000006C0 AE                          scasb   ;Compare char to list, offset gives return code
   697 000006C1 740F                        je .validInput  ;If they are equal, ecx has return code
   698 000006C3 FFC1                        inc ecx
   699 000006C5 81F904000000                cmp ecx, 4
   700 000006CB 75F3                        jne .uip1
   701 000006CD E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   702                                  .validInput:
   703 000006D2 88C8                        mov al, cl  ;Move the offset into .responses into al
   704                                  ;Now check if the input is permitted
   705 000006D4 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   706 000006D6 7427                        je .cehExit
   707 000006D8 84C0                        test al, al ;Check if 0 => Ignore
   708 000006DA 740F                        je .viIgnore
   709 000006DC 3C01                        cmp al, 1   ;Check if 1 => Retry
   710 000006DE 7416                        je .viRetry
   711                                  .viFail:    ;Fallthrough for fail (al = 3)
   712 000006E0 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   713 000006E3 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   714 000006E9 EB14                        jmp short .cehExit
   715                                  .viIgnore:
   716 000006EB F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   717 000006EE 0F8447FFFFFF                jz .userInput
   718 000006F4 EB09                        jmp short .cehExit
   719                                  .viRetry:
   720 000006F6 F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   721 000006F9 0F843CFFFFFF                jz .userInput
   722                                  .cehExit:
   723 000006FF 5E                          pop rsi
   724 00000700 5F                          pop rdi
   725 00000701 5A                          pop rdx
   726 00000702 59                          pop rcx
   727 00000703 5B                          pop rbx
   728 00000704 48CF                        iretq
   729                                  .charError:
   730 00000706 B908000000                  mov ecx, 8  ;8 chars in device name
   731 0000070B 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   732                                  .ce1:
   733 00000712 AC                          lodsb   ;Get a string char into al and inc rsi
   734 00000713 88C2                        mov dl, al  ;Move char into dl
   735 00000715 B402                        mov ah, 02h
   736 00000717 CD41                        int 41h ;Print char
   737 00000719 E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   738 0000071B E91BFFFFFF                  jmp .userInput
   739                                  
   740                                  .errorMsgTable: ;Each table entry is 18 chars long
   741 00000720 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   741 00000729 746563742024202020 
   742 00000732 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   742 0000073B 6E6974202420202020 
   743 00000744 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   743 0000074D 202420202020202020 
   744 00000756 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   744 0000075F 6F6D6D616E64202420 
   745 00000768 446174612024202020-                 db "Data $            "       ;Error 4
   745 00000771 202020202020202020 
   746 0000077A 426164205265717565-                 db "Bad Request $     "       ;Error 5
   746 00000783 737420242020202020 
   747 0000078C 5365656B2024202020-                 db "Seek $            "       ;Error 6
   747 00000795 202020202020202020 
   748 0000079E 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   748 000007A7 656469612024202020 
   749 000007B0 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   749 000007B9 7420466F756E642024 
   750 000007C2 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   750 000007CB 706572202420202020 
   751 000007D4 577269746520466175-                 db "Write Fault $     "       ;Error A
   751 000007DD 6C7420242020202020 
   752 000007E6 52656164204661756C-                 db "Read Fault $      "       ;Error B
   752 000007EF 742024202020202020 
   753 000007F8 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   753 00000801 61696C757265202420 
   754                                  
   755 0000080A 64726976652024          .drive      db "drive $"
   756 00000811 6572726F7220726561-     .readmsg    db "error reading $"
   756 0000081A 64696E672024       
   757 00000820 6572726F7220777269-     .writemsg   db "error writing $"
   757 00000829 74696E672024       
   758 0000082F 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   759 00000832 41626F727424            .abortmsg   db "Abort$" 
   760 00000838 49676E6F726524          .ignoremsg  db "Ignore$"
   761 0000083F 526574727924            .retrymsg   db "Retry$"
   762 00000845 4661696C24              .failmsg    db "Fail$"
   763 0000084A 2C2024                  .betweenMsg db ", $"
   764 0000084D 3F2024                  .endMsg     db "? $"
   765 00000850 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   766                                  absDiskRead:        ;Int 45h
   767                                  ;al = Drive number
   768                                  ;rbx = Memory Buffer address
   769                                  ;ecx = Number of sectors to read (max 255 for now)
   770                                  ;rdx = Start LBA to read from
   771 00000854 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   772 00000858 8A80[BF120000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   773 0000085E 4891                        xchg rax, rcx
   774 00000860 4887CA                      xchg rcx, rdx
   775 00000863 B482                        mov ah, 82h
   776 00000865 CD33                        int 33h
   777 00000867 48CF                        iretq
   778                                  absDiskWrite:       ;Int 46h
   779 00000869 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   780 0000086D 8A80[BF120000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   781 00000873 4891                        xchg rax, rcx
   782 00000875 4887CA                      xchg rcx, rdx
   783 00000878 B483                        mov ah, 83h
   784 0000087A CD33                        int 33h
   785 0000087C 48CF                        iretq
   786                                  terminateResident:  ;Int 47h
   787                                  inDosHandler:       ;Int 48h
   788                                  ;Called when DOS idle
   789 0000087E 48CF                        iretq
   790                                  fastOutput:         ;Int 49h
   791                                  ;Called with char to transfer in al
   792 00000880 50                          push rax
   793 00000881 B40E                        mov ah, 0Eh
   794 00000883 CD30                        int 30h
   795 00000885 58                          pop rax
   796 00000886 48CF                        iretq
   797                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   798 00000888 48CF                        iretq
   799                                  multiplex:          ;Int 4Fh, kept as iretq for now
   800 0000088A 48CF                        iretq
   801                                  ;-----------------------------------:
   802                                  ;          Driver routines          :
   803                                  ;-----------------------------------:
   804                                  drivers:
   805                                  conHdr:
   806 0000088C [AE08000000000000]          dq auxHdr
   807 00000894 1308                        dw 0813h
   808 00000896 [240A000000000000]          dq commonStrat
   809 0000089E [3B0A000000000000]          dq conDriver
   810 000008A6 434F4E2020202020            db "CON     "
   811                                  auxHdr:
   812 000008AE [D008000000000000]          dq prnHdr
   813 000008B6 0080                        dw 08000h
   814 000008B8 [240A000000000000]          dq commonStrat
   815 000008C0 [C40C000000000000]          dq com1Intr
   816 000008C8 4155582020202020            db "AUX     "
   817                                  prnHdr:
   818 000008D0 [F208000000000000]          dq clkHdr
   819 000008D8 40A0                        dw 0A040h
   820 000008DA [340A000000000000]          dq nulStrat
   821 000008E2 [3A0A000000000000]          dq nulIntr
   822 000008EA 50524E2020202020            db "PRN     "
   823                                  clkHdr:
   824 000008F2 [1409000000000000]          dq msdHdr
   825 000008FA 0880                        dw 08008h
   826 000008FC [240A000000000000]          dq commonStrat
   827 00000904 [730B000000000000]          dq clkDriver
   828 0000090C 434C4F434B242020            db "CLOCK$  "
   829                                  msdHdr:
   830 00000914 [3609000000000000]          dq com1Hdr
   831 0000091C 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   832 0000091E [240A000000000000]          dq commonStrat
   833 00000926 [690E000000000000]          dq msdDriver
   834 0000092E 0000000000000000            db 0,0,0,0,0,0,0,0
   835                                  com1Hdr:
   836 00000936 [5809000000000000]          dq com2Hdr
   837 0000093E 0080                        dw 08000h
   838 00000940 [240A000000000000]          dq commonStrat
   839 00000948 [C40C000000000000]          dq com1Intr
   840 00000950 434F4D3120202020            db "COM1    "
   841                                  com2Hdr:
   842 00000958 [7A09000000000000]          dq com3Hdr
   843 00000960 0080                        dw 08000h
   844 00000962 [240A000000000000]          dq commonStrat
   845 0000096A [CD0C000000000000]          dq com2Intr
   846 00000972 434F4D3220202020            db "COM2    "
   847                                  com3Hdr:
   848 0000097A [9C09000000000000]          dq com4Hdr
   849 00000982 0080                        dw 08000h
   850 00000984 [240A000000000000]          dq commonStrat
   851 0000098C [D60C000000000000]          dq com3Intr
   852 00000994 434F4D3320202020            db "COM3    "
   853                                  com4Hdr:
   854 0000099C [BE09000000000000]          dq lpt1Hdr
   855 000009A4 0080                        dw 08000h
   856 000009A6 [240A000000000000]          dq commonStrat
   857 000009AE [DF0C000000000000]          dq com4Intr
   858 000009B6 434F4D3420202020            db "COM4    "
   859                                  lpt1Hdr:
   860 000009BE [E009000000000000]          dq lpt2Hdr
   861 000009C6 40A0                        dw 0A040h
   862 000009C8 [340A000000000000]          dq nulStrat
   863 000009D0 [3A0A000000000000]          dq nulIntr
   864 000009D8 4C50543120202020            db "LPT1    "
   865                                  lpt2Hdr:
   866 000009E0 [020A000000000000]          dq lpt3Hdr
   867 000009E8 40A0                        dw 0A040h
   868 000009EA [340A000000000000]          dq nulStrat
   869 000009F2 [3A0A000000000000]          dq nulIntr
   870 000009FA 4C50543220202020            db "LPT2    "
   871                                  lpt3Hdr:
   872 00000A02 FFFFFFFFFFFFFFFF            dq -1
   873 00000A0A 40A0                        dw 0A040h
   874 00000A0C [340A000000000000]          dq nulStrat
   875 00000A14 [3A0A000000000000]          dq nulIntr
   876 00000A1C 4C50543320202020            dq "LPT3    "
   877                                  
   878                                  commonStrat:
   879                                  ;DOS calls this function with rbx=Ptr to request header
   880 00000A24 48891D01000000              mov qword [reqHdrPtr], rbx
   881 00000A2B C3                          ret
   882 00000A2C 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   883                                  
   884                                  nulStrat:
   885 00000A34 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   886                                  nulIntr:
   887 00000A3A C3                          ret
   888                                  
   889                                  conDriver:
   890 00000A3B 50                          push rax
   891 00000A3C 53                          push rbx
   892 00000A3D 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   893 00000A44 B003                        mov al, 03h ;Unknown Command
   894 00000A46 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
   895 00000A4A 7735                        ja .conWriteErrorCode ;If yes, error!
   896                                  
   897 00000A4C 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   898 00000A4F 3C04                        cmp al, 4
   899 00000A51 743D                        jz .conRead
   900 00000A53 3C05                        cmp al, 5
   901 00000A55 747F                        jz .conNondestructiveRead
   902 00000A57 3C06                        cmp al, 6
   903 00000A59 0F84A8000000                jz .conInputStatus
   904 00000A5F 3C07                        cmp al, 7
   905 00000A61 0F84B0000000                jz .conFlushInputBuffers
   906 00000A67 3C08                        cmp al, 8
   907 00000A69 0F84CA000000                jz .conWrite
   908 00000A6F 3C09                        cmp al, 9
   909 00000A71 0F84C2000000                jz .conWrite
   910 00000A77 3C0A                        cmp al, 0Ah
   911 00000A79 0F84E3000000                jz .conOutputStatus
   912 00000A7F EB06                        jmp short .conExit  ;All other valid functions return done
   913                                  .conWriteErrorCode:     ;Jump to with al=Standard Error code
   914 00000A81 B480                        mov ah, 80h ;Set error bit
   915 00000A83 66894303                    mov word [rbx + drvReqHdr.status], ax
   916                                  .conExit:
   917 00000A87 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   918 00000A8D 5B                          pop rbx
   919 00000A8E 58                          pop rax
   920 00000A8F C3                          ret
   921                                  .conRead:    ;Function 4
   922 00000A90 B005                        mov al, 05h ;Bad request structure length?
   923 00000A92 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
   924 00000A95 75EA                        jne .conWriteErrorCode
   925                                  
   926 00000A97 57                          push rdi
   927 00000A98 51                          push rcx
   928 00000A99 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   929 00000A9D 31C9                        xor ecx, ecx    ;Zero the char counter
   930                                  .cre1:
   931 00000A9F 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   932 00000AA2 741C                        je .cre2
   933 00000AA4 803DC700000000              cmp byte [.conBuf], 0   ;Does the buffer contain a zero?
   934 00000AAB 751A                        jnz .cre3   ;No, get the buffer value
   935 00000AAD 31C0                        xor eax, eax
   936 00000AAF CD36                        int 36h
   937                                  .cre11:
   938 00000AB1 AA                          stosb
   939 00000AB2 84C0                        test al, al ;Was the ascii code 0?
   940 00000AB4 7506                        jnz .cre12  ;No, skip storing scancode
   941 00000AB6 8825B6000000                mov byte [.conBuf], ah  ;Save scancode
   942                                  .cre12:
   943 00000ABC FFC1                        inc ecx ;Inc chars stored in buffer
   944 00000ABE EBDF                        jmp short .cre1
   945                                  .cre2:
   946 00000AC0 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   947 00000AC3 59                          pop rcx
   948 00000AC4 5F                          pop rdi
   949 00000AC5 EBC0                        jmp short .conExit
   950                                  .cre3:
   951 00000AC7 8A05A5000000                mov al, byte [.conBuf]  ;Get the buffer value
   952 00000ACD C6059E00000000              mov byte [.conBuf], 0   ;Reset the buffer value
   953 00000AD4 EBDB                        jmp short .cre11
   954                                  
   955                                  .conNondestructiveRead:  ;Function 5
   956 00000AD6 B005                        mov al, 05h ;Bad request structure length?
   957 00000AD8 803B0E                      cmp byte [rbx + drvReqHdr.hdrlen], nonDestInNoWaitReqPkt_size
   958 00000ADB 75A4                        jne .conWriteErrorCode
   959 00000ADD 803D8E00000000              cmp byte [.conBuf], 0
   960 00000AE4 7519                        jnz .cnr2
   961 00000AE6 B401                        mov ah, 01h     ;Get key if exists
   962 00000AE8 CD36                        int 36h
   963 00000AEA 7408                        jz .cnr1        ;If zero clear => no key, go forwards
   964                                      ;Keystroke available
   965                                  .cnr0:
   966 00000AEC 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   967 00000AEF E993FFFFFF                  jmp .conExit
   968                                  .cnr1: ;No keystroke available
   969 00000AF4 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h   ;Set busy bit
   970 00000AFA E988FFFFFF                  jmp .conExit
   971                                  .cnr2:
   972 00000AFF 8A056D000000                mov al, byte [.conBuf]  ;Copy scancode but dont reset it
   973 00000B05 EBE5                        jmp short .cnr0   ;Keystroke is available clearly
   974                                  
   975                                  .conInputStatus:         ;Function 6
   976 00000B07 B005                        mov al, 05h ;Bad request structure length?
   977 00000B09 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
   978 00000B0C 0F856FFFFFFF                jne .conWriteErrorCode
   979 00000B12 E970FFFFFF                  jmp .conExit ;Exit, device ready
   980                                  
   981                                  .conFlushInputBuffers:   ;Function 7
   982 00000B17 B005                        mov al, 05h ;Bad request structure length?
   983 00000B19 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
   984 00000B1C 0F855FFFFFFF                jne .conWriteErrorCode
   985 00000B22 C6054900000000              mov byte [.conBuf], 0   ;Clear buffer
   986                                  .cfib0:
   987 00000B29 B401                        mov ah, 01      ;Get buffer status
   988 00000B2B CD36                        int 36h
   989 00000B2D 0F8454FFFFFF                jz .conExit     ;If zero clear => no more keys to read
   990 00000B33 30E4                        xor ah, ah
   991 00000B35 CD36                        int 36h ;Read key to flush from buffer
   992 00000B37 EBF0                        jmp short .cfib0
   993                                  
   994                                  .conWrite:   ;Function 8 and 9
   995 00000B39 B005                        mov al, 05h ;Bad request structure length?
   996 00000B3B 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
   997 00000B3E 0F853DFFFFFF                jne .conWriteErrorCode
   998                                  
   999 00000B44 56                          push rsi
  1000 00000B45 51                          push rcx
  1001 00000B46 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1002 00000B4A 31C9                        xor ecx, ecx    ;Zero the char counter
  1003                                  .cw1: 
  1004 00000B4C 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1005 00000B4F 7407                        je .cw2
  1006 00000B51 AC                          lodsb   ;Get char into al, and inc rsi
  1007 00000B52 CD49                        int 49h ;Fast print char
  1008 00000B54 FFC1                        inc ecx
  1009 00000B56 EBF4                        jmp short .cw1 ;keep printing until all chars printed
  1010                                  .cw2:
  1011 00000B58 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1012 00000B5B 59                          pop rcx
  1013 00000B5C 5E                          pop rsi
  1014 00000B5D E925FFFFFF                  jmp .conExit
  1015                                  .conOutputStatus:   ;Function 0Ah
  1016 00000B62 B005                        mov al, 05h ;Bad request structure length?
  1017 00000B64 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1018 00000B67 0F8514FFFFFF                jne .conWriteErrorCode
  1019 00000B6D E915FFFFFF                  jmp .conExit
  1020                                  
  1021 00000B72 00                      .conBuf db 0    ;Single byte buffer
  1022                                  clkDriver:
  1023 00000B73 50                          push rax
  1024 00000B74 53                          push rbx
  1025 00000B75 51                          push rcx
  1026 00000B76 52                          push rdx
  1027 00000B77 56                          push rsi
  1028 00000B78 57                          push rdi
  1029 00000B79 55                          push rbp
  1030 00000B7A 488B1DABFEFFFF              mov rbx, qword [reqHdrPtr]
  1031 00000B81 B003                        mov al, 03h ;Unknown Command
  1032 00000B83 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1033 00000B87 772D                        ja .clkWriteErrorCode ;If yes, error!
  1034 00000B89 80FC04                      cmp ah, 04h
  1035 00000B8C 743C                        jz .clkRead
  1036 00000B8E 80FC06                      cmp ah, 06h
  1037 00000B91 0F84BE000000                jz .clkInputStatus
  1038 00000B97 80FC07                      cmp ah, 07h
  1039 00000B9A 0F84C5000000                jz .clkFlushInputBuffers
  1040 00000BA0 80FC08                      cmp ah, 08h
  1041 00000BA3 0F84CC000000                jz .clkWrite
  1042 00000BA9 80FC09                      cmp ah, 09h
  1043 00000BAC 0F84C3000000                jz .clkWrite
  1044 00000BB2 EB08                        jmp short .clkExit  ;All other valid functions return done immediately!
  1045                                  .clkNotFunctioning:
  1046 00000BB4 B002                        mov al, 02h ;Device not ready error
  1047                                  .clkWriteErrorCode:
  1048 00000BB6 B480                        mov ah, 80h ;Set error bit
  1049 00000BB8 66894303                    mov word [rbx + drvReqHdr.status], ax
  1050                                  .clkExit:
  1051 00000BBC 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Merge done bit
  1052 00000BC2 5D                          pop rbp
  1053 00000BC3 5F                          pop rdi
  1054 00000BC4 5E                          pop rsi
  1055 00000BC5 5A                          pop rdx
  1056 00000BC6 59                          pop rcx
  1057 00000BC7 5B                          pop rbx
  1058 00000BC8 58                          pop rax
  1059 00000BC9 C3                          ret
  1060                                  
  1061                                  .clkRead:           ;Function 4
  1062 00000BCA B005                        mov al, 05h ;Bad request structure length?
  1063 00000BCC 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1064 00000BCF 75E5                        jne .clkWriteErrorCode
  1065                                  
  1066 00000BD1 4831ED                      xor rbp, rbp    ;Write to RBP rather than updating record word by word
  1067 00000BD4 B404                        mov ah, 04h ;Read RTC date
  1068 00000BD6 CD3A                        int 3Ah
  1069 00000BD8 72DA                        jc .clkNotFunctioning
  1070 00000BDA 0FB6C2                      movzx eax, dl  ;Get dl (day of the month) into al
  1071 00000BDD E8A8000000                  call .clkBCDtoHex   ;Convert BCD value to hex
  1072 00000BE2 89C5                        mov ebp, eax    ;Save result in bp
  1073 00000BE4 88F0                        mov al, dh 
  1074 00000BE6 E89F000000                  call .clkBCDtoHex
  1075 00000BEB C1E005                      shl eax, 5  ;Shift month
  1076 00000BEE 01C5                        add ebp, eax    ;Add month number to bp
  1077 00000BF0 88C8                        mov al, cl      ;Get year from cl
  1078 00000BF2 E893000000                  call .clkBCDtoHex
  1079 00000BF7 3C50                        cmp al, 80  ;Is the value less than 80
  1080 00000BF9 7302                        jae .cread0
  1081 00000BFB 0464                        add al, 100
  1082                                  .cread0:
  1083 00000BFD 2C50                        sub al, 80
  1084 00000BFF C1E009                      shl eax, 9
  1085 00000C02 01C5                        add ebp, eax    ;number of years since 1980 shifted by 9 to ebp
  1086 00000C04 48C1E510                    shl rbp, 10h    ;Shift word 1 into word 2
  1087 00000C08 B402                        mov ah, 02h ;Read RTC time
  1088 00000C0A CD3A                        int 3Ah
  1089 00000C0C 72A6                        jc .clkNotFunctioning
  1090 00000C0E 88C8                        mov al, cl  ;Get minutes into al
  1091 00000C10 E875000000                  call .clkBCDtoHex
  1092 00000C15 4809C5                      or rbp, rax ;Add minutes byte low
  1093 00000C18 48C1E508                    shl rbp, 8  ;Shift up by a byte
  1094                                  
  1095 00000C1C 88E8                        mov al, ch  ;Get hours into al
  1096 00000C1E E867000000                  call .clkBCDtoHex
  1097 00000C23 4809C5                      or rbp, rax ;Add hours to byte low
  1098 00000C26 48C1E510                    shl rbp, 10h  ;Shift up by a byte and add an empty byte for 100ths of second
  1099 00000C2A 88F0                        mov al, dh  ;Get seconds into al
  1100 00000C2C E859000000                  call .clkBCDtoHex
  1101 00000C31 4809C5                      or rbp, rax ;Add seconds to byte low
  1102 00000C34 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Get the buffer pointer
  1103 00000C38 4881C705000000              add rdi, 5  ;Move pointer to the end of the buffer
  1104 00000C3F 4889E8                      mov rax, rbp    ;Get the packed 6 bytes into rax
  1105 00000C42 B906000000                  mov ecx, 6  ;6 bytes to transfer
  1106 00000C47 FD                          std ;Reverse direction of string operation
  1107                                  .cread1:
  1108 00000C48 AA                          stosb   ;Store byte and dec rdi
  1109 00000C49 48C1E808                    shr rax, 8  ;Shift all down by one byte
  1110 00000C4D E2F9                        loop .cread1    ;do it until ecx=0
  1111 00000C4F FC                          cld ;
  1112 00000C50 E967FFFFFF                  jmp .clkExit
  1113                                  
  1114                                  .clkInputStatus:    ;Function 6
  1115                                  ;Always return ready
  1116 00000C55 B005                        mov al, 05h ;Bad request structure length?
  1117 00000C57 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1118 00000C5A 0F8556FFFFFF                jne .clkWriteErrorCode
  1119 00000C60 E957FFFFFF                  jmp .clkExit
  1120                                  .clkFlushInputBuffers:  ;Function 7
  1121                                  ;Always return done immediately
  1122 00000C65 B005                        mov al, 05h ;Bad request structure length?
  1123 00000C67 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], flushReqPkt_size
  1124 00000C6A 0F8546FFFFFF                jne .clkWriteErrorCode
  1125 00000C70 E947FFFFFF                  jmp .clkExit
  1126                                  
  1127                                  .clkWrite:          ;Functions 8 and 9
  1128 00000C75 B005                        mov al, 05h ;Bad request structure length?
  1129 00000C77 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1130 00000C7A 0F8536FFFFFF                jne .clkWriteErrorCode
  1131                                  
  1132 00000C80 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr]
  1133 00000C84 31C0                        xor eax, eax
  1134 00000C86 66AB                        stosw   ;Get first word into ax
  1135 00000C88 89C1                        mov ecx, eax    ;Save ax in cx
  1136                                  
  1137                                  .clkBCDtoHex:
  1138                                  ;Converts a BCD value to a Hex byte
  1139                                  ;Takes input in al, returns in al (zero-ed upper seven bytes)
  1140 00000C8A 51                          push rcx
  1141 00000C8B 0FB6C0                      movzx eax, al   ;Zero extend
  1142 00000C8E 89C1                        mov ecx, eax    ;Save al in ecx
  1143 00000C90 250F000000                  and eax, 0Fh    ;Get lower nybble
  1144 00000C95 81E1F0000000                and ecx, 0F0h   ;Get upper nybble
  1145 00000C9B C1E904                      shr ecx, 4      ;Shift upper nybble value down
  1146                                  .cbth0:
  1147 00000C9E 050A000000                  add eax, 10
  1148 00000CA3 E2F9                        loop .cbth0
  1149 00000CA5 59                          pop rcx
  1150 00000CA6 C3                          ret
  1151                                  
  1152                                  .clkHexToBCD:
  1153                                  ;Converts a Hex byte into two BCD digits
  1154                                  ;Takes input in al, returns in al (zero-ed upper seven bytes)
  1155 00000CA7 51                          push rcx
  1156 00000CA8 0FB6C0                      movzx eax, al   ;Zero extend
  1157 00000CAB 31C9                        xor ecx, ecx
  1158                                  .chtb0:
  1159 00000CAD 3D0A000000                  cmp eax, 10
  1160 00000CB2 7209                        jb .chtb1
  1161 00000CB4 2D0A000000                  sub eax, 10
  1162 00000CB9 FFC1                        inc ecx
  1163 00000CBB EBF0                        jmp short .chtb0
  1164                                  .chtb1:
  1165 00000CBD C1E104                      shl ecx, 4  ;Move to upper nybble
  1166 00000CC0 08C8                        or al, cl   ;Move upper nybble into al upper nybble
  1167 00000CC2 59                          pop rcx
  1168 00000CC3 C3                          ret
  1169                                  
  1170                                  ;COM Driver headers and main interrupt strat
  1171                                  com1Intr:
  1172 00000CC4 C6059D01000000              mov byte [comIntr.comDevice], 0
  1173 00000CCB EB19                        jmp short comIntr
  1174                                  com2Intr:
  1175 00000CCD C6059401000001              mov byte [comIntr.comDevice], 1
  1176 00000CD4 EB10                        jmp short comIntr
  1177                                  com3Intr:
  1178 00000CD6 C6058B01000002              mov byte [comIntr.comDevice], 2
  1179 00000CDD EB07                        jmp short comIntr
  1180                                  com4Intr:
  1181 00000CDF C6058201000003              mov byte [comIntr.comDevice], 3
  1182                                  comIntr:
  1183 00000CE6 50                          push rax
  1184 00000CE7 53                          push rbx
  1185 00000CE8 51                          push rcx
  1186 00000CE9 52                          push rdx
  1187 00000CEA 56                          push rsi
  1188 00000CEB 57                          push rdi
  1189 00000CEC 488B1D39FDFFFF              mov rbx, qword [reqHdrPtr]
  1190 00000CF3 B003                        mov al, 03h ;Unknown Command
  1191 00000CF5 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1192 00000CF9 7756                        ja .comWriteErrorCode ;If yes, error!
  1193                                  
  1194 00000CFB 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
  1195 00000CFE 3C04                        cmp al, 4   ;Read Character(s)
  1196 00000D00 7462                        jz .comRead
  1197 00000D02 3C05                        cmp al, 5   ;Non-destructive read, acts like fast read 1 char if available
  1198 00000D04 0F849B000000                jz .comNondestructiveRead   
  1199 00000D0A 3C06                        cmp al, 6   ;Read Input Status, always return with Busy bit = 0
  1200 00000D0C 0F8484000000                jz .comReadInputStatus
  1201 00000D12 3C07                        cmp al, 7   ;Flush read buffers, return done
  1202 00000D14 0F84B9000000                jz .comFlushInputBuffers
  1203 00000D1A 3C08                        cmp al, 8
  1204 00000D1C 0F84DB000000                jz .comWrite
  1205 00000D22 3C09                        cmp al, 9
  1206 00000D24 0F84D3000000                jz .comWrite
  1207 00000D2A 3C0A                        cmp al, 0Ah
  1208 00000D2C 0F8400010000                jz .comOutputStatus ;Return Clear to send bit inverted for busy bit
  1209 00000D32 EB23                        jmp short .comExit  ;All other valid functions should return done
  1210                                  .comErrorNoCount:
  1211 00000D34 B002                        mov al, 02h ;Unknown device
  1212 00000D36 EB19                        jmp short .comWriteErrorCode
  1213                                  .comReadError:
  1214 00000D38 BA0B000000                  mov edx, 0Bh
  1215                                  .comWriteError:
  1216 00000D3D BA0A000000                  mov edx, 0Ah
  1217                                  .comError:
  1218 00000D42 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx ;Store actual transferred chars
  1219 00000D45 B902000000                  mov ecx, 02h    ;Unknown device
  1220 00000D4A 3CFE                        cmp al, 0FEh    ;Invalid COM port
  1221 00000D4C 0F44D1                      cmove edx, ecx  ;Only move unknown device error code if invalid COM port
  1222 00000D4F 88D0                        mov al, dl      ;Move dl to al to store error code
  1223                                  .comWriteErrorCode:    ;Jump to with al=Standard Error code
  1224 00000D51 B480                        mov ah, 80h ;Set error bit
  1225 00000D53 66894303                    mov word [rbx + drvReqHdr.status], ax
  1226                                  .comExit:
  1227 00000D57 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
  1228 00000D5D 5F                          pop rdi
  1229 00000D5E 5E                          pop rsi
  1230 00000D5F 5A                          pop rdx
  1231 00000D60 59                          pop rcx
  1232 00000D61 5B                          pop rbx
  1233 00000D62 58                          pop rax
  1234 00000D63 C3                          ret
  1235                                  
  1236                                  .comRead:
  1237 00000D64 B005                        mov al, 05h ;Bad request structure length?
  1238 00000D66 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1239 00000D69 75E6                        jne .comWriteErrorCode
  1240                                  
  1241 00000D6B 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
  1242 00000D6F 31C9                        xor ecx, ecx    ;Zero the char counter
  1243                                  .cr1:
  1244 00000D71 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1245 00000D74 741B                        je .cre2
  1246                                  .cr11:  ;Blocking wait, could be an infinite loop. Imitate basic DOS driver
  1247 00000D76 B802000000                  mov eax, 02h    ;Recieve 
  1248 00000D7B 8A15E7000000                mov dl, byte [.comDevice]    ;Get transacting com device
  1249 00000D81 6698                        cbw     ;Zero extend to upper byte
  1250 00000D83 CD34                        int 34h ;Recieve Char
  1251 00000D85 72BB                        jc .comError
  1252 00000D87 80FC80                      cmp ah, 80h ;Did a "timeout" occur? If so, keep waiting
  1253 00000D8A 74EA                        je .cr11
  1254 00000D8C AA                          stosb   ;Store char in al into buffer and inc rdi
  1255 00000D8D FFC1                        inc ecx
  1256 00000D8F EBE0                        jmp short .cr1
  1257                                  .cre2:
  1258 00000D91 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1259 00000D94 EBC1                        jmp short .comExit
  1260                                  
  1261                                  .comReadInputStatus:
  1262 00000D96 B005                        mov al, 05h ;Bad request structure length?
  1263 00000D98 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1264 00000D9B 75B4                        jne .comWriteErrorCode
  1265 00000D9D 66C743030000                mov word [rbx + statusReqPkt.status], 0 ;Chars ready to read status
  1266 00000DA3 EBB2                        jmp short .comExit
  1267                                  
  1268                                  .comNondestructiveRead:
  1269                                  ;Acts like a "read one character if there is one" function
  1270 00000DA5 B005                        mov al, 05h ;Bad request structure length?
  1271 00000DA7 803B0E                      cmp byte [rbx + drvReqHdr.hdrlen], nonDestInNoWaitReqPkt_size
  1272 00000DAA 75A5                        jne .comWriteErrorCode
  1273                                  .cndr1:
  1274 00000DAC B802000000                  mov eax, 02h    ;Recieve 
  1275 00000DB1 8A15B1000000                mov dl, byte [.comDevice]    ;Get transacting com device
  1276 00000DB7 6698                        cbw     ;Zero extend to upper byte
  1277 00000DB9 CD34                        int 34h ;Recieve Char
  1278 00000DBB 0F8273FFFFFF                jc .comErrorNoCount ;Dont save a char transfer number
  1279 00000DC1 80FC80                      cmp ah, 80h ;Did a "timeout" occur? If so, return with busy = 1
  1280 00000DC4 7405                        je .cndr2
  1281 00000DC6 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Get next char
  1282 00000DC9 EB8C                        jmp short .comExit
  1283                                  .cndr2:
  1284 00000DCB 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 200h ;Busy bit set
  1285 00000DD1 EB84                        jmp short .comExit
  1286                                  
  1287                                  .comFlushInputBuffers:
  1288 00000DD3 B005                        mov al, 05h ;Bad request structure length?
  1289 00000DD5 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], flushReqPkt_size
  1290 00000DD8 0F8573FFFFFF                jne .comWriteErrorCode
  1291                                  .cfib0:
  1292 00000DDE 8A1584000000                mov dl, byte [.comDevice]
  1293 00000DE4 6698                        cbw
  1294 00000DE6 B802000000                  mov eax, 02h    ;Recieve
  1295 00000DEB CD34                        int 34h
  1296 00000DED 0F8241FFFFFF                jc .comErrorNoCount
  1297 00000DF3 80FC80                      cmp ah, 80h ;Keep looping until ah = 80h (no more chars in buffer)
  1298 00000DF6 75E6                        jne .cfib0
  1299 00000DF8 E95AFFFFFF                  jmp .comExit
  1300                                  
  1301                                  .comWrite:
  1302 00000DFD B005                        mov al, 05h ;Bad request structure length?
  1303 00000DFF 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1304 00000E02 0F8549FFFFFF                jne .comWriteErrorCode
  1305                                  
  1306 00000E08 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1307 00000E0C 31C9                        xor ecx, ecx    ;Zero the char counter
  1308                                  .cw1: 
  1309 00000E0E 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1310 00000E11 7417                        je .cw2
  1311 00000E13 AC                          lodsb   ;Get char into al, and inc rsi
  1312 00000E14 B401                        mov ah, 01h ;Move function number into ah
  1313 00000E16 8A154C000000                mov dl, byte [.comDevice]
  1314 00000E1C 6698                        cbw     ;Zero extend to upper byte
  1315 00000E1E CD34                        int 34h ;Transmit char
  1316 00000E20 0F821CFFFFFF                jc .comError
  1317 00000E26 FFC1                        inc ecx
  1318 00000E28 EBE4                        jmp short .cw1 ;keep printing until all chars printed
  1319                                  .cw2:
  1320 00000E2A 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1321 00000E2D E925FFFFFF                  jmp .comExit
  1322                                  
  1323                                  .comOutputStatus:
  1324                                  ;Read MODEM status
  1325 00000E32 B005                        mov al, 05h ;Bad request structure length?
  1326 00000E34 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1327 00000E37 0F8514FFFFFF                jne .comWriteErrorCode
  1328                                  
  1329 00000E3D 8A1525000000                mov dl, byte [.comDevice]
  1330 00000E43 6698                        cbw     ;Zero extend to upper byte
  1331 00000E45 B403                        mov ah, 03h     ;Get status
  1332 00000E47 CD34                        int 34h
  1333 00000E49 0F82E5FEFFFF                jc .comErrorNoCount
  1334 00000E4F 2510000000                  and eax, 10h ;Isolate bit 4 of al, clear to set, and clear all other bits
  1335 00000E54 C1E005                      shl eax, 5   ;Shift it up to bit 9 (busy bit in status word) 
  1336 00000E57 F7D0                        not eax      ;Bitwise inversion
  1337 00000E59 2500020000                  and eax, 200h   ;Isolate bit 9
  1338 00000E5E 6689441B03                  mov word [rbx + rbx + drvReqHdr.status], ax  ;Add the busy bit
  1339 00000E63 E9EFFEFFFF                  jmp .comExit
  1340 00000E68 00                      .comDevice   db 0
  1341                                  
  1342                                  msdDriver:
  1343 00000E69 50                          push rax
  1344 00000E6A 53                          push rbx
  1345 00000E6B 51                          push rcx
  1346 00000E6C 52                          push rdx
  1347 00000E6D 56                          push rsi
  1348 00000E6E 57                          push rdi
  1349 00000E6F 55                          push rbp
  1350 00000E70 4150                        push r8
  1351 00000E72 488B1DB3FBFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1352 00000E79 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1353 00000E7D B003                        mov al, 03h
  1354 00000E7F 0F87F9000000                ja .msdWriteErrorCode ;If yes, error!
  1355 00000E85 B001                        mov al, 01h ;Unknown Unit Error
  1356 00000E87 807B0105                    cmp byte [rbx + drvReqHdr.unitnm], 05h  ;Unit greater than 5 is invalid
  1357 00000E8B 0F87ED000000                ja .msdWriteErrorCode ;If yes, error!
  1358 00000E91 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1359 00000E94 84C0                        test al, al
  1360 00000E96 0F84F8000000                jz .msdInit
  1361 00000E9C 3C01                        cmp al, 01
  1362 00000E9E 0F8496010000                jz .msdMedChk
  1363 00000EA4 3C02                        cmp al, 02
  1364 00000EA6 0F84FF010000                jz .msdBuildBPB
  1365 00000EAC 3C03                        cmp al, 03
  1366 00000EAE 0F8465020000                jz .msdIOCTLRead
  1367 00000EB4 3C04                        cmp al, 04
  1368 00000EB6 0F846D020000                jz .msdRead
  1369 00000EBC 3C08                        cmp al, 08
  1370 00000EBE 0F84A1020000                jz .msdWrite
  1371 00000EC4 3C09                        cmp al, 09
  1372 00000EC6 0F84D5020000                jz .msdWriteVerify
  1373 00000ECC 3C0C                        cmp al, 12
  1374 00000ECE 0F8416030000                jz .msdIOCTLWrite
  1375 00000ED4 3C0D                        cmp al, 13
  1376 00000ED6 0F841E030000                jz .msdDevOpen
  1377 00000EDC 3C0E                        cmp al, 14
  1378 00000EDE 0F8431030000                jz .msdDevClose
  1379 00000EE4 3C0F                        cmp al, 15
  1380 00000EE6 0F8444030000                jz .msdRemovableMedia
  1381 00000EEC 3C13                        cmp al, 19
  1382 00000EEE 0F8465030000                jz .msdGenericIOCTL
  1383 00000EF4 3C17                        cmp al, 23
  1384 00000EF6 0F846D030000                jz .msdGetLogicalDev
  1385 00000EFC 3C18                        cmp al, 24
  1386 00000EFE 0F847E030000                jz .msdSetLogicalDev
  1387 00000F04 EB7E                        jmp short .msdDriverExit    ;All other valid functions exit done
  1388                                  .msdIOError:  ;In Read and Write errors, rbp points to the dev struc
  1389 00000F06 4889EB                      mov rbx, rbp
  1390 00000F09 0FB6C0                      movzx eax, al   ;Number of IO-ed sectors in last request
  1391 00000F0C 01C6                        add esi, eax    ;esi Keeps sector count across transfers
  1392 00000F0E 897316                      mov dword [rbx + ioReqPkt.tfrlen], esi ;Save number of IO-ed sectors
  1393                                  ;Now fall through to general error
  1394                                  .msdGenDiskError:
  1395 00000F11 B401                        mov ah, 01h
  1396 00000F13 30D2                        xor dl, dl  ;Work around bug that fails request if dl > 7Fh
  1397 00000F15 CD33                        int 33h ;Read status of last operation
  1398 00000F17 80FC06                      cmp ah, 06h ;Mock Seek response (device not present)
  1399 00000F1A B002                        mov al, 02h ;Give device not ready error (sensibly I think)
  1400 00000F1C 7460                        je .msdWriteErrorCode 
  1401 00000F1E B00C                        mov al, 0Ch ;Preliminary General Error Faults
  1402 00000F20 80FCFF                      cmp ah, -1  ;Sense operation failed
  1403 00000F23 7459                        je .msdWriteErrorCode 
  1404 00000F25 80FC20                      cmp ah, 20h ;Gen. ctrlr. failure. Consider new error code to halt system.
  1405 00000F28 7454                        je .msdWriteErrorCode
  1406                                  ;Device Not Ready
  1407 00000F2A B002                        mov al, 02h  ;Device not ready code
  1408 00000F2C 4138C0                      cmp r8b, al  ;SCSI Not ready commands start with 2
  1409 00000F2F 744D                        je .msdWriteErrorCode
  1410 00000F31 49C1E808                    shr r8, 8       ;Remove Sense Key
  1411 00000F35 410FB7C8                    movzx ecx, r8w  ;Get ASC and ASCQ in cl and ch bzw.
  1412                                  ;Write Protected
  1413 00000F39 30C0                        xor al, al
  1414 00000F3B 6681F92700                  cmp cx, 0027h   ;Write protected error
  1415 00000F40 743C                        je .msdWriteErrorCode
  1416                                  ;CRC Error
  1417 00000F42 B004                        mov al, 04h     ;CRC error code
  1418 00000F44 6681F90803                  cmp cx, 0308h   ;LU comms CRC error (UDMA/32)
  1419 00000F49 7433                        je .msdWriteErrorCode
  1420 00000F4B 6681F91000                  cmp cx, 0010h   ;ID CRC or ECC error
  1421 00000F50 742C                        je .msdWriteErrorCode
  1422 00000F52 6681F94701                  cmp cx, 0147h   ;Data phase CRC error detected
  1423 00000F57 7425                        je .msdWriteErrorCode
  1424                                  ;Seek Error
  1425 00000F59 B006                        mov al, 06h     ;Seek error code
  1426 00000F5B 80F902                      cmp cl, 02h     ;No Seek Complete
  1427 00000F5E 741E                        je .msdWriteErrorCode
  1428                                  ;Unknown Hardware Media (Shouldn't happen with Flash Drives)
  1429                                  ;This error should only be called if BPB not recognised for Flash Drives
  1430 00000F60 B007                        mov al, 07h
  1431 00000F62 80F930                      cmp cl, 30h   ;All issues with media returns unknown media
  1432 00000F65 7417                        je .msdWriteErrorCode
  1433                                  ;Sector Not Found
  1434 00000F67 B008                        mov al, 08h     ;Sector not found code
  1435 00000F69 80F921                      cmp cl, 21h     ;Illegal Request - Invalid LBA
  1436 00000F6C 7410                        je .msdWriteErrorCode
  1437                                  ;Write faults
  1438 00000F6E B00A                        mov al, 0Ah     ;Write fault
  1439 00000F70 80F90C                      cmp cl, 0Ch     ;Write Error ASC code
  1440 00000F73 7409                        je .msdWriteErrorCode
  1441                                  ;Read faults
  1442 00000F75 B00B                        mov al, 0Bh     ;Read fault
  1443 00000F77 80F911                      cmp cl, 11h     ;Read error
  1444 00000F7A 7402                        je .msdWriteErrorCode
  1445                                  ;General Errors
  1446 00000F7C B00C                        mov al, 0Ch     ;Everything else is general error
  1447                                  .msdWriteErrorCode:    ;Jump to with al=Standard Error code
  1448 00000F7E B480                        mov ah, 80h ;Set error bit
  1449 00000F80 66894303                    mov word [rbx + drvReqHdr.status], ax
  1450                                  .msdDriverExit:
  1451 00000F84 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1452 00000F8A 4158                        pop r8
  1453 00000F8C 5D                          pop rbp
  1454 00000F8D 5F                          pop rdi
  1455 00000F8E 5E                          pop rsi
  1456 00000F8F 5A                          pop rdx
  1457 00000F90 59                          pop rcx
  1458 00000F91 5B                          pop rbx
  1459 00000F92 58                          pop rax
  1460 00000F93 C3                          ret
  1461                                  .msdInit:            ;Function 0
  1462 00000F94 B005                        mov al, 05h ;Bad request structure length
  1463 00000F96 803B1F                      cmp byte [rbx + drvReqHdr.hdrlen], initReqPkt_size
  1464 00000F99 75E3                        jne .msdWriteErrorCode
  1465                                  
  1466 00000F9B 4151                        push r9
  1467 00000F9D CD31                        int 31h ;Get number of Int 33h devices in r8b
  1468 00000F9F 4159                        pop r9
  1469 00000FA1 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1470 00000FA5 4489C0                      mov eax, r8d
  1471 00000FA8 3C01                        cmp al, 1
  1472 00000FAA 7702                        ja .mi1
  1473 00000FAC FEC0                        inc al ;Make it two
  1474                                  .mi1:
  1475 00000FAE BA05000000                  mov edx, 5
  1476 00000FB3 39D0                        cmp eax, edx
  1477 00000FB5 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1478 00000FB8 880570F9FFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1479 00000FBE 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1480 00000FC1 440005(A9000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1481 00000FC8 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1482 00000FCA 488D3D20030000              lea rdi, qword [.msdBPBblks]
  1483 00000FD1 53                          push rbx
  1484                                  .mi2:
  1485 00000FD2 89EA                        mov edx, ebp
  1486 00000FD4 488D1D6E050000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1487 00000FDB 31C9                        xor ecx, ecx    ;Sector 0
  1488 00000FDD B801820000                  mov eax, 8201h       ;Read 1 sector
  1489 00000FE2 CD33                        int 33h
  1490 00000FE4 724E                        jc .msdInitError
  1491                                  
  1492 00000FE6 488D355C050000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1493 00000FED B90F000000                  mov ecx, bpbEx_size/8
  1494 00000FF2 F348A5                      rep movsq   ;Move the BPB data into the right block
  1495                                  
  1496 00000FF5 FFC5                        inc ebp
  1497 00000FF7 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1498 00000FFA 75D6                        jne .mi2  ;No? Go again
  1499                                  
  1500 00000FFC 488D3DC6020000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1501 00001003 488D15E7020000              lea rdx, qword [.msdBPBblks]
  1502                                  .mi3:
  1503 0000100A 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1504 0000100D 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1505 00001014 FFCD                        dec ebp
  1506 00001016 75F2                        jnz .mi3  ;If not zero yet, go again
  1507                                  
  1508 00001018 5B                          pop rbx
  1509 00001019 488D15A9020000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1510 00001020 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1511 00001024 488D151E050000              lea rdx, qword [driverDataPtr]
  1512 0000102B 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1513 0000102F E950FFFFFF                  jmp .msdDriverExit
  1514                                  .msdInitError:
  1515 00001034 5B                          pop rbx
  1516 00001035 E94AFFFFFF                  jmp .msdDriverExit
  1517                                  .msdMedChk:          ;Function 1
  1518                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1519                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1520                                  ; suffice.
  1521 0000103A B005                        mov al, 05h ;Bad request structure length
  1522 0000103C 803B17                      cmp byte [rbx + drvReqHdr.hdrlen], mediaCheckReqPkt_size
  1523 0000103F 0F8539FFFFFF                jne .msdWriteErrorCode
  1524                                  
  1525 00001045 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1526 0000104A 8A90[BF120000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1527 00001050 F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1528 00001053 754D                        jnz .mmcNoChange
  1529                                  ;Now we do a BIOS changeline check. If it returns 80h or 86h then check med desc
  1530 00001055 B416                        mov ah, 16h 
  1531 00001057 CD33                        int 33h
  1532 00001059 0F82B2FEFFFF                jc .msdGenDiskError
  1533 0000105F 80FC80                      cmp ah, 80h
  1534 00001062 740E                        je .mmcNoChangeLine
  1535 00001064 80FC86                      cmp ah, 86h
  1536 00001067 7409                        je .mmcNoChangeLine
  1537 00001069 84E4                        test ah, ah ;No change?
  1538 0000106B 7435                        jz .mmcNoChange
  1539 0000106D F6C401                      test ah, 1  ;Neither 80h or 86h have bit 0 set
  1540 00001070 7513                        jnz .mmcChange
  1541                                  ;If nothing, fall through and test manually, should never happen though
  1542                                  .mmcNoChangeLine:
  1543                                  ;Now we test Media Descriptor
  1544 00001072 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1545 00001075 488B3CC5[C9120000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1546 0000107D 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1547 00001080 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1548 00001083 7414                        je .mmcUnsure
  1549                                  .mmcChange:
  1550 00001085 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1551 00001089 488D0525020000              lea rax, qword [.msdDefLabel]           ;Temp, ret def label
  1552 00001090 4889430F                    mov qword [rbx + mediaCheckReqPkt.desptr], rax 
  1553 00001094 E9EBFEFFFF                  jmp .msdDriverExit
  1554                                  .mmcUnsure:
  1555 00001099 C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1556 0000109D E9E2FEFFFF                  jmp .msdDriverExit
  1557                                  .mmcNoChange:
  1558 000010A2 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1559 000010A6 E9D9FEFFFF                  jmp .msdDriverExit
  1560                                  
  1561                                  .msdBuildBPB:        ;Function 2
  1562 000010AB B005                        mov al, 05h ;Bad request structure length
  1563 000010AD 803B1E                      cmp byte [rbx + drvReqHdr.hdrlen], bpbBuildReqPkt_size
  1564 000010B0 0F85C8FEFFFF                jne .msdWriteErrorCode
  1565                                  
  1566 000010B6 4889DE                      mov rsi, rbx
  1567 000010B9 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1568 000010BE 8A90[BF120000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1569 000010C4 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1570 000010C8 31C9                        xor ecx, ecx    ;Read Sector 0
  1571 000010CA B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1572 000010CF CD33                        int 33h
  1573 000010D1 0F823AFEFFFF                jc .msdGenDiskError
  1574                                  ;Check Media Descriptor, must be F0h or F8h-FFh or unknown media
  1575 000010D7 807B15F0                    cmp byte [rbx + bpb.media], 0F0h    ;3.5" FDD standard
  1576 000010DB 7418                        je .mbbpb0
  1577 000010DD 807B15F8                    cmp byte [rbx + bpb.media], 0F8h    ;FDD/Large Media Standard
  1578 000010E1 7412                        je .mbbpb0
  1579 000010E3 807B15F9                    cmp byte [rbx + bpb.media], 0F9h    ;5.25" & 720K 3.5" Media Standard
  1580 000010E7 740C                        je .mbbpb0
  1581 000010E9 807B15FC                    cmp byte [rbx + bpb.media], 0FCh    ;Very Obsolete Media Standards
  1582 000010ED B007                        mov al, 07h ;Unknown media error code
  1583 000010EF 0F8289FEFFFF                jb .msdWriteErrorCode
  1584                                  .mbbpb0:
  1585 000010F5 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1586 000010F8 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1587 000010FD 488B3CC5[C9120000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1588 00001105 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1589 00001108 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1590 0000110C B90F000000                  mov ecx, bpbEx_size/8
  1591 00001111 F348A5                      rep movsq   ;Move the BPB data into the right space
  1592 00001114 E96BFEFFFF                  jmp .msdDriverExit
  1593                                  .msdIOCTLRead:       ;Function 3, returns done
  1594 00001119 B005                        mov al, 05h ;Bad request structure length
  1595 0000111B 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1596 0000111E 0F855AFEFFFF                jne .msdWriteErrorCode
  1597                                  
  1598 00001124 E95BFEFFFF                  jmp .msdDriverExit
  1599                                  .msdRead:            ;Function 4
  1600                                  ;Will read one sector at a time.
  1601 00001129 B005                        mov al, 05h ;Bad request structure length
  1602 0000112B 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1603 0000112E 0F854AFEFFFF                jne .msdWriteErrorCode
  1604                                  
  1605 00001134 4889DD                      mov rbp, rbx
  1606 00001137 31F6                        xor esi, esi  ;Set sector read counter to zero
  1607                                  .msdr0:
  1608 00001139 B682                        mov dh, 82h ;LBA Read Sectors
  1609 0000113B E85B010000                  call .msdBlkIOCommon
  1610 00001140 0F82C0FDFFFF                jc .msdIOError
  1611 00001146 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1612 0000114E 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1613 00001156 FFC6                        inc esi
  1614 00001158 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1615 0000115B 75DC                        jne .msdr0
  1616 0000115D 4889EB                      mov rbx, rbp
  1617 00001160 E91FFEFFFF                  jmp .msdDriverExit
  1618                                  .msdWrite:           ;Function 8
  1619                                  ;Will write one sector at a time.
  1620 00001165 B005                        mov al, 05h ;Bad request structure length
  1621 00001167 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1622 0000116A 0F850EFEFFFF                jne .msdWriteErrorCode
  1623                                  
  1624 00001170 4889DD                      mov rbp, rbx
  1625 00001173 31F6                        xor esi, esi  ;Set counter to zero
  1626                                  .msdw0:
  1627 00001175 B683                        mov dh, 83h ;LBA Write Sectors
  1628 00001177 E81F010000                  call .msdBlkIOCommon
  1629 0000117C 0F8284FDFFFF                jc .msdIOError
  1630 00001182 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1631 0000118A 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1632 00001192 FFC6                        inc esi
  1633 00001194 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1634 00001197 75DC                        jne .msdw0
  1635 00001199 4889EB                      mov rbx, rbp
  1636 0000119C E9E3FDFFFF                  jmp .msdDriverExit
  1637                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1638                                  ;Will write one sector at a time and then verify it.
  1639 000011A1 B005                        mov al, 05h ;Bad request structure length
  1640 000011A3 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1641 000011A6 0F85D2FDFFFF                jne .msdWriteErrorCode
  1642                                  
  1643 000011AC 4889DD                      mov rbp, rbx
  1644 000011AF 31F6                        xor esi, esi  ;Set counter to zero
  1645                                  .msdwv0:
  1646 000011B1 B683                        mov dh, 83h ;LBA Write Sectors
  1647 000011B3 E8E3000000                  call .msdBlkIOCommon
  1648 000011B8 0F8248FDFFFF                jc .msdIOError    ;Error handler needs to add to esi the value in al
  1649 000011BE B684                        mov dh, 84h ;LBA Verify Sectors
  1650 000011C0 E8D6000000                  call .msdBlkIOCommon
  1651 000011C5 0F823BFDFFFF                jc .msdIOError    ;Error handler needs to add to esi the value in al
  1652 000011CB 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1653 000011D3 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1654 000011DB FFC6                        inc esi
  1655 000011DD 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1656 000011E0 75CF                        jne .msdwv0
  1657 000011E2 4889EB                      mov rbx, rbp
  1658 000011E5 E99AFDFFFF                  jmp .msdDriverExit
  1659                                  .msdIOCTLWrite:      ;Function 12, returns done
  1660 000011EA B005                        mov al, 05h ;Bad request structure length
  1661 000011EC 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1662 000011EF 0F8589FDFFFF                jne .msdWriteErrorCode
  1663                                  
  1664 000011F5 E98AFDFFFF                  jmp .msdDriverExit
  1665                                  .msdDevOpen:         ;Function 13
  1666 000011FA B005                        mov al, 05h ;Bad request structure length
  1667 000011FC 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], openReqPkt_size
  1668 000011FF 0F8579FDFFFF                jne .msdWriteErrorCode
  1669                                  
  1670 00001205 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1671 0000120A FE80[C4120000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1672 00001210 E96FFDFFFF                  jmp .msdDriverExit
  1673                                  .msdDevClose:        ;Function 14
  1674 00001215 B005                        mov al, 05h ;Bad request structure length
  1675 00001217 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], closeReqPkt_size
  1676 0000121A 0F855EFDFFFF                jne .msdWriteErrorCode
  1677                                  
  1678 00001220 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1679 00001225 FE88[C4120000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1680 0000122B E954FDFFFF                  jmp .msdDriverExit
  1681                                  .msdRemovableMedia:  ;Function 15
  1682 00001230 B005                        mov al, 05h ;Bad request structure length
  1683 00001232 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], remMediaReqPkt_size
  1684 00001235 0F8543FDFFFF                jne .msdWriteErrorCode
  1685                                  
  1686 0000123B 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1687 00001240 8A80[BF120000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1688 00001246 A880                        test al, 80h
  1689 00001248 0F8436FDFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1690 0000124E 66C743030002                mov word [rbx + remMediaReqPkt.status], 0200h ;Set Busy bit
  1691 00001254 E92BFDFFFF                  jmp .msdDriverExit
  1692                                  .msdGenericIOCTL:    ;Function 19
  1693 00001259 B005                        mov al, 05h ;Bad request structure length
  1694 0000125B 803B27                      cmp byte [rbx + drvReqHdr.hdrlen], ioctlReqPkt_size
  1695 0000125E 0F851AFDFFFF                jne .msdWriteErrorCode
  1696                                  
  1697 00001264 E91BFDFFFF                  jmp .msdDriverExit
  1698                                  .msdGetLogicalDev:   ;Function 23
  1699 00001269 B005                        mov al, 05h ;Bad request structure length
  1700 0000126B 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], getDevReqPkt_size
  1701 0000126E 0F850AFDFFFF                jne .msdWriteErrorCode
  1702                                  
  1703 00001274 8A0544000000                mov al, byte [.msdCurDev]
  1704 0000127A 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1705 0000127D E902FDFFFF                  jmp .msdDriverExit
  1706                                  .msdSetLogicalDev:   ;Function 24
  1707 00001282 B005                        mov al, 05h ;Bad request structure length
  1708 00001284 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], setDevReqPkt_size
  1709 00001287 0F85F1FCFFFF                jne .msdWriteErrorCode
  1710                                  
  1711 0000128D 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1712 00001290 880528000000                mov byte [.msdCurDev], al
  1713 00001296 E9E9FCFFFF                  jmp .msdDriverExit
  1714                                  
  1715                                  .msdBlkIOCommon:  ;Does block IO
  1716                                  ;Called with rbp containing old rbx value and ah with function number
  1717                                  ;Error handled by caller
  1718                                  ;Sector count handled by caller
  1719                                  ;Called with dh = BIOS function number
  1720 0000129B 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1721 000012A0 8A90[BF120000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req in dl
  1722 000012A6 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1723 000012AA 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1724 000012AE 88F4                        mov ah, dh
  1725 000012B0 B001                        mov al, 01h ;Do one sector at a time 
  1726 000012B2 CD33                        int 33h
  1727 000012B4 C3                          ret
  1728                                  
  1729 000012B5 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1730                                  ;LASTDRIVE default is 5
  1731 000012BE 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1732                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1733 000012BF 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1734 000012C4 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1735 000012C9 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1735 000012D2 000000000000000000-
  1735 000012DB 000000000000000000-
  1735 000012E4 000000000000000000-
  1735 000012ED 00000000           
  1736 000012F1 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1736 000012FA 000000000000000000-
  1736 00001303 000000000000000000-
  1736 0000130C 000000000000000000-
  1736 00001315 000000000000000000-
  1736 0000131E 000000000000000000-
  1736 00001327 000000000000000000-
  1736 00001330 000000000000000000-
  1736 00001339 000000000000000000-
  1736 00001342 000000000000000000-
  1736 0000134B 000000000000000000-
  1736 00001354 000000000000000000-
  1736 0000135D 000000000000000000-
  1736 00001366 000000000000000000-
  1736 0000136F 000000000000000000-
  1736 00001378 000000000000000000-
  1736 00001381 000000000000000000-
  1736 0000138A 000000000000000000-
  1736 00001393 000000000000000000-
  1736 0000139C 000000000000000000-
  1736 000013A5 000000000000000000-
  1736 000013AE 000000000000000000-
  1736 000013B7 000000000000000000-
  1736 000013C0 000000000000000000-
  1736 000013C9 000000000000000000-
  1736 000013D2 000000000000000000-
  1736 000013DB 000000000000000000-
  1736 000013E4 000000000000000000-
  1736 000013ED 000000000000000000-
  1736 000013F6 000000000000000000-
  1736 000013FF 000000000000000000-
  1736 00001408 000000000000000000-
  1736 00001411 000000000000000000-
  1736 0000141A 000000000000000000-
  1736 00001423 000000000000000000-
  1736 0000142C 000000000000000000-
  1736 00001435 000000000000000000-
  1736 0000143E 000000000000000000-
  1736 00001447 000000000000000000-
  1736 00001450 000000000000000000-
  1736 00001459 000000000000000000-
  1736 00001462 000000000000000000-
  1736 0000146B 000000000000000000-
  1736 00001474 000000000000000000-
  1736 0000147D 000000000000000000-
  1736 00001486 000000000000000000-
  1736 0000148F 000000000000000000-
  1736 00001498 000000000000000000-
  1736 000014A1 000000000000000000-
  1736 000014AA 000000000000000000-
  1736 000014B3 000000000000000000-
  1736 000014BC 000000000000000000-
  1736 000014C5 000000000000000000-
  1736 000014CE 000000000000000000-
  1736 000014D7 000000000000000000-
  1736 000014E0 000000000000000000-
  1736 000014E9 000000000000000000-
  1736 000014F2 000000000000000000-
  1736 000014FB 000000000000000000-
  1736 00001504 000000000000000000-
  1736 0000150D 000000000000000000-
  1736 00001516 000000000000000000-
  1736 0000151F 000000000000000000-
  1736 00001528 000000000000000000-
  1736 00001531 000000000000000000-
  1736 0000153A 000000000000000000-
  1736 00001543 000000000000       
  1737                                  
  1738                                  driverDataPtr:
