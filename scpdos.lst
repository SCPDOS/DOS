     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc mbr
    74 00000000 <res 1B8h>          <1>     .bsCode     resb 440
    75 000001B8 ????????            <1>     .diskID     resb 4
    76 000001BC ????                <1>     .reserved   resb 2
    77 000001BE <res 10h>           <1>     .mbrEntry1  resb 16
    78 000001CE <res 10h>           <1>     .mbrEntry2  resb 16
    79 000001DE <res 10h>           <1>     .mbrEntry3  resb 16
    80 000001EE <res 10h>           <1>     .mbrEntry4  resb 16
    81 000001FE ????                <1>     .mbrSig     resb 2
    82                              <1> endstruc
    83                              <1> 
    84                              <1> struc mbrEntry
    85 00000000 ??                  <1>     .ptnAtrib   resb 1  ;80h = active
    86 00000001 ??????              <1>     .chsStart   resb 3  ;Ignore practically
    87 00000004 ??                  <1>     .ptnType    resb 1
    88 00000005 ??????              <1>     .chsEnd     resb 3  ;Ignore
    89 00000008 ????????            <1>     .lbaStart   resb 4  ;Start of partition in 32 bit LBA
    90 0000000C ????????            <1>     .numSectors resb 4  ;Number of sectors in partition
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc fatDirEntry
    94                              <1> 
    95 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    96 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    97 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    98 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    99 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
   100 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
   101 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
   102 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
   103 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
   104 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
   105 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
   106 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
   107                              <1> 
   108                              <1> endstruc
   109                              <1> ;Directory attribute equates
   110                              <1>     dirReadOnly     equ 01h
   111                              <1>     dirHidden       equ 02h
   112                              <1>     dirSystem       equ 04h
   113                              <1>     dirVolumeID     equ 08h
   114                              <1>     dirDirectory    equ 10h
   115                              <1>     dirArchive      equ 20h
   116                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
   117                              <1> 
   118                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
   119                              <1> 
   120 00000000 ??????              <1>     .jmpBoot                resb 3 
   121 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   122 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   123 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   124 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   125 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   126 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   127 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   128 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   129 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   130 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   131 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   132 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   133 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   134 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   135 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   136 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   137 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   138 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   139                              <1> 
   140                              <1> endstruc
   141                              <1> 
   142                              <1> struc FSInfo
   143                              <1> 
   144 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   145 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   146 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   147 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   148 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   149 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   150 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   151                              <1> 
   152                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Rel cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Rel number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFileName   resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Addr of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????????????    <1>     .bufferLBA   resq  1   ;LBA the buffer contains
   165 00000012 ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 00000013 ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000014 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, pointer to rax saved in oldRSP
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> ;Pushed by Processor when invoked via Interrupt
   186 00000048 ????????????????    <1>     .rip    resq 1
   187 00000050 ????????????????    <1>     .cs     resq 1
   188 00000058 ????????????????    <1>     .flags  resq 1
   189                              <1> endstruc
   190                              <1> 
   191                              <1> %macro pushDOS 0
   192                              <1>     push r9
   193                              <1>     push r8
   194                              <1>     push rbp
   195                              <1>     push rdi
   196                              <1>     push rsi
   197                              <1>     push rdx
   198                              <1>     push rcx
   199                              <1>     push rbx
   200                              <1>     push rax
   201                              <1> %endmacro
   202                              <1> 
   203                              <1> %macro popDOS 0
   204                              <1>     pop rax
   205                              <1>     pop rbx
   206                              <1>     pop rcx
   207                              <1>     pop rdx
   208                              <1>     pop rsi
   209                              <1>     pop rdi
   210                              <1>     pop rbp
   211                              <1>     pop r8
   212                              <1>     pop r9
   213                              <1> %endmacro
   214                              <1> 
   215                              <1> struc psp
   216 00000000 ????                <1>     .return     resb 2  ;Should always be CDh 40h
   217 00000002 ????????????????    <1>     .startSeg   resq 1  ;Pointer to the start of the PSP
   218 0000000A ????????????????    <1>     .oldInt42h  resq 1  ;Int 42h pointer on overlay load
   219 00000012 ????????????????    <1>     .oldInt43h  resq 1  ;Int 43h pointer on overlay load
   220 0000001A ????????????????    <1>     .oldInt44h  resq 1  ;Int 44h pointer on overlay load
   221 00000022 ????????????????    <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   222 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   223 0000003E ????????????????    <1>     .envPtr     resq 1  ;Pointer to the environment
   224 00000046 ????????????????    <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to Int 41h
   225 0000004E ????                <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   226 00000050 ??????              <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   227 00000053 ????????????????    <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   228 0000005B ????????????????    <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   229 00000063 ????????????????    <1>     .fcbPtr1    resq 1  ;Pointer to the first OS allocated FCB
   230 0000006B <res 15h>           <1>     .reserved   resb 21
   231 00000080 ??                  <1>     .charCount  resb 1  ;Number of characters in command tail
   232 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   233                              <1> endstruc
   234                              <1> 
   235                              <1> struc mcb
   236 00000000 ??                  <1>     .mzbyte     resb 1  ;M=In use, Z=Free
   237 00000001 ????????????????    <1>     .processPtr resq 1  ;Points to the start of the process PSP
   238 00000009 ????????            <1>     .paragraphs resd 1  ;Gives the number of paras allocated to this process
   239 0000000D ??????              <1>     .reserved   resb 3
   240                              <1>     .program:
   241                              <1> endstruc
   242                              <1> 
   243                              <1> struc clkStruc
   244 00000000 ????                <1>     .dateWord   resw 1
   245 00000002 ??                  <1>     .minutes    resb 1
   246 00000003 ??                  <1>     .hours      resb 1
   247 00000004 ??                  <1>     .hseconds   resb 1  ;Hundreths of seconds
   248 00000005 ??                  <1>     .seconds    resb 1
   249                              <1> endstruc
     7                                  %include "dosSeg.asm"
     8                              <1> ;This file contains the main DOS data segment
     9                              <1> 
    10                              <1> Segment dSeg nobits align=1 
    11 00000000 ????????????????    <1>     dosSegPtr   resq 1    ;Pointer to the data Segment itself
    12 00000008 ??                  <1>     bootDrive   resb 1    ;The Int 33h device we booted from
    13 00000009 ??                  <1>     numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    14 0000000A ??                  <1>     numLDrives  resb 1    ;Number of logical drives in the system
    15 0000000B ??                  <1>     lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    16 0000000C <res 2Ah>           <1>     charReqHdr  resb ioReqPkt_size  ;Character IO Request header
    17 00000036 <res 2Ah>           <1>     diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
    18                              <1>     ;The device driver header with space for the largest possible packet
    19 00000060 ????????????????    <1>     sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    20 00000068 ????????????????    <1>     mcbChainPtr resq 1    ;Pointer to the MCB chain
    21 00000070 ????????????????    <1>     dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    22 00000078 ????????????????    <1>     sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    23 00000080 ????????????????    <1>     clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    24                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
    25 00000088 ????????????????    <1>     conPtr      resq 1    ;Pointer to the current active CON device header 
    26                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
    27 00000090 ????                <1>     maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    28 00000092 ????????????????    <1>     bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    29 0000009A ????????????????    <1>     cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    30 000000A2 ????????????????    <1>     sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    31 000000AA ????                <1>     numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    32 000000AC ??                  <1>     numJoinDrv  resb 1    ;Number of Joined Drives
    33 000000AD <res 22h>           <1>     nulDevHdr   resb drvHdr_size
    34                              <1> 
    35                              <1> ;Start of Swappable Data Area, this bit can remain static
    36 000000CF ??                  <1>     critErrFlag resb 1  ;Critical error flag, set on entry to INT 44h
    37 000000D0 ??                  <1>     inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    38 000000D1 ??                  <1>     errorDrv    resb 1  ;Drive on which error occured or FFh
    39 000000D2 ??                  <1>     errorLocus  resb 1  ;Where the error took place  
    40 000000D3 ????                <1>     errorExt    resw 1  ;Extended Error Code
    41 000000D5 ??                  <1>     errorAction resb 1  ;Suggested action for error  
    42 000000D6 ??                  <1>     errorClass  resb 1  ;Error Class
    43                              <1> 
    44 000000D7 ????????????????    <1>     currentDTA  resq 1  ;Address of the current DTA
    45 000000DF ????????????????    <1>     currentPSP  resq 1  ;Address of current PSP
    46 000000E7 ????????????????    <1>     rdiErrorPtr resq 1  ;Saves RDI value of last error (could make this dx)
    47 000000EF ????????????????    <1>     xInt43hRSP  resq 1  ;Saves RSP across an Int 43h call
    48 000000F7 ????                <1>     lastRetCode resw 1  ;Last return code returned by Int 41h/4Ch
    49 000000F9 ??                  <1>     currentDrv  resb 1  ;Default, last accessed drive
    50 000000FA ??                  <1>     breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    51                              <1> ;SDA, needs to be replaced between processes
    52 000000FB ????????????????    <1>     xInt44hRSP  resq 1  ;RSP across an Int 44h call
    53                              <1> 
    54 00000103 ??                  <1>     Int44RetVal resb 1  ;Saves a copy of the Int 44 return value
    55 00000104 ??                  <1>     Int44bitfld resb 1  ;Copies the bit field given to the Int 44h handler
    56 00000105 ??                  <1>     int48Flag   resb 1  ;If set, Int 48h should be called, if clear no
    57 00000106 ????????????????    <1>     oldoldRSP   resq 1  ;RSP at prev Int 41h entry if called from within Int 41h
    58 0000010E ????????????????    <1>     oldRSP      resq 1  ;RSP when entering Int 41h
    59 00000116 ????????????????    <1>     oldRBX      resq 1  ;Temp var to save value of rbx during an Int 41 call
    60                              <1> ;Time stuff
    61 0000011E ????????????        <1>     CLOCKrecrd  resb 6  ;Clock driver record
    62 00000124 ??                  <1>     dayOfMonth  resb 1  ;01h - 1Fh (1 - 31)
    63 00000125 ??                  <1>     monthOfYear resb 1  ;01h - 0Ch (1 - 12)
    64 00000126 ??                  <1>     years       resb 1  ;00h - FFh (00 = 1980 - 128 = 2107)
    65 00000127 ????                <1>     daysOffset  resw 1  ;Days since 1-1-1980
    66 00000129 ??                  <1>     dayOfWeek   resb 1  ;0 = Sunday <-> 6 = Saturday
    67                              <1> 
    68                              <1> ;Stacks
    69 0000012A <res 528h>          <1>     critStack   resq 165
    70 00000652 ????????????????    <1>     critStakTop resq 1
    71 0000065A <res 638h>          <1>     IOStack     resq 199
    72 00000C92 ????????????????    <1>     IOStakTop   resq 1
    73 00000C9A <res 638h>          <1>     DiskStack   resq 199
    74 000012D2 ????????????????    <1>     DiskStakTop resq 1
    75                              <1>     dSegLen     equ     $
    76                              <1> 
    77                              <1> Segment dynamicDataArea nobits valign=1 vfollows=resSeg
    78                              <1> ;Create SFT header and corresponding array of five default sft entries
    79 00000000 <res Ah>            <1> firstSftHeader  resb sfth_size
    80 0000000A <res 3Dh>           <1> firstSft        resb sft_size
    81 00000047 <res 3Dh>           <1> secondSft       resb sft_size
    82 00000084 <res 3Dh>           <1> thirdSft        resb sft_size
    83 000000C1 <res 3Dh>           <1> fourthSft       resb sft_size
    84 000000FE <res 3Dh>           <1> fifthSft        resb sft_size
    85                              <1> 
    86                              <1> 
    87 0000013B <res 200h>          <1> msdTempBuffer   resb 512    ;Reserve one sectors worth of space
    88                              <1> dynamicDataAreaLength equ $
     8                                  
     9                                  Segment .text align=1
    10                                  ; We arrive here with the following values in the registers.
    11                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    12                                  ; dx  = Int 33h boot device number
    13                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    14                                  tempPSP:    ;Here to allow the loader to use Int 41h once it is loaded high
    15 00000000 55AA                        dw 0AA55h           ;Initial signature
    16 00000002 909090909090909090-         db (100h-2) dup (90h)   ;Duplicate NOPs for the PSP
    16 0000000B 909090909090909090-
    16 00000014 909090909090909090-
    16 0000001D 909090909090909090-
    16 00000026 909090909090909090-
    16 0000002F 909090909090909090-
    16 00000038 909090909090909090-
    16 00000041 909090909090909090-
    16 0000004A 909090909090909090-
    16 00000053 909090909090909090-
    16 0000005C 909090909090909090-
    16 00000065 909090909090909090-
    16 0000006E 909090909090909090-
    16 00000077 909090909090909090-
    16 00000080 909090909090909090-
    16 00000089 909090909090909090-
    16 00000092 909090909090909090-
    16 0000009B 909090909090909090-
    16 000000A4 909090909090909090-
    16 000000AD 909090909090909090-
    16 000000B6 909090909090909090-
    16 000000BF 909090909090909090-
    16 000000C8 909090909090909090-
    16 000000D1 909090909090909090-
    16 000000DA 909090909090909090-
    16 000000E3 909090909090909090-
    16 000000EC 909090909090909090-
    16 000000F5 909090909090909090-
    16 000000FE 9090               
    17 00000100 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    18 00000108 488D15F1FEFFFF              lea rdx, qword [tempPSP]    ;Get the address of the tempPSP
    19 0000010F 6448891425-                 mov qword fs:[currentPSP], rdx
    19 00000114 [DF000000]         
    20                                  ;DOS allows for non-PARA aligned PSPs but DOS aligns all programs on PARA bndry
    21 00000118 B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    22 0000011D 0F32                        rdmsr
    23 0000011F 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    24 00000121 48C1E720                    shl rdi, 20h        ;Shift high
    25 00000125 89C7                        mov edi, eax        ;Get the low dword in
    26                                  
    27 00000127 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    27 0000012C [00000000]         
    28 00000130 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    29 00000133 4881C7[DA120000]            add rdi, dSegLen ;Move destination past end of data area
    30 0000013A 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    31 00000141 B900100000                  mov ecx, 1000h
    32 00000146 F348A5                      rep movsq
    33                                  
    34 00000149 CD31                        int 31h ;Get number of Int 33h devices in r8b
    35 0000014B 6444880425-                 mov byte fs:[numMSDdrv], r8b    ;Save number of physical int 33h devs
    35 00000150 [09000000]         
    36 00000154 64C60425[0B000000]-         mov byte fs:[lastdrvNum], 5     ;Last drive is by default 5
    36 0000015C 05                 
    37 0000015D 64C60425[0A000000]-         mov byte fs:[numLDrives], 0     ;Number of logical drives
    37 00000165 00                 
    38                                  
    39                                  ;Modify the pointers in nData before putting them in the data area
    40 00000166 48012D5F020000              add qword [nData + drvHdr.nxtPtr], rbp
    41 0000016D 48012D62020000              add qword [nData + drvHdr.strPtr], rbp
    42 00000174 48012D63020000              add qword [nData + drvHdr.intPtr], rbp
    43                                  ;Copy the Null driver to its location in Sysvars
    44 0000017B B922000000                  mov ecx, drvHdr_size
    45 00000180 488D3545020000              lea rsi, qword [nData]
    46 00000187 488DBD[AD000000]            lea rdi, qword [rbp + nulDevHdr]
    47 0000018E F3A4                        rep movsb   
    48                                  
    49                                  ;Adjust the addresses in the other driver headers 
    50 00000190 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    50 00000192 [C608000000000000] 
    51 0000019A B90C000000                  mov ecx, 12      ;12 drivers in data area
    52 0000019F 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    53                                  adjDrivers:
    54 000001A3 E8AB010000                  call adjustDrvHdr
    55 000001A8 E2F9                        loop adjDrivers
    56                                  
    57                                      ;Open NUL
    58 000001AA 488D9D[B7000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    59 000001B1 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    60 000001B4 30C0                        xor al, al
    61 000001B6 FFD3                        call rbx
    62                                  
    63                                  ;Open CON
    64                                  conInit:    ;Rather than keeping this resident... do it here
    65                                  .ci0:
    66 000001B8 B401                        mov ah, 01      ;Get buffer status
    67 000001BA CD36                        int 36h
    68 000001BC 7406                        jz .ci1      ;If zero clear => no more keys to read
    69 000001BE 30E4                        xor ah, ah
    70 000001C0 CD36                        int 36h ;Read key to flush from buffer
    71 000001C2 EBF4                        jmp short .ci0
    72                                  .ci1:
    73 000001C4 B800050000                  mov eax, 0500h  ;Set page zero as the default page
    74 000001C9 CD30                        int 30h
    75 000001CB B402                        mov ah, 02h
    76 000001CD 31D2                        xor edx, edx    ;Set screen cursor to top right corner
    77 000001CF 88D7                        mov bh, dl      ;Set cursor for page 0
    78 000001D1 CD30                        int 30h
    79 000001D3 B707                        mov bh, 07h     ;Grey/Black attribs
    80 000001D5 B800060000                  mov eax, 0600h  ;Clear whole screen
    81 000001DA CD30                        int 30h
    82                                  
    83                                      ;Open Mass Storage
    84 000001DC 488D9D[36000000]            lea rbx, qword [rbp + diskReqHdr]
    85 000001E3 C6031F                      mov byte [rbx + initReqPkt.hdrlen], initReqPkt_size
    86 000001E6 C6430200                    mov byte [rbx + initReqPkt.cmdcde], 00h     ;MSD init
    87 000001EA 66C743030000                mov word [rbx + initReqPkt.status], 0       ;Zero status word
    88 000001F0 648A0425[0A000000]          mov al, byte fs:[numLDrives]
    89 000001F8 88431E                      mov byte [rbx + initReqPkt.drvnum], al      ;First unit is drive A
    90 000001FB FF95[58090000]              call qword [rbp + msdHdr + drvHdr.strPtr]
    91 00000201 FF95[60090000]              call qword [rbp + msdHdr + drvHdr.intPtr]
    92                                  
    93                                  ;Adjust Int 41h address table
    94                                  adjInt41h:
    95 00000207 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
    96 0000020C 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
    96 0000020E [AB02000000000000] 
    97 00000216 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
    98                                  .ai41h:
    99 0000021B 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
   100 0000021E 4881C308000000              add rbx, 8              ;Each entry is size 8
   101 00000225 FFC9                        dec ecx
   102 00000227 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
   103                                  
   104                                  ;Adjust Interrupt Entries Int 40h-49h
   105                                  adjInts:
   106 00000229 B340                        mov bl, 40h
   107 0000022B B807F00000                  mov eax, 0F007h ;Get the descriptor
   108 00000230 CD35                        int 35h
   109 00000232 B940000000                  mov ecx, 40h    ;Start from interrupt 40h
   110 00000237 488D3D3E010000              lea rdi, intData
   111 0000023E 89C6                        mov esi, eax    ;Move segment selector info to esi
   112                                  .ai0:
   113 00000240 B808F00000                  mov eax, 0F008h ;Set the descriptor
   114 00000245 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
   115 00000248 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
   116 0000024B CD35                        int 35h
   117 0000024D 4881C708000000              add rdi, 8
   118 00000254 FFC1                        inc ecx
   119 00000256 81F94A000000                cmp ecx, 4Ah
   120 0000025C 75E2                        jne .ai0
   121                                  
   122                                  ;Fill in the default file table entries
   123                                      ;lea rbx, qword [rbp + firstSftHeader]
   124                                      ;mov qword [rbx + sfth.qNextSFTPtr], -1  ;Last sfth in chain
   125                                      ;mov word [rbx + sfth.wNumFiles], 5      ;5 default files
   126                                      ;mov qword fs:[sftHeadPtr], rbx  ;Save ptr to this sft header in SysVars
   127                                  
   128                                      ;lea rbx, qword [rbp + firstSft]
   129                                      ;mov word [rbx + sft.wNumHandles], 0 ;Nothing pointing to this file yet
   130                                      ;mov word [rbx + sft.w]
   131                                  
   132                                  
   133                                  ;Test Error Case
   134                                      ;mov ah, 00110000b
   135                                      ;mov al, 00h
   136                                      ;mov edi, 0Ch
   137                                      ;int 44h
   138                                  
   139 0000025E 488D1501010000              lea rdx, qword [startmsg]   ;Get the absolute address of message
   140 00000265 B409                        mov ah, 09h
   141 00000267 CD41                        int 41h
   142                                  
   143 00000269 64488B3425-                 mov rsi, fs:[nulDevHdr]
   143 0000026E [AD000000]         
   144 00000272 B801C50000                  mov eax, 0C501h ;Connect debugger
   145 00000277 CD35                        int 35h
   146                                  l1:
   147 00000279 B401                        mov ah, 01h  ;Write with echo
   148 0000027B CD41                        int 41h
   149 0000027D 3C00                        cmp al, 0
   150 0000027F 7402                        je l2
   151 00000281 EBF6                        jmp short l1
   152                                  l2:
   153 00000283 B407                        mov ah, 07h
   154 00000285 CD41                        int 41h
   155 00000287 3C42                        cmp al, 42h
   156 00000289 75EE                        jne l1
   157                                  l3:
   158 0000028B 6466C70425-                 mov word fs:[CLOCKrecrd + clkStruc.dateWord], 0
   158 00000290 [1E010000]0000     
   159 00000296 488D9D[0C000000]            lea rbx, qword [rbp + charReqHdr] ;Get the address of this request block
   160 0000029D 488D85[1E010000]            lea rax, qword [rbp + CLOCKrecrd]
   161 000002A4 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   162 000002A7 C6430204                    mov byte [rbx + ioReqPkt.cmdcde], 04h   ;Read the time
   163 000002AB 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   164 000002B1 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   165 000002B5 C7431606000000              mov dword [rbx + ioReqPkt.tfrlen], 06
   166 000002BC FF95[36090000]              call qword [rbp + clkHdr + drvHdr.strPtr]
   167 000002C2 FF95[3E090000]              call qword [rbp + clkHdr + drvHdr.intPtr]
   168                                  
   169 000002C8 B403                        mov ah, 03h
   170 000002CA 30FF                        xor bh, bh
   171 000002CC CD30                        int 30h
   172 000002CE 30D2                        xor dl, dl  ;0 column
   173 000002D0 B402                        mov ah, 02h
   174 000002D2 CD30                        int 30h
   175                                  
   176 000002D4 488D9D[1E010000]            lea rbx, qword [rbp + CLOCKrecrd]
   177 000002DB 0FB64303                    movzx eax, byte [rbx + clkStruc.hours]
   178 000002DF E832000000                  call .clkHexToBCD
   179 000002E4 B40E                        mov ah, 0Eh
   180 000002E6 B03A                        mov al, ":"
   181 000002E8 CD30                        int 30h
   182 000002EA 0FB64302                    movzx eax, byte [rbx + clkStruc.minutes]
   183 000002EE E823000000                  call .clkHexToBCD
   184 000002F3 B40E                        mov ah, 0Eh
   185 000002F5 B03A                        mov al, ":"
   186 000002F7 CD30                        int 30h
   187 000002F9 0FB64305                    movzx eax, byte [rbx + clkStruc.seconds]
   188 000002FD E814000000                  call .clkHexToBCD
   189 00000302 B40E                        mov ah, 0Eh
   190 00000304 B02E                        mov al, "."
   191 00000306 CD30                        int 30h
   192 00000308 0FB64304                    movzx eax, byte [rbx + clkStruc.hseconds]
   193 0000030C E805000000                  call .clkHexToBCD
   194 00000311 E963FFFFFF                  jmp l1
   195                                  .clkHexToBCD:
   196                                  ;Converts a Hex byte into two BCD digits
   197                                  ;Takes input in each nybble of al
   198 00000316 53                          push rbx
   199                                      ;xchg bx, bx
   200 00000317 48BB0A000000000000-         mov rbx, 0Ah  ;Divide by 10
   200 00000320 00                 
   201 00000321 31D2                        xor edx, edx
   202 00000323 48F7F3                      div rbx
   203 00000326 80C230                      add dl, '0'
   204 00000329 80FA39                      cmp dl, '9'
   205 0000032C 7603                        jbe .chtb0
   206 0000032E 80C207                      add dl, 'A'-'0'-10
   207                                  .chtb0:
   208 00000331 88D1                        mov cl, dl    ;Save remainder byte
   209 00000333 31D2                        xor edx, edx
   210 00000335 48F7F3                      div rbx
   211 00000338 80C230                      add dl, '0'
   212 0000033B 80FA39                      cmp dl, '9'
   213 0000033E 7603                        jbe .chtb1
   214 00000340 80C207                      add dl, 'A'-'0'-10
   215                                  .chtb1:
   216 00000343 88D5                        mov ch, dl    ;Save remainder byte
   217                                  
   218 00000345 88E8                        mov al, ch    ;Get most sig digit into al
   219 00000347 B40E                        mov ah, 0Eh
   220 00000349 CD30                        int 30h
   221 0000034B 88C8                        mov al, cl    ;Get least sig digit into al
   222 0000034D B40E                        mov ah, 0Eh
   223 0000034F CD30                        int 30h
   224 00000351 5B                          pop rbx
   225 00000352 C3                          ret
   226                                  
   227                                  adjustDrvHdr:
   228                                  ;Input: rsi = Effective address of driver in DOS segment
   229                                  ;       rbp = Ptr to the start of the DOS segment
   230                                  ;Output: rsi = EA of next header in DOS segment
   231 00000353 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   232 00000356 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   233 0000035A 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   234 0000035E 4881C622000000              add rsi, drvHdr_size
   235 00000365 C3                          ret
   236 00000366 5374617274696E6720-     startmsg db "Starting SCP/DOS...",0Ah,0Dh,"$"
   236 0000036F 5343502F444F532E2E-
   236 00000378 2E0A0D24           
   237                                  intData:
   238 0000037C [5900000000000000]          dq terminateProcess ;Int 40h
   239 00000384 [5900000000000000]          dq functionDispatch ;Int 41h
   240 0000038C [FB05000000000000]          dq terminateHandler ;Int 42h
   241 00000394 [FB05000000000000]          dq ctrlCHandler     ;Int 43h
   242 0000039C [FB05000000000000]          dq critErrorHandler ;Int 44h
   243 000003A4 [8E08000000000000]          dq absDiskRead      ;Int 45h
   244 000003AC [A308000000000000]          dq absDiskWrite     ;Int 46h
   245 000003B4 [B808000000000000]          dq terminateResident    ;Int 47h
   246 000003BC [B808000000000000]          dq inDosHandler     ;Int 48h
   247 000003C4 [BA08000000000000]          dq fastOutput       ;Int 49h
   248                                  nData:
   249 000003CC [C608000000000000]          dq conHdr
   250 000003D4 0480                        dw 08004h
   251 000003D6 [6E0A000000000000]          dq nulStrat
   252 000003DE [740A000000000000]          dq nulIntr
   253 000003E6 4E554C2020202020            db "NUL     " ;Default NUL data
   254                                  
   255                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   256                                  ;-----------------------------------:
   257                                  ;       Misc System routines        :
   258                                  ;-----------------------------------:
   259                                  findLRUBuffer: 
   260                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   261                                  ;Input: Nothing
   262                                  ;Output: rbx = Pointer to the buffer to use
   263 00000000 52                          push rdx
   264 00000001 488B1D(92000000)            mov rbx, qword [bufHeadPtr]
   265 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   266 0000000F 7502                        jne .flb1
   267 00000011 5A                          pop rdx
   268 00000012 C3                          ret
   269                                  .flb1:
   270 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   271 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   272 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   273 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   274 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   275 00000029 488B15(92000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   276 00000030 48891D(92000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   277 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   278 0000003A 5A                          pop rdx
   279 0000003B C3                          ret
   280                                  
   281                                  findDPB:
   282                                  ;Finds the DPB for a given drive
   283                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   284                                  ;Output: al = 00, rbx = Pointer to the DPB
   285                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   286 0000003C 488B1D(70000000)            mov rbx, qword [dpbHeadPtr]
   287                                  .fd1:
   288 00000043 30C0                        xor al, al
   289 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   290 00000047 740F                        je .fd2
   291 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   292 0000004D B0FF                        mov al, -1
   293 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   294 00000056 75EB                        jne .fd1
   295                                  .fd2:
   296 00000058 C3                          ret
   297                                  callCritError:
   298                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   299                                  ;-----------------------------------:
   300                                  ;       File System routines        :
   301                                  ;-----------------------------------:
   302                                  name2Clust:
   303                                  ;Converts a file name to a first cluster number
   304                                  ;-----------------------------------:
   305                                  ;        Interrupt routines         :
   306                                  ;-----------------------------------:
   307                                  terminateProcess:   ;Int 40h
   308                                  
   309                                  functionDispatch:   ;Int 41h Main function dispatcher
   310                                  ;ah = Function number, all other registers have various meanings
   311 00000059 FA                          cli ;Halt external interrupts
   312 0000005A FC                          cld ;Ensure all string ops occur in the right direction
   313 0000005B 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   314 0000005E 0F871E010000                ja .fdExitBad
   315                                      ;Cherry pick functions
   316 00000064 80FC33                      cmp ah, 33h ;CTRL+BREAK check
   317 00000067 722C                        jb .fsbegin   ;If below skip these checks
   318 00000069 0F843B020000                je .ctrlBreakCheck
   319 0000006F 80FC64                      cmp ah, 64h
   320 00000072 0F8432020000                je .setDriverLookahead  ;Reserved, but avoids usual Int 41h spiel
   321 00000078 771B                        ja .fsbegin   ;If above, do usual Int41 entry
   322 0000007A 80FC51                      cmp ah, 51h
   323 0000007D 0F8427020000                je .getCurrProcessID    ;This an below are exactly the same
   324 00000083 80FC62                      cmp ah, 62h
   325 00000086 0F841E020000                je .getPSPaddr          ;Calls the above function
   326 0000008C 80FC50                      cmp ah, 50h
   327 0000008F 0F8415020000                je .setCurrProcessID
   328                                  .fsbegin:
   329                                      pushDOS ;Push the usual prologue registers
   192 00000095 4151                <1>  push r9
   193 00000097 4150                <1>  push r8
   194 00000099 55                  <1>  push rbp
   195 0000009A 57                  <1>  push rdi
   196 0000009B 56                  <1>  push rsi
   197 0000009C 52                  <1>  push rdx
   198 0000009D 51                  <1>  push rcx
   199 0000009E 53                  <1>  push rbx
   200 0000009F 50                  <1>  push rax
   330 000000A0 488B05(0E010000)            mov rax, qword [oldRSP]
   331 000000A7 488905(06010000)            mov qword [oldoldRSP], rax
   332 000000AE FE05(D0000000)              inc byte [inDOS]    ;Increment in DOS flag
   333 000000B4 488925(0E010000)            mov qword [oldRSP], rsp
   334                                  ;Here, we want to save oldRSP in the callers PSP
   335 000000BB 803D(D0000000)01            cmp byte [inDOS], 1 ;Check how many times we are in DOS
   336 000000C2 750B                        jne .fsb1   ;If this is first entry, save rsp in callers PSP
   337 000000C4 488B05(DF000000)            mov rax, qword [currentPSP] ;Get current PSP address
   338 000000CB 48896046                    mov qword [rax + psp.rspPtr], rsp    ;Save rsp on callers stack
   339                                  .fsb1:
   340 000000CF 58                          pop rax     ;Get old rax back
   341 000000D0 50                          push rax    ;and push it back onto the stack
   342 000000D1 488D25(52060000)            lea rsp, critStakTop
   343 000000D8 FB                          sti         ;Reenable interrupts
   344                                  
   345 000000D9 C605(05010000)01            mov byte [int48Flag], 1 ;Make it ok to trigger Int 48h
   346                                  
   347 000000E0 48891D(16010000)            mov qword [oldRBX], rbx ;Need to do this as I might switch stacks later
   348 000000E7 0FB6DC                      movzx ebx, ah   ;Move the function number bl zero extended to rbx
   349 000000EA C1E303                      shl ebx, 3      ;Multiply the function number by 8 for offset into table
   350 000000ED 50                          push rax        ;Push rax onto the stack
   351 000000EE 488D05B6010000              lea rax, qword [.dispatchTable]
   352 000000F5 4801C3                      add rbx, rax    ;Add dispatch table offset into rbx
   353 000000F8 58                          pop rax
   354 000000F9 488B1B                      mov rbx, qword [rbx]    ;Get the address from the dispatch table
   355                                  
   356 000000FC 84E4                        test ah, ah     ;Simple Terminate function?
   357 000000FE 741C                        jz .fddiskOp
   358 00000100 80FC59                      cmp ah, 59h     ;Extended Error report?
   359 00000103 7443                        je .fdGoToFunction  ;Bypass code that clears the error report
   360 00000105 80FC0C                      cmp ah, 0Ch     ;Are we a char function?
   361 00000108 7712                        ja .fddiskOp
   362                                  ;Char operations here
   363 0000010A F605(CF000000)01            test byte [critErrFlag], 1  ;Are we in critical error?
   364 00000111 7535                        jnz .fdGoToFunction         ;If we are, stay on Critical Error Stack
   365 00000113 488D25(920C0000)            lea rsp, IOStakTop          ;Otherwise, switch to IO stack
   366 0000011A EB2C                        jmp short .fdGoToFunction
   367                                  .fddiskOp:
   368                                      ;Disk operations go here
   369                                      ;Clear up error info
   370 0000011C C605(D2000000)01            mov byte [errorLocus], 1    ;Reset to generic, unknown locus
   371 00000123 C605(CF000000)00            mov byte [critErrFlag], 0   ;Clear the Critical Error Flag
   372 0000012A C605(D1000000)FF            mov byte [errorDrv], -1     ;Set the drive which caused the error to none
   373                                  
   374 00000131 C605(05010000)00            mov byte [int48Flag], 0     ;Turn off the ability to trigger Int 48h
   375 00000138 488D25(D2120000)            lea rsp, DiskStakTop        ;Swap the stack to the Disk Transfer Stack
   376 0000013F F605(FA000000)FF            test byte [breakFlag], -1   ;Test if set
   377 00000146 7400                        jz .fdGoToFunction
   378                                  ; HANDLE CTRL+BREAK HERE!
   379                                  .fdGoToFunction:
   380 00000148 48871D(16010000)            xchg rbx, qword [oldRBX]    ;Put the call addr in oldRBX and get oldRBX back
   381                                      ;Potentially point rbp to caller reg frame for easy access of registers 
   382                                      ;mov rbp, qword [oldRSP]    ;Move rsp on entry into rbp
   383 0000014F FF15(16010000)              call qword [oldRBX]     ;Call the desired function, rax contains ret code
   384                                  .fdExit:
   385 00000155 FA                          cli     ;Redisable interrupts
   386                                      ;???
   387 00000156 FE0D(D0000000)              dec byte [inDOS]            ;Decrement the inDOS count
   388 0000015C 488B25(0E010000)            mov rsp, qword [oldRSP]     ;Point rsp to old stack
   389 00000163 48890424                    mov qword [rsp], rax    ;Put the ret code into its pos on the register frame
   390 00000167 488B05(06010000)            mov rax, qword [oldoldRSP]
   391 0000016E 488905(0E010000)            mov qword [oldRSP], rax
   392                                      popDOS  ;Pop the frame
   204 00000175 58                  <1>  pop rax
   205 00000176 5B                  <1>  pop rbx
   206 00000177 59                  <1>  pop rcx
   207 00000178 5A                  <1>  pop rdx
   208 00000179 5E                  <1>  pop rsi
   209 0000017A 5F                  <1>  pop rdi
   210 0000017B 5D                  <1>  pop rbp
   211 0000017C 4158                <1>  pop r8
   212 0000017E 4159                <1>  pop r9
   393 00000180 48CF                        iretq
   394                                  .fdExitBad:
   395 00000182 B400                        mov ah, 0
   396 00000184 48CF                        iretq
   397                                  .simpleTerminate:     ;ah = 00h
   398 00000186 C3                          ret
   399                                  .stdinReadEcho:     ;ah = 01h
   400 00000187 488D1D(0C000000)            lea rbx, charReqHdr ;Get the address of this request block
   401 0000018E 488D0566000000              lea rax, .stdinReadEchoBuffer
   402 00000195 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   403 00000198 C6430204                    mov byte [rbx + ioReqPkt.cmdcde], 04h   ;Read a byte
   404 0000019C 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   405 000001A2 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   406 000001A6 C7431601000000              mov dword [rbx + ioReqPkt.tfrlen], 01
   407 000001AD FF151D070000                call qword [conHdr + drvHdr.strPtr]
   408 000001B3 FF151F070000                call qword [conHdr + drvHdr.intPtr]
   409 000001B9 803D3B00000000              cmp byte [.stdinReadEchoBuffer], 00h
   410 000001C0 7432                        jz .stdireexit
   411 000001C2 488D1D(0C000000)            lea rbx, charReqHdr ;Get the address of this request block
   412 000001C9 488D052B000000              lea rax, .stdinReadEchoBuffer
   413 000001D0 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   414 000001D3 C6430208                    mov byte [rbx + ioReqPkt.cmdcde], 08h   ;Write a byte
   415 000001D7 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   416 000001DD 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   417 000001E1 C7431601000000              mov dword [rbx + ioReqPkt.tfrlen], 01
   418 000001E8 FF15E2060000                call qword [conHdr + drvHdr.strPtr]
   419 000001EE FF15E4060000                call qword [conHdr + drvHdr.intPtr]
   420                                  .stdireexit:
   421 000001F4 8A0501000000                mov al, byte [.stdinReadEchoBuffer]
   422 000001FA C3                          ret
   423 000001FB 00                      .stdinReadEchoBuffer    db 0
   424                                  .stdoutWrite:       ;ah = 02h
   425                                  ;Bspace is regular cursor left, does not insert a blank
   426 000001FC 881533000000                mov byte [.stdoutWriteBuffer], dl
   427 00000202 488D1D(0C000000)            lea rbx, charReqHdr ;Get the address of this request block
   428 00000209 488D0525000000              lea rax, .stdoutWriteBuffer
   429 00000210 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   430 00000213 C6430208                    mov byte [rbx + ioReqPkt.cmdcde], 08h   ;Write a byte
   431 00000217 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   432 0000021D 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   433 00000221 C7431601000000              mov dword [rbx + ioReqPkt.tfrlen], 01
   434 00000228 FF15A2060000                call qword [conHdr + drvHdr.strPtr]
   435 0000022E FF15A4060000                call qword [conHdr + drvHdr.intPtr]
   436 00000234 C3                          ret
   437 00000235 00                      .stdoutWriteBuffer db 0
   438                                  .stdauxRead:        ;ah = 03h
   439                                  .stdauxWrite:       ;ah = 04h
   440                                  .stdprnWrite:       ;ah = 05h
   441                                  .directCONIO:       ;ah = 06h
   442                                  .waitDirectInNoEcho:;ah = 07h
   443 00000236 488D1D(0C000000)            lea rbx, charReqHdr ;Get the address of this request block
   444 0000023D 488D052B000000              lea rax, .function7buffer
   445 00000244 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   446 00000247 C6430204                    mov byte [rbx + ioReqPkt.cmdcde], 04h   ;Read a byte
   447 0000024B 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   448 00000251 4889430E                    mov qword [rbx + ioReqPkt.bufptr], rax
   449 00000255 C7431601000000              mov dword [rbx + ioReqPkt.tfrlen], 01
   450 0000025C FF156E060000                call qword [conHdr + drvHdr.strPtr]
   451 00000262 FF1570060000                call qword [conHdr + drvHdr.intPtr]
   452 00000268 8A0501000000                mov al, byte [.function7buffer]
   453 0000026E C3                          ret
   454 0000026F 00                      .function7buffer    db 0
   455                                  .waitStdinNoEcho:   ;ah = 08h
   456 00000270 C3                          ret
   457                                  .printString:       ;ah = 09h
   458 00000271 31C9                        xor ecx, ecx    ;Clear char counter
   459 00000273 B824000000                  mov eax, "$"    ;Terminating char
   460 00000278 4889D7                      mov rdi, rdx    ;Set up for scasb
   461                                  .ps0:   ;Search for $ to get count of chars
   462 0000027B AE                          scasb
   463 0000027C 7404                        je .ps1
   464 0000027E FFC1                        inc ecx
   465 00000280 EBF9                        jmp short .ps0
   466                                  .ps1:   ;Use handle 
   467 00000282 488D1D(0C000000)            lea rbx, charReqHdr ;Get the address of this request block
   468 00000289 C6032A                      mov byte [rbx + ioReqPkt.hdrlen], ioReqPkt_size
   469 0000028C C6430208                    mov byte [rbx + ioReqPkt.cmdcde], 08h   ;Write a byte
   470 00000290 66C743030000                mov word [rbx + ioReqPkt.status], 0 ;Zero status word
   471 00000296 4889530E                    mov qword [rbx + ioReqPkt.bufptr], rdx
   472 0000029A 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx
   473 0000029D FF152D060000                call qword [conHdr + drvHdr.strPtr]
   474 000002A3 FF152F060000                call qword [conHdr + drvHdr.intPtr]
   475 000002A9 C3                          ret
   476                                  .buffStdinInput:    ;ah = 0Ah
   477                                  .checkStdinStatus:  ;ah = 0Bh
   478                                  .clearbuffDoFunc:   ;ah = 0Ch
   479                                  .diskReset:         ;ah = 0Dh
   480                                  .selectDisk:        ;ah = 0Eh
   481                                  .openFileFCB:       ;ah = 0Fh
   482                                  .closeFileFCB:      ;ah = 10h
   483                                  .findFirstFileFCB:  ;ah = 11h
   484                                  .findNextFileFCB:   ;ah = 12h
   485                                  .deleteFileFCB:     ;ah = 13h
   486                                  .sequentialReadFCB: ;ah = 14h
   487                                  .sequentialWriteFCB:;ah = 15h
   488                                  .createFileFCB:     ;ah = 16h
   489                                  .renameFileFCB:     ;ah = 17h
   490                                                      ;ah = 18h unused
   491                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   492                                  .setDTA:            ;ah = 1Ah
   493                                  .FATinfoDefault:    ;ah = 1Bh
   494                                  .FatinfoDevice:     ;ah = 1Ch
   495                                                      ;ah = 1Dh unused
   496                                                      ;ah = 1Eh unused
   497                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   498                                                      ;ah = 20h unused
   499                                  .randomReadFCB:     ;ah = 21h
   500                                  .randomWriteFCB:    ;ah = 22h
   501                                  .getFileSizeFCB:    ;ah = 23h
   502                                  .setRelRecordFCB:   ;ah = 24h
   503                                  .setIntVector:      ;ah = 25h
   504                                  .createNewPSP:      ;ah = 26h
   505                                  .randBlockReadFCB:  ;ah = 27h
   506                                  .randBlockWriteFCB: ;ah = 28h
   507                                  .parseFilenameFCB:  ;ah = 29h
   508                                  .getDate:           ;ah = 2Ah
   509                                  .setDate:           ;ah = 2Bh
   510                                  .getTime:           ;ah = 2Ch
   511                                  .setTime:           ;ah = 2Dh
   512                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   513                                  .getDTA:            ;ah = 2Fh
   514                                  .getDOSversion:     ;ah = 30h
   515                                  .terminateStayRes:  ;ah = 31h
   516                                  .getDeviceDPBptr:   ;ah = 32h
   517                                  .ctrlBreakCheck:    ;ah = 33h
   518                                  .getInDOSflagPtr:   ;ah = 34h
   519                                  .getIntVector:      ;ah = 35h
   520                                  .getDiskFreeSpace:  ;ah = 36h
   521                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   522                                  .getsetCountryInfo: ;ah = 38h, localisation info
   523                                  .makeDIR:           ;ah = 39h
   524                                  .removeDIR:         ;ah = 3Ah
   525                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   526                                  .createFileHdl:     ;ah = 3Ch, handle function
   527                                  .openFileHdl:       ;ah = 3Dh, handle function
   528                                  .closeFileHdl:      ;ah = 3Eh, handle function
   529                                  .readFileHdl:       ;ah = 3Fh, handle function
   530                                  .writeFileHdl:      ;ah = 40h, handle function
   531                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   532                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   533                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   534                                  .ioctrl:            ;ah = 44h, handle function
   535                                  .duplicateHandle:   ;ah = 45h, handle function
   536                                  .forceDuplicateHdl: ;ah = 46h, handle function
   537                                  .getCurrentDIR:     ;ah = 47h
   538                                  .allocateMemory:    ;ah = 48h
   539                                  .freeMemory:        ;ah = 49h
   540                                  .reallocMemory:     ;ah = 4Ah
   541                                  .loadExecChild:     ;ah = 4Bh, EXEC
   542                                  .terminateClean:    ;ah = 4Ch, EXIT
   543                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   544                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   545                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   546                                  .setCurrProcessID:  ;ah = 50h, set current process ID (Set current PSP)
   547                                  .getCurrProcessID:  ;ah = 51h, get current process ID (Get current PSP)
   548                                  .getSysVarsPtr:     ;ah = 52h
   549                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   550                                  .getVerifySetting:  ;ah = 54h
   551                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   552                                  .renameFile:        ;ah = 56h
   553                                  .getSetFileDateTime:;ah = 57h
   554                                  .getsetMallocStrat: ;ah = 58h
   555                                  .getExtendedError:  ;ah = 59h
   556                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   557                                  .createNewFile:     ;ah = 5Bh
   558                                  .lockUnlockFile:    ;ah = 5Ch
   559                                  .getCritErrorInfo:  ;ah = 5Dh
   560                                  .networkServices:   ;ah = 5Eh, do nothing
   561                                  .networkRedirection:;ah = 5Fh, do nothing
   562                                  .trueName:          ;ah = 60h, get fully qualified name
   563                                                      ;ah = 61h, reserved
   564                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   565                                                      ;ah = 63h, reserved
   566                                  .setDriverLookahead:;ah = 64h, reserved
   567                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   568                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   569                                  .setHandleCount:    ;ah = 67h
   570                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   571                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   572                                  .return:
   573 000002AA C3                          ret
   574                                  
   575                                  
   576                                  .dispatchTable:
   577 000002AB [8601000000000000]          dq .simpleTerminate     ;AH = 00H, PROCESS MANAGEMENT
   578 000002B3 [8701000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   579 000002BB [FC01000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   580 000002C3 [3602000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   581 000002CB [3602000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   582 000002D3 [3602000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   583 000002DB [3602000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   584 000002E3 [3602000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   585 000002EB [7002000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   586 000002F3 [7102000000000000]          dq .printString         ;AH = 09H, CHAR IO
   587 000002FB [AA02000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   588 00000303 [AA02000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   589 0000030B [AA02000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   590 00000313 [AA02000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   591 0000031B [AA02000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   592 00000323 [AA02000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   593 0000032B [AA02000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   594 00000333 [AA02000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   595 0000033B [AA02000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   596 00000343 [AA02000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   597 0000034B [AA02000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   598 00000353 [AA02000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   599 0000035B [AA02000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   600 00000363 [AA02000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   601 0000036B [AA02000000000000]          dq .return              ;AH = 18H, RESERVED
   602 00000373 [AA02000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   603 0000037B [AA02000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   604 00000383 [AA02000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   605 0000038B [AA02000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   606 00000393 [AA02000000000000]          dq .return              ;AH = 1DH, RESERVED
   607 0000039B [AA02000000000000]          dq .return              ;AH = 1EH, RESERVED
   608 000003A3 [AA02000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   609 000003AB [AA02000000000000]          dq .return              ;AH = 20H, RESERVED
   610 000003B3 [AA02000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   611 000003BB [AA02000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   612 000003C3 [AA02000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   613 000003CB [AA02000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   614 000003D3 [AA02000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   615 000003DB [AA02000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   616 000003E3 [AA02000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   617 000003EB [AA02000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   618 000003F3 [AA02000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   619 000003FB [AA02000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   620 00000403 [AA02000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   621 0000040B [AA02000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   622 00000413 [AA02000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   623 0000041B [AA02000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   624 00000423 [AA02000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   625 0000042B [AA02000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   626 00000433 [AA02000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   627 0000043B [AA02000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   628 00000443 [AA02000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   629 0000044B [AA02000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   630 00000453 [AA02000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   631 0000045B [AA02000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   632 00000463 [AA02000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   633 0000046B [AA02000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   634 00000473 [AA02000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   635 0000047B [AA02000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   636 00000483 [AA02000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   637 0000048B [AA02000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   638 00000493 [AA02000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   639 0000049B [AA02000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   640 000004A3 [AA02000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   641 000004AB [AA02000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   642 000004B3 [AA02000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   643 000004BB [AA02000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   644 000004C3 [AA02000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   645 000004CB [AA02000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   646 000004D3 [AA02000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   647 000004DB [AA02000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   648 000004E3 [AA02000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   649 000004EB [AA02000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   650 000004F3 [AA02000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   651 000004FB [AA02000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   652 00000503 [AA02000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   653 0000050B [AA02000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   654 00000513 [AA02000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   655 0000051B [AA02000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   656 00000523 [AA02000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   657 0000052B [AA02000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   658 00000533 [AA02000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   659 0000053B [AA02000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   660 00000543 [AA02000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   661 0000054B [AA02000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   662 00000553 [AA02000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   663 0000055B [AA02000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   664 00000563 [AA02000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   665 0000056B [AA02000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   666 00000573 [AA02000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   667 0000057B [AA02000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   668 00000583 [AA02000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   669 0000058B [AA02000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   670 00000593 [AA02000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   671 0000059B [AA02000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   672 000005A3 [AA02000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   673 000005AB [AA02000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   674 000005B3 [AA02000000000000]          dq .return              ;AH = 61H, RESERVED
   675 000005BB [AA02000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   676 000005C3 [AA02000000000000]          dq .return              ;AH = 63H, RESERVED
   677 000005CB [AA02000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   678 000005D3 [AA02000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   679 000005DB [AA02000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   680 000005E3 [AA02000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   681 000005EB [AA02000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   682 000005F3 [AA02000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   683                                  dispatchTableL  equ $ - .dispatchTable 
   684                                  
   685                                  terminateHandler:   ;Int 42h
   686                                  ctrlCHandler:       ;Int 43h
   687                                  critErrorHandler:   ;Int 44h
   688                                  ;User Stack in usage here, must be swapped to before this is called
   689                                  ;Entered with:  
   690                                  ;               AH = Critical Error Bitfield
   691                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   692                                  ;               Bit 6 - Reserved
   693                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   694                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   695                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   696                                  ;               Bits [2-1] = Affected Disk Error
   697                                  ;                     0 0   DOS area
   698                                  ;                     0 1   FAT area
   699                                  ;                     1 0   Directory area
   700                                  ;                     1 1   Data area
   701                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   702                                  ;               AL  = Failing drive number if AH[7] = 0
   703                                  ;               DIL = Error code for errorMsg
   704                                  ;               RSI = EA of Device Header for which device the error occured
   705                                  ;Return:
   706                                  ;               AL = 0 - Ignore the Error       (Ignore)
   707                                  ;                  = 1 - Retry the Operation    (Retry)
   708                                  ;                  = 2 - Terminate the Program  (Abort)
   709                                  ;                  = 3 - Fail the DOS call      (Fail)
   710 000005FB 53                          push rbx
   711 000005FC 51                          push rcx
   712 000005FD 52                          push rdx
   713 000005FE 57                          push rdi
   714 000005FF 56                          push rsi
   715 00000600 FC                          cld         ;Make String ops go forward
   716                                  
   717 00000601 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   718 00000604 488D155E020000              lea rdx, qword [.crlf]
   719 0000060B B409                        mov ah, 09h ;Print String
   720 0000060D CD41                        int 41h     ;Call DOS to print CRLF part of message
   721                                  
   722 0000060F 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   723 00000615 B90C000000                  mov ecx, 0Ch
   724 0000061A 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   725 0000061C 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   726 0000061F 480FB7FF                    movzx rdi, di
   727 00000623 4889FA                      mov rdx, rdi    ;Copy error code
   728 00000626 48C1E704                    shl rdi, 4  ;Multiply by 16
   729 0000062A 48D1E2                      shl rdx, 1  ;Multiply by 2
   730 0000062D 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   731 00000630 488D1523010000              lea rdx, qword [.errorMsgTable]
   732 00000637 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   733 0000063B B409                        mov ah, 09h ;Print String
   734 0000063D CD41                        int 41h     ;Call DOS to print first part of message
   735                                  
   736 0000063F 488D1505020000              lea rdx, qword [.readmsg]
   737 00000646 488D3D0D020000              lea rdi, qword [.writemsg]
   738 0000064D F6C701                      test bh, 1  ;Bit 0 is set if write operation
   739 00000650 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   740 00000654 B409                        mov ah, 09h ;Print String
   741 00000656 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   742                                  
   743 00000658 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   744 0000065B 0F85DF000000                jnz .charError
   745                                  ;Disk error continues here
   746 00000661 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   747 00000668 B409                        mov ah, 09h
   748 0000066A CD41                        int 41h
   749 0000066C 88DA                        mov dl, bl  ;Get zero based drive number into dl
   750 0000066E 80C241                      add dl, "A" ;Add ASCII code
   751 00000671 B402                        mov ah, 02h ;Print char in dl
   752 00000673 CD41                        int 41h
   753                                  .userInput:
   754 00000675 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   755 0000067C B409                        mov ah, 09h
   756 0000067E CD41                        int 41h
   757                                  ;Abort, Retry, Ignore, Fail is word order
   758                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   759                                  .userAbort:
   760                                  ;Abort is always an option
   761 00000680 488D15E5010000              lea rdx, qword [.abortmsg]
   762 00000687 B409                        mov ah, 09h
   763 00000689 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   764                                  .userRetry:
   765 0000068B F6C710                      test bh, 10h  ;Bit 4 is retry bit
   766 0000068E 7416                        jz .userIgnore    ;If clear, dont print message
   767 00000690 488D15ED010000              lea rdx, qword [.betweenMsg]
   768 00000697 B409                        mov ah, 09h
   769 00000699 CD41                        int 41h
   770 0000069B 488D15D7010000              lea rdx, qword [.retrymsg]
   771 000006A2 B409                        mov ah, 09h
   772 000006A4 CD41                        int 41h
   773                                  .userIgnore:
   774 000006A6 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   775 000006A9 7416                        jz .userFail
   776 000006AB 488D15D2010000              lea rdx, qword [.betweenMsg]
   777 000006B2 B409                        mov ah, 09h
   778 000006B4 CD41                        int 41h
   779 000006B6 488D15B5010000              lea rdx, qword [.ignoremsg]
   780 000006BD B409                        mov ah, 09h
   781 000006BF CD41                        int 41h
   782                                  .userFail:
   783 000006C1 F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   784 000006C4 7416                        jz .userMsgEnd
   785 000006C6 488D15B7010000              lea rdx, qword [.betweenMsg]
   786 000006CD B409                        mov ah, 09h
   787 000006CF CD41                        int 41h
   788 000006D1 488D15A7010000              lea rdx, qword [.failmsg]
   789 000006D8 B409                        mov ah, 09h
   790 000006DA CD41                        int 41h
   791                                  .userMsgEnd:
   792 000006DC 488D15A4010000              lea rdx, qword [.endMsg]
   793 000006E3 B409                        mov ah, 09h
   794 000006E5 CD41                        int 41h
   795                                  ;Get user input now 
   796 000006E7 31C9                        xor ecx, ecx  ;4 Possible Responses
   797 000006E9 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   798 000006F0 B401                        mov ah, 01h ;STDIN without Console Echo
   799 000006F2 CD41                        int 41h ;Get char in al
   800 000006F4 3C61                        cmp al, "a" ;Chack if lowercase
   801 000006F6 7202                        jb .uip1    ;If the value is below, ignore subtraction
   802 000006F8 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   803                                  .uip1:
   804 000006FA AE                          scasb   ;Compare char to list, offset gives return code
   805 000006FB 740F                        je .validInput  ;If they are equal, ecx has return code
   806 000006FD FFC1                        inc ecx
   807 000006FF 81F904000000                cmp ecx, 4
   808 00000705 75F3                        jne .uip1
   809 00000707 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   810                                  .validInput:
   811 0000070C 88C8                        mov al, cl  ;Move the offset into .responses into al
   812                                  ;Now check if the input is permitted
   813 0000070E 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   814 00000710 7427                        je .cehExit
   815 00000712 84C0                        test al, al ;Check if 0 => Ignore
   816 00000714 740F                        je .viIgnore
   817 00000716 3C01                        cmp al, 1   ;Check if 1 => Retry
   818 00000718 7416                        je .viRetry
   819                                  .viFail:    ;Fallthrough for fail (al = 3)
   820 0000071A F6C708                      test bh, 8  ;Bit 3 is Fail bit
   821 0000071D 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   822 00000723 EB14                        jmp short .cehExit
   823                                  .viIgnore:
   824 00000725 F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   825 00000728 0F8447FFFFFF                jz .userInput
   826 0000072E EB09                        jmp short .cehExit
   827                                  .viRetry:
   828 00000730 F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   829 00000733 0F843CFFFFFF                jz .userInput
   830                                  .cehExit:
   831 00000739 5E                          pop rsi
   832 0000073A 5F                          pop rdi
   833 0000073B 5A                          pop rdx
   834 0000073C 59                          pop rcx
   835 0000073D 5B                          pop rbx
   836 0000073E 48CF                        iretq
   837                                  .charError:
   838 00000740 B908000000                  mov ecx, 8  ;8 chars in device name
   839 00000745 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   840                                  .ce1:
   841 0000074C AC                          lodsb   ;Get a string char into al and inc rsi
   842 0000074D 88C2                        mov dl, al  ;Move char into dl
   843 0000074F B402                        mov ah, 02h
   844 00000751 CD41                        int 41h ;Print char
   845 00000753 E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   846 00000755 E91BFFFFFF                  jmp .userInput
   847                                  
   848                                  .errorMsgTable: ;Each table entry is 18 chars long
   849 0000075A 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   849 00000763 746563742024202020 
   850 0000076C 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   850 00000775 6E6974202420202020 
   851 0000077E 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   851 00000787 202420202020202020 
   852 00000790 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   852 00000799 6F6D6D616E64202420 
   853 000007A2 446174612024202020-                 db "Data $            "       ;Error 4
   853 000007AB 202020202020202020 
   854 000007B4 426164205265717565-                 db "Bad Request $     "       ;Error 5
   854 000007BD 737420242020202020 
   855 000007C6 5365656B2024202020-                 db "Seek $            "       ;Error 6
   855 000007CF 202020202020202020 
   856 000007D8 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   856 000007E1 656469612024202020 
   857 000007EA 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   857 000007F3 7420466F756E642024 
   858 000007FC 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   858 00000805 706572202420202020 
   859 0000080E 577269746520466175-                 db "Write Fault $     "       ;Error A
   859 00000817 6C7420242020202020 
   860 00000820 52656164204661756C-                 db "Read Fault $      "       ;Error B
   860 00000829 742024202020202020 
   861 00000832 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   861 0000083B 61696C757265202420 
   862                                  
   863 00000844 64726976652024          .drive      db "drive $"
   864 0000084B 6572726F7220726561-     .readmsg    db "error reading $"
   864 00000854 64696E672024       
   865 0000085A 6572726F7220777269-     .writemsg   db "error writing $"
   865 00000863 74696E672024       
   866 00000869 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   867 0000086C 41626F727424            .abortmsg   db "Abort$" 
   868 00000872 49676E6F726524          .ignoremsg  db "Ignore$"
   869 00000879 526574727924            .retrymsg   db "Retry$"
   870 0000087F 4661696C24              .failmsg    db "Fail$"
   871 00000884 2C2024                  .betweenMsg db ", $"
   872 00000887 3F2024                  .endMsg     db "? $"
   873 0000088A 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   874                                  absDiskRead:        ;Int 45h
   875                                  ;al = Drive number
   876                                  ;rbx = Memory Buffer address
   877                                  ;ecx = Number of sectors to read (max 255 for now)
   878                                  ;rdx = Start LBA to read from
   879 0000088E 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   880 00000892 8A80[74130000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   881 00000898 4891                        xchg rax, rcx
   882 0000089A 4887CA                      xchg rcx, rdx
   883 0000089D B482                        mov ah, 82h
   884 0000089F CD33                        int 33h
   885 000008A1 48CF                        iretq
   886                                  absDiskWrite:       ;Int 46h
   887 000008A3 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   888 000008A7 8A80[74130000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   889 000008AD 4891                        xchg rax, rcx
   890 000008AF 4887CA                      xchg rcx, rdx
   891 000008B2 B483                        mov ah, 83h
   892 000008B4 CD33                        int 33h
   893 000008B6 48CF                        iretq
   894                                  terminateResident:  ;Int 47h
   895                                  inDosHandler:       ;Int 48h
   896                                  ;Called when DOS idle
   897 000008B8 48CF                        iretq
   898                                  fastOutput:         ;Int 49h
   899                                  ;Called with char to transfer in al
   900 000008BA 50                          push rax
   901 000008BB B40E                        mov ah, 0Eh
   902 000008BD CD30                        int 30h
   903 000008BF 58                          pop rax
   904 000008C0 48CF                        iretq
   905                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   906 000008C2 48CF                        iretq
   907                                  multiplex:          ;Int 4Fh, kept as iretq for now
   908 000008C4 48CF                        iretq
   909                                  ;-----------------------------------:
   910                                  ;          Driver routines          :
   911                                  ;-----------------------------------:
   912                                  drivers:
   913                                  conHdr:
   914 000008C6 [E808000000000000]          dq auxHdr
   915 000008CE 1308                        dw 0813h
   916 000008D0 [5E0A000000000000]          dq commonStrat
   917 000008D8 [750A000000000000]          dq conDriver
   918 000008E0 434F4E2020202020            db "CON     "
   919                                  auxHdr:
   920 000008E8 [0A09000000000000]          dq prnHdr
   921 000008F0 0080                        dw 08000h
   922 000008F2 [5E0A000000000000]          dq commonStrat
   923 000008FA [3A0D000000000000]          dq com1Intr
   924 00000902 4155582020202020            db "AUX     "
   925                                  prnHdr:
   926 0000090A [2C09000000000000]          dq clkHdr
   927 00000912 40A0                        dw 0A040h
   928 00000914 [6E0A000000000000]          dq nulStrat
   929 0000091C [740A000000000000]          dq nulIntr
   930 00000924 50524E2020202020            db "PRN     "
   931                                  clkHdr:
   932 0000092C [4E09000000000000]          dq msdHdr
   933 00000934 0880                        dw 08008h
   934 00000936 [5E0A000000000000]          dq commonStrat
   935 0000093E [AD0B000000000000]          dq clkDriver
   936 00000946 434C4F434B242020            db "CLOCK$  "
   937                                  msdHdr:
   938 0000094E [7009000000000000]          dq com1Hdr
   939 00000956 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   940 00000958 [5E0A000000000000]          dq commonStrat
   941 00000960 [DF0E000000000000]          dq msdDriver
   942 00000968 0000000000000000            db 0,0,0,0,0,0,0,0
   943                                  com1Hdr:
   944 00000970 [9209000000000000]          dq com2Hdr
   945 00000978 0080                        dw 08000h
   946 0000097A [5E0A000000000000]          dq commonStrat
   947 00000982 [3A0D000000000000]          dq com1Intr
   948 0000098A 434F4D3120202020            db "COM1    "
   949                                  com2Hdr:
   950 00000992 [B409000000000000]          dq com3Hdr
   951 0000099A 0080                        dw 08000h
   952 0000099C [5E0A000000000000]          dq commonStrat
   953 000009A4 [430D000000000000]          dq com2Intr
   954 000009AC 434F4D3220202020            db "COM2    "
   955                                  com3Hdr:
   956 000009B4 [D609000000000000]          dq com4Hdr
   957 000009BC 0080                        dw 08000h
   958 000009BE [5E0A000000000000]          dq commonStrat
   959 000009C6 [4C0D000000000000]          dq com3Intr
   960 000009CE 434F4D3320202020            db "COM3    "
   961                                  com4Hdr:
   962 000009D6 [F809000000000000]          dq lpt1Hdr
   963 000009DE 0080                        dw 08000h
   964 000009E0 [5E0A000000000000]          dq commonStrat
   965 000009E8 [550D000000000000]          dq com4Intr
   966 000009F0 434F4D3420202020            db "COM4    "
   967                                  lpt1Hdr:
   968 000009F8 [1A0A000000000000]          dq lpt2Hdr
   969 00000A00 40A0                        dw 0A040h
   970 00000A02 [6E0A000000000000]          dq nulStrat
   971 00000A0A [740A000000000000]          dq nulIntr
   972 00000A12 4C50543120202020            db "LPT1    "
   973                                  lpt2Hdr:
   974 00000A1A [3C0A000000000000]          dq lpt3Hdr
   975 00000A22 40A0                        dw 0A040h
   976 00000A24 [6E0A000000000000]          dq nulStrat
   977 00000A2C [740A000000000000]          dq nulIntr
   978 00000A34 4C50543220202020            db "LPT2    "
   979                                  lpt3Hdr:
   980 00000A3C FFFFFFFFFFFFFFFF            dq -1
   981 00000A44 40A0                        dw 0A040h
   982 00000A46 [6E0A000000000000]          dq nulStrat
   983 00000A4E [740A000000000000]          dq nulIntr
   984 00000A56 4C50543320202020            dq "LPT3    "
   985                                  
   986                                  commonStrat:
   987                                  ;DOS calls this function with rbx=Ptr to request header
   988 00000A5E 48891D01000000              mov qword [reqHdrPtr], rbx
   989 00000A65 C3                          ret
   990 00000A66 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   991                                  
   992                                  nulStrat:
   993 00000A6E 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   994                                  nulIntr:
   995 00000A74 C3                          ret
   996                                  
   997                                  conDriver:
   998 00000A75 50                          push rax
   999 00000A76 53                          push rbx
  1000 00000A77 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
  1001 00000A7E B003                        mov al, 03h ;Unknown Command
  1002 00000A80 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1003 00000A84 7735                        ja .conWriteErrorCode ;If yes, error!
  1004                                  
  1005 00000A86 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
  1006 00000A89 3C04                        cmp al, 4
  1007 00000A8B 743D                        jz .conRead
  1008 00000A8D 3C05                        cmp al, 5
  1009 00000A8F 747F                        jz .conNondestructiveRead
  1010 00000A91 3C06                        cmp al, 6
  1011 00000A93 0F84A8000000                jz .conInputStatus
  1012 00000A99 3C07                        cmp al, 7
  1013 00000A9B 0F84B0000000                jz .conFlushInputBuffers
  1014 00000AA1 3C08                        cmp al, 8
  1015 00000AA3 0F84CA000000                jz .conWrite
  1016 00000AA9 3C09                        cmp al, 9
  1017 00000AAB 0F84C2000000                jz .conWrite
  1018 00000AB1 3C0A                        cmp al, 0Ah
  1019 00000AB3 0F84E3000000                jz .conOutputStatus
  1020 00000AB9 EB06                        jmp short .conExit  ;All other valid functions return done
  1021                                  .conWriteErrorCode:     ;Jump to with al=Standard Error code
  1022 00000ABB B480                        mov ah, 80h ;Set error bit
  1023 00000ABD 66894303                    mov word [rbx + drvReqHdr.status], ax
  1024                                  .conExit:
  1025 00000AC1 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
  1026 00000AC7 5B                          pop rbx
  1027 00000AC8 58                          pop rax
  1028 00000AC9 C3                          ret
  1029                                  .conRead:    ;Function 4
  1030 00000ACA B005                        mov al, 05h ;Bad request structure length?
  1031 00000ACC 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1032 00000ACF 75EA                        jne .conWriteErrorCode
  1033                                  
  1034 00000AD1 57                          push rdi
  1035 00000AD2 51                          push rcx
  1036 00000AD3 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
  1037 00000AD7 31C9                        xor ecx, ecx    ;Zero the char counter
  1038                                  .cre1:
  1039 00000AD9 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1040 00000ADC 741C                        je .cre2
  1041 00000ADE 803DC700000000              cmp byte [.conBuf], 0   ;Does the buffer contain a zero?
  1042 00000AE5 751A                        jnz .cre3   ;No, get the buffer value
  1043 00000AE7 31C0                        xor eax, eax
  1044 00000AE9 CD36                        int 36h
  1045                                  .cre11:
  1046 00000AEB AA                          stosb
  1047 00000AEC 84C0                        test al, al ;Was the ascii code 0?
  1048 00000AEE 7506                        jnz .cre12  ;No, skip storing scancode
  1049 00000AF0 8825B6000000                mov byte [.conBuf], ah  ;Save scancode
  1050                                  .cre12:
  1051 00000AF6 FFC1                        inc ecx ;Inc chars stored in buffer
  1052 00000AF8 EBDF                        jmp short .cre1
  1053                                  .cre2:
  1054 00000AFA 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1055 00000AFD 59                          pop rcx
  1056 00000AFE 5F                          pop rdi
  1057 00000AFF EBC0                        jmp short .conExit
  1058                                  .cre3:
  1059 00000B01 8A05A5000000                mov al, byte [.conBuf]  ;Get the buffer value
  1060 00000B07 C6059E00000000              mov byte [.conBuf], 0   ;Reset the buffer value
  1061 00000B0E EBDB                        jmp short .cre11
  1062                                  
  1063                                  .conNondestructiveRead:  ;Function 5
  1064 00000B10 B005                        mov al, 05h ;Bad request structure length?
  1065 00000B12 803B0E                      cmp byte [rbx + drvReqHdr.hdrlen], nonDestInNoWaitReqPkt_size
  1066 00000B15 75A4                        jne .conWriteErrorCode
  1067 00000B17 803D8E00000000              cmp byte [.conBuf], 0
  1068 00000B1E 7519                        jnz .cnr2
  1069 00000B20 B401                        mov ah, 01h     ;Get key if exists
  1070 00000B22 CD36                        int 36h
  1071 00000B24 7408                        jz .cnr1        ;If zero clear => no key, go forwards
  1072                                      ;Keystroke available
  1073                                  .cnr0:
  1074 00000B26 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
  1075 00000B29 E993FFFFFF                  jmp .conExit
  1076                                  .cnr1: ;No keystroke available
  1077 00000B2E 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h   ;Set busy bit
  1078 00000B34 E988FFFFFF                  jmp .conExit
  1079                                  .cnr2:
  1080 00000B39 8A056D000000                mov al, byte [.conBuf]  ;Copy scancode but dont reset it
  1081 00000B3F EBE5                        jmp short .cnr0   ;Keystroke is available clearly
  1082                                  
  1083                                  .conInputStatus:         ;Function 6
  1084 00000B41 B005                        mov al, 05h ;Bad request structure length?
  1085 00000B43 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1086 00000B46 0F856FFFFFFF                jne .conWriteErrorCode
  1087 00000B4C E970FFFFFF                  jmp .conExit ;Exit, device ready
  1088                                  
  1089                                  .conFlushInputBuffers:   ;Function 7
  1090 00000B51 B005                        mov al, 05h ;Bad request structure length?
  1091 00000B53 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1092 00000B56 0F855FFFFFFF                jne .conWriteErrorCode
  1093 00000B5C C6054900000000              mov byte [.conBuf], 0   ;Clear buffer
  1094                                  .cfib0:
  1095 00000B63 B401                        mov ah, 01      ;Get buffer status
  1096 00000B65 CD36                        int 36h
  1097 00000B67 0F8454FFFFFF                jz .conExit     ;If zero clear => no more keys to read
  1098 00000B6D 30E4                        xor ah, ah
  1099 00000B6F CD36                        int 36h ;Read key to flush from buffer
  1100 00000B71 EBF0                        jmp short .cfib0
  1101                                  
  1102                                  .conWrite:   ;Function 8 and 9
  1103 00000B73 B005                        mov al, 05h ;Bad request structure length?
  1104 00000B75 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1105 00000B78 0F853DFFFFFF                jne .conWriteErrorCode
  1106                                  
  1107 00000B7E 56                          push rsi
  1108 00000B7F 51                          push rcx
  1109 00000B80 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1110 00000B84 31C9                        xor ecx, ecx    ;Zero the char counter
  1111                                  .cw1: 
  1112 00000B86 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1113 00000B89 7407                        je .cw2
  1114 00000B8B AC                          lodsb   ;Get char into al, and inc rsi
  1115 00000B8C CD49                        int 49h ;Fast print char
  1116 00000B8E FFC1                        inc ecx
  1117 00000B90 EBF4                        jmp short .cw1 ;keep printing until all chars printed
  1118                                  .cw2:
  1119 00000B92 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1120 00000B95 59                          pop rcx
  1121 00000B96 5E                          pop rsi
  1122 00000B97 E925FFFFFF                  jmp .conExit
  1123                                  .conOutputStatus:   ;Function 0Ah
  1124 00000B9C B005                        mov al, 05h ;Bad request structure length?
  1125 00000B9E 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1126 00000BA1 0F8514FFFFFF                jne .conWriteErrorCode
  1127 00000BA7 E915FFFFFF                  jmp .conExit
  1128                                  
  1129 00000BAC 00                      .conBuf db 0    ;Single byte buffer
  1130                                  clkDriver:
  1131 00000BAD 50                          push rax
  1132 00000BAE 53                          push rbx
  1133 00000BAF 51                          push rcx
  1134 00000BB0 52                          push rdx
  1135 00000BB1 56                          push rsi
  1136 00000BB2 55                          push rbp
  1137 00000BB3 488B1DACFEFFFF              mov rbx, qword [reqHdrPtr]
  1138 00000BBA B003                        mov al, 03h ;Unknown Command
  1139 00000BBC 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1140 00000BC0 772B                        ja .clkWriteErrorCode ;If yes, error!
  1141                                  
  1142 00000BC2 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
  1143 00000BC5 3C04                        cmp al, 04h
  1144 00000BC7 7437                        jz .clkRead
  1145 00000BC9 3C06                        cmp al, 06h
  1146 00000BCB 0F8494000000                jz .clkInputStatus
  1147 00000BD1 3C07                        cmp al, 07h
  1148 00000BD3 0F8498000000                jz .clkFlushInputBuffers
  1149 00000BD9 3C08                        cmp al, 08h
  1150 00000BDB 0F84A0000000                jz .clkWrite
  1151 00000BE1 3C09                        cmp al, 09h
  1152 00000BE3 0F8498000000                jz .clkWrite
  1153 00000BE9 EB08                        jmp short .clkExit  ;All other valid functions return done immediately!
  1154                                  .clkNotFunctioning:
  1155 00000BEB B002                        mov al, 02h ;Device not ready error
  1156                                  .clkWriteErrorCode:
  1157 00000BED B480                        mov ah, 80h ;Set error bit
  1158 00000BEF 66894303                    mov word [rbx + drvReqHdr.status], ax
  1159                                  .clkExit:
  1160 00000BF3 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Merge done bit
  1161 00000BF9 5D                          pop rbp
  1162 00000BFA 5E                          pop rsi
  1163 00000BFB 5A                          pop rdx
  1164 00000BFC 59                          pop rcx
  1165 00000BFD 5B                          pop rbx
  1166 00000BFE 58                          pop rax
  1167 00000BFF C3                          ret
  1168                                  
  1169                                  .clkRead:           ;Function 4
  1170 00000C00 B005                        mov al, 05h ;Bad request structure length?
  1171 00000C02 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1172 00000C05 75E6                        jne .clkWriteErrorCode
  1173                                  
  1174 00000C07 4889DE                      mov rsi, rbx    ;Save rbx temporarily in rsi
  1175 00000C0A 488B6B0E                    mov rbp, qword [rbx + ioReqPkt.bufptr]    ;Save the clock struc ptr in rbp
  1176 00000C0E 668B05FE000000              mov ax, word [.clkDate] ;Get the clock date
  1177 00000C15 66894500                    mov word [rbp + clkStruc.dateWord], ax
  1178 00000C19 30E4                        xor ah, ah
  1179 00000C1B CD3A                        int 3Ah         ;Read the system timer
  1180 00000C1D 84C0                        test al, al     ;Check to see if midnight has passed?
  1181 00000C1F 740D                        jz .clkr1       ;Nope, now just time 
  1182 00000C21 30E4                        xor ah, ah
  1183                                      ;This works as al should keep count of the # of days passed since last read
  1184 00000C23 66014500                    add word [rbp + clkStruc.dateWord], ax
  1185 00000C27 660105E5000000              add word [.clkDate], ax ;Add to internal date counter too
  1186                                  .clkr1:
  1187 00000C2E 884D03                      mov byte [rbp + clkStruc.hours], cl   ;Save hours
  1188 00000C31 0FB7D2                      movzx edx, dx
  1189 00000C34 89D3                        mov ebx, edx  ;Save the minutes/seconds/hseconds count
  1190 00000C36 89D0                        mov eax, edx
  1191 00000C38 31D2                        xor edx, edx
  1192 00000C3A 89D8                        mov eax, ebx
  1193 00000C3C B944040000                  mov ecx, 1092   
  1194 00000C41 F7F1                        div ecx
  1195 00000C43 884502                      mov byte [rbp + clkStruc.minutes], al
  1196 00000C46 89D0                        mov eax, edx    ;Get remainder in eax
  1197 00000C48 678D0480                    lea eax, dword [eax + 4*eax]    ;Multiply by 5
  1198 00000C4C 31D2                        xor edx, edx
  1199 00000C4E B95B000000                  mov ecx, 91 ;5*18.2
  1200 00000C53 F7F1                        div ecx
  1201 00000C55 884505                      mov byte [rbp + clkStruc.seconds], al
  1202 00000C58 89D0                        mov eax, edx    ;Get remainder in eax
  1203                                      ;lea eax, dword [eax + 4*eax]
  1204                                      ;add eax, edx    ;Essentially multiply by 6
  1205 00000C5A 884504                      mov byte [rbp + clkStruc.hseconds], al
  1206 00000C5D 4889F3                      mov rbx, rsi    ;Return the packet pointer back to rbx
  1207 00000C60 E98EFFFFFF                  jmp .clkExit
  1208                                  
  1209                                  .clkInputStatus:    ;Function 6
  1210                                  ;Always return ready
  1211 00000C65 B005                        mov al, 05h ;Bad request structure length?
  1212 00000C67 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1213 00000C6A 7581                        jne .clkWriteErrorCode
  1214 00000C6C E982FFFFFF                  jmp .clkExit
  1215                                  .clkFlushInputBuffers:  ;Function 7
  1216                                  ;Always return done immediately
  1217 00000C71 B005                        mov al, 05h ;Bad request structure length?
  1218 00000C73 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], flushReqPkt_size
  1219 00000C76 0F8571FFFFFF                jne .clkWriteErrorCode
  1220 00000C7C E972FFFFFF                  jmp .clkExit
  1221                                  
  1222                                  .clkWrite:          ;Functions 8 and 9
  1223 00000C81 B005                        mov al, 05h ;Bad request structure length?
  1224 00000C83 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1225 00000C86 0F8561FFFFFF                jne .clkWriteErrorCode
  1226                                  
  1227 00000C8C 4889DE                      mov rsi, rbx    ;Save rbx temporarily in rsi
  1228 00000C8F 488B6B0E                    mov rbp, qword [rbx + ioReqPkt.bufptr]    ;Save the clock struc ptr in rbp
  1229 00000C93 668B4500                    mov ax, word [rbp + clkStruc.dateWord]    ;Get date word
  1230 00000C97 66890575000000              mov word [.clkDate], ax ;Save date internally
  1231                                  
  1232 00000C9E 31DB                        xor ebx, ebx    ;Clear temporary lo count register
  1233 00000CA0 0FB64504                    movzx eax, byte [rbp + clkStruc.hseconds]
  1234 00000CA4 B105                        mov cl, 5
  1235 00000CA6 F6F1                        div cl          ;Divide al by 5
  1236 00000CA8 30E4                        xor ah, ah      ;Remove the remainder
  1237 00000CAA 01C3                        add ebx, eax    ;Add the hseconds to final value
  1238                                  ;Using the decimal part of this formula for the low count
  1239                                  ;LoCount = (Minutes * 1092.38) + (Seconds * 18.21) + (Hundreths * .182)
  1240 00000CAC 8A4505                      mov al, byte [rbp + clkStruc.seconds]
  1241 00000CAF B912000000                  mov ecx, 18
  1242 00000CB4 F7E1                        mul ecx  
  1243 00000CB6 01C3                        add ebx, eax
  1244                                  
  1245 00000CB8 31D2                        xor edx, edx
  1246 00000CBA 0FB64502                    movzx eax, byte [rbp + clkStruc.minutes]
  1247 00000CBE B944040000                  mov ecx, 1092
  1248 00000CC3 F7E1                        mul ecx
  1249 00000CC5 01C3                        add ebx, eax
  1250 00000CC7 89DA                        mov edx, ebx    ;edx now has low count
  1251 00000CC9 0FB64D03                    movzx ecx, byte [rbp + clkStruc.hours]
  1252 00000CCD B401                        mov ah, 01h     ;Set the system time
  1253 00000CCF CD3A                        int 3Ah
  1254                                  
  1255 00000CD1 4889F3                      mov rbx, rsi
  1256 00000CD4 E91AFFFFFF                  jmp .clkExit
  1257                                  
  1258                                  .clkBCDtoHex:
  1259                                  ;Converts a BCD value to a Hex byte
  1260                                  ;Takes input in al, returns in al (zero-ed upper seven bytes)
  1261 00000CD9 51                          push rcx
  1262 00000CDA 0FB6C0                      movzx eax, al   ;Zero extend
  1263 00000CDD 89C1                        mov ecx, eax    ;Save al in ecx
  1264 00000CDF 250F000000                  and eax, 0Fh    ;Get lower nybble
  1265 00000CE4 81E1F0000000                and ecx, 0F0h   ;Get upper nybble
  1266 00000CEA C1E904                      shr ecx, 4      ;Shift upper nybble value down
  1267                                  .cbth0:
  1268 00000CED 050A000000                  add eax, 10
  1269 00000CF2 E2F9                        loop .cbth0
  1270 00000CF4 59                          pop rcx
  1271 00000CF5 C3                          ret
  1272                                  
  1273                                  .clkHexToBCD:
  1274                                  ;Converts a Hex byte into two BCD digits
  1275                                  ;Takes input in al, returns in al (zero-ed upper seven bytes)
  1276 00000CF6 51                          push rcx
  1277 00000CF7 0FB6C0                      movzx eax, al   ;Zero extend
  1278 00000CFA 31C9                        xor ecx, ecx
  1279                                  .chtb0:
  1280 00000CFC 3D0A000000                  cmp eax, 10
  1281 00000D01 7209                        jb .chtb1
  1282 00000D03 2D0A000000                  sub eax, 10
  1283 00000D08 FFC1                        inc ecx
  1284 00000D0A EBF0                        jmp short .chtb0
  1285                                  .chtb1:
  1286 00000D0C C1E104                      shl ecx, 4  ;Move to upper nybble
  1287 00000D0F 08C8                        or al, cl   ;Move upper nybble into al upper nybble
  1288 00000D11 59                          pop rcx
  1289 00000D12 C3                          ret
  1290 00000D13 0000                    .clkDate    dw 0    ;Number of days since 01/01/1980
  1291                                  ;When counting the number of days, first compute the number of years since
  1292                                  ; 1980 and your year. 
  1293                                  ;Then, using the table below, find the number of leap years between 1980
  1294                                  ; and (YourYear - 1). 
  1295                                  ;Then do (YourYear - 1980) * 365 + numberOfLeapYears to get the number of 
  1296                                  ; days since 01/01/1980 and 01/01/YourYear.
  1297                                  ;Use the months table to get the number of days in a normal month as leap 
  1298                                  ; years are added using the previous comment.
  1299                                  ;Finally check if the date is after 28th Feb. If it is, check if your year is 
  1300                                  ; a leap year using the table. If it is, add an extra day.
  1301                                  .clkLeapYears:
  1302 00000D15 0004080C1014181C20-         db 00, 04, 08, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 
  1302 00000D1E 24282C30           
  1303 00000D22 34383C4044484C5054-         db 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96
  1303 00000D2B 585C60             
  1304                                  .clkMonths:
  1305 00000D2E 1F1C1F1E1F1E1F1F1E-         db 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  1305 00000D37 1F1E1F             
  1306                                  ;COM Driver headers and main interrupt strat
  1307                                  com1Intr:
  1308 00000D3A C6059D01000000              mov byte [comIntr.comDevice], 0
  1309 00000D41 EB19                        jmp short comIntr
  1310                                  com2Intr:
  1311 00000D43 C6059401000001              mov byte [comIntr.comDevice], 1
  1312 00000D4A EB10                        jmp short comIntr
  1313                                  com3Intr:
  1314 00000D4C C6058B01000002              mov byte [comIntr.comDevice], 2
  1315 00000D53 EB07                        jmp short comIntr
  1316                                  com4Intr:
  1317 00000D55 C6058201000003              mov byte [comIntr.comDevice], 3
  1318                                  comIntr:
  1319 00000D5C 50                          push rax
  1320 00000D5D 53                          push rbx
  1321 00000D5E 51                          push rcx
  1322 00000D5F 52                          push rdx
  1323 00000D60 56                          push rsi
  1324 00000D61 57                          push rdi
  1325 00000D62 488B1DFDFCFFFF              mov rbx, qword [reqHdrPtr]
  1326 00000D69 B003                        mov al, 03h ;Unknown Command
  1327 00000D6B 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1328 00000D6F 7756                        ja .comWriteErrorCode ;If yes, error!
  1329                                  
  1330 00000D71 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
  1331 00000D74 3C04                        cmp al, 4   ;Read Character(s)
  1332 00000D76 7462                        jz .comRead
  1333 00000D78 3C05                        cmp al, 5   ;Non-destructive read, acts like fast read 1 char if available
  1334 00000D7A 0F849B000000                jz .comNondestructiveRead   
  1335 00000D80 3C06                        cmp al, 6   ;Read Input Status, always return with Busy bit = 0
  1336 00000D82 0F8484000000                jz .comReadInputStatus
  1337 00000D88 3C07                        cmp al, 7   ;Flush read buffers, return done
  1338 00000D8A 0F84B9000000                jz .comFlushInputBuffers
  1339 00000D90 3C08                        cmp al, 8
  1340 00000D92 0F84DB000000                jz .comWrite
  1341 00000D98 3C09                        cmp al, 9
  1342 00000D9A 0F84D3000000                jz .comWrite
  1343 00000DA0 3C0A                        cmp al, 0Ah
  1344 00000DA2 0F8400010000                jz .comOutputStatus ;Return Clear to send bit inverted for busy bit
  1345 00000DA8 EB23                        jmp short .comExit  ;All other valid functions should return done
  1346                                  .comErrorNoCount:
  1347 00000DAA B002                        mov al, 02h ;Unknown device
  1348 00000DAC EB19                        jmp short .comWriteErrorCode
  1349                                  .comReadError:
  1350 00000DAE BA0B000000                  mov edx, 0Bh
  1351                                  .comWriteError:
  1352 00000DB3 BA0A000000                  mov edx, 0Ah
  1353                                  .comError:
  1354 00000DB8 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx ;Store actual transferred chars
  1355 00000DBB B902000000                  mov ecx, 02h    ;Unknown device
  1356 00000DC0 3CFE                        cmp al, 0FEh    ;Invalid COM port
  1357 00000DC2 0F44D1                      cmove edx, ecx  ;Only move unknown device error code if invalid COM port
  1358 00000DC5 88D0                        mov al, dl      ;Move dl to al to store error code
  1359                                  .comWriteErrorCode:    ;Jump to with al=Standard Error code
  1360 00000DC7 B480                        mov ah, 80h ;Set error bit
  1361 00000DC9 66894303                    mov word [rbx + drvReqHdr.status], ax
  1362                                  .comExit:
  1363 00000DCD 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
  1364 00000DD3 5F                          pop rdi
  1365 00000DD4 5E                          pop rsi
  1366 00000DD5 5A                          pop rdx
  1367 00000DD6 59                          pop rcx
  1368 00000DD7 5B                          pop rbx
  1369 00000DD8 58                          pop rax
  1370 00000DD9 C3                          ret
  1371                                  
  1372                                  .comRead:
  1373 00000DDA B005                        mov al, 05h ;Bad request structure length?
  1374 00000DDC 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1375 00000DDF 75E6                        jne .comWriteErrorCode
  1376                                  
  1377 00000DE1 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
  1378 00000DE5 31C9                        xor ecx, ecx    ;Zero the char counter
  1379                                  .cr1:
  1380 00000DE7 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1381 00000DEA 741B                        je .cre2
  1382                                  .cr11:  ;Blocking wait, could be an infinite loop. Imitate basic DOS driver
  1383 00000DEC B802000000                  mov eax, 02h    ;Recieve 
  1384 00000DF1 8A15E7000000                mov dl, byte [.comDevice]    ;Get transacting com device
  1385 00000DF7 6698                        cbw     ;Zero extend to upper byte
  1386 00000DF9 CD34                        int 34h ;Recieve Char
  1387 00000DFB 72BB                        jc .comError
  1388 00000DFD 80FC80                      cmp ah, 80h ;Did a "timeout" occur? If so, keep waiting
  1389 00000E00 74EA                        je .cr11
  1390 00000E02 AA                          stosb   ;Store char in al into buffer and inc rdi
  1391 00000E03 FFC1                        inc ecx
  1392 00000E05 EBE0                        jmp short .cr1
  1393                                  .cre2:
  1394 00000E07 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1395 00000E0A EBC1                        jmp short .comExit
  1396                                  
  1397                                  .comReadInputStatus:
  1398 00000E0C B005                        mov al, 05h ;Bad request structure length?
  1399 00000E0E 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1400 00000E11 75B4                        jne .comWriteErrorCode
  1401 00000E13 66C743030000                mov word [rbx + statusReqPkt.status], 0 ;Chars ready to read status
  1402 00000E19 EBB2                        jmp short .comExit
  1403                                  
  1404                                  .comNondestructiveRead:
  1405                                  ;Acts like a "read one character if there is one" function
  1406 00000E1B B005                        mov al, 05h ;Bad request structure length?
  1407 00000E1D 803B0E                      cmp byte [rbx + drvReqHdr.hdrlen], nonDestInNoWaitReqPkt_size
  1408 00000E20 75A5                        jne .comWriteErrorCode
  1409                                  .cndr1:
  1410 00000E22 B802000000                  mov eax, 02h    ;Recieve 
  1411 00000E27 8A15B1000000                mov dl, byte [.comDevice]    ;Get transacting com device
  1412 00000E2D 6698                        cbw     ;Zero extend to upper byte
  1413 00000E2F CD34                        int 34h ;Recieve Char
  1414 00000E31 0F8273FFFFFF                jc .comErrorNoCount ;Dont save a char transfer number
  1415 00000E37 80FC80                      cmp ah, 80h ;Did a "timeout" occur? If so, return with busy = 1
  1416 00000E3A 7405                        je .cndr2
  1417 00000E3C 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Get next char
  1418 00000E3F EB8C                        jmp short .comExit
  1419                                  .cndr2:
  1420 00000E41 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 200h ;Busy bit set
  1421 00000E47 EB84                        jmp short .comExit
  1422                                  
  1423                                  .comFlushInputBuffers:
  1424 00000E49 B005                        mov al, 05h ;Bad request structure length?
  1425 00000E4B 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], flushReqPkt_size
  1426 00000E4E 0F8573FFFFFF                jne .comWriteErrorCode
  1427                                  .cfib0:
  1428 00000E54 8A1584000000                mov dl, byte [.comDevice]
  1429 00000E5A 6698                        cbw
  1430 00000E5C B802000000                  mov eax, 02h    ;Recieve
  1431 00000E61 CD34                        int 34h
  1432 00000E63 0F8241FFFFFF                jc .comErrorNoCount
  1433 00000E69 80FC80                      cmp ah, 80h ;Keep looping until ah = 80h (no more chars in buffer)
  1434 00000E6C 75E6                        jne .cfib0
  1435 00000E6E E95AFFFFFF                  jmp .comExit
  1436                                  
  1437                                  .comWrite:
  1438 00000E73 B005                        mov al, 05h ;Bad request structure length?
  1439 00000E75 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1440 00000E78 0F8549FFFFFF                jne .comWriteErrorCode
  1441                                  
  1442 00000E7E 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1443 00000E82 31C9                        xor ecx, ecx    ;Zero the char counter
  1444                                  .cw1: 
  1445 00000E84 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1446 00000E87 7417                        je .cw2
  1447 00000E89 AC                          lodsb   ;Get char into al, and inc rsi
  1448 00000E8A B401                        mov ah, 01h ;Move function number into ah
  1449 00000E8C 8A154C000000                mov dl, byte [.comDevice]
  1450 00000E92 6698                        cbw     ;Zero extend to upper byte
  1451 00000E94 CD34                        int 34h ;Transmit char
  1452 00000E96 0F821CFFFFFF                jc .comError
  1453 00000E9C FFC1                        inc ecx
  1454 00000E9E EBE4                        jmp short .cw1 ;keep printing until all chars printed
  1455                                  .cw2:
  1456 00000EA0 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1457 00000EA3 E925FFFFFF                  jmp .comExit
  1458                                  
  1459                                  .comOutputStatus:
  1460                                  ;Read MODEM status
  1461 00000EA8 B005                        mov al, 05h ;Bad request structure length?
  1462 00000EAA 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], statusReqPkt_size
  1463 00000EAD 0F8514FFFFFF                jne .comWriteErrorCode
  1464                                  
  1465 00000EB3 8A1525000000                mov dl, byte [.comDevice]
  1466 00000EB9 6698                        cbw     ;Zero extend to upper byte
  1467 00000EBB B403                        mov ah, 03h     ;Get status
  1468 00000EBD CD34                        int 34h
  1469 00000EBF 0F82E5FEFFFF                jc .comErrorNoCount
  1470 00000EC5 2510000000                  and eax, 10h ;Isolate bit 4 of al, clear to set, and clear all other bits
  1471 00000ECA C1E005                      shl eax, 5   ;Shift it up to bit 9 (busy bit in status word) 
  1472 00000ECD F7D0                        not eax      ;Bitwise inversion
  1473 00000ECF 2500020000                  and eax, 200h   ;Isolate bit 9
  1474 00000ED4 6689441B03                  mov word [rbx + rbx + drvReqHdr.status], ax  ;Add the busy bit
  1475 00000ED9 E9EFFEFFFF                  jmp .comExit
  1476 00000EDE 00                      .comDevice   db 0
  1477                                  
  1478                                  msdDriver:
  1479 00000EDF 50                          push rax
  1480 00000EE0 53                          push rbx
  1481 00000EE1 51                          push rcx
  1482 00000EE2 52                          push rdx
  1483 00000EE3 56                          push rsi
  1484 00000EE4 57                          push rdi
  1485 00000EE5 55                          push rbp
  1486 00000EE6 4150                        push r8
  1487 00000EE8 488B1D77FBFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1488 00000EEF 807B0218                    cmp byte [rbx + drvReqHdr.cmdcde], 24 ; Command code bigger than 24?
  1489 00000EF3 B003                        mov al, 03h
  1490 00000EF5 0F87F9000000                ja .msdWriteErrorCode ;If yes, error!
  1491 00000EFB B001                        mov al, 01h ;Unknown Unit Error
  1492 00000EFD 807B0105                    cmp byte [rbx + drvReqHdr.unitnm], 05h  ;Unit greater than 5 is invalid
  1493 00000F01 0F87ED000000                ja .msdWriteErrorCode ;If yes, error!
  1494 00000F07 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1495 00000F0A 84C0                        test al, al
  1496 00000F0C 0F84F8000000                jz .msdInit
  1497 00000F12 3C01                        cmp al, 01
  1498 00000F14 0F84C9010000                jz .msdMedChk
  1499 00000F1A 3C02                        cmp al, 02
  1500 00000F1C 0F8432020000                jz .msdBuildBPB
  1501 00000F22 3C03                        cmp al, 03
  1502 00000F24 0F8498020000                jz .msdIOCTLRead
  1503 00000F2A 3C04                        cmp al, 04
  1504 00000F2C 0F84A0020000                jz .msdRead
  1505 00000F32 3C08                        cmp al, 08
  1506 00000F34 0F84D4020000                jz .msdWrite
  1507 00000F3A 3C09                        cmp al, 09
  1508 00000F3C 0F8408030000                jz .msdWriteVerify
  1509 00000F42 3C0C                        cmp al, 12
  1510 00000F44 0F8449030000                jz .msdIOCTLWrite
  1511 00000F4A 3C0D                        cmp al, 13
  1512 00000F4C 0F8451030000                jz .msdDevOpen
  1513 00000F52 3C0E                        cmp al, 14
  1514 00000F54 0F8468030000                jz .msdDevClose
  1515 00000F5A 3C0F                        cmp al, 15
  1516 00000F5C 0F847F030000                jz .msdRemovableMedia
  1517 00000F62 3C13                        cmp al, 19
  1518 00000F64 0F84A4030000                jz .msdGenericIOCTL
  1519 00000F6A 3C17                        cmp al, 23
  1520 00000F6C 0F84AC030000                jz .msdGetLogicalDev
  1521 00000F72 3C18                        cmp al, 24
  1522 00000F74 0F84BD030000                jz .msdSetLogicalDev
  1523 00000F7A EB7E                        jmp short .msdDriverExit    ;All other valid functions exit done
  1524                                  .msdIOError:  ;In Read and Write errors, rbp points to the dev struc
  1525 00000F7C 4889EB                      mov rbx, rbp
  1526 00000F7F 0FB6C0                      movzx eax, al   ;Number of IO-ed sectors in last request
  1527 00000F82 01C6                        add esi, eax    ;esi Keeps sector count across transfers
  1528 00000F84 897316                      mov dword [rbx + ioReqPkt.tfrlen], esi ;Save number of IO-ed sectors
  1529                                  ;Now fall through to general error
  1530                                  .msdGenDiskError:
  1531 00000F87 B401                        mov ah, 01h
  1532 00000F89 30D2                        xor dl, dl  ;Work around bug that fails request if dl > 7Fh
  1533 00000F8B CD33                        int 33h ;Read status of last operation
  1534 00000F8D 80FC06                      cmp ah, 06h ;Mock Seek response (device not present)
  1535 00000F90 B002                        mov al, 02h ;Give device not ready error (sensibly I think)
  1536 00000F92 7460                        je .msdWriteErrorCode 
  1537 00000F94 B00C                        mov al, 0Ch ;Preliminary General Error Faults
  1538 00000F96 80FCFF                      cmp ah, -1  ;Sense operation failed
  1539 00000F99 7459                        je .msdWriteErrorCode 
  1540 00000F9B 80FC20                      cmp ah, 20h ;Gen. ctrlr. failure. Consider new error code to halt system.
  1541 00000F9E 7454                        je .msdWriteErrorCode
  1542                                  ;Device Not Ready
  1543 00000FA0 B002                        mov al, 02h  ;Device not ready code
  1544 00000FA2 4138C0                      cmp r8b, al  ;SCSI Not ready commands start with 2
  1545 00000FA5 744D                        je .msdWriteErrorCode
  1546 00000FA7 49C1E808                    shr r8, 8       ;Remove Sense Key
  1547 00000FAB 410FB7C8                    movzx ecx, r8w  ;Get ASC and ASCQ in cl and ch bzw.
  1548                                  ;Write Protected
  1549 00000FAF 30C0                        xor al, al
  1550 00000FB1 6681F92700                  cmp cx, 0027h   ;Write protected error
  1551 00000FB6 743C                        je .msdWriteErrorCode
  1552                                  ;CRC Error
  1553 00000FB8 B004                        mov al, 04h     ;CRC error code
  1554 00000FBA 6681F90803                  cmp cx, 0308h   ;LU comms CRC error (UDMA/32)
  1555 00000FBF 7433                        je .msdWriteErrorCode
  1556 00000FC1 6681F91000                  cmp cx, 0010h   ;ID CRC or ECC error
  1557 00000FC6 742C                        je .msdWriteErrorCode
  1558 00000FC8 6681F94701                  cmp cx, 0147h   ;Data phase CRC error detected
  1559 00000FCD 7425                        je .msdWriteErrorCode
  1560                                  ;Seek Error
  1561 00000FCF B006                        mov al, 06h     ;Seek error code
  1562 00000FD1 80F902                      cmp cl, 02h     ;No Seek Complete
  1563 00000FD4 741E                        je .msdWriteErrorCode
  1564                                  ;Unknown Hardware Media (Shouldn't happen with Flash Drives)
  1565                                  ;This error should only be called if BPB not recognised for Flash Drives
  1566 00000FD6 B007                        mov al, 07h
  1567 00000FD8 80F930                      cmp cl, 30h   ;All issues with media returns unknown media
  1568 00000FDB 7417                        je .msdWriteErrorCode
  1569                                  ;Sector Not Found
  1570 00000FDD B008                        mov al, 08h     ;Sector not found code
  1571 00000FDF 80F921                      cmp cl, 21h     ;Illegal Request - Invalid LBA
  1572 00000FE2 7410                        je .msdWriteErrorCode
  1573                                  ;Write faults
  1574 00000FE4 B00A                        mov al, 0Ah     ;Write fault
  1575 00000FE6 80F90C                      cmp cl, 0Ch     ;Write Error ASC code
  1576 00000FE9 7409                        je .msdWriteErrorCode
  1577                                  ;Read faults
  1578 00000FEB B00B                        mov al, 0Bh     ;Read fault
  1579 00000FED 80F911                      cmp cl, 11h     ;Read error
  1580 00000FF0 7402                        je .msdWriteErrorCode
  1581                                  ;General Errors
  1582 00000FF2 B00C                        mov al, 0Ch     ;Everything else is general error
  1583                                  .msdWriteErrorCode:    ;Jump to with al=Standard Error code
  1584 00000FF4 B480                        mov ah, 80h ;Set error bit
  1585 00000FF6 66894303                    mov word [rbx + drvReqHdr.status], ax
  1586                                  .msdDriverExit:
  1587 00000FFA 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1588 00001000 4158                        pop r8
  1589 00001002 5D                          pop rbp
  1590 00001003 5F                          pop rdi
  1591 00001004 5E                          pop rsi
  1592 00001005 5A                          pop rdx
  1593 00001006 59                          pop rcx
  1594 00001007 5B                          pop rbx
  1595 00001008 58                          pop rax
  1596 00001009 C3                          ret
  1597                                  .msdInit:            ;Function 0
  1598 0000100A B005                        mov al, 05h ;Bad request structure length
  1599 0000100C 803B1F                      cmp byte [rbx + drvReqHdr.hdrlen], initReqPkt_size
  1600 0000100F 75E3                        jne .msdWriteErrorCode
  1601                                  
  1602 00001011 488D2DE6050000              lea rbp, endptr
  1603 00001018 48896B0E                    mov qword [rbx + initReqPkt.endptr], rbp    ;Where the end is gonna be
  1604 0000101C 488D2D5B030000              lea rbp, .msdBPBTbl
  1605 00001023 48896B16                    mov qword [rbx + initReqPkt.optptr], rbp    ;Where bpb tbl is gonna be
  1606                                  
  1607 00001027 4889DD                      mov rbp, rbx ;Save the req block ptr in rbp
  1608 0000102A 31D2                        xor edx, edx  ;Start from device zero
  1609 0000102C 88550D                      mov byte [rbp + initReqPkt.numunt], dl   ;Zero this field, max 5
  1610                                  .mi0:   ;Now check each device for partitions
  1611 0000102F 807D0D05                    cmp byte [rbp + initReqPkt.numunt], 5
  1612 00001033 746C                        je .msdExit ;IF we are at 5 now, we exit
  1613 00001035 B482                        mov ah, 82h ;LBA read
  1614 00001037 B001                        mov al, 1   ;1 sector
  1615 00001039 B900000000                  mov ecx, 0  ;Read sector 0
  1616 0000103E 488D1D(3B010000)            lea rbx, msdTempBuffer  ;Get address of this space
  1617 00001045 CD33                        int 33h
  1618 00001047 0F828E000000                jc .msdInitError
  1619                                  ;Now we verify if this is a BPB. Removable devices can't be partitioned (yet)
  1620                                  ;1) Check byte 0 for EBh (short jmp) and byte 2 for a 90h (nop).
  1621 0000104D 8A03                        mov al, byte [rbx]
  1622 0000104F 8A6302                      mov ah, byte [rbx + 2]
  1623 00001052 663DEB90                    cmp ax, 090EBh
  1624 00001056 7573                        jne .mimbr
  1625                                  ;Valid BPB found! Copy to internal table and inc lastdrive
  1626 00001058 4889DE                      mov rsi, rbx
  1627 0000105B B878000000                  mov eax, bpbEx_size
  1628 00001060 89D1                        mov ecx, edx    ;Temporarily save dl in ecx
  1629 00001062 F7E2                        mul edx
  1630 00001064 89CA                        mov edx, ecx
  1631 00001066 488D3D39030000              lea rdi, .msdBPBblks
  1632 0000106D 4801C7                      add rdi, rax
  1633 00001070 B978000000                  mov ecx, bpbEx_size
  1634 00001075 4889F8                      mov rax, rdi    ;Save the entry address in rax
  1635 00001078 F3A4                        rep movsb   ;Copy the bpb into the bpb table
  1636 0000107A 488D3DFD020000              lea rdi, .msdBPBTbl
  1637 00001081 488D3CD7                    lea rdi, qword [rdi + 8*rdx]
  1638 00001085 488907                      mov qword [rdi], rax
  1639 00001088 488D3DE5020000              lea rdi, .msdBIOSmap
  1640 0000108F 4801D7                      add rdi, rdx    ;rdx contains a number, table is a list of bytes
  1641 00001092 8817                        mov byte [rdi], dl
  1642 00001094 FE450D                      inc byte [rbp + initReqPkt.numunt]
  1643 00001097 FEC2                        inc dl
  1644 00001099 3A15(09000000)              cmp dl, byte [numMSDdrv] ;Once these are equal, we have processed last dev
  1645 0000109F 758E                        jne .mi0
  1646                                  .msdExit:
  1647                                  ;If one device only, copy its BPB pointer and drive number
  1648                                  ;When HDD support implemented, this will check the number of remdevs not lastdrv
  1649 000010A1 807D0D01                    cmp byte [rbp + initReqPkt.numunt], 1
  1650 000010A5 751C                        jne .msdexit1
  1651                                  ;Here ONLY if one device found
  1652 000010A7 488D35D0020000              lea rsi, .msdBPBTbl
  1653 000010AE 488D7E08                    lea rdi, qword [rsi + 8]    ;Point to next entry
  1654 000010B2 48A5                        movsq   ;Copy pointer
  1655 000010B4 488D35B9020000              lea rsi, .msdBIOSmap
  1656 000010BB 488D7E01                    lea rdi, qword [rsi + 1]
  1657 000010BF A4                          movsb   ;Copy byte
  1658 000010C0 FE450D                      inc byte [rbp + initReqPkt.numunt]
  1659                                  .msdexit1:
  1660 000010C3 4889EB                      mov rbx, rbp
  1661 000010C6 E92FFFFFFF                  jmp .msdDriverExit
  1662                                  .mimbr:
  1663                                  ;Goto next device without incrementing LASTDRIVE
  1664 000010CB FEC2                        inc dl
  1665 000010CD 3A15(09000000)              cmp dl, byte [numMSDdrv] ;Once these are equal, we have processed last dev
  1666 000010D3 0F8556FFFFFF                jne .mi0
  1667 000010D9 EBC6                        jmp short .msdExit
  1668                                  .msdInitError:
  1669 000010DB 4889EB                      mov rbx, rbp
  1670 000010DE E9A4FEFFFF                  jmp .msdGenDiskError
  1671                                  .msdMedChk:          ;Function 1
  1672                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1673                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1674                                  ; suffice.
  1675 000010E3 B005                        mov al, 05h ;Bad request structure length
  1676 000010E5 803B17                      cmp byte [rbx + drvReqHdr.hdrlen], mediaCheckReqPkt_size
  1677 000010E8 0F8506FFFFFF                jne .msdWriteErrorCode
  1678                                  
  1679 000010EE 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1680 000010F3 8A90[74130000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1681 000010F9 F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1682 000010FC 754D                        jnz .mmcNoChange
  1683                                  ;Now we do a BIOS changeline check. If it returns 80h or 86h then check med desc
  1684 000010FE B416                        mov ah, 16h 
  1685 00001100 CD33                        int 33h
  1686 00001102 0F827FFEFFFF                jc .msdGenDiskError
  1687 00001108 80FC80                      cmp ah, 80h
  1688 0000110B 740E                        je .mmcNoChangeLine
  1689 0000110D 80FC86                      cmp ah, 86h
  1690 00001110 7409                        je .mmcNoChangeLine
  1691 00001112 84E4                        test ah, ah ;No change?
  1692 00001114 7435                        jz .mmcNoChange
  1693 00001116 F6C401                      test ah, 1  ;Neither 80h or 86h have bit 0 set
  1694 00001119 7513                        jnz .mmcChange
  1695                                  ;If nothing, fall through and test manually, should never happen though
  1696                                  .mmcNoChangeLine:
  1697                                  ;Now we test Media Descriptor
  1698 0000111B 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1699 0000111E 488B3CC5[7E130000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1700 00001126 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1701 00001129 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1702 0000112C 7414                        je .mmcUnsure
  1703                                  .mmcChange:
  1704 0000112E C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1705 00001132 488D0531020000              lea rax, qword [.msdDefLabel]           ;Temp, ret def label
  1706 00001139 4889430F                    mov qword [rbx + mediaCheckReqPkt.desptr], rax 
  1707 0000113D E9B8FEFFFF                  jmp .msdDriverExit
  1708                                  .mmcUnsure:
  1709 00001142 C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1710 00001146 E9AFFEFFFF                  jmp .msdDriverExit
  1711                                  .mmcNoChange:
  1712 0000114B C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1713 0000114F E9A6FEFFFF                  jmp .msdDriverExit
  1714                                  
  1715                                  .msdBuildBPB:        ;Function 2
  1716 00001154 B005                        mov al, 05h ;Bad request structure length
  1717 00001156 803B1E                      cmp byte [rbx + drvReqHdr.hdrlen], bpbBuildReqPkt_size
  1718 00001159 0F8595FEFFFF                jne .msdWriteErrorCode
  1719                                  
  1720 0000115F 4889DE                      mov rsi, rbx
  1721 00001162 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1722 00001167 8A90[74130000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1723 0000116D 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1724 00001171 31C9                        xor ecx, ecx    ;Read Sector 0
  1725 00001173 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1726 00001178 CD33                        int 33h
  1727 0000117A 0F8207FEFFFF                jc .msdGenDiskError
  1728                                  ;Check Media Descriptor, must be F0h or F8h-FFh or unknown media
  1729 00001180 807B15F0                    cmp byte [rbx + bpb.media], 0F0h    ;3.5" FDD standard
  1730 00001184 7418                        je .mbbpb0
  1731 00001186 807B15F8                    cmp byte [rbx + bpb.media], 0F8h    ;FDD/Large Media Standard
  1732 0000118A 7412                        je .mbbpb0
  1733 0000118C 807B15F9                    cmp byte [rbx + bpb.media], 0F9h    ;5.25" & 720K 3.5" Media Standard
  1734 00001190 740C                        je .mbbpb0
  1735 00001192 807B15FC                    cmp byte [rbx + bpb.media], 0FCh    ;Very Obsolete Media Standards
  1736 00001196 B007                        mov al, 07h ;Unknown media error code
  1737 00001198 0F8256FEFFFF                jb .msdWriteErrorCode
  1738                                  .mbbpb0:
  1739 0000119E 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1740 000011A1 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1741 000011A6 488B3CC5[7E130000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1742 000011AE 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1743 000011B1 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1744 000011B5 B90F000000                  mov ecx, bpbEx_size/8
  1745 000011BA F348A5                      rep movsq   ;Move the BPB data into the right space
  1746 000011BD E938FEFFFF                  jmp .msdDriverExit
  1747                                  .msdIOCTLRead:       ;Function 3, returns done
  1748 000011C2 B005                        mov al, 05h ;Bad request structure length
  1749 000011C4 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1750 000011C7 0F8527FEFFFF                jne .msdWriteErrorCode
  1751                                  
  1752 000011CD E928FEFFFF                  jmp .msdDriverExit
  1753                                  .msdRead:            ;Function 4
  1754                                  ;Will read one sector at a time.
  1755 000011D2 B005                        mov al, 05h ;Bad request structure length
  1756 000011D4 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1757 000011D7 0F8517FEFFFF                jne .msdWriteErrorCode
  1758                                  
  1759 000011DD 4889DD                      mov rbp, rbx
  1760 000011E0 31F6                        xor esi, esi  ;Set sector read counter to zero
  1761                                  .msdr0:
  1762 000011E2 B682                        mov dh, 82h ;LBA Read Sectors
  1763 000011E4 E867010000                  call .msdBlkIOCommon
  1764 000011E9 0F828DFDFFFF                jc .msdIOError
  1765 000011EF 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1766 000011F7 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1767 000011FF FFC6                        inc esi
  1768 00001201 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1769 00001204 75DC                        jne .msdr0
  1770 00001206 4889EB                      mov rbx, rbp
  1771 00001209 E9ECFDFFFF                  jmp .msdDriverExit
  1772                                  .msdWrite:           ;Function 8
  1773                                  ;Will write one sector at a time.
  1774 0000120E B005                        mov al, 05h ;Bad request structure length
  1775 00001210 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1776 00001213 0F85DBFDFFFF                jne .msdWriteErrorCode
  1777                                  
  1778 00001219 4889DD                      mov rbp, rbx
  1779 0000121C 31F6                        xor esi, esi  ;Set counter to zero
  1780                                  .msdw0:
  1781 0000121E B683                        mov dh, 83h ;LBA Write Sectors
  1782 00001220 E82B010000                  call .msdBlkIOCommon
  1783 00001225 0F8251FDFFFF                jc .msdIOError
  1784 0000122B 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1785 00001233 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1786 0000123B FFC6                        inc esi
  1787 0000123D 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1788 00001240 75DC                        jne .msdw0
  1789 00001242 4889EB                      mov rbx, rbp
  1790 00001245 E9B0FDFFFF                  jmp .msdDriverExit
  1791                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1792                                  ;Will write one sector at a time and then verify it.
  1793 0000124A B005                        mov al, 05h ;Bad request structure length
  1794 0000124C 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1795 0000124F 0F859FFDFFFF                jne .msdWriteErrorCode
  1796                                  
  1797 00001255 4889DD                      mov rbp, rbx
  1798 00001258 31F6                        xor esi, esi  ;Set counter to zero
  1799                                  .msdwv0:
  1800 0000125A B683                        mov dh, 83h ;LBA Write Sectors
  1801 0000125C E8EF000000                  call .msdBlkIOCommon
  1802 00001261 0F8215FDFFFF                jc .msdIOError    ;Error handler needs to add to esi the value in al
  1803 00001267 B684                        mov dh, 84h ;LBA Verify Sectors
  1804 00001269 E8E2000000                  call .msdBlkIOCommon
  1805 0000126E 0F8208FDFFFF                jc .msdIOError    ;Error handler needs to add to esi the value in al
  1806 00001274 4881451A00020000            add qword [rbp + ioReqPkt.strtsc], 200h  ;Add one sector
  1807 0000127C 4881450E00020000            add qword [rbp + ioReqPkt.bufptr], 200h  ;Add one sector
  1808 00001284 FFC6                        inc esi
  1809 00001286 3B7516                      cmp esi, dword [rbp + ioReqPkt.tfrlen]
  1810 00001289 75CF                        jne .msdwv0
  1811 0000128B 4889EB                      mov rbx, rbp
  1812 0000128E E967FDFFFF                  jmp .msdDriverExit
  1813                                  .msdIOCTLWrite:      ;Function 12, returns done
  1814 00001293 B005                        mov al, 05h ;Bad request structure length
  1815 00001295 803B2A                      cmp byte [rbx + drvReqHdr.hdrlen], ioReqPkt_size
  1816 00001298 0F8556FDFFFF                jne .msdWriteErrorCode
  1817                                  
  1818 0000129E E957FDFFFF                  jmp .msdDriverExit
  1819                                  .msdDevOpen:         ;Function 13
  1820 000012A3 B005                        mov al, 05h ;Bad request structure length
  1821 000012A5 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], openReqPkt_size
  1822 000012A8 0F8546FDFFFF                jne .msdWriteErrorCode
  1823                                  
  1824 000012AE 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1825 000012B3 488D0DBF000000              lea rcx, .msdHdlCnt
  1826 000012BA FE0401                      inc byte [rcx + rax]  ;Inc handle cnt for given unit
  1827 000012BD E938FDFFFF                  jmp .msdDriverExit
  1828                                  .msdDevClose:        ;Function 14
  1829 000012C2 B005                        mov al, 05h ;Bad request structure length
  1830 000012C4 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], closeReqPkt_size
  1831 000012C7 0F8527FDFFFF                jne .msdWriteErrorCode
  1832                                  
  1833 000012CD 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1834 000012D2 488D0DA0000000              lea rcx, .msdHdlCnt
  1835 000012D9 FE0C01                      dec byte [rcx + rax]  ;Dec handle cnt for given unit
  1836 000012DC E919FDFFFF                  jmp .msdDriverExit
  1837                                  .msdRemovableMedia:  ;Function 15
  1838 000012E1 B005                        mov al, 05h ;Bad request structure length
  1839 000012E3 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], remMediaReqPkt_size
  1840 000012E6 0F8508FDFFFF                jne .msdWriteErrorCode
  1841                                  
  1842 000012EC 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1843 000012F1 488D0D7C000000              lea rcx, .msdBIOSmap
  1844 000012F8 8A0401                      mov al, byte [rcx + rax]    ;Get BIOS number
  1845 000012FB A880                        test al, 80h
  1846 000012FD 0F84F7FCFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1847 00001303 66C743030002                mov word [rbx + remMediaReqPkt.status], 0200h ;Set Busy bit
  1848 00001309 E9ECFCFFFF                  jmp .msdDriverExit
  1849                                  .msdGenericIOCTL:    ;Function 19
  1850 0000130E B005                        mov al, 05h ;Bad request structure length
  1851 00001310 803B27                      cmp byte [rbx + drvReqHdr.hdrlen], ioctlReqPkt_size
  1852 00001313 0F85DBFCFFFF                jne .msdWriteErrorCode
  1853                                  
  1854 00001319 E9DCFCFFFF                  jmp .msdDriverExit
  1855                                  .msdGetLogicalDev:   ;Function 23
  1856 0000131E B005                        mov al, 05h ;Bad request structure length
  1857 00001320 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], getDevReqPkt_size
  1858 00001323 0F85CBFCFFFF                jne .msdWriteErrorCode
  1859                                  
  1860 00001329 8A0544000000                mov al, byte [.msdCurDev]
  1861 0000132F 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1862 00001332 E9C3FCFFFF                  jmp .msdDriverExit
  1863                                  .msdSetLogicalDev:   ;Function 24
  1864 00001337 B005                        mov al, 05h ;Bad request structure length
  1865 00001339 803B0D                      cmp byte [rbx + drvReqHdr.hdrlen], setDevReqPkt_size
  1866 0000133C 0F85B2FCFFFF                jne .msdWriteErrorCode
  1867                                  
  1868 00001342 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1869 00001345 880528000000                mov byte [.msdCurDev], al
  1870 0000134B E9AAFCFFFF                  jmp .msdDriverExit
  1871                                  
  1872                                  .msdBlkIOCommon:  ;Does block IO
  1873                                  ;Called with rbp containing old rbx value and ah with function number
  1874                                  ;Error handled by caller
  1875                                  ;Sector count handled by caller
  1876                                  ;Called with dh = BIOS function number
  1877 00001350 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1878 00001355 8A90[74130000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req in dl
  1879 0000135B 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1880 0000135F 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1881 00001363 88F4                        mov ah, dh
  1882 00001365 B001                        mov al, 01h ;Do one sector at a time 
  1883 00001367 CD33                        int 33h
  1884 00001369 C3                          ret
  1885                                  
  1886 0000136A 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1887                                  ;LASTDRIVE default is 5
  1888 00001373 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1889                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1890 00001374 FFFFFFFFFF              .msdBIOSmap  db 5 dup (0FFh) ;Translates DOS drive number to BIOS number
  1891 00001379 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1892 0000137E 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1892 00001387 000000000000000000-
  1892 00001390 000000000000000000-
  1892 00001399 000000000000000000-
  1892 000013A2 00000000           
  1893 000013A6 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1893 000013AF 000000000000000000-
  1893 000013B8 000000000000000000-
  1893 000013C1 000000000000000000-
  1893 000013CA 000000000000000000-
  1893 000013D3 000000000000000000-
  1893 000013DC 000000000000000000-
  1893 000013E5 000000000000000000-
  1893 000013EE 000000000000000000-
  1893 000013F7 000000000000000000-
  1893 00001400 000000000000000000-
  1893 00001409 000000000000000000-
  1893 00001412 000000000000000000-
  1893 0000141B 000000000000000000-
  1893 00001424 000000000000000000-
  1893 0000142D 000000000000000000-
  1893 00001436 000000000000000000-
  1893 0000143F 000000000000000000-
  1893 00001448 000000000000000000-
  1893 00001451 000000000000000000-
  1893 0000145A 000000000000000000-
  1893 00001463 000000000000000000-
  1893 0000146C 000000000000000000-
  1893 00001475 000000000000000000-
  1893 0000147E 000000000000000000-
  1893 00001487 000000000000000000-
  1893 00001490 000000000000000000-
  1893 00001499 000000000000000000-
  1893 000014A2 000000000000000000-
  1893 000014AB 000000000000000000-
  1893 000014B4 000000000000000000-
  1893 000014BD 000000000000000000-
  1893 000014C6 000000000000000000-
  1893 000014CF 000000000000000000-
  1893 000014D8 000000000000000000-
  1893 000014E1 000000000000000000-
  1893 000014EA 000000000000000000-
  1893 000014F3 000000000000000000-
  1893 000014FC 000000000000000000-
  1893 00001505 000000000000000000-
  1893 0000150E 000000000000000000-
  1893 00001517 000000000000000000-
  1893 00001520 000000000000000000-
  1893 00001529 000000000000000000-
  1893 00001532 000000000000000000-
  1893 0000153B 000000000000000000-
  1893 00001544 000000000000000000-
  1893 0000154D 000000000000000000-
  1893 00001556 000000000000000000-
  1893 0000155F 000000000000000000-
  1893 00001568 000000000000000000-
  1893 00001571 000000000000000000-
  1893 0000157A 000000000000000000-
  1893 00001583 000000000000000000-
  1893 0000158C 000000000000000000-
  1893 00001595 000000000000000000-
  1893 0000159E 000000000000000000-
  1893 000015A7 000000000000000000-
  1893 000015B0 000000000000000000-
  1893 000015B9 000000000000000000-
  1893 000015C2 000000000000000000-
  1893 000015CB 000000000000000000-
  1893 000015D4 000000000000000000-
  1893 000015DD 000000000000000000-
  1893 000015E6 000000000000000000-
  1893 000015EF 000000000000000000-
  1893 000015F8 000000000000       
  1894                                  
  1895                                  endptr equ $
