     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame   
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, rbp + 0
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> endstruc
   186                              <1> 
   187                              <1> %macro pushDOS 0
   188                              <1>     push r9
   189                              <1>     push r8
   190                              <1>     push rbp
   191                              <1>     push rdi
   192                              <1>     push rsi
   193                              <1>     push rdx
   194                              <1>     push rcx
   195                              <1>     push rbx
   196                              <1>     push rax
   197                              <1> %endmacro
   198                              <1> 
   199                              <1> %macro popDOS 0
   200                              <1>     pop rax
   201                              <1>     pop rbx
   202                              <1>     pop rcx
   203                              <1>     pop rdx
   204                              <1>     pop rsi
   205                              <1>     pop rdi
   206                              <1>     pop r8
   207                              <1>     pop r9
   208                              <1> %endmacro
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   requestHdr  resb ioReqPkt_size   
    12                                      ;The device driver header with space for the largest possible packet
    13 00000033 ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    14 0000003B ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    15 00000043 ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    16 0000004B ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    17 00000053 ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    18                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    19 0000005B ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    20                                      ;                    The last driver loaded with the STDIN bit[0] set
    21 00000063 ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    22 00000065 ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    23 0000006D ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    24 00000075 ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    25 0000007D ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    26 0000007F ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    27 00000080 ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    28 00000081 ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    29 00000082 <res 22h>                   nulDevHdr   resb drvHdr_size
    30                                  
    31                                  ;Swappable, process related data here
    32 000000A4 ??                          inDOS       resb 1    ;Inc on each DOS call, dec when leaving
    33 000000A5 ??                          breakFlag   resb 1    ;If set, check for CTRL+C on all DOS calls
    34 000000A6 ??                          defaultDrv  resb 1    ;Default, last accessed drive
    35 000000A7 ????????????????            currentPSP  resq 1    ;Address of current PSP
    36 000000AF ????????????????            oldRSP      resq 1    ;RSP value before stack switch
    37                                  
    38 000000B7 <res 528h>                  critStack   resq 165
    39 000005DF ????????????????            critStakTop resq 1
    40 000005E7 <res 638h>                  IOStack     resq 199
    41 00000C1F ????????????????            IOStakTop   resq 1
    42 00000C27 <res 638h>                  DiskStack   resq 199
    43 0000125F ????????????????            DiskStakTop resq 1
    44                                      dSegLen     equ     $
    45                                  
    46                                  Segment .text align=1
    47                                  ; We arrive here with the following values in the registers.
    48                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    49                                  ; dx  = Int 33h boot device number
    50                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    51 00000000 55AA                        dw 0AA55h           ;Initial signature
    52 00000002 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    53                                  
    54 0000000A B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    55 0000000F 0F32                        rdmsr
    56 00000011 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    57 00000013 48C1E720                    shl rdi, 20h        ;Shift high
    58 00000017 89C7                        mov edi, eax        ;Get the low dword in
    59                                  
    60 00000019 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    60 0000001E [00000000]         
    61 00000022 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    62 00000025 4881C7[67120000]            add rdi, dSegLen ;Move destination past end of data area
    63 0000002C 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    64 00000033 B900100000                  mov ecx, 1000h
    65 00000038 F348A5                      rep movsq
    66                                  
    67                                  ;Modify the pointers in nData before putting them in the data area
    68 0000003B 48012D77010000              add qword [nData + drvHdr.nxtPtr], rbp
    69 00000042 48012D7A010000              add qword [nData + drvHdr.strPtr], rbp
    70 00000049 48012D7B010000              add qword [nData + drvHdr.intPtr], rbp
    71                                  ;Copy the Null driver to its location in Sysvars
    72 00000050 B922000000                  mov ecx, drvHdr_size
    73 00000055 488D355D010000              lea rsi, qword [nData]
    74 0000005C 488DBD[82000000]            lea rdi, qword [rbp + nulDevHdr]
    75 00000063 F3A4                        rep movsb   
    76                                  
    77                                  ;Adjust the addresses in the other driver headers 
    78 00000065 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
    78 00000067 [A606000000000000] 
    79 0000006F B90C000000                  mov ecx, 12      ;12 drivers in data area
    80 00000074 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
    81                                  adjDrivers:
    82 00000078 E8C1000000                  call adjustDrvHdr
    83 0000007D E2F9                        loop adjDrivers
    84                                  
    85                                      ;Open NUL
    86 0000007F 488D9D[8C000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
    87 00000086 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
    88 00000089 30C0                        xor al, al
    89 0000008B FFD3                        call rbx
    90                                  
    91                                      ;Open CON
    92 0000008D 48BB-                       mov rbx, conDriver
    92 0000008F [5508000000000000] 
    93 00000097 488D5C1D00                  lea rbx, qword [rbp+rbx]
    94 0000009C 30C0                        xor al, al
    95 0000009E FFD3                        call rbx
    96                                  
    97                                      ;Open Mass Storage
    98 000000A0 48BB-                       mov rbx, msdDriver
    98 000000A2 [BB09000000000000] 
    99 000000AA 488D5C1D00                  lea rbx, qword [rbp+rbx]
   100 000000AF 30C0                        xor al, al
   101 000000B1 FFD3                        call rbx
   102                                  ;Adjust Int 41h address table
   103                                  
   104                                  adjInt41h:
   105 000000B3 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
   106 000000B8 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
   106 000000BA [9600000000000000] 
   107 000000C2 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
   108                                  .ai41h:
   109 000000C7 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
   110 000000CA 4881C308000000              add rbx, 8              ;Each entry is size 8
   111 000000D1 FFC9                        dec ecx
   112 000000D3 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
   113                                  
   114                                  ;Adjust Interrupt Entries Int 40h-49h
   115                                  adjInts:
   116 000000D5 B340                        mov bl, 40h
   117 000000D7 B807F00000                  mov eax, 0F007h ;Get the descriptor
   118 000000DC CD35                        int 35h
   119 000000DE B940000000                  mov ecx, 40h    ;Start from interrupt 40h
   120 000000E3 488D3D7F000000              lea rdi, intData
   121 000000EA 89C6                        mov esi, eax    ;Move segment selector info to esi
   122                                  .ai0:
   123 000000EC B808F00000                  mov eax, 0F008h ;Set the descriptor
   124 000000F1 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
   125 000000F4 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
   126 000000F7 CD35                        int 35h
   127 000000F9 4881C708000000              add rdi, 8
   128 00000100 FFC1                        inc ecx
   129 00000102 81F94A000000                cmp ecx, 4Ah
   130 00000108 75E2                        jne .ai0
   131                                  
   132                                  ;Test Error Case
   133 0000010A B430                        mov ah, 000110000b
   134 0000010C B000                        mov al, 00h
   135 0000010E BF0C000000                  mov edi, 0Ch
   136 00000113 CD44                        int 44h
   137                                  
   138 00000115 488D2D35000000              lea rbp, qword [startmsg]   ;Get the absolute address of message
   139 0000011C B804130000                  mov eax, 1304h
   140 00000121 CD30                        int 30h
   141                                  
   142 00000123 64488B3425-                 mov rsi, fs:[nulDevHdr]
   142 00000128 [82000000]         
   143 0000012C B801C50000                  mov eax, 0C501h ;Connect debugger
   144 00000131 CD35                        int 35h
   145                                  l1:
   146 00000133 6631C0                      xor ax, ax
   147 00000136 CD36                        int 36h
   148 00000138 B40E                        mov ah, 0Eh
   149 0000013A CD30                        int 30h
   150 0000013C EBF5                        jmp short l1
   151                                  adjustDrvHdr:
   152                                  ;Input: rsi = Effective address of driver in DOS segment
   153                                  ;       rbp = Ptr to the start of the DOS segment
   154                                  ;Output: rsi = EA of next header in DOS segment
   155 0000013E 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   156 00000141 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   157 00000145 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   158 00000149 4881C622000000              add rsi, drvHdr_size
   159 00000150 C3                          ret
   160                                  
   161 00000151 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,0
   161 0000015A 67205343502F444F53-
   161 00000163 2E2E2E0A0D00       
   162                                  intData:
   163 00000169 [5900000000000000]          dq terminateProcess ;Int 40h
   164 00000171 [5900000000000000]          dq functionDispatch ;Int 41h
   165 00000179 [E603000000000000]          dq terminateHandler ;Int 42h
   166 00000181 [E603000000000000]          dq ctrlCHandler     ;Int 43h
   167 00000189 [E603000000000000]          dq critErrorHandler ;Int 44h
   168 00000191 [6E06000000000000]          dq absDiskRead      ;Int 45h
   169 00000199 [8306000000000000]          dq absDiskWrite     ;Int 46h
   170 000001A1 [9806000000000000]          dq terminateResident    ;Int 47h
   171 000001A9 [9806000000000000]          dq inDosHandler     ;Int 48h
   172 000001B1 [9A06000000000000]          dq fastOutput       ;Int 49h
   173                                  nData:
   174 000001B9 [A606000000000000]          dq conHdr
   175 000001C1 0480                        dw 08004h
   176 000001C3 [4E08000000000000]          dq nulStrat
   177 000001CB [5408000000000000]          dq nulIntr
   178 000001D3 4E554C2020202020            db "NUL     " ;Default NUL data
   179                                  
   180                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   181                                  ;-----------------------------------:
   182                                  ;       Misc System routines        :
   183                                  ;-----------------------------------:
   184                                  findLRUBuffer: 
   185                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   186                                  ;Input: Nothing
   187                                  ;Output: rbx = Pointer to the buffer to use
   188 00000000 52                          push rdx
   189 00000001 488B1D(65000000)            mov rbx, qword [bufHeadPtr]
   190 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   191 0000000F 7502                        jne .flb1
   192 00000011 5A                          pop rdx
   193 00000012 C3                          ret
   194                                  .flb1:
   195 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   196 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   197 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   198 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   199 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   200 00000029 488B15(65000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   201 00000030 48891D(65000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   202 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   203 0000003A 5A                          pop rdx
   204 0000003B C3                          ret
   205                                  
   206                                  findDPB:
   207                                  ;Finds the DPB for a given drive
   208                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   209                                  ;Output: al = 00, rbx = Pointer to the DPB
   210                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   211 0000003C 488B1D(43000000)            mov rbx, qword [dpbHeadPtr]
   212                                  .fd1:
   213 00000043 30C0                        xor al, al
   214 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   215 00000047 740F                        je .fd2
   216 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   217 0000004D B0FF                        mov al, -1
   218 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   219 00000056 75EB                        jne .fd1
   220                                  .fd2:
   221 00000058 C3                          ret
   222                                  callCritError:
   223                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   224                                  ;-----------------------------------:
   225                                  ;       File System routines        :
   226                                  ;-----------------------------------:
   227                                  fatProc:
   228                                  ;-----------------------------------:
   229                                  ;        Interrupt routines         :
   230                                  ;-----------------------------------:
   231                                  terminateProcess:   ;Int 40h
   232                                  
   233                                  functionDispatch:   ;Int 41h Main function dispatcher
   234                                  ;ah = Function number, all other registers have various meanings
   235 00000059 FA                          cli ;Halt external interrupts
   236 0000005A 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   237 0000005D 7711                        ja .fdExitBad
   238 0000005F 80FC01                      cmp ah, 01h
   239 00000062 740E                        je .stdinReadEcho
   240 00000064 80FC02                      cmp ah, 02h
   241 00000067 7411                        je .stdoutWrite
   242 00000069 80FC09                      cmp ah, 09h
   243 0000006C 7414                        je .printString
   244 0000006E 48CF                        iretq
   245                                  .fdExit:
   246                                  .fdExitBad:
   247 00000070 48CF                        iretq
   248                                  .dispTerminate:     ;ah = 00h
   249                                  .stdinReadEcho:     ;ah = 01h
   250 00000072 30E4                        xor ah, ah
   251 00000074 CD36                        int 36h
   252 00000076 CD49                        int 49h ;Pass al to fast output
   253 00000078 48CF                        iretq
   254                                  .stdoutWrite:       ;ah = 02h
   255                                  ;Bspace is regular cursor left, does not insert a blank
   256 0000007A 50                          push rax
   257 0000007B 88D0                        mov al, dl
   258 0000007D CD49                        int 49h
   259 0000007F 58                          pop rax
   260 00000080 48CF                        iretq
   261                                  .stdauxRead:        ;ah = 03h
   262                                  .stdauxWrite:       ;ah = 04h
   263                                  .stdprnWrite:       ;ah = 05h
   264                                  .directCONIO:       ;ah = 06h
   265                                  .waitDirectInNoEcho:;ah = 07h
   266                                  .waitStdinNoEcho:   ;ah = 08h
   267                                  .printString:       ;ah = 09h
   268 00000082 50                          push rax
   269 00000083 52                          push rdx
   270                                  .ps0:
   271 00000084 8A02                        mov al, byte [rdx]
   272 00000086 3C24                        cmp al, "$"
   273 00000088 7407                        je .ps1
   274 0000008A 48FFC2                      inc rdx ;Goto next char
   275 0000008D CD49                        int 49h ;Print char in al
   276 0000008F EBF3                        jmp short .ps0
   277                                  .ps1:
   278 00000091 5A                          pop rdx
   279 00000092 58                          pop rax
   280 00000093 48CF                        iretq
   281                                  .buffStdinInput:    ;ah = 0Ah
   282                                  .checkStdinStatus:  ;ah = 0Bh
   283                                  .clearbuffDoFunc:   ;ah = 0Ch
   284                                  .diskReset:         ;ah = 0Dh
   285                                  .selectDisk:        ;ah = 0Eh
   286                                  .openFileFCB:       ;ah = 0Fh
   287                                  .closeFileFCB:      ;ah = 10h
   288                                  .findFirstFileFCB:  ;ah = 11h
   289                                  .findNextFileFCB:   ;ah = 12h
   290                                  .deleteFileFCB:     ;ah = 13h
   291                                  .sequentialReadFCB: ;ah = 14h
   292                                  .sequentialWriteFCB:;ah = 15h
   293                                  .createFileFCB:     ;ah = 16h
   294                                  .renameFileFCB:     ;ah = 17h
   295                                                      ;ah = 18h unused
   296                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   297                                  .setDTA:            ;ah = 1Ah
   298                                  .FATinfoDefault:    ;ah = 1Bh
   299                                  .FatinfoDevice:     ;ah = 1Ch
   300                                                      ;ah = 1Dh unused
   301                                                      ;ah = 1Eh unused
   302                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   303                                                      ;ah = 20h unused
   304                                  .randomReadFCB:     ;ah = 21h
   305                                  .randomWriteFCB:    ;ah = 22h
   306                                  .getFileSizeFCB:    ;ah = 23h
   307                                  .setRelRecordFCB:   ;ah = 24h
   308                                  .setIntVector:      ;ah = 25h
   309                                  .createNewPSP:      ;ah = 26h
   310                                  .randBlockReadFCB:  ;ah = 27h
   311                                  .randBlockWriteFCB: ;ah = 28h
   312                                  .parseFilenameFCB:  ;ah = 29h
   313                                  .getDate:           ;ah = 2Ah
   314                                  .setDate:           ;ah = 2Bh
   315                                  .getTime:           ;ah = 2Ch
   316                                  .setTime:           ;ah = 2Dh
   317                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   318                                  .getDTA:            ;ah = 2Fh
   319                                  .getDOSversion:     ;ah = 30h
   320                                  .terminateStayRes:  ;ah = 31h
   321                                  .getDeviceDPBptr:   ;ah = 32h
   322                                  .ctrlBreakCheck:    ;ah = 33h
   323                                  .getInDOSflagPtr:   ;ah = 34h
   324                                  .getIntVector:      ;ah = 35h
   325                                  .getDiskFreeSpace:  ;ah = 36h
   326                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   327                                  .getsetCountryInfo: ;ah = 38h, localisation info
   328                                  .makeDIR:           ;ah = 39h
   329                                  .removeDIR:         ;ah = 3Ah
   330                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   331                                  .createFileHdl:     ;ah = 3Ch, handle function
   332                                  .openFileHdl:       ;ah = 3Dh, handle function
   333                                  .closeFileHdl:      ;ah = 3Eh, handle function
   334                                  .readFileHdl:       ;ah = 3Fh, handle function
   335                                  .writeFileHdl:      ;ah = 40h, handle function
   336                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   337                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   338                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   339                                  .ioctrl:            ;ah = 44h, handle function
   340                                  .duplicateHandle:   ;ah = 45h, handle function
   341                                  .forceDuplicateHdl: ;ah = 46h, handle function
   342                                  .getCurrentDIR:     ;ah = 47h
   343                                  .allocateMemory:    ;ah = 48h
   344                                  .freeMemory:        ;ah = 49h
   345                                  .reallocMemory:     ;ah = 4Ah
   346                                  .loadExecChild:     ;ah = 4Bh, EXEC
   347                                  .terminateClean:    ;ah = 4Ch, EXIT
   348                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   349                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   350                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   351                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   352                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   353                                  .getSysVarsPtr:     ;ah = 52h
   354                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   355                                  .getVerifySetting:  ;ah = 54h
   356                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   357                                  .renameFile:        ;ah = 56h
   358                                  .getSetFileDateTime:;ah = 57h
   359                                  .getsetMallocStrat: ;ah = 58h
   360                                  .getExtendedError:  ;ah = 59h
   361                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   362                                  .createNewFile:     ;ah = 5Bh
   363                                  .lockUnlockFile:    ;ah = 5Ch
   364                                  .getCritErrorInfo:  ;ah = 5Dh
   365                                  .networkServices:   ;ah = 5Eh, do nothing
   366                                  .networkRedirection:;ah = 5Fh, do nothing
   367                                  .trueName:          ;ah = 60h, get fully qualified name
   368                                                      ;ah = 61h, reserved
   369                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   370                                                      ;ah = 63h, reserved
   371                                  .setDriverLookahead:;ah = 64h, reserved
   372                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   373                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   374                                  .setHandleCount:    ;ah = 67h
   375                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   376                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   377                                  .return:
   378 00000095 C3                          ret
   379                                  
   380                                  
   381                                  .dispatchTable:
   382 00000096 [7200000000000000]          dq .dispTerminate       ;AH = 00H, PROCESS MANAGEMENT
   383 0000009E [7200000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   384 000000A6 [7A00000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   385 000000AE [8200000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   386 000000B6 [8200000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   387 000000BE [8200000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   388 000000C6 [8200000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   389 000000CE [8200000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   390 000000D6 [8200000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   391 000000DE [8200000000000000]          dq .printString         ;AH = 09H, CHAR IO
   392 000000E6 [9500000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   393 000000EE [9500000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   394 000000F6 [9500000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   395 000000FE [9500000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   396 00000106 [9500000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   397 0000010E [9500000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   398 00000116 [9500000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   399 0000011E [9500000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   400 00000126 [9500000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   401 0000012E [9500000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   402 00000136 [9500000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   403 0000013E [9500000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   404 00000146 [9500000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   405 0000014E [9500000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   406 00000156 [9500000000000000]          dq .return              ;AH = 18H, RESERVED
   407 0000015E [9500000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   408 00000166 [9500000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   409 0000016E [9500000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   410 00000176 [9500000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   411 0000017E [9500000000000000]          dq .return              ;AH = 1DH, RESERVED
   412 00000186 [9500000000000000]          dq .return              ;AH = 1EH, RESERVED
   413 0000018E [9500000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   414 00000196 [9500000000000000]          dq .return              ;AH = 20H, RESERVED
   415 0000019E [9500000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   416 000001A6 [9500000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   417 000001AE [9500000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   418 000001B6 [9500000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   419 000001BE [9500000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   420 000001C6 [9500000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   421 000001CE [9500000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   422 000001D6 [9500000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   423 000001DE [9500000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   424 000001E6 [9500000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   425 000001EE [9500000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   426 000001F6 [9500000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   427 000001FE [9500000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   428 00000206 [9500000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   429 0000020E [9500000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   430 00000216 [9500000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   431 0000021E [9500000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   432 00000226 [9500000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   433 0000022E [9500000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   434 00000236 [9500000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   435 0000023E [9500000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   436 00000246 [9500000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   437 0000024E [9500000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   438 00000256 [9500000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   439 0000025E [9500000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   440 00000266 [9500000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   441 0000026E [9500000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   442 00000276 [9500000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   443 0000027E [9500000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   444 00000286 [9500000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   445 0000028E [9500000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   446 00000296 [9500000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   447 0000029E [9500000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   448 000002A6 [9500000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   449 000002AE [9500000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   450 000002B6 [9500000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   451 000002BE [9500000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   452 000002C6 [9500000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   453 000002CE [9500000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   454 000002D6 [9500000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   455 000002DE [9500000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   456 000002E6 [9500000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   457 000002EE [9500000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   458 000002F6 [9500000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   459 000002FE [9500000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   460 00000306 [9500000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   461 0000030E [9500000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   462 00000316 [9500000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   463 0000031E [9500000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   464 00000326 [9500000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   465 0000032E [9500000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   466 00000336 [9500000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   467 0000033E [9500000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   468 00000346 [9500000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   469 0000034E [9500000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   470 00000356 [9500000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   471 0000035E [9500000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   472 00000366 [9500000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   473 0000036E [9500000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   474 00000376 [9500000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   475 0000037E [9500000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   476 00000386 [9500000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   477 0000038E [9500000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   478 00000396 [9500000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   479 0000039E [9500000000000000]          dq .return              ;AH = 61H, RESERVED
   480 000003A6 [9500000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   481 000003AE [9500000000000000]          dq .return              ;AH = 63H, RESERVED
   482 000003B6 [9500000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   483 000003BE [9500000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   484 000003C6 [9500000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   485 000003CE [9500000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   486 000003D6 [9500000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   487 000003DE [9500000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   488                                  dispatchTableL  equ $ - .dispatchTable 
   489                                  
   490                                  terminateHandler:   ;Int 42h
   491                                  ctrlCHandler:       ;Int 43h
   492                                  critErrorHandler:   ;Int 44h
   493                                  ;User Stack in usage here, must be swapped to before this is called
   494                                  ;Entered with:  
   495                                  ;               AH = Critical Error Bitfield
   496                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   497                                  ;               Bit 6 - Reserved
   498                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   499                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   500                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   501                                  ;               Bits [2-1] = Affected Disk Error
   502                                  ;                     0 0   DOS area
   503                                  ;                     0 1   FAT area
   504                                  ;                     1 0   Directory area
   505                                  ;                     1 1   Data area
   506                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   507                                  ;               AL  = Failing drive number if AH[7] = 0
   508                                  ;               DIL = Error code for errorMsg
   509                                  ;               RSI = EA of Device Header for which device the error occured
   510                                  ;Return:
   511                                  ;               AL = 0 - Ignore the Error       (Ignore)
   512                                  ;                  = 1 - Retry the Operation    (Retry)
   513                                  ;                  = 2 - Terminate the Program  (Abort)
   514                                  ;                  = 3 - Fail the DOS call      (Fail)
   515 000003E6 53                          push rbx
   516 000003E7 51                          push rcx
   517 000003E8 52                          push rdx
   518 000003E9 57                          push rdi
   519 000003EA 56                          push rsi
   520 000003EB FC                          cld         ;Make String ops go forward
   521                                  
   522 000003EC 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   523 000003EF 488D1553020000              lea rdx, qword [.crlf]
   524 000003F6 B409                        mov ah, 09h ;Print String
   525 000003F8 CD41                        int 41h     ;Call DOS to print CRLF part of message
   526                                  
   527 000003FA 6681E7FF00                  and di, 00FFh   ;Zero the upper byte of DI just in case
   528 000003FF 480FB7FF                    movzx rdi, di
   529 00000403 4889FA                      mov rdx, rdi    ;Copy error code
   530 00000406 48C1E704                    shl rdi, 4  ;Multiply by 16
   531 0000040A 48D1E2                      shl rdx, 1  ;Multiply by 2
   532 0000040D 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   533 00000410 488D1523010000              lea rdx, qword [.errorMsgTable]
   534 00000417 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   535 0000041B B409                        mov ah, 09h ;Print String
   536 0000041D CD41                        int 41h     ;Call DOS to print first part of message
   537                                  
   538 0000041F 488D1505020000              lea rdx, qword [.readmsg]
   539 00000426 488D3D0D020000              lea rdi, qword [.writemsg]
   540 0000042D F6C701                      test bh, 1  ;Bit 0 is set if write operation
   541 00000430 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   542 00000434 B409                        mov ah, 09h ;Print String
   543 00000436 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   544                                  
   545 00000438 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   546 0000043B 0F85DF000000                jnz .charError
   547                                  ;Disk error continues here
   548 00000441 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   549 00000448 B409                        mov ah, 09h
   550 0000044A CD41                        int 41h
   551 0000044C 88DA                        mov dl, bl  ;Get zero based drive number into dl
   552 0000044E 80C241                      add dl, "A" ;Add ASCII code
   553 00000451 B402                        mov ah, 02h ;Print char in dl
   554 00000453 CD41                        int 41h
   555                                  .userInput:
   556 00000455 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   557 0000045C B409                        mov ah, 09h
   558 0000045E CD41                        int 41h
   559                                  ;Abort, Retry, Ignore, Fail is word order
   560                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   561                                  .userAbort:
   562                                  ;Abort is always an option
   563 00000460 488D15E5010000              lea rdx, qword [.abortmsg]
   564 00000467 B409                        mov ah, 09h
   565 00000469 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   566                                  .userRetry:
   567 0000046B F6C710                      test bh, 10h  ;Bit 4 is retry bit
   568 0000046E 7416                        jz .userIgnore    ;If clear, dont print message
   569 00000470 488D15ED010000              lea rdx, qword [.betweenMsg]
   570 00000477 B409                        mov ah, 09h
   571 00000479 CD41                        int 41h
   572 0000047B 488D15D7010000              lea rdx, qword [.retrymsg]
   573 00000482 B409                        mov ah, 09h
   574 00000484 CD41                        int 41h
   575                                  .userIgnore:
   576 00000486 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   577 00000489 7416                        jz .userFail
   578 0000048B 488D15D2010000              lea rdx, qword [.betweenMsg]
   579 00000492 B409                        mov ah, 09h
   580 00000494 CD41                        int 41h
   581 00000496 488D15B5010000              lea rdx, qword [.ignoremsg]
   582 0000049D B409                        mov ah, 09h
   583 0000049F CD41                        int 41h
   584                                  .userFail:
   585 000004A1 F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   586 000004A4 7416                        jz .userMsgEnd
   587 000004A6 488D15B7010000              lea rdx, qword [.betweenMsg]
   588 000004AD B409                        mov ah, 09h
   589 000004AF CD41                        int 41h
   590 000004B1 488D15A7010000              lea rdx, qword [.failmsg]
   591 000004B8 B409                        mov ah, 09h
   592 000004BA CD41                        int 41h
   593                                  .userMsgEnd:
   594 000004BC 488D15A4010000              lea rdx, qword [.endMsg]
   595 000004C3 B409                        mov ah, 09h
   596 000004C5 CD41                        int 41h
   597                                  ;Get user input now 
   598 000004C7 31C9                        xor ecx, ecx  ;4 Possible Responses
   599 000004C9 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   600 000004D0 B401                        mov ah, 01h ;STDIN without Console Echo
   601 000004D2 CD41                        int 41h ;Get char in al
   602 000004D4 3C61                        cmp al, "a" ;Chack if lowercase
   603 000004D6 7202                        jb .uip1    ;If the value is below, ignore subtraction
   604 000004D8 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   605                                  .uip1:
   606 000004DA AE                          scasb   ;Compare char to list, offset gives return code
   607 000004DB 740F                        je .validInput  ;If they are equal, ecx has return code
   608 000004DD FFC1                        inc ecx
   609 000004DF 81F904000000                cmp ecx, 4
   610 000004E5 75F3                        jne .uip1
   611 000004E7 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   612                                  .validInput:
   613 000004EC 88C8                        mov al, cl  ;Move the offset into .responses into al
   614                                  ;Now check if the input is permitted
   615 000004EE 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   616 000004F0 7427                        je .cehExit
   617 000004F2 84C0                        test al, al ;Check if 0 => Ignore
   618 000004F4 740F                        je .viIgnore
   619 000004F6 3C01                        cmp al, 1   ;Check if 1 => Retry
   620 000004F8 7416                        je .viRetry
   621                                  .viFail:    ;Fallthrough for fail (al = 3)
   622 000004FA F6C708                      test bh, 8  ;Bit 3 is Fail bit
   623 000004FD 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   624 00000503 EB14                        jmp short .cehExit
   625                                  .viIgnore:
   626 00000505 F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   627 00000508 0F8447FFFFFF                jz .userInput
   628 0000050E EB09                        jmp short .cehExit
   629                                  .viRetry:
   630 00000510 F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   631 00000513 0F843CFFFFFF                jz .userInput
   632                                  .cehExit:
   633 00000519 5E                          pop rsi
   634 0000051A 5F                          pop rdi
   635 0000051B 5A                          pop rdx
   636 0000051C 59                          pop rcx
   637 0000051D 5B                          pop rbx
   638 0000051E 48CF                        iretq
   639                                  .charError:
   640 00000520 B908000000                  mov ecx, 8  ;8 chars in device name
   641 00000525 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   642                                  .ce1:
   643 0000052C AC                          lodsb   ;Get a string char into al and inc rsi
   644 0000052D 88C2                        mov dl, al  ;Move char into dl
   645 0000052F B402                        mov ah, 02h
   646 00000531 CD41                        int 41h ;Print char
   647 00000533 E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   648 00000535 E91BFFFFFF                  jmp .userInput
   649                                  
   650                                  .errorMsgTable: ;Each table entry is 18 chars long
   651 0000053A 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   651 00000543 746563742024202020 
   652 0000054C 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   652 00000555 6E6974202420202020 
   653 0000055E 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   653 00000567 202420202020202020 
   654 00000570 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   654 00000579 6F6D6D616E64202420 
   655 00000582 44617461204572726F-                 db "Data Error $      "       ;Error 4
   655 0000058B 722024202020202020 
   656 00000594 426164205265717565-                 db "Bad Request $     "       ;Error 5
   656 0000059D 737420242020202020 
   657 000005A6 5365656B2024202020-                 db "Seek $            "       ;Error 6
   657 000005AF 202020202020202020 
   658 000005B8 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   658 000005C1 656469612024202020 
   659 000005CA 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   659 000005D3 7420466F756E642024 
   660 000005DC 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   660 000005E5 706572202420202020 
   661 000005EE 577269746520466175-                 db "Write Fault $     "       ;Error A
   661 000005F7 6C7420242020202020 
   662 00000600 52656164204661756C-                 db "Read Fault $      "       ;Error B
   662 00000609 742024202020202020 
   663 00000612 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   663 0000061B 61696C757265202420 
   664                                  
   665 00000624 64726976652024          .drive      db "drive $"
   666 0000062B 6572726F7220726561-     .readmsg    db "error reading $"
   666 00000634 64696E672024       
   667 0000063A 6572726F7220777269-     .writemsg   db "error writing $"
   667 00000643 74696E672024       
   668 00000649 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   669 0000064C 41626F727424            .abortmsg   db "Abort$" 
   670 00000652 49676E6F726524          .ignoremsg  db "Ignore$"
   671 00000659 526574727924            .retrymsg   db "Retry$"
   672 0000065F 4661696C24              .failmsg    db "Fail$"
   673 00000664 2C2024                  .betweenMsg db ", $"
   674 00000667 3F2024                  .endMsg     db "? $"
   675 0000066A 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   676                                  absDiskRead:        ;Int 45h
   677                                  ;al = Drive number
   678                                  ;rbx = Memory Buffer address
   679                                  ;ecx = Number of sectors to read (max 255 for now)
   680                                  ;rdx = Start LBA to read from
   681 0000066E 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   682 00000672 8A80[300C0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   683 00000678 4891                        xchg rax, rcx
   684 0000067A 4887CA                      xchg rcx, rdx
   685 0000067D B482                        mov ah, 82h
   686 0000067F CD33                        int 33h
   687 00000681 48CF                        iretq
   688                                  absDiskWrite:       ;Int 46h
   689 00000683 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   690 00000687 8A80[300C0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   691 0000068D 4891                        xchg rax, rcx
   692 0000068F 4887CA                      xchg rcx, rdx
   693 00000692 B483                        mov ah, 83h
   694 00000694 CD33                        int 33h
   695 00000696 48CF                        iretq
   696                                  terminateResident:  ;Int 47h
   697                                  inDosHandler:       ;Int 48h
   698                                  ;Called when DOS idle
   699 00000698 48CF                        iretq
   700                                  fastOutput:         ;Int 49h
   701                                  ;Called with char to transfer in al
   702 0000069A 50                          push rax
   703 0000069B B40E                        mov ah, 0Eh
   704 0000069D CD30                        int 30h
   705 0000069F 58                          pop rax
   706 000006A0 48CF                        iretq
   707                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   708 000006A2 48CF                        iretq
   709                                  multiplex:          ;Int 4Fh, kept as iretq for now
   710 000006A4 48CF                        iretq
   711                                  ;-----------------------------------:
   712                                  ;          Driver routines          :
   713                                  ;-----------------------------------:
   714                                  drivers:
   715                                  conHdr:
   716 000006A6 [C806000000000000]          dq auxHdr
   717 000006AE 1308                        dw 0813h
   718 000006B0 [3E08000000000000]          dq commonStrat
   719 000006B8 [5508000000000000]          dq conDriver
   720 000006C0 434F4E2020202020            db "CON     "
   721                                  auxHdr:
   722 000006C8 [EA06000000000000]          dq prnHdr
   723 000006D0 0080                        dw 08000h
   724 000006D2 [3E08000000000000]          dq commonStrat
   725 000006DA [1009000000000000]          dq com1Intr
   726 000006E2 4155582020202020            db "AUX     "
   727                                  prnHdr:
   728 000006EA [0C07000000000000]          dq clkHdr
   729 000006F2 40A0                        dw 0A040h
   730 000006F4 [3E08000000000000]          dq commonStrat
   731 000006FC [D807000000000000]          dq lpt1Hdr
   732 00000704 50524E2020202020            db "PRN     "
   733                                  clkHdr:
   734 0000070C [2E07000000000000]          dq msdHdr
   735 00000714 0880                        dw 08008h
   736 00000716 [3E08000000000000]          dq commonStrat
   737 0000071E [1009000000000000]          dq clkDriver
   738 00000726 434C4F434B242020            db "CLOCK$  "
   739                                  msdHdr:
   740 0000072E [5007000000000000]          dq com1Hdr
   741 00000736 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   742 00000738 [3E08000000000000]          dq commonStrat
   743 00000740 [BB09000000000000]          dq msdDriver
   744 00000748 0000000000000000            db 0,0,0,0,0,0,0,0
   745                                  com1Hdr:
   746 00000750 [7207000000000000]          dq com2Hdr
   747 00000758 0080                        dw 08000h
   748 0000075A [3E08000000000000]          dq commonStrat
   749 00000762 [1009000000000000]          dq com1Intr
   750 0000076A 434F4D3120202020            db "COM1    "
   751                                  com2Hdr:
   752 00000772 [9407000000000000]          dq com3Hdr
   753 0000077A 0080                        dw 08000h
   754 0000077C [3E08000000000000]          dq commonStrat
   755 00000784 [1909000000000000]          dq com2Intr
   756 0000078C 434F4D3220202020            db "COM2    "
   757                                  com3Hdr:
   758 00000794 [B607000000000000]          dq com4Hdr
   759 0000079C 0080                        dw 08000h
   760 0000079E [3E08000000000000]          dq commonStrat
   761 000007A6 [2209000000000000]          dq com3Intr
   762 000007AE 434F4D3320202020            db "COM3    "
   763                                  com4Hdr:
   764 000007B6 [D807000000000000]          dq lpt1Hdr
   765 000007BE 0080                        dw 08000h
   766 000007C0 [3E08000000000000]          dq commonStrat
   767 000007C8 [2B09000000000000]          dq com4Intr
   768 000007D0 434F4D3420202020            db "COM4    "
   769                                  lpt1Hdr:
   770 000007D8 [FA07000000000000]          dq lpt2Hdr
   771 000007E0 40A0                        dw 0A040h
   772 000007E2 [3E08000000000000]          dq commonStrat
   773 000007EA [AB09000000000000]          dq lptDriver
   774 000007F2 4C50543120202020            db "LPT1    "
   775                                  lpt2Hdr:
   776 000007FA [1C08000000000000]          dq lpt3Hdr
   777 00000802 40A0                        dw 0A040h
   778 00000804 [3E08000000000000]          dq commonStrat
   779 0000080C [AB09000000000000]          dq lptDriver
   780 00000814 4C50543220202020            db "LPT2    "
   781                                  lpt3Hdr:
   782 0000081C FFFFFFFFFFFFFFFF            dq -1
   783 00000824 40A0                        dw 0A040h
   784 00000826 [3E08000000000000]          dq commonStrat
   785 0000082E [AB09000000000000]          dq lptDriver
   786 00000836 4C50543320202020            dq "LPT3    "
   787                                  
   788                                  commonStrat:
   789                                  ;DOS calls this function with rbx=Ptr to request header
   790 0000083E 48891D01000000              mov qword [reqHdrPtr], rbx
   791 00000845 C3                          ret
   792 00000846 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   793                                  
   794                                  nulStrat:
   795 0000084E 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   796                                  nulIntr:
   797 00000854 C3                          ret
   798                                  
   799                                  conDriver:
   800 00000855 50                          push rax
   801 00000856 53                          push rbx
   802 00000857 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   803 0000085E 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   804 00000861 84C0                        test al, al
   805 00000863 7421                        jz conInit
   806 00000865 3C04                        cmp al, 4
   807 00000867 744D                        jz conRead
   808 00000869 3C05                        cmp al, 5
   809 0000086B 7466                        jz conNondestructiveRead
   810 0000086D 3C06                        cmp al, 6
   811 0000086F 740C                        jz conExit
   812 00000871 3C07                        cmp al, 7
   813 00000873 7471                        jz conFlushInputBuffers
   814 00000875 3C08                        cmp al, 8
   815 00000877 7479                        jz conWrite
   816 00000879 3C09                        cmp al, 9
   817 0000087B 7475                        jz conWrite
   818                                  ;All other cases fall through here
   819                                  conExit:
   820 0000087D 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   821 00000883 5B                          pop rbx
   822 00000884 58                          pop rax
   823 00000885 C3                          ret
   824                                  conInit:    ;Function 0
   825 00000886 52                          push rdx
   826                                      ;Flush keyboard buffer
   827                                  .ci0:
   828 00000887 B401                        mov ah, 01      ;Get buffer status
   829 00000889 CD36                        int 36h
   830 0000088B 7406                        jz .ci1      ;If zero clear => no more keys to read
   831 0000088D 30E4                        xor ah, ah
   832 0000088F CD36                        int 36h ;Read key to flush from buffer
   833 00000891 EBF4                        jmp short .ci0
   834                                  .ci1:
   835 00000893 B800050000                  mov eax, 0500h  ;Set page zero as the default page
   836 00000898 CD30                        int 30h
   837 0000089A B402                        mov ah, 02h
   838 0000089C 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   839 0000089E 88D7                        mov bh, dl      ;Set cursor for page 0
   840 000008A0 CD30                        int 30h
   841 000008A2 B707                        mov bh, 07h     ;Grey/Black attribs
   842 000008A4 B800060000                  mov eax, 0600h  ;Clear whole screen
   843 000008A9 CD30                        int 30h
   844 000008AB 5A                          pop rdx
   845 000008AC EBCF                        jmp short conExit
   846                                  conIORead:
   847 000008AE 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   848 000008B4 EBC7                        jmp short conExit
   849                                  conRead:    ;Function 4
   850 000008B6 57                          push rdi
   851 000008B7 51                          push rcx
   852 000008B8 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   853 000008BC 31C9                        xor ecx, ecx    ;Zero the char counter
   854                                  .cr1:
   855 000008BE 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   856 000008C1 7409                        je .cre2
   857 000008C3 31C0                        xor eax, eax
   858 000008C5 CD36                        int 36h
   859 000008C7 AA                          stosb   ;Store char in al into buffer and inc rdi
   860 000008C8 FFC1                        inc ecx
   861 000008CA EBF2                        jmp short .cr1
   862                                  .cre2:
   863 000008CC 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   864 000008CF 59                          pop rcx
   865 000008D0 5F                          pop rdi
   866 000008D1 EBAA                        jmp short conExit
   867                                  conNondestructiveRead:  ;Function 5
   868 000008D3 B401                        mov ah, 01h     ;Get key if exists
   869 000008D5 CD36                        int 36h
   870 000008D7 7405                        jz .cnr           ;If zero clear => no key, go forwards
   871                                      ;Keystroke available
   872 000008D9 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   873 000008DC EB9F                        jmp short conExit
   874                                  .cnr: ;No keystroke available
   875 000008DE 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   876 000008E4 EB97                        jmp short conExit
   877                                  conFlushInputBuffers:   ;Function 7
   878 000008E6 B401                        mov ah, 01      ;Get buffer status
   879 000008E8 CD36                        int 36h
   880 000008EA 7491                        jz conExit      ;If zero clear => no more keys to read
   881 000008EC 30E4                        xor ah, ah
   882 000008EE CD36                        int 36h ;Read key to flush from buffer
   883 000008F0 EBF4                        jmp short conFlushInputBuffers
   884                                  conWrite:   ;Function 8 and 9
   885 000008F2 56                          push rsi
   886 000008F3 51                          push rcx
   887 000008F4 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   888 000008F8 31C9                        xor ecx, ecx    ;Zero the char counter
   889                                  .cw1: 
   890 000008FA 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   891 000008FD 7407                        je .cw2
   892 000008FF AC                          lodsb   ;Get char into al, and inc rsi
   893 00000900 CD49                        int 49h ;Fast print char
   894 00000902 FFC1                        inc ecx
   895 00000904 EBF4                        jmp short .cw1 ;keep printing until all chars printed
   896                                  .cw2:
   897 00000906 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   898 00000909 59                          pop rcx
   899 0000090A 5E                          pop rsi
   900 0000090B E96DFFFFFF                  jmp conExit
   901                                  
   902                                  clkDriver:
   903                                  
   904                                  comDriver:
   905                                  com1Intr:
   906 00000910 C6059300000000              mov byte [comDevice], 0
   907 00000917 EB19                        jmp short comIntr
   908                                  com2Intr:
   909 00000919 C6058A00000001              mov byte [comDevice], 1
   910 00000920 EB10                        jmp short comIntr
   911                                  com3Intr:
   912 00000922 C6058100000002              mov byte [comDevice], 2
   913 00000929 EB07                        jmp short comIntr
   914                                  com4Intr:
   915 0000092B C6057800000003              mov byte [comDevice], 3
   916                                  comIntr:
   917 00000932 50                          push rax
   918 00000933 53                          push rbx
   919 00000934 51                          push rcx
   920 00000935 52                          push rdx
   921 00000936 56                          push rsi
   922 00000937 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
   923 0000093E 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   924 00000941 3C04                        cmp al, 4
   925 00000943 7418                        jz comRead
   926 00000945 3C05                        cmp al, 5
   927 00000947 7439                        jz comNondestructiveRead
   928 00000949 3C08                        cmp al, 8
   929 0000094B 743D                        jz comWrite
   930 0000094D 3C09                        cmp al, 9
   931 0000094F 7439                        jz comWrite
   932                                  ;All other cases fall through here
   933                                  comExit:
   934 00000951 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   935 00000957 5E                          pop rsi
   936 00000958 5A                          pop rdx
   937 00000959 59                          pop rcx
   938 0000095A 5B                          pop rbx
   939 0000095B 58                          pop rax
   940 0000095C C3                          ret
   941                                  comRead:
   942 0000095D 57                          push rdi
   943 0000095E 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   944 00000962 31C9                        xor ecx, ecx    ;Zero the char counter
   945                                  .cr1:
   946 00000964 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   947 00000967 7413                        je .cre2
   948 00000969 B802000000                  mov eax, 02h    ;Recieve 
   949 0000096E 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
   950 00000975 CD34                        int 34h ;Recieve Char
   951 00000977 AA                          stosb   ;Store char in al into buffer and inc rdi
   952 00000978 FFC1                        inc ecx
   953 0000097A EBE8                        jmp short .cr1
   954                                  .cre2:
   955 0000097C 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   956 0000097F 5F                          pop rdi
   957 00000980 EBCF                        jmp short comExit
   958                                  comNondestructiveRead:
   959 00000982 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
   960 00000988 EBC7                        jmp short comExit
   961                                  comWrite:
   962 0000098A 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   963 0000098E 31C9                        xor ecx, ecx    ;Zero the char counter
   964                                  .cw1: 
   965 00000990 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   966 00000993 7410                        je .cw2
   967 00000995 AC                          lodsb   ;Get char into al, and inc rsi
   968 00000996 B401                        mov ah, 01h ;Move function number into ah
   969 00000998 668B150B000000              mov dx, word [comDevice]
   970 0000099F CD34                        int 34h ;Transmit char
   971 000009A1 FFC1                        inc ecx
   972 000009A3 EBEB                        jmp short .cw1 ;keep printing until all chars printed
   973                                  .cw2:
   974 000009A5 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   975 000009A8 EBA7                        jmp short comExit
   976 000009AA 00                      comDevice   db 0
   977                                  
   978                                  lptDriver:    ;Drivers for LPT 1, 2, 3
   979 000009AB 57                          push rdi
   980 000009AC 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
   981 000009B3 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
   982 000009B9 5F                          pop rdi
   983 000009BA C3                          ret
   984                                  
   985                                  msdDriver:
   986 000009BB 50                          push rax
   987 000009BC 53                          push rbx
   988 000009BD 51                          push rcx
   989 000009BE 52                          push rdx
   990 000009BF 56                          push rsi
   991 000009C0 57                          push rdi
   992 000009C1 55                          push rbp
   993 000009C2 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
   994 000009C9 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
   995 000009CC 3C18                        cmp al, 24  ;Check cmd num is valid
   996 000009CE 776C                        ja .msdError
   997 000009D0 84C0                        test al, al
   998 000009D2 7476                        jz .msdInit
   999 000009D4 3C01                        cmp al, 01
  1000 000009D6 0F8409010000                jz .msdMedChk
  1001 000009DC 3C02                        cmp al, 02
  1002 000009DE 0F8442010000                jz .msdBuildBPB
  1003 000009E4 3C03                        cmp al, 03
  1004 000009E6 0F847B010000                jz .msdIOCTLRead
  1005 000009EC 3C04                        cmp al, 04
  1006 000009EE 0F8478010000                jz .msdRead
  1007 000009F4 3C08                        cmp al, 08
  1008 000009F6 0F8482010000                jz .msdWrite
  1009 000009FC 3C09                        cmp al, 09
  1010 000009FE 0F848C010000                jz .msdWriteVerify
  1011 00000A04 3C0C                        cmp al, 12
  1012 00000A06 0F849D010000                jz .msdIOCTLWrite
  1013 00000A0C 3C0D                        cmp al, 13
  1014 00000A0E 0F849A010000                jz .msdDevOpen
  1015 00000A14 3C0E                        cmp al, 14
  1016 00000A16 0F84A2010000                jz .msdDevClose
  1017 00000A1C 3C0F                        cmp al, 15
  1018 00000A1E 0F84AA010000                jz .msdRemovableMedia
  1019 00000A24 3C13                        cmp al, 19
  1020 00000A26 0F84C0010000                jz .msdGenericIOCTL
  1021 00000A2C 3C17                        cmp al, 23
  1022 00000A2E 0F84BD010000                jz .msdGetLogicalDev
  1023 00000A34 3C18                        cmp al, 24
  1024 00000A36 0F84C3010000                jz .msdSetLogicalDev
  1025                                  .msdError:
  1026                                  .msdDriverExit:
  1027 00000A3C 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1028 00000A42 5D                          pop rbp
  1029 00000A43 5F                          pop rdi
  1030 00000A44 5E                          pop rsi
  1031 00000A45 5A                          pop rdx
  1032 00000A46 59                          pop rcx
  1033 00000A47 5B                          pop rbx
  1034 00000A48 58                          pop rax
  1035 00000A49 C3                          ret
  1036                                  .msdInit:            ;Function 0
  1037 00000A4A CD31                        int 31h ;Get number of Int 33h devices in r8b
  1038 00000A4C 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1039 00000A50 4489C0                      mov eax, r8d
  1040 00000A53 3C01                        cmp al, 1
  1041 00000A55 7702                        ja .mi1
  1042 00000A57 FEC0                        inc al ;Make it two
  1043                                  .mi1:
  1044 00000A59 BA05000000                  mov edx, 5
  1045 00000A5E 39D0                        cmp eax, edx
  1046 00000A60 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1047 00000A63 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1048 00000A69 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1049 00000A6C 440005(7F000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1050 00000A73 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1051 00000A75 488D3DE6010000              lea rdi, qword [.msdBPBblks]
  1052 00000A7C 53                          push rbx
  1053                                  .mi2:
  1054 00000A7D 89EA                        mov edx, ebp
  1055 00000A7F 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1056 00000A86 31C9                        xor ecx, ecx    ;Sector 0
  1057 00000A88 B801820000                  mov eax, 8201h       ;Read 1 sector
  1058 00000A8D CD33                        int 33h
  1059 00000A8F 724E                        jc .msdInitError
  1060                                  
  1061 00000A91 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1062 00000A98 B90F000000                  mov ecx, bpbEx_size/8
  1063 00000A9D F348A5                      rep movsq   ;Move the BPB data into the right block
  1064                                  
  1065 00000AA0 FFC5                        inc ebp
  1066 00000AA2 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1067 00000AA5 75D6                        jne .mi2  ;No? Go again
  1068                                  
  1069 00000AA7 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1070 00000AAE 488D15AD010000              lea rdx, qword [.msdBPBblks]
  1071                                  .mi3:
  1072 00000AB5 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1073 00000AB8 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1074 00000ABF FFCD                        dec ebp
  1075 00000AC1 75F2                        jnz .mi3  ;If not zero yet, go again
  1076                                  
  1077 00000AC3 5B                          pop rbx
  1078 00000AC4 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1079 00000ACB 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1080 00000ACF 488D15E4030000              lea rdx, qword [driverDataPtr]
  1081 00000AD6 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1082 00000ADA E95DFFFFFF                  jmp .msdDriverExit
  1083                                  .msdInitError:
  1084 00000ADF 5B                          pop rbx
  1085 00000AE0 E957FFFFFF                  jmp .msdDriverExit
  1086                                  .msdMedChk:          ;Function 1
  1087                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1088                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1089                                  ; suffice.
  1090 00000AE5 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1091 00000AEA 8A90[300C0000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1092 00000AF0 F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1093 00000AF3 7528                        jnz .mmcNoChange
  1094                                  ;Now we test Media Descriptor
  1095 00000AF5 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1096 00000AF8 488B3CC5[3A0C0000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1097 00000B00 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1098 00000B03 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1099 00000B06 740C                        je .mmcUnsure
  1100                                  .mmcChange: ;Fail safe, always assume the device has changed
  1101 00000B08 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1102 00000B0C 48C7430F[260C0000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
  1103                                  .mmcUnsure:
  1104 00000B14 C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1105 00000B18 E91FFFFFFF                  jmp .msdDriverExit
  1106                                  .mmcNoChange:
  1107 00000B1D C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1108 00000B21 E916FFFFFF                  jmp .msdDriverExit
  1109                                  
  1110                                  .msdBuildBPB:        ;Function 2
  1111 00000B26 4889DE                      mov rsi, rbx
  1112 00000B29 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1113 00000B2E 8A90[300C0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1114 00000B34 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1115 00000B38 31C9                        xor ecx, ecx    ;Read Sector 0
  1116 00000B3A B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1117 00000B3F CD33                        int 33h
  1118 00000B41 7224                        jc .mbbpbError
  1119 00000B43 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1120 00000B46 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1121 00000B4B 488B3CC5[3A0C0000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1122 00000B53 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1123 00000B56 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1124 00000B5A B90F000000                  mov ecx, bpbEx_size/8
  1125 00000B5F F348A5                      rep movsq   ;Move the BPB data into the right space
  1126 00000B62 E9D5FEFFFF                  jmp .msdDriverExit
  1127                                  .mbbpbError:
  1128                                  .msdIOCTLRead:       ;Function 3, returns done
  1129 00000B67 E9D0FEFFFF                  jmp .msdDriverExit
  1130                                  .msdRead:            ;Function 4
  1131 00000B6C 4889DD                      mov rbp, rbx
  1132 00000B6F B482                        mov ah, 82h ;LBA Read Sectors
  1133 00000B71 E897000000                  call .msdBlkIOCommon
  1134 00000B76 4889EB                      mov rbx, rbp
  1135 00000B79 E9BEFEFFFF                  jmp .msdDriverExit
  1136                                  .msdWrite:           ;Function 8
  1137 00000B7E 4889DD                      mov rbp, rbx
  1138 00000B81 B483                        mov ah, 83h ;LBA Write Sectors
  1139 00000B83 E885000000                  call .msdBlkIOCommon
  1140 00000B88 4889EB                      mov rbx, rbp
  1141 00000B8B E9ACFEFFFF                  jmp .msdDriverExit
  1142                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1143 00000B90 4889DD                      mov rbp, rbx
  1144 00000B93 B483                        mov ah, 83h ;LBA Write Sectors
  1145 00000B95 E873000000                  call .msdBlkIOCommon
  1146 00000B9A B484                        mov ah, 84h ;LBA Verify Sectors
  1147 00000B9C E86C000000                  call .msdBlkIOCommon
  1148 00000BA1 4889EB                      mov rbx, rbp
  1149 00000BA4 E993FEFFFF                  jmp .msdDriverExit
  1150                                  .msdIOCTLWrite:      ;Function 12, returns done
  1151 00000BA9 E98EFEFFFF                  jmp .msdDriverExit
  1152                                  .msdDevOpen:         ;Function 13
  1153 00000BAE 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1154 00000BB3 FE80[350C0000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1155 00000BB9 E97EFEFFFF                  jmp .msdDriverExit
  1156                                  .msdDevClose:        ;Function 14
  1157 00000BBE 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1158 00000BC3 FE88[350C0000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1159 00000BC9 E96EFEFFFF                  jmp .msdDriverExit
  1160                                  .msdRemovableMedia:  ;Function 15
  1161 00000BCE 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1162 00000BD3 8A80[300C0000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1163 00000BD9 A880                        test al, 80h
  1164 00000BDB 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1165 00000BE1 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
  1166 00000BE7 E950FEFFFF                  jmp .msdDriverExit
  1167                                  .msdGenericIOCTL:    ;Function 19
  1168 00000BEC E94BFEFFFF                  jmp .msdDriverExit
  1169                                  .msdGetLogicalDev:   ;Function 23
  1170 00000BF1 8A0538000000                mov al, byte [.msdCurDev]
  1171 00000BF7 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1172 00000BFA E93DFEFFFF                  jmp .msdDriverExit
  1173                                  .msdSetLogicalDev:   ;Function 24
  1174 00000BFF 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1175 00000C02 880527000000                mov byte [.msdCurDev], al
  1176 00000C08 E92FFEFFFF                  jmp .msdDriverExit
  1177                                  
  1178                                  .msdBlkIOCommon:  ;Does block IO
  1179                                  ;Called with rbp containing old rbx value and ah with function number
  1180                                  ;Error handled by caller
  1181 00000C0D 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1182 00000C12 8A90[300C0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1183 00000C18 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1184 00000C1C 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
  1185 00000C1F 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1186 00000C23 CD33                        int 33h
  1187 00000C25 C3                          ret
  1188                                  
  1189 00000C26 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1190                                  ;LASTDRIVE default is 5
  1191 00000C2F 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1192                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1193 00000C30 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1194 00000C35 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1195 00000C3A 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1195 00000C43 000000000000000000-
  1195 00000C4C 000000000000000000-
  1195 00000C55 000000000000000000-
  1195 00000C5E 00000000           
  1196 00000C62 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1196 00000C6B 000000000000000000-
  1196 00000C74 000000000000000000-
  1196 00000C7D 000000000000000000-
  1196 00000C86 000000000000000000-
  1196 00000C8F 000000000000000000-
  1196 00000C98 000000000000000000-
  1196 00000CA1 000000000000000000-
  1196 00000CAA 000000000000000000-
  1196 00000CB3 000000000000000000-
  1196 00000CBC 000000000000000000-
  1196 00000CC5 000000000000000000-
  1196 00000CCE 000000000000000000-
  1196 00000CD7 000000000000000000-
  1196 00000CE0 000000000000000000-
  1196 00000CE9 000000000000000000-
  1196 00000CF2 000000000000000000-
  1196 00000CFB 000000000000000000-
  1196 00000D04 000000000000000000-
  1196 00000D0D 000000000000000000-
  1196 00000D16 000000000000000000-
  1196 00000D1F 000000000000000000-
  1196 00000D28 000000000000000000-
  1196 00000D31 000000000000000000-
  1196 00000D3A 000000000000000000-
  1196 00000D43 000000000000000000-
  1196 00000D4C 000000000000000000-
  1196 00000D55 000000000000000000-
  1196 00000D5E 000000000000000000-
  1196 00000D67 000000000000000000-
  1196 00000D70 000000000000000000-
  1196 00000D79 000000000000000000-
  1196 00000D82 000000000000000000-
  1196 00000D8B 000000000000000000-
  1196 00000D94 000000000000000000-
  1196 00000D9D 000000000000000000-
  1196 00000DA6 000000000000000000-
  1196 00000DAF 000000000000000000-
  1196 00000DB8 000000000000000000-
  1196 00000DC1 000000000000000000-
  1196 00000DCA 000000000000000000-
  1196 00000DD3 000000000000000000-
  1196 00000DDC 000000000000000000-
  1196 00000DE5 000000000000000000-
  1196 00000DEE 000000000000000000-
  1196 00000DF7 000000000000000000-
  1196 00000E00 000000000000000000-
  1196 00000E09 000000000000000000-
  1196 00000E12 000000000000000000-
  1196 00000E1B 000000000000000000-
  1196 00000E24 000000000000000000-
  1196 00000E2D 000000000000000000-
  1196 00000E36 000000000000000000-
  1196 00000E3F 000000000000000000-
  1196 00000E48 000000000000000000-
  1196 00000E51 000000000000000000-
  1196 00000E5A 000000000000000000-
  1196 00000E63 000000000000000000-
  1196 00000E6C 000000000000000000-
  1196 00000E75 000000000000000000-
  1196 00000E7E 000000000000000000-
  1196 00000E87 000000000000000000-
  1196 00000E90 000000000000000000-
  1196 00000E99 000000000000000000-
  1196 00000EA2 000000000000000000-
  1196 00000EAB 000000000000000000-
  1196 00000EB4 000000000000       
  1197                                  
  1198                                  driverDataPtr:
