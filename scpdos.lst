     1                                  [map all scpdos.map]
     2                                  [DEFAULT REL]
     3                                  BITS 64
     4                                  %include "driverStruc.inc"
     5                              <1> 
     6                              <1> ;-------------------------------------------------------;
     7                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     8                              <1> ; device driver related structures.                     ;
     9                              <1> ;-------------------------------------------------------;
    10                              <1> 
    11                              <1> struc drvHdr  ;Device Driver Header for character and block devices
    12                              <1> 
    13 00000000 ????????????????    <1>     .nxtPtr resq 1  ;Pointer to the next driver header, -1 if at the end
    14 00000008 ????                <1>     .attrib resw 1  ;Attribute Word
    15 0000000A ????????????????    <1>     .strPtr resq 1  ;Strategy Entry Pointer
    16 00000012 ????????????????    <1>     .intPtr resq 1  ;Interrupt Entry Pointer
    17 0000001A ????????????????    <1>     .drvNam resb 8  ;Driver name (Char) or Number of units byte (Block)
    18                              <1> 
    19                              <1> endstruc
    20                              <1> 
    21                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    22                              <1> 
    23                              <1>     .hdrlen resb 1  ;Length of the request header
    24                              <1>     .unitnm resb 1  ;Unit number, meaningless for character devs
    25                              <1>     .cmdcde resb 1  ;Command code
    26                              <1>     .status resw 1  ;Status word
    27                              <1>     .devptr resq 1  ;Device queue pointer field
    28                              <1> 
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> struc drvReqHdr
    32                              <1>     drvReqHdrM
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    33                              <1> endstruc
    34                              <1> 
    35                              <1> struc initReqPkt  ;Init Request Packet
    36                              <1> 
    37                              <1>     drvReqHdrM   ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    38 0000000D ??                  <1>     .numunt resb 1  ;Number of logical units (Block only, 0 for char)
    39 0000000E ????????????????    <1>     .endptr resq 1  ;Pointer to first free byte after driver
    40 00000016 ????????????????    <1>     .optptr resq 1  ;Pointer to the BPB array (block) or optional args (char)
    41 0000001E ??                  <1>     .drvnum resb 1  ;Drive number
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
    46                              <1> 
    47                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    48 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    49 0000000E ??                  <1>     .medret resb 1  ;Return byte (Has media been changed?)
    50 0000000F ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field
    51                              <1> 
    52                              <1> endstruc
    53                              <1> 
    54                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
    55                              <1> 
    56                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    57 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    58 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    59 00000016 ????????????????    <1>     .bpbptr resq 1  ;Pointer to the BPB
    60                              <1> 
    61                              <1> endstruc
    62                              <1> 
    63                              <1> struc ioReqPkt   ;IO Request Packet
    64                              <1> 
    65                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    66 0000000D ??                  <1>     .medesc resb 1  ;DOS media descriptor
    67 0000000E ????????????????    <1>     .bufptr resq 1  ;Transfer buffer
    68 00000016 ????????            <1>     .tfrlen resd 1  ;Number of Sectors/bytes to transfer
    69 0000001A ????????????????    <1>     .strtsc resq 1  ;Starting sector for transfer
    70 00000022 ????????????????    <1>     .desptr resq 1  ;Pointer to a valid volume id field if error
    71                              <1> 
    72                              <1> endstruc
    73                              <1> 
    74                              <1> struc nonDestInNoWaitReqPkt    ;Nondestructive Input No Wait Request Packet
    75                              <1>     
    76                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    77 0000000D ??                  <1>     .retbyt resb 1  ;Byte read non destructively
    78                              <1> 
    79                              <1> endstruc
    80                              <1> 
    81                              <1> struc statusReqPkt   ;Status Request Packet
    82                              <1> 
    83                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    84                              <1> 
    85                              <1> endstruc
    86                              <1> 
    87                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
    88                              <1> 
    89                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    90                              <1>      
    91                              <1> endstruc
    92                              <1> 
    93                              <1> struc openReqPkt ;Open Device Request Packet
    94                              <1> 
    95                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
    96                              <1>      
    97                              <1> endstruc
    98                              <1> 
    99                              <1> struc closeReqPkt ;Close Device Request Packet
   100                              <1> 
   101                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   102                              <1>      
   103                              <1> endstruc
   104                              <1> 
   105                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   106                              <1> 
   107                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   108                              <1>      
   109                              <1> endstruc
   110                              <1> 
   111                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   112                              <1> 
   113                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   114 0000000D ??                  <1>     .majfun resb 1  ;Major function number
   115 0000000E ??                  <1>     .minfun resb 1  ;Minor function number
   116 0000000F ????????????????    <1>     .rsival resq 1  ;Contents of RSI
   117 00000017 ????????????????    <1>     .rdival resq 1  ;Contents of RDI
   118 0000001F ????????????????    <1>     .ctlptr resq 1  ;Pointer to Generic IOCTL Request Packet
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   123                              <1>     
   124                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   125                              <1> 
   126                              <1> endstruc
   127                              <1> 
   128                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   129                              <1>     
   130                              <1>     drvReqHdrM    ;Common Driver Header Macro
    22                              <2> 
    23 00000000 ??                  <2>  .hdrlen resb 1
    24 00000001 ??                  <2>  .unitnm resb 1
    25 00000002 ??                  <2>  .cmdcde resb 1
    26 00000003 ????                <2>  .status resw 1
    27 00000005 ????????????????    <2>  .devptr resq 1
    28                              <2> 
   131                              <1> 
   132                              <1> endstruc
     5                                  %include "fatStruc.inc"
     6                              <1> 
     7                              <1> ;-------------------------------------------------------;
     8                              <1> ; This include file contains miscellaneous FAT driver   ;
     9                              <1> ; structures. exFAT will have it's own files at a later ;
    10                              <1> ; stage.                                                ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> struc bpb          ;FAT 12 and 16 BPB, SIZE: 62 bytes
    14                              <1> 
    15 00000000 ??????              <1>     .jmpBoot    resb 3 
    16 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    17 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    18 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    19 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    20 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    21 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    22 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    23 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    24 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT
    25 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    26 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    27 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    28 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    29                              <1> 
    30 00000024 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    31 00000025 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    32 00000026 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    33 00000027 ????????            <1>     .volID      resd 1  ;Volume serial number
    34 0000002B <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    35 00000036 ????????????????    <1>     .filSysType resb 8  ;File system type string
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> struc bpb32       ;FAT 32 BPB, SIZE: 90 bytes
    40                              <1> 
    41 00000000 ??????              <1>     .jmpBoot    resb 3
    42 00000003 ????????????????    <1>     .oemName    resb 8  ;OEM name
    43 0000000B ????                <1>     .bytsPerSec resw 1  ;Bytes per sector
    44 0000000D ??                  <1>     .secPerClus resb 1  ;Sectors per cluster
    45 0000000E ????                <1>     .revdSecCnt resw 1  ;Number of reserved sectors
    46 00000010 ??                  <1>     .numFATs    resb 1  ;Number of FATs on media
    47 00000011 ????                <1>     .rootEntCnt resw 1  ;Number of entries in Root directory
    48 00000013 ????                <1>     .totSec16   resw 1  ;Number of sectors on medium
    49 00000015 ??                  <1>     .media      resb 1  ;Media descriptor byte
    50 00000016 ????                <1>     .FATsz16    resw 1  ;Number of sectors per FAT, must be 0 for FAT 32
    51 00000018 ????                <1>     .secPerTrk  resw 1  ;Number of sectors per "track"
    52 0000001A ????                <1>     .numHeads   resw 1  ;Number of read "heads"
    53 0000001C ????????            <1>     .hiddSec    resd 1  ;Number of hidden sectors
    54 00000020 ????????            <1>     .totSec32   resd 1  ;32 bit count of sectors
    55                              <1> 
    56 00000024 ????????            <1>     .FATsz32    resd 1  ;32 bit count of sectors occupied by one FAT
    57 00000028 ????                <1>     .extFlags   resw 1  ;Extended Flags word
    58 0000002A ????                <1>     .FSver      resw 1  ;File system version word, must be 0
    59 0000002C ????????            <1>     .RootClus   resd 1  ;First Cluster of Root Directory
    60 00000030 ????                <1>     .FSinfo     resw 1  ;Sector number of FSINFO structure, usually 1
    61 00000032 ????                <1>     .BkBootSec  resw 1  ;Backup Boot sector, either 0 or 6
    62 00000034 <res Ch>            <1>     .reserved   resb 12 ;Reserved 12 bytes
    63                              <1> 
    64 00000040 ??                  <1>     .drvNum     resb 1  ;Logical drive number (00h or 80h)
    65 00000041 ??                  <1>     .reserved1  resb 1  ;Reserved byte
    66 00000042 ??                  <1>     .bootSig    resb 1  ;Extended boot signature (29h)
    67 00000043 ????????            <1>     .volID      resd 1  ;Volume serial number
    68 00000047 <res Bh>            <1>     .volLab     resb 11 ;Volume label string
    69 00000052 ????????????????    <1>     .filSysType resb 8  ;File system type string
    70                              <1> 
    71                              <1> endstruc
    72                              <1> 
    73                              <1> struc fatDirEntry
    74                              <1> 
    75 00000000 <res Bh>            <1>     .name       resb 11 ;8.3 File Name
    76 0000000B ??                  <1>     .attribute  resb 1  ;Usual attributes
    77 0000000C ??                  <1>     .ntRes      resb 1  ;Reserved 0
    78 0000000D ??                  <1>     .crtTimeT   resb 1  ;Count of tenths of a second of file creation time <=199
    79 0000000E ????                <1>     .crtTime    resb 2  ;Creation time, granularity of 2 seconds
    80 00000010 ????                <1>     .crtDate    resb 2  ;Creation date
    81 00000012 ????                <1>     .lastAccDat resb 2  ;Last Read/Write date
    82 00000014 ????                <1>     .fstClusHi  resb 2  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
    83 00000016 ????                <1>     .wrtTime    resb 2  ;Last modification (write) time
    84 00000018 ????                <1>     .wrtDate    resb 2  ;Last modification (write) date
    85 0000001A ????                <1>     .fstClusLo  resb 2  ;Lo word of 1st data cluster for file/dir
    86 0000001C ????????            <1>     .fileSize   resb 4  ;32-bit quantity with size of file described by entry
    87                              <1> 
    88                              <1> endstruc
    89                              <1> ;Directory attribute equates
    90                              <1>     dirReadOnly     equ 01h
    91                              <1>     dirHidden       equ 02h
    92                              <1>     dirSystem       equ 04h
    93                              <1>     dirVolumeID     equ 08h
    94                              <1>     dirDirectory    equ 10h
    95                              <1>     dirArchive      equ 20h
    96                              <1>     dirLongName     equ dirReadOnly | dirHidden | dirSystem | dirVolumeID
    97                              <1> 
    98                              <1> struc bpbEx   ;exFAT BPB, SIZE: 120 bytes
    99                              <1> 
   100 00000000 ??????              <1>     .jmpBoot                resb 3 
   101 00000003 ????????????????    <1>     .oemName                resb 8  ;OEM name
   102 0000000B <res 35h>           <1>     .MustBeZero             resb 53 ;Must be 0, 53 bytes
   103 00000040 ????????????????    <1>     .partitionOffset        resq 1  ;in sectors, 0 means ignore this field
   104 00000048 ????????????????    <1>     .volumeLength           resq 1  ;Volume Length in sectors
   105 00000050 ????????            <1>     .FAToffset              resd 1  ;Volume rel offset of first FAT, in sectors
   106 00000054 ????????            <1>     .FATlength              resd 1  ;FAT length, in sectors
   107 00000058 ????????            <1>     .clusterHeapOffset      resd 1  ;Start of data area, in sectors
   108 0000005C ????????            <1>     .clusterCount           resd 1  ;Number of clusters on medium
   109 00000060 ????????            <1>     .firstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
   110 00000064 ????????            <1>     .volumeSerialNum        resd 1  ;Volume Serial Number
   111 00000068 ????                <1>     .FSrevision             resw 1  ;Should be 0001 (v1.00)
   112 0000006A ????                <1>     .volumeFlags            resw 1  ;Volume Flags, refer to documentation
   113 0000006C ??                  <1>     .bytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
   114 0000006D ??                  <1>     .sectorsPerClusterShift resb 1  ;Result of log_2(N) for N=sec per clus
   115 0000006E ??                  <1>     .numberOfFATs           resb 1  ;Number of FATs, only 1 or 2
   116 0000006F ??                  <1>     .driveSelect            resb 1  ;Drive Select, 0 or 80h (Int 13h)
   117 00000070 ??                  <1>     .percentInUse           resb 1  ;Rounded down. FFh means unknown
   118 00000071 ??????????????      <1>     .reserved               resb 7  ;Reserved for alignment
   119                              <1> 
   120                              <1> endstruc
   121                              <1> 
   122                              <1> struc FSInfo
   123                              <1> 
   124 00000000 ????????            <1>     .leadSig    resb 4  ;Leading Signature, should be 041615252h
   125 00000004 <res 1E0h>          <1>     .reserved1  resb 480
   126 000001E4 ????????            <1>     .strucSig   resb 4  ;Should be 061417272h
   127 000001E8 ????????            <1>     .freeCount  resb 4  ;Contains the last known free cluster on volume
   128 000001EC ????????            <1>     .nextFree   resb 4  ;Contains the first known free cluster on volume
   129 000001F0 <res Ch>            <1>     .reserved2  resb 12 ;Should be 0
   130 000001FC ????????            <1>     .trailSig   resb 4  ;Should be 0AA550000h
   131                              <1> 
   132                              <1> endstruc
     6                                  %include "dosStruc.inc"
     7                              <1> 
     8                              <1> ;-------------------------------------------------------;
     9                              <1> ; This include file contains miscellaneous internal     ;
    10                              <1> ; SCP/DOS structures.                                   ;
    11                              <1> ;-------------------------------------------------------;
    12                              <1> 
    13                              <1> ;------------------------------------------------------------------------;
    14                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
    15                              <1> ; its file system structure. This is used to locate files and structures
    16                              <1> ; on the device itself and to translate file requests to cluster chains
    17                              <1> ; to LBAs to pass to the disk driver..
    18                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    19                              <1> ; drivers Initialise routine has been called.
    20                              <1> ;------------------------------------------------------------------------;
    21                              <1> struc dpb        ;Drive Parameter Block
    22                              <1> 
    23 00000000 ??                  <1>     .bDriveNumber            resb 1  ;Drive number (0=A, 1=B ...)
    24 00000001 ??                  <1>     .bUnitNumber             resb 1  ;Unit number in device
    25 00000002 ??                  <1>     .bBytesPerSectorShift    resb 1  ;min 9 (512 bps), max 12 (4096 bps)
    26 00000003 ??                  <1>     .bMaxSectorInCluster     resb 1  ;(Maximum sector in cluster) - 1
    27                              <1> ;                                       i.e. (2^bSectorsPerClusterShift) - 1
    28 00000004 ??                  <1>     .bSectorsPerClusterShift resb 1  ;Sectors per cluster exponent
    29 00000005 ????????            <1>     .dFAToffset              resd 1  ;Vol rel offset of first FAT, in sectors
    30 00000009 ??                  <1>     .bNumberOfFATs           resb 1  ;Number of FATs
    31 0000000A ????                <1>     .wNumberRootDirEntries   resw 1  ;In sectors
    32 0000000C ????????            <1>     .dClusterHeapOffset      resd 1  ;Start of data area, in sectors
    33 00000010 ????????            <1>     .dClusterCount           resd 1  ;Total number of clusters (volume size)
    34 00000014 ????????            <1>     .dFATlength              resd 1  ;FAT length, in sectors
    35 00000018 ????????            <1>     .dFirstClusterOfRootDir  resd 1  ;First Cluster of Root Directory, min 2
    36 0000001C ????????????????    <1>     .qDriverHeaderPtr        resq 1  ;Pointer to device driver header
    37 00000024 ??                  <1>     .bMediaDescriptor        resb 1  ;Media descriptor
    38 00000025 ??                  <1>     .bAccessFlag             resb 1  ;Access Flag (0 if accessed, else -1)
    39 00000026 ????????????????    <1>     .qNextDPBPtr             resq 1  ;Pointer to next DPB, -1 if at end
    40 0000002E ????????            <1>     .dFirstFreeCluster       resd 1  ;Starting cluster of free space search
    41 00000032 ????????            <1>     .dNumberOfFreeClusters   resd 1  ;Number of free clusters, -1 unknown
    42                              <1> 
    43                              <1> endstruc
    44                              <1> 
    45                              <1> ;------------------------------------------------------------------------;
    46                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    47                              <1> ; All disk pathing requests go via the CDS for that drive.
    48                              <1> ; The default drive is the last accessed drive, this number is stored
    49                              <1> ; in the DOS data area.
    50                              <1> ; The CDS is stored as an array with the offset into the array being 
    51                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    52                              <1> ;
    53                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    54                              <1> ;------------------------------------------------------------------------;
    55                              <1> struc cds       ;Current Directory structure
    56 00000000 <res 43h>           <1>     .sCurrentPath        resb 67    ;Current Directory Path String
    57 00000043 ????                <1>     .wFlags              resw 1 ;CDS Flags - 
    58 00000045 ????????????????    <1>     .qDPBPtr             resq 1 ;Ptr to the DPB of the dev using this CDS
    59 0000004D ????????            <1>     .dStartCluster       resd 1 ;Starting cluster of the directory on disk
    60 00000051 ????????????????    <1>     .qReserved           resq 1 ;Reserved for future expansions
    61 00000059 ????                <1>     .wBackslashOffset    resw 1 ;How many chars to start of current dir in the 
    62                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    63                              <1> ; another, we save the number of chars to skip to that deep level).
    64                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    65                              <1> ; Flags: Bit 15 set = Network drive
    66                              <1> ;        Bit 14 set = Physical drive
    67                              <1> ;        Bit 13 set = JOIN'ed drive
    68                              <1> ;        Bit 12 set = SUBST'ed drive
    69                              <1> ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
    70                              <1> endstruc
    71                              <1> ;CDS equates
    72                              <1>     cdsNetDrive     equ 8000h
    73                              <1>     cdsPhysDrive    equ 4000h
    74                              <1>     cdsJoinDrive    equ 2000h
    75                              <1>     cdsSubstDrive   equ 1000h
    76                              <1>     cdsRedirDrive   equ 0080h
    77                              <1> ;------------------------------------------------------------------------;
    78                              <1> ; The SFT is a way to allow applications to open file handles to files 
    79                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    80                              <1> ; under the first header, and then a second header will be linked to the 
    81                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    82                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    83                              <1> ; using the FCBS= command. Default FCBS=5.
    84                              <1> ;
    85                              <1> ; A file handle describes the file, and the location within the file that
    86                              <1> ; we are reading. The file handle can be manipulated without the file
    87                              <1> ; being in memory, thus allowing the user to access data without needing 
    88                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    89                              <1> ; accessing devices, by treating them as files with their drivers 
    90                              <1> ; responding and translating the manipulations of the file handle itself.
    91                              <1> ; Neither the driver nor the application should see or use the SFT for
    92                              <1> ; the handle, as it is subject to change (and will change when file 
    93                              <1> ; sharing provisions are included). The DOS will make requests to the 
    94                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    95                              <1> ; track of the information in the SFT entry for that handle. 
    96                              <1> ;
    97                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    98                              <1> ; can point to the same file. It all depends on what the applications 
    99                              <1> ; want to do with the File.
   100                              <1> ;
   101                              <1> ; !!!!IMPORTANT!!!!
   102                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   103                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   104                              <1> ;
   105                              <1> ;Each SFT may look like this:
   106                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   107                              <1> ;            |                |
   108                              <1> ;       wNumFiles*sft    wNumFiles*sft
   109                              <1> ;
   110                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   111                              <1> ; System FCBs.
   112                              <1> ;
   113                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   114                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   115                              <1> ;
   116                              <1> ; DEFAULT FILES=15, MINIMUM FILES=5
   117                              <1> ; DEFAULT FCBS=5, MINIMUM FCBS=5
   118                              <1> ;------------------------------------------------------------------------;
   119                              <1> struc sfth   ;System file table header
   120                              <1> ; This is the SFT header.
   121                              <1> ; This structure comes before the start of the first file in the array/table.
   122 00000000 ????????????????    <1>     .qNextSFTPtr resq 1    ;Pointer to the next SFT
   123 00000008 ????                <1>     .wNumFiles   resw 1    ;Number of files in this table
   124                              <1> endstruc
   125                              <1> 
   126                              <1> struc sft
   127                              <1> ;This is the file struc itself
   128 00000000 ????                <1>     .wNumHandles resw 1    ;Number of handles pointing to this file
   129 00000002 ????                <1>     .wOpenMode   resw 1    ;Bit 15 set if opened via FCB
   130 00000004 ??                  <1>     .bFileAttrib resb 1    ;Regular File Attributes
   131 00000005 ????                <1>     .wDeviceInfo resw 1    ;Includes Device number
   132 00000007 ????????????????    <1>     .qPtr        resq 1    ;IF char, ptr to device driver, ELSE DPBptr
   133 0000000F ????????            <1>     .dStartClust resd 1    ;Start cluster of file
   134 00000013 ????                <1>     .wTime       resw 1    ;File Time
   135 00000015 ????                <1>     .wDate       resw 1    ;File Date
   136 00000017 ????????            <1>     .dFileSize   resd 1    ;File Size, in bytes
   137 0000001B ????????            <1>     .dCurntOff   resd 1    ;Current Offset in file, in bytes
   138 0000001F ????                <1>     .wRelClust   resw 1    ;Relative cluster in file of the last cluster accessed
   139 00000021 ????????            <1>     .dDirSect    resd 1    ;Relative number of sector containing directory entry 
   140 00000025 ??                  <1>     .bNumDirEnt  resb 1    ;Number of dir entry within sector (byte offset/32)
   141 00000026 <res Bh>            <1>     .sFCBName    resb 11   ;8.3 Filename
   142 00000031 ????????????????    <1>     .qPSPOwner   resq 1    ;Address of PSP of program which first opened this file
   143 00000039 ????????            <1>     .dAbsClusr   resd 1    ;Absolute cluster of last cluster accessed
   144                              <1> endstruc
   145                              <1> 
   146                              <1> ;------------------------------------------------------------------------;
   147                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   148                              <1> ; to an internal buffer, and then copying it to the specified location
   149                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   150                              <1> ; another request for the same sector from the same device is made, so 
   151                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   152                              <1> ; size, selected according to the largest detected sector size during 
   153                              <1> ; the initial loadup.
   154                              <1> ;
   155                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   156                              <1> ;
   157                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   158                              <1> ;------------------------------------------------------------------------;
   159                              <1> 
   160                              <1> struc bufferHdr
   161 00000000 ????????????????    <1>     .nextBufPtr  resq  1   ;Pointer to the next buffer in the chain or -1 at end
   162 00000008 ??                  <1>     .driveNumber resb  1   ;Drive number the buffer is used for
   163 00000009 ??                  <1>     .bufferFlags resb  1   ;Standard Flags
   164 0000000A ????????            <1>     .bufferLBA   resd  1   ;LBA the buffer contains
   165 0000000E ??                  <1>     .bufFATcopy  resb  1   ;Number of copies of the FAT to write (1 if non-FAT)
   166 0000000F ??                  <1>     .bufFAToff   resb  1   ;Sector offset of the backup copy of the FAT on disk
   167 00000010 ????????????????    <1>     .driveDPBPtr resq  1   ;Pointer to the device DPB block
   168                              <1> endstruc
   169                              <1> 
   170                              <1> ;------------------------------------------------------------------------;
   171                              <1> ; For Int 41h, the callers registers are saved on their stack in the 
   172                              <1> ; following order, thus allowing for return values to be placed in the 
   173                              <1> ; registers by accessing the caller register stack frame.
   174                              <1> ;------------------------------------------------------------------------;
   175                              <1> struc callerFrame
   176 00000000 ????????????????    <1>     .rax    resq 1  ;Bottom of frame, pointer to rax saved in oldRSP
   177 00000008 ????????????????    <1>     .rbx    resq 1    
   178 00000010 ????????????????    <1>     .rcx    resq 1
   179 00000018 ????????????????    <1>     .rdx    resq 1
   180 00000020 ????????????????    <1>     .rsi    resq 1
   181 00000028 ????????????????    <1>     .rdi    resq 1
   182 00000030 ????????????????    <1>     .rbp    resq 1
   183 00000038 ????????????????    <1>     .r8     resq 1  ;To be removed if truly not needed
   184 00000040 ????????????????    <1>     .r9     resq 1
   185                              <1> ;Pushed by Processor when invoked via Interrupt
   186 00000048 ????????????????    <1>     .rip    resq 1
   187 00000050 ????????????????    <1>     .cs     resq 1
   188 00000058 ????????????????    <1>     .flags  resq 1
   189                              <1> endstruc
   190                              <1> 
   191                              <1> %macro pushDOS 0
   192                              <1>     push r9
   193                              <1>     push r8
   194                              <1>     push rbp
   195                              <1>     push rdi
   196                              <1>     push rsi
   197                              <1>     push rdx
   198                              <1>     push rcx
   199                              <1>     push rbx
   200                              <1>     push rax
   201                              <1> %endmacro
   202                              <1> 
   203                              <1> %macro popDOS 0
   204                              <1>     pop rax
   205                              <1>     pop rbx
   206                              <1>     pop rcx
   207                              <1>     pop rdx
   208                              <1>     pop rsi
   209                              <1>     pop rdi
   210                              <1>     pop rbp
   211                              <1>     pop r8
   212                              <1>     pop r9
   213                              <1> %endmacro
   214                              <1> 
   215                              <1> struc psp
   216 00000000 ????                <1>     .return     resb 2  ;Should always be CDh 40h
   217 00000002 ????????????????    <1>     .startSeg   resq 1  ;Pointer to the start of the PSP
   218 0000000A ????????????????    <1>     .oldInt42h  resq 1  ;Int 42h pointer on overlay load
   219 00000012 ????????????????    <1>     .oldInt43h  resq 1  ;Int 43h pointer on overlay load
   220 0000001A ????????????????    <1>     .oldInt44h  resq 1  ;Int 44h pointer on overlay load
   221 00000022 ????????????????    <1>     .parentPtr  resq 1  ;Pointer to parent process PSP
   222 0000002A <res 14h>           <1>     .fHandles   resb 20 ;Main File handle array
   223 0000003E ????????????????    <1>     .envPtr     resq 1  ;Pointer to the environment
   224 00000046 ????????????????    <1>     .rspPtr     resq 1  ;Pointer to rsp on entry to Int 41h
   225 0000004E ????                <1>     .xtraHdlSz  resw 1  ;Additional File Handle array size
   226 00000050 ??????              <1>     .unixEntry  resb 3  ;Must always be CDh 41h CBh
   227 00000053 ????????????????    <1>     .prevPSP    resq 1  ;Pointer to the previous PSP in chain
   228 0000005B ????????????????    <1>     .xtraHdlPtr resq 1  ;Pointer to the extra handle array if needed
   229 00000063 ????????????????    <1>     .fcbPtr1    resq 1  ;Pointer to the first OS allocated FCB
   230 0000006B <res 15h>           <1>     .reserved   resb 21
   231 00000080 ??                  <1>     .charCount  resb 1  ;Number of characters in command tail
   232 00000081 <res 7Fh>           <1>     .progTail   resb 127 ;Default DTA/Program tail
   233                              <1> endstruc
   234                              <1> 
   235                              <1> struc mcb
   236 00000000 ??                  <1>     .mzbyte     resb 1  ;M=In use, Z=Free
   237 00000001 ????????????????    <1>     .processPtr resq 1  ;Points to the start of the process PSP
   238 00000009 ????????            <1>     .paragraphs resd 1  ;Gives the number of paras allocated to this process
   239 0000000D ??????              <1>     .reserved   resb 3
   240                              <1>     .program:
   241                              <1> endstruc
     7                                  
     8                                  Segment dSeg nobits align=1 
     9 00000000 ????????????????            dosSegPtr   resq 1    ;Pointer to the data Segment itself
    10 00000008 ??                          bootDrive   resb 1    ;The Int 33h device we booted from
    11 00000009 <res 2Ah>                   charReqHdr  resb ioReqPkt_size  ;Character IO Request header
    12 00000033 <res 2Ah>                   diskReqHdr  resb ioReqPkt_size  ;Disk Action Request header
    13                                      ;The device driver header with space for the largest possible packet
    14 0000005D ????????????????            sysVarsPtr  resq 1    ;Pointer to dpbHeadPtr, head of Sys Vars struc below
    15 00000065 ????????????????            mcbChainPtr resq 1    ;Pointer to the MCB chain
    16 0000006D ????????????????            dpbHeadPtr  resq 1    ;Pointer to the first DPB in the DPB chain
    17 00000075 ????????????????            sftHeadPtr  resq 1    ;Pointer to the first SFT header in SFT chain
    18 0000007D ????????????????            clockPtr    resq 1    ;Pointer to the current active CLOCK$ device header
    19                                      ;                    The last driver loaded with the CLOCK$ bit[3] set 
    20 00000085 ????????????????            conPtr      resq 1    ;Pointer to the current active CON device header 
    21                                      ;                    The last driver loaded with the STDIN bit[0] set
    22 0000008D ????                        maxBytesSec resw 1    ;Maximum number of bytes per sector (size of buffers)
    23 0000008F ????????????????            bufHeadPtr  resq 1    ;Pointer to the head of the disk buffer chain
    24 00000097 ????????????????            cdsHeadPtr  resq 1    ;Pointer to the head of the CDS array
    25 0000009F ????????????????            sfcbHeadPTr resq 1    ;Pointer to the head of the System FCB chain
    26 000000A7 ????                        numSafeSFCB resw 1    ;Number of protected FCBs (y in FCBS=x,y)
    27 000000A9 ??                          numMSDdrv   resb 1    ;Number of mass storage devices detected in system
    28 000000AA ??                          lastdrvNum  resb 1    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
    29 000000AB ??                          numJoinDrv  resb 1    ;Number of Joined Drives
    30 000000AC <res 22h>                   nulDevHdr   resb drvHdr_size
    31                                  
    32                                  ;Start of Swappable Data Area, this bit can remain static
    33 000000CE ??                          critErrFlag resb 1  ;Critical error flag, set on entry to INT 44h
    34 000000CF ??                          inDOS       resb 1  ;Inc on each DOS call, dec when leaving
    35 000000D0 ??                          errorDrv    resb 1  ;Drive on which error occured or FFh
    36 000000D1 ??                          errorLocus  resb 1  ;Where the error took place  
    37 000000D2 ????                        errorExt    resw 1  ;Extended Error Code
    38 000000D4 ??                          errorAction resb 1  ;Suggested action for error  
    39 000000D5 ??                          errorClass  resb 1  ;Error Class
    40                                  
    41 000000D6 ????????????????            currentDTA  resq 1  ;Address of the current DTA
    42 000000DE ????????????????            currentPSP  resq 1  ;Address of current PSP
    43 000000E6 ????????????????            rdiErrorPtr resq 1  ;Saves RDI value of last error
    44 000000EE ????????????????            xInt43hRSP  resq 1  ;Saves RSP across an Int 43h call
    45 000000F6 ????                        lastRetCode resw 1  ;Last return code returned by Int 41h/4Ch
    46 000000F8 ??                          currentDrv  resb 1  ;Default, last accessed drive
    47 000000F9 ??                          breakFlag   resb 1  ;If set, check for CTRL+C on all DOS calls
    48                                  ;SDA, needs to be replaced between processes
    49 000000FA ????????????????            xInt44hRSP  resq 1  ;RSP across an Int 44h call
    50                                  
    51 00000102 ??                          Int44RetVal resb 1  ;Saves a copy of the Int 44 return value
    52 00000103 ??                          Int44bitfld resb 1  ;Copies the bit field given to the Int 44h handler
    53 00000104 ??                          int48Flag   resb 1  ;If set, Int 48h should be called, if clear no
    54 00000105 ????????????????            oldoldRSP   resq 1  ;RSP at prev Int 41h entry if called from within Int 41h
    55 0000010D ????????????????            oldRSP      resq 1  ;RSP when entering Int 41h
    56 00000115 ????????????????            oldRBX      resq 1  ;Temp var to save value of rbx during an Int 41 call
    57                                  ;Time stuff
    58 0000011D ????????????                CLOCKrecrd  resb 6  ;Clock driver record
    59 00000123 ??                          dayOfMonth  resb 1  ;1 - 31 BCD
    60 00000124 ??                          monthOfYear resb 1  ;1 - 12 BCD
    61 00000125 ????                        years       resw 1  ;0000 - 9999 BCD
    62 00000127 ????                        yearsOffset resw 1  ;Current Year - 1980
    63 00000129 ????????                    daysOffset  resd 1  ;Days since 1-1-1980
    64 0000012D ??                          dayOfWeek   resb 1  ;0 = Sunday <-> 6 = Saturday
    65                                  
    66                                  ;Stacks
    67 0000012E <res 528h>                  critStack   resq 165
    68 00000656 ????????????????            critStakTop resq 1
    69 0000065E <res 638h>                  IOStack     resq 199
    70 00000C96 ????????????????            IOStakTop   resq 1
    71 00000C9E <res 638h>                  DiskStack   resq 199
    72 000012D6 ????????????????            DiskStakTop resq 1
    73                                      dSegLen     equ     $
    74                                  
    75                                  Segment .text align=1
    76                                  ; We arrive here with the following values in the registers.
    77                                  ; rbx =  LBA of first Logical Block after SCP/BIOS
    78                                  ; dx  = Int 33h boot device number
    79                                  ; fs  = userbase pointer (pointer to first usable block of RAM)
    80                                  tempPSP:    ;Here to allow the loader to use Int 41h once it is loaded high
    81 00000000 55AA                        dw 0AA55h           ;Initial signature
    82 00000002 909090909090909090-         db (100h-2) dup (90h)
    82 0000000B 909090909090909090-
    82 00000014 909090909090909090-
    82 0000001D 909090909090909090-
    82 00000026 909090909090909090-
    82 0000002F 909090909090909090-
    82 00000038 909090909090909090-
    82 00000041 909090909090909090-
    82 0000004A 909090909090909090-
    82 00000053 909090909090909090-
    82 0000005C 909090909090909090-
    82 00000065 909090909090909090-
    82 0000006E 909090909090909090-
    82 00000077 909090909090909090-
    82 00000080 909090909090909090-
    82 00000089 909090909090909090-
    82 00000092 909090909090909090-
    82 0000009B 909090909090909090-
    82 000000A4 909090909090909090-
    82 000000AD 909090909090909090-
    82 000000B6 909090909090909090-
    82 000000BF 909090909090909090-
    82 000000C8 909090909090909090-
    82 000000D1 909090909090909090-
    82 000000DA 909090909090909090-
    82 000000E3 909090909090909090-
    82 000000EC 909090909090909090-
    82 000000F5 909090909090909090-
    82 000000FE 9090               
    83 00000100 64881425[08000000]          mov byte fs:[bootDrive], dl ;Save the boot drive in memory
    84 00000108 488D15F1FEFFFF              lea rdx, qword [tempPSP]    ;Get the address of the tempPSP
    85 0000010F 6448891425-                 mov qword fs:[currentPSP], rdx
    85 00000114 [DE000000]         
    86                                  ;DOS allows for non-PARA aligned PSPs but DOS aligns all programs on PARA bndry
    87 00000118 B9000100C0                  mov ecx, 0C0000100h ;Read FS MSR
    88 0000011D 0F32                        rdmsr
    89 0000011F 89D7                        mov edi, edx        ;Get the hi dword, and clear the upper bytes
    90 00000121 48C1E720                    shl rdi, 20h        ;Shift high
    91 00000125 89C7                        mov edi, eax        ;Get the low dword in
    92                                  
    93 00000127 6448893C25-                 mov qword fs:[dosSegPtr], rdi 
    93 0000012C [00000000]         
    94 00000130 4889FD                      mov rbp, rdi    ;Save the start of dosSeg in rdx 
    95 00000133 4881C7[DE120000]            add rdi, dSegLen ;Move destination past end of data area
    96 0000013A 488D35(00000000)            lea rsi, section.resSeg.start  ;Get RIP relative address to copy high
    97 00000141 B900100000                  mov ecx, 1000h
    98 00000146 F348A5                      rep movsq
    99                                  
   100                                  ;Modify the pointers in nData before putting them in the data area
   101 00000149 48012D72010000              add qword [nData + drvHdr.nxtPtr], rbp
   102 00000150 48012D75010000              add qword [nData + drvHdr.strPtr], rbp
   103 00000157 48012D76010000              add qword [nData + drvHdr.intPtr], rbp
   104                                  ;Copy the Null driver to its location in Sysvars
   105 0000015E B922000000                  mov ecx, drvHdr_size
   106 00000163 488D3558010000              lea rsi, qword [nData]
   107 0000016A 488DBD[AC000000]            lea rdi, qword [rbp + nulDevHdr]
   108 00000171 F3A4                        rep movsb   
   109                                  
   110                                  ;Adjust the addresses in the other driver headers 
   111 00000173 48BE-                       mov rsi, conHdr ;Point to the first non-NUL dev in chain
   111 00000175 [B007000000000000] 
   112 0000017D B90C000000                  mov ecx, 12      ;12 drivers in data area
   113 00000182 488D342E                    lea rsi, qword [rsi + rbp]  ;Get effective addr of driver header
   114                                  adjDrivers:
   115 00000186 E8BC000000                  call adjustDrvHdr
   116 0000018B E2F9                        loop adjDrivers
   117                                  
   118                                      ;Open NUL
   119 0000018D 488D9D[B6000000]            lea rbx, qword [rbp + nulDevHdr + drvHdr.strPtr]    ;Get ptr to strat ptr
   120 00000194 488B1B                      mov rbx, qword [rbx]    ;Get strat ptr
   121 00000197 30C0                        xor al, al
   122 00000199 FFD3                        call rbx
   123                                  
   124                                      ;Open CON
   125 0000019B 48BB-                       mov rbx, conDriver
   125 0000019D [5F09000000000000] 
   126 000001A5 488D5C1D00                  lea rbx, qword [rbp+rbx]
   127 000001AA 30C0                        xor al, al
   128 000001AC FFD3                        call rbx
   129                                  
   130                                      ;Open Mass Storage
   131 000001AE 48BB-                       mov rbx, msdDriver
   131 000001B0 [C50A000000000000] 
   132 000001B8 488D5C1D00                  lea rbx, qword [rbp+rbx]
   133 000001BD 30C0                        xor al, al
   134 000001BF FFD3                        call rbx
   135                                  ;Adjust Int 41h address table
   136                                  
   137                                  adjInt41h:
   138 000001C1 B96A000000                  mov ecx, dispatchTableL/8 ;Number of elements in table
   139 000001C6 48BB-                       mov rbx, functionDispatch.dispatchTable ;Get EA of table
   139 000001C8 [9501000000000000] 
   140 000001D0 488D5C1D00                  lea rbx, qword [rbp+rbx]    ;Point to the start of the relocated table 
   141                                  .ai41h:
   142 000001D5 48012B                      add qword [rbx], rbp    ;Add base address value to entry in reloc table
   143 000001D8 4881C308000000              add rbx, 8              ;Each entry is size 8
   144 000001DF FFC9                        dec ecx
   145 000001E1 75F2                        jnz .ai41h  ;Keep looping until all entries have been adjusted
   146                                  
   147                                  ;Adjust Interrupt Entries Int 40h-49h
   148                                  adjInts:
   149 000001E3 B340                        mov bl, 40h
   150 000001E5 B807F00000                  mov eax, 0F007h ;Get the descriptor
   151 000001EA CD35                        int 35h
   152 000001EC B940000000                  mov ecx, 40h    ;Start from interrupt 40h
   153 000001F1 488D3D7A000000              lea rdi, intData
   154 000001F8 89C6                        mov esi, eax    ;Move segment selector info to esi
   155                                  .ai0:
   156 000001FA B808F00000                  mov eax, 0F008h ;Set the descriptor
   157 000001FF 488B1F                      mov rbx, qword [rdi]    ;Get address pointed to by rdi
   158 00000202 4801EB                      add rbx, rbp            ;Add the relocated base to rbx
   159 00000205 CD35                        int 35h
   160 00000207 4881C708000000              add rdi, 8
   161 0000020E FFC1                        inc ecx
   162 00000210 81F94A000000                cmp ecx, 4Ah
   163 00000216 75E2                        jne .ai0
   164                                  
   165                                  ;Test Error Case
   166 00000218 B430                        mov ah, 00110000b
   167 0000021A B000                        mov al, 00h
   168 0000021C BF0C000000                  mov edi, 0Ch
   169 00000221 CD44                        int 44h
   170                                  
   171                                  
   172 00000223 488D1530000000              lea rdx, qword [startmsg]   ;Get the absolute address of message
   173 0000022A B409                        mov ah, 09h
   174 0000022C CD41                        int 41h
   175                                  
   176 0000022E 64488B3425-                 mov rsi, fs:[nulDevHdr]
   176 00000233 [AC000000]         
   177 00000237 B801C50000                  mov eax, 0C501h ;Connect debugger
   178 0000023C CD35                        int 35h
   179 0000023E 6687DB                      xchg bx, bx
   180                                  l1:
   181 00000241 B401                        mov ah, 01h  ;Write with echo
   182 00000243 CD41                        int 41h
   183 00000245 EBFA                        jmp short l1
   184                                  adjustDrvHdr:
   185                                  ;Input: rsi = Effective address of driver in DOS segment
   186                                  ;       rbp = Ptr to the start of the DOS segment
   187                                  ;Output: rsi = EA of next header in DOS segment
   188 00000247 48012E                      add qword [rsi + drvHdr.nxtPtr], rbp    ;Adjust address
   189 0000024A 48016E0A                    add qword [rsi + drvHdr.strPtr], rbp
   190 0000024E 48016E12                    add qword [rsi + drvHdr.intPtr], rbp
   191 00000252 4881C622000000              add rsi, drvHdr_size
   192 00000259 C3                          ret
   193                                  
   194 0000025A 0A0D5374617274696E-     startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,"$"
   194 00000263 67205343502F444F53-
   194 0000026C 2E2E2E0A0D24       
   195                                  intData:
   196 00000272 [5900000000000000]          dq terminateProcess ;Int 40h
   197 0000027A [5900000000000000]          dq functionDispatch ;Int 41h
   198 00000282 [E504000000000000]          dq terminateHandler ;Int 42h
   199 0000028A [E504000000000000]          dq ctrlCHandler     ;Int 43h
   200 00000292 [E504000000000000]          dq critErrorHandler ;Int 44h
   201 0000029A [7807000000000000]          dq absDiskRead      ;Int 45h
   202 000002A2 [8D07000000000000]          dq absDiskWrite     ;Int 46h
   203 000002AA [A207000000000000]          dq terminateResident    ;Int 47h
   204 000002B2 [A207000000000000]          dq inDosHandler     ;Int 48h
   205 000002BA [A407000000000000]          dq fastOutput       ;Int 49h
   206                                  nData:
   207 000002C2 [B007000000000000]          dq conHdr
   208 000002CA 0480                        dw 08004h
   209 000002CC [5809000000000000]          dq nulStrat
   210 000002D4 [5E09000000000000]          dq nulIntr
   211 000002DC 4E554C2020202020            db "NUL     " ;Default NUL data
   212                                  
   213                                  Segment resSeg follows=.text align=1 vfollows=dSeg valign=1 
   214                                  ;-----------------------------------:
   215                                  ;       Misc System routines        :
   216                                  ;-----------------------------------:
   217                                  findLRUBuffer: 
   218                                  ;Finds least recently used buffer, links it and returns ptr to it in rbx
   219                                  ;Input: Nothing
   220                                  ;Output: rbx = Pointer to the buffer to use
   221 00000000 52                          push rdx
   222 00000001 488B1D(8F000000)            mov rbx, qword [bufHeadPtr]
   223 00000008 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
   224 0000000F 7502                        jne .flb1
   225 00000011 5A                          pop rdx
   226 00000012 C3                          ret
   227                                  .flb1:
   228 00000013 4889DA                      mov rdx, rbx    ;Save a ptr to the previous buffer header
   229 00000016 488B1A                      mov rbx, qword [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
   230 00000019 48813BFFFFFFFF              cmp qword [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
   231 00000020 75F1                        jne .flb1   ;If not LRU, keep walking, else process
   232 00000022 48C702FFFFFFFF              mov qword [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
   233 00000029 488B15(8F000000)            mov rdx, qword [bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
   234 00000030 48891D(8F000000)            mov qword [bufHeadPtr], rbx    ;Sysvars to point to new buffer
   235 00000037 488913                      mov qword [rbx + bufferHdr.nextBufPtr], rdx
   236 0000003A 5A                          pop rdx
   237 0000003B C3                          ret
   238                                  
   239                                  findDPB:
   240                                  ;Finds the DPB for a given drive
   241                                  ;Input:   dl = Drive number (0=A, 1=B etc...)
   242                                  ;Output: al = 00, rbx = Pointer to the DPB
   243                                  ;        al = -1, Failed, no DPB for device, rbx destroyed
   244 0000003C 488B1D(6D000000)            mov rbx, qword [dpbHeadPtr]
   245                                  .fd1:
   246 00000043 30C0                        xor al, al
   247 00000045 3813                        cmp byte [rbx + dpb.bDriveNumber], dl
   248 00000047 740F                        je .fd2
   249 00000049 488B5B26                    mov rbx, qword [rbx + dpb.qNextDPBPtr]
   250 0000004D B0FF                        mov al, -1
   251 0000004F 4881FBFFFFFFFF              cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
   252 00000056 75EB                        jne .fd1
   253                                  .fd2:
   254 00000058 C3                          ret
   255                                  callCritError:
   256                                  ;Common Procedure to swap stacks and call Critical Error Interrupt
   257                                  ;-----------------------------------:
   258                                  ;       File System routines        :
   259                                  ;-----------------------------------:
   260                                  name2Clust:
   261                                  ;Converts a file name to a first cluster number
   262                                  ;-----------------------------------:
   263                                  ;        Interrupt routines         :
   264                                  ;-----------------------------------:
   265                                  terminateProcess:   ;Int 40h
   266                                  
   267                                  functionDispatch:   ;Int 41h Main function dispatcher
   268                                  ;ah = Function number, all other registers have various meanings
   269 00000059 FA                          cli ;Halt external interrupts
   270 0000005A FC                          cld ;Ensure all string ops occur in the right direction
   271 0000005B 80FC6A                      cmp ah, dispatchTableL/8    ;Number of functions
   272 0000005E 0F870A010000                ja .fdExitBad
   273                                      ;Cherry pick functions
   274 00000064 80FC33                      cmp ah, 33h ;CTRL+BREAK check
   275 00000067 722C                        jb .fdInInt41   ;If below skip these checks
   276 00000069 0F8425010000                je .ctrlBreakCheck
   277 0000006F 80FC64                      cmp ah, 64h
   278 00000072 0F841C010000                je .setDriverLookahead  ;Reserved, but avoids usual Int 41h spiel
   279 00000078 771B                        ja .fdInInt41   ;If above, do usual Int41 entry
   280 0000007A 80FC51                      cmp ah, 51h
   281 0000007D 0F8411010000                je .getCurrProcessID    ;This an below are exactly the same
   282 00000083 80FC62                      cmp ah, 62h
   283 00000086 0F8408010000                je .getPSPaddr          ;Calls the above function
   284 0000008C 80FC50                      cmp ah, 50h
   285 0000008F 0F84FF000000                je .setCurrProcessID
   286                                  .fdInInt41:
   287                                      pushDOS ;Push the usual prologue registers
   192 00000095 4151                <1>  push r9
   193 00000097 4150                <1>  push r8
   194 00000099 55                  <1>  push rbp
   195 0000009A 57                  <1>  push rdi
   196 0000009B 56                  <1>  push rsi
   197 0000009C 52                  <1>  push rdx
   198 0000009D 51                  <1>  push rcx
   199 0000009E 53                  <1>  push rbx
   200 0000009F 50                  <1>  push rax
   288 000000A0 488B05(0D010000)            mov rax, qword [oldRSP]
   289 000000A7 488905(05010000)            mov qword [oldoldRSP], rax
   290 000000AE FE05(CF000000)              inc byte [inDOS]    ;Increment in DOS flag
   291 000000B4 488925(0D010000)            mov qword [oldRSP], rsp
   292 000000BB 58                          pop rax     ;Get old rax back
   293 000000BC 50                          push rax    ;and push it back onto the stack
   294                                      ;Here, we want to save oldRSP in the callers PSP
   295 000000BD 488D25(56060000)            lea rsp, critStakTop
   296 000000C4 FB                          sti         ;Reenable interrupts
   297                                  
   298 000000C5 C605(04010000)01            mov byte [int48Flag], 1 ;Make it ok to trigger Int 48h
   299                                  
   300 000000CC 48891D(15010000)            mov qword [oldRBX], rbx ;Need to do this as I might switch stacks later
   301 000000D3 0FB6DC                      movzx ebx, ah   ;Move the function number bl zero extended to rbx
   302 000000D6 C1E303                      shl ebx, 3      ;Multiply the function number by 8 for offset into table
   303 000000D9 50                          push rax        ;Push rax onto the stack
   304 000000DA 488D05B4000000              lea rax, qword [.dispatchTable]
   305 000000E1 4801C3                      add rbx, rax    ;Add dispatch table offset into rbx
   306 000000E4 58                          pop rax
   307 000000E5 488B1B                      mov rbx, qword [rbx]    ;Get the address from the dispatch table
   308                                  
   309 000000E8 84E4                        test ah, ah     ;Simple Terminate function?
   310 000000EA 741C                        jz .fddiskOp
   311 000000EC 80FC59                      cmp ah, 59h     ;Extended Error report?
   312 000000EF 7443                        je .fdGoToFunction  ;Bypass code that clears the error report
   313 000000F1 80FC0C                      cmp ah, 0Ch     ;Are we a char function?
   314 000000F4 7712                        ja .fddiskOp
   315                                  ;Char operations here
   316 000000F6 F605(CE000000)01            test byte [critErrFlag], 1  ;Are we in critical error?
   317 000000FD 7535                        jnz .fdGoToFunction         ;If we are, stay on Critical Error Stack
   318 000000FF 488D25(960C0000)            lea rsp, IOStakTop          ;Otherwise, switch to IO stack
   319 00000106 EB2C                        jmp short .fdGoToFunction
   320                                  .fddiskOp:
   321                                      ;Disk operations go here
   322                                      ;Clear up error info
   323 00000108 C605(D1000000)01            mov byte [errorLocus], 1    ;Reset to generic, unknown locus
   324 0000010F C605(CE000000)00            mov byte [critErrFlag], 0   ;Clear the Critical Error Flag
   325 00000116 C605(D0000000)FF            mov byte [errorDrv], -1     ;Set the drive which caused the error to none
   326                                  
   327 0000011D C605(04010000)00            mov byte [int48Flag], 0     ;Turn off the ability to trigger Int 48h
   328 00000124 488D25(D6120000)            lea rsp, DiskStakTop        ;Swap the stack to the Disk Transfer Stack
   329 0000012B F605(F9000000)FF            test byte [breakFlag], -1   ;Test if set
   330 00000132 7400                        jz .fdGoToFunction
   331                                  ; HANDLE CTRL+BREAK HERE!
   332                                  .fdGoToFunction:
   333 00000134 48871D(15010000)            xchg rbx, qword [oldRBX]    ;Put the call addr in oldRBX and get oldRBX back
   334                                      ;Potentially point rbp to caller reg frame for easy access of registers 
   335                                      ;mov rbp, qword [oldRSP]    ;Move rsp on entry into rbp
   336 0000013B FF15(15010000)              call qword [oldRBX]     ;Call the desired function, rax contains ret code
   337                                  .fdExit:
   338 00000141 FA                          cli     ;Redisable interrupts
   339                                      ;???
   340 00000142 FE0D(CF000000)              dec byte [inDOS]            ;Decrement the inDOS count
   341 00000148 488B25(0D010000)            mov rsp, qword [oldRSP]     ;Point rsp to old stack
   342 0000014F 48890424                    mov qword [rsp], rax    ;Put the ret code into its pos on the register frame
   343 00000153 488B05(05010000)            mov rax, qword [oldoldRSP]
   344 0000015A 488905(0D010000)            mov qword [oldRSP], rax
   345                                      popDOS  ;Pop the frame
   204 00000161 58                  <1>  pop rax
   205 00000162 5B                  <1>  pop rbx
   206 00000163 59                  <1>  pop rcx
   207 00000164 5A                  <1>  pop rdx
   208 00000165 5E                  <1>  pop rsi
   209 00000166 5F                  <1>  pop rdi
   210 00000167 5D                  <1>  pop rbp
   211 00000168 4158                <1>  pop r8
   212 0000016A 4159                <1>  pop r9
   346 0000016C 48CF                        iretq
   347                                  .fdExitBad:
   348 0000016E B400                        mov ah, 0
   349 00000170 48CF                        iretq
   350                                  .simpleTerminate:     ;ah = 00h
   351 00000172 C3                          ret
   352                                  .stdinReadEcho:     ;ah = 01h
   353 00000173 30E4                        xor ah, ah
   354 00000175 CD36                        int 36h
   355 00000177 CD49                        int 49h ;Pass al to fast output
   356 00000179 C3                          ret
   357                                  .stdoutWrite:       ;ah = 02h
   358                                  ;Bspace is regular cursor left, does not insert a blank
   359 0000017A 50                          push rax
   360 0000017B 88D0                        mov al, dl
   361 0000017D CD49                        int 49h
   362 0000017F 58                          pop rax
   363 00000180 C3                          ret
   364                                  .stdauxRead:        ;ah = 03h
   365                                  .stdauxWrite:       ;ah = 04h
   366                                  .stdprnWrite:       ;ah = 05h
   367                                  .directCONIO:       ;ah = 06h
   368                                  .waitDirectInNoEcho:;ah = 07h
   369                                  .waitStdinNoEcho:   ;ah = 08h
   370 00000181 C3                          ret
   371                                  .printString:       ;ah = 09h
   372 00000182 50                          push rax
   373 00000183 52                          push rdx
   374                                  .ps0:
   375 00000184 8A02                        mov al, byte [rdx]
   376 00000186 3C24                        cmp al, "$"
   377 00000188 7407                        je .ps1
   378 0000018A 48FFC2                      inc rdx ;Goto next char
   379 0000018D CD49                        int 49h ;Print char in al
   380 0000018F EBF3                        jmp short .ps0
   381                                  .ps1:
   382 00000191 5A                          pop rdx
   383 00000192 58                          pop rax
   384 00000193 C3                          ret
   385                                  .buffStdinInput:    ;ah = 0Ah
   386                                  .checkStdinStatus:  ;ah = 0Bh
   387                                  .clearbuffDoFunc:   ;ah = 0Ch
   388                                  .diskReset:         ;ah = 0Dh
   389                                  .selectDisk:        ;ah = 0Eh
   390                                  .openFileFCB:       ;ah = 0Fh
   391                                  .closeFileFCB:      ;ah = 10h
   392                                  .findFirstFileFCB:  ;ah = 11h
   393                                  .findNextFileFCB:   ;ah = 12h
   394                                  .deleteFileFCB:     ;ah = 13h
   395                                  .sequentialReadFCB: ;ah = 14h
   396                                  .sequentialWriteFCB:;ah = 15h
   397                                  .createFileFCB:     ;ah = 16h
   398                                  .renameFileFCB:     ;ah = 17h
   399                                                      ;ah = 18h unused
   400                                  .getCurrentDisk:       ;ah = 19h, get current default drive
   401                                  .setDTA:            ;ah = 1Ah
   402                                  .FATinfoDefault:    ;ah = 1Bh
   403                                  .FatinfoDevice:     ;ah = 1Ch
   404                                                      ;ah = 1Dh unused
   405                                                      ;ah = 1Eh unused
   406                                  .getCurrentDPBptr:  ;ah = 1Fh, simply calls int 41h ah = 32h with dl = 0
   407                                                      ;ah = 20h unused
   408                                  .randomReadFCB:     ;ah = 21h
   409                                  .randomWriteFCB:    ;ah = 22h
   410                                  .getFileSizeFCB:    ;ah = 23h
   411                                  .setRelRecordFCB:   ;ah = 24h
   412                                  .setIntVector:      ;ah = 25h
   413                                  .createNewPSP:      ;ah = 26h
   414                                  .randBlockReadFCB:  ;ah = 27h
   415                                  .randBlockWriteFCB: ;ah = 28h
   416                                  .parseFilenameFCB:  ;ah = 29h
   417                                  .getDate:           ;ah = 2Ah
   418                                  .setDate:           ;ah = 2Bh
   419                                  .getTime:           ;ah = 2Ch
   420                                  .setTime:           ;ah = 2Dh
   421                                  .setResetVerify:    ;ah = 2Eh, turns ALL writes to write + verify
   422                                  .getDTA:            ;ah = 2Fh
   423                                  .getDOSversion:     ;ah = 30h
   424                                  .terminateStayRes:  ;ah = 31h
   425                                  .getDeviceDPBptr:   ;ah = 32h
   426                                  .ctrlBreakCheck:    ;ah = 33h
   427                                  .getInDOSflagPtr:   ;ah = 34h
   428                                  .getIntVector:      ;ah = 35h
   429                                  .getDiskFreeSpace:  ;ah = 36h
   430                                  .getsetSwitchChar:  ;ah = 37h, allows changing default switch from / to anything
   431                                  .getsetCountryInfo: ;ah = 38h, localisation info
   432                                  .makeDIR:           ;ah = 39h
   433                                  .removeDIR:         ;ah = 3Ah
   434                                  .changeCurrentDIR:  ;ah = 3Bh, changes directory for current drive
   435                                  .createFileHdl:     ;ah = 3Ch, handle function
   436                                  .openFileHdl:       ;ah = 3Dh, handle function
   437                                  .closeFileHdl:      ;ah = 3Eh, handle function
   438                                  .readFileHdl:       ;ah = 3Fh, handle function
   439                                  .writeFileHdl:      ;ah = 40h, handle function
   440                                  .deleteFileHdl:     ;ah = 41h, handle function, delete from specified dir
   441                                  .movFileReadPtr:    ;ah = 42h, handle function, LSEEK
   442                                  .changeFileModeHdl: ;ah = 43h, handle function, CHMOD
   443                                  .ioctrl:            ;ah = 44h, handle function
   444                                  .duplicateHandle:   ;ah = 45h, handle function
   445                                  .forceDuplicateHdl: ;ah = 46h, handle function
   446                                  .getCurrentDIR:     ;ah = 47h
   447                                  .allocateMemory:    ;ah = 48h
   448                                  .freeMemory:        ;ah = 49h
   449                                  .reallocMemory:     ;ah = 4Ah
   450                                  .loadExecChild:     ;ah = 4Bh, EXEC
   451                                  .terminateClean:    ;ah = 4Ch, EXIT
   452                                  .getRetCodeChild:   ;ah = 4Dh, WAIT, get ret code of subprocess
   453                                  .findFirstFileHdl:  ;ah = 4Eh, handle function, Find First Matching File
   454                                  .findNextFileHdl:   ;ah = 4Fh, handle function, Find Next Matching File
   455                                  .setCurrProcessID:  ;ah = 50h, set current process ID
   456                                  .getCurrProcessID:  ;ah = 51h, get current process ID
   457                                  .getSysVarsPtr:     ;ah = 52h
   458                                  .createDPB:         ;ah = 53h, generates a DPB from a given BPB
   459                                  .getVerifySetting:  ;ah = 54h
   460                                  .createPSP:         ;ah = 55h, creates a PSP for a program
   461                                  .renameFile:        ;ah = 56h
   462                                  .getSetFileDateTime:;ah = 57h
   463                                  .getsetMallocStrat: ;ah = 58h
   464                                  .getExtendedError:  ;ah = 59h
   465                                  .createUniqueFile:  ;ah = 5Ah, attempts to make a file with a unique filename
   466                                  .createNewFile:     ;ah = 5Bh
   467                                  .lockUnlockFile:    ;ah = 5Ch
   468                                  .getCritErrorInfo:  ;ah = 5Dh
   469                                  .networkServices:   ;ah = 5Eh, do nothing
   470                                  .networkRedirection:;ah = 5Fh, do nothing
   471                                  .trueName:          ;ah = 60h, get fully qualified name
   472                                                      ;ah = 61h, reserved
   473                                  .getPSPaddr:        ;ah = 62h, gives PSP addr/Process ID
   474                                                      ;ah = 63h, reserved
   475                                  .setDriverLookahead:;ah = 64h, reserved
   476                                  .getExtLocalInfo:   ;ah = 65h, Get Extended Country Info
   477                                  .getsetGlobalCP:    ;ah = 66h, Get/Set Global Codepage, reserved
   478                                  .setHandleCount:    ;ah = 67h
   479                                  .commitFile:        ;ah = 68h, flushes buffers for handle to disk 
   480                                  .getsetDiskSerial:  ;ah = 69h, get/set disk serial number
   481                                  .return:
   482 00000194 C3                          ret
   483                                  
   484                                  
   485                                  .dispatchTable:
   486 00000195 [7201000000000000]          dq .simpleTerminate     ;AH = 00H, PROCESS MANAGEMENT
   487 0000019D [7301000000000000]          dq .stdinReadEcho       ;AH = 01H, CHAR IO
   488 000001A5 [7A01000000000000]          dq .stdoutWrite         ;AH = 02H, CHAR IO
   489 000001AD [8101000000000000]          dq .stdauxRead          ;AH = 03H, CHAR IO
   490 000001B5 [8101000000000000]          dq .stdauxWrite         ;AH = 04H, CHAR IO
   491 000001BD [8101000000000000]          dq .stdprnWrite         ;AH = 05H, CHAR IO
   492 000001C5 [8101000000000000]          dq .directCONIO         ;AH = 06H, CHAR IO
   493 000001CD [8101000000000000]          dq .waitDirectInNoEcho  ;AH = 07H, CHAR IO
   494 000001D5 [8101000000000000]          dq .waitStdinNoEcho     ;AH = 08H, CHAR IO
   495 000001DD [8201000000000000]          dq .printString         ;AH = 09H, CHAR IO
   496 000001E5 [9401000000000000]          dq .buffStdinInput      ;AH = 0AH, CHAR IO
   497 000001ED [9401000000000000]          dq .checkStdinStatus    ;AH = 0BH, CHAR IO
   498 000001F5 [9401000000000000]          dq .clearbuffDoFunc     ;AH = 0CH, CHAR IO
   499 000001FD [9401000000000000]          dq .diskReset           ;AH = 0DH, DISK MANAGEMENT
   500 00000205 [9401000000000000]          dq .selectDisk          ;AH = 0EH, DISK MANAGEMENT
   501 0000020D [9401000000000000]          dq .openFileFCB         ;AH = 0FH, FILE OPERATION       FCB
   502 00000215 [9401000000000000]          dq .closeFileFCB        ;AH = 10H, FILE OPERATION       FCB
   503 0000021D [9401000000000000]          dq .findFirstFileFCB    ;AH = 11H, FILE OPERATION       FCB
   504 00000225 [9401000000000000]          dq .findNextFileFCB     ;AH = 12H, FILE OPERATION       FCB
   505 0000022D [9401000000000000]          dq .deleteFileFCB       ;AH = 13H, FILE OPERATION       FCB
   506 00000235 [9401000000000000]          dq .sequentialReadFCB   ;AH = 14H, RECORD OPERATION     FCB
   507 0000023D [9401000000000000]          dq .sequentialWriteFCB  ;AH = 15H, RECORD OPERTAION     FCB
   508 00000245 [9401000000000000]          dq .createFileFCB       ;AH = 16H, FILE OPERATION       FCB
   509 0000024D [9401000000000000]          dq .renameFileFCB       ;AH = 17H, FILE OPERATION       FCB
   510 00000255 [9401000000000000]          dq .return              ;AH = 18H, RESERVED
   511 0000025D [9401000000000000]          dq .getCurrentDisk      ;AH = 19H, DISK MANAGEMENT
   512 00000265 [9401000000000000]          dq .setDTA              ;AH = 1AH, RECORD OPERATION     F/H
   513 0000026D [9401000000000000]          dq .FATinfoDefault      ;AH = 1BH, DISK MANAGEMENT
   514 00000275 [9401000000000000]          dq .FatinfoDevice       ;AH = 1CH, DISK MANAGEMENT
   515 0000027D [9401000000000000]          dq .return              ;AH = 1DH, RESERVED
   516 00000285 [9401000000000000]          dq .return              ;AH = 1EH, RESERVED
   517 0000028D [9401000000000000]          dq .getCurrentDPBptr    ;AH = 1FH, RESERVED INTERNAL, GET CURR DRIVE DPB PTR
   518 00000295 [9401000000000000]          dq .return              ;AH = 20H, RESERVED
   519 0000029D [9401000000000000]          dq .randomReadFCB       ;AH = 21H, RECORD OPERATION     FCB
   520 000002A5 [9401000000000000]          dq .randomWriteFCB      ;AH = 22H, RECORD OPERATION     FCB
   521 000002AD [9401000000000000]          dq .getFileSizeFCB      ;AH = 23H, FILE OPERATION       FCB
   522 000002B5 [9401000000000000]          dq .setRelRecordFCB     ;AH = 24H, RECORD OPERATION     FCB
   523 000002BD [9401000000000000]          dq .setIntVector        ;AH = 25H, MISC. SYS. FUNCTION
   524 000002C5 [9401000000000000]          dq .createNewPSP        ;AH = 26H, PROCESS MANAGEMENT
   525 000002CD [9401000000000000]          dq .randBlockReadFCB    ;AH = 27H, RECORD OPERATION     FCB
   526 000002D5 [9401000000000000]          dq .randBlockWriteFCB   ;AH = 28H, RECORD OPERATION     FCB
   527 000002DD [9401000000000000]          dq .parseFilenameFCB    ;AH = 29H, FILE OPERATION       FCB
   528 000002E5 [9401000000000000]          dq .getDate             ;AH = 2AH, TIME AND DATE
   529 000002ED [9401000000000000]          dq .setDate             ;AH = 2BH, TIME AND DATE
   530 000002F5 [9401000000000000]          dq .getTime             ;AH = 2CH, TIME AND DATE
   531 000002FD [9401000000000000]          dq .setTime             ;AH = 2DH, TIME AND DATE
   532 00000305 [9401000000000000]          dq .setResetVerify      ;AH = 2EH, DISK MANAGEMENT
   533 0000030D [9401000000000000]          dq .getDTA              ;AH = 2FH, RECORD OPERATION     F/H
   534 00000315 [9401000000000000]          dq .getDOSversion       ;AH = 30H, MISC. SYS. FUNCTION
   535 0000031D [9401000000000000]          dq .terminateStayRes    ;AH = 31H, PROCESS MANAGEMENT
   536 00000325 [9401000000000000]          dq .getDeviceDPBptr     ;AH = 32H, RESERVED INTERNAL, GET DEVICE DPB PTR
   537 0000032D [9401000000000000]          dq .ctrlBreakCheck      ;AH = 33H, MISC. SYS. FUNCTION
   538 00000335 [9401000000000000]          dq .getInDOSflagPtr     ;AH = 34H, RESERVED INTERNAL, GET PTR TO INDOS FLAG
   539 0000033D [9401000000000000]          dq .getIntVector        ;AH = 35H, MISC. SYS. FUNCTION
   540 00000345 [9401000000000000]          dq .getDiskFreeSpace    ;AH = 36H, DISK MANAGEMENT
   541 0000034D [9401000000000000]          dq .getsetSwitchChar    ;AH = 37H, RESERVED INTERNAL, CHANGE SWITCH CHAR
   542 00000355 [9401000000000000]          dq .getsetCountryInfo   ;AH = 38H, MISC. SYS. FUNCTION
   543 0000035D [9401000000000000]          dq .makeDIR             ;AH = 39H, DIRECTORY OPERATION
   544 00000365 [9401000000000000]          dq .removeDIR           ;AH = 3AH, DIRECTORY OPERATION
   545 0000036D [9401000000000000]          dq .changeCurrentDIR    ;AH = 3BH, DIRECTORY OPERATION
   546 00000375 [9401000000000000]          dq .createFileHdl       ;AH = 3CH, FILE OPERATION       HANDLE
   547 0000037D [9401000000000000]          dq .openFileHdl         ;AH = 3DH, FILE OPERATION       HANDLE
   548 00000385 [9401000000000000]          dq .closeFileHdl        ;AH = 3EH, FILE OPERATION       HANDLE
   549 0000038D [9401000000000000]          dq .readFileHdl         ;AH = 3FH, RECORD OPERATION     HANDLE
   550 00000395 [9401000000000000]          dq .writeFileHdl        ;AH = 40H, RECORD OPERATION     HANDLE
   551 0000039D [9401000000000000]          dq .deleteFileHdl       ;AH = 41H, FILE OPERATION       HANDLE
   552 000003A5 [9401000000000000]          dq .movFileReadPtr      ;AH = 42H, RECORD OPERATION     HANDLE
   553 000003AD [9401000000000000]          dq .changeFileModeHdl   ;AH = 43H, FILE OPERATION       HANDLE
   554 000003B5 [9401000000000000]          dq .ioctrl              ;AH = 44H, MISC. SYS. FUNCTION
   555 000003BD [9401000000000000]          dq .duplicateHandle     ;AH = 45H, FILE OPERATION       HANDLE
   556 000003C5 [9401000000000000]          dq .forceDuplicateHdl   ;AH = 46H, FILE OPERATION       HANDLE
   557 000003CD [9401000000000000]          dq .getCurrentDIR       ;AH = 47H, DIRECTORY OPERATION
   558 000003D5 [9401000000000000]          dq .allocateMemory      ;AH = 48H, MEMORY MANAGEMENT
   559 000003DD [9401000000000000]          dq .freeMemory          ;AH = 49H, MEMORY MANAGEMENT
   560 000003E5 [9401000000000000]          dq .reallocMemory       ;AH = 4AH, MEMORY MANAGEMENT
   561 000003ED [9401000000000000]          dq .loadExecChild       ;AH = 4BH, PROCESS MANAGEMENT
   562 000003F5 [9401000000000000]          dq .terminateClean      ;AH = 4CH, PROCESS MANAGEMENT
   563 000003FD [9401000000000000]          dq .getRetCodeChild     ;AH = 4DH, PROCESS MANAGEMENT
   564 00000405 [9401000000000000]          dq .findFirstFileHdl    ;AH = 4EH, FILE OPERATION       HANDLE
   565 0000040D [9401000000000000]          dq .findNextFileHdl     ;AH = 4FH, FILE OPERATION       HANDLE
   566 00000415 [9401000000000000]          dq .setCurrProcessID    ;AH = 50H, RESERVED INTERNAL, SET CURRENT PROCESS ID
   567 0000041D [9401000000000000]          dq .getCurrProcessID    ;AH = 51H, RESERVED INTERNAL, GET CURRENT PROCESS ID
   568 00000425 [9401000000000000]          dq .getSysVarsPtr       ;AH = 52H, RESERVED INTERNAL, GET SYSVARS POINTER
   569 0000042D [9401000000000000]          dq .createDPB           ;AH = 53H, RESERVED INTERNAL, TRANSLATE A BPB TO DPB
   570 00000435 [9401000000000000]          dq .getVerifySetting    ;AH = 54H, DISK MANAGEMENT
   571 0000043D [9401000000000000]          dq .createPSP           ;AH = 55H, RESERVED INTERNAL, CREATE A PSP
   572 00000445 [9401000000000000]          dq .renameFile          ;AH = 56H, FILE OPERATION       HANDLE
   573 0000044D [9401000000000000]          dq .getSetFileDateTime  ;AH = 57H, FILE OPERATION       HANDLE
   574 00000455 [9401000000000000]          dq .getsetMallocStrat   ;AH = 58H, MEMORY MANAGEMENT
   575 0000045D [9401000000000000]          dq .getExtendedError    ;AH = 59H, MISC. SYS. FUNCTION
   576 00000465 [9401000000000000]          dq .createUniqueFile    ;AH = 5AH, FILE OPERATION       HANDLE
   577 0000046D [9401000000000000]          dq .createNewFile       ;AH = 5BH, FILE OPERATION       HANDLE
   578 00000475 [9401000000000000]          dq .lockUnlockFile      ;AH = 5CH, RECORD OPERATION     HANDLE
   579 0000047D [9401000000000000]          dq .getCritErrorInfo    ;AH = 5DH, RESERVED INTERNAL, GET CRIT. ERROR DATA
   580 00000485 [9401000000000000]          dq .networkServices     ;AH = 5EH, RESERVED NETWORK FUNCTION
   581 0000048D [9401000000000000]          dq .networkRedirection  ;AH = 5FH, RESERVED NETWORK FUNCTION
   582 00000495 [9401000000000000]          dq .trueName            ;AH = 60H, RESERVED INTERNAL, GET TRUE NAME
   583 0000049D [9401000000000000]          dq .return              ;AH = 61H, RESERVED
   584 000004A5 [9401000000000000]          dq .getPSPaddr          ;AH = 62H, PROCESS MANAGEMENT
   585 000004AD [9401000000000000]          dq .return              ;AH = 63H, RESERVED
   586 000004B5 [9401000000000000]          dq .setDriverLookahead  ;AH = 64H, RESERVED INTERNAL, DRIVER LOOKAHEAD
   587 000004BD [9401000000000000]          dq .getExtLocalInfo     ;AH = 65H, MISC. SYS. FUNCTION
   588 000004C5 [9401000000000000]          dq .getsetGlobalCP      ;AH = 66H, MISC. SYS. FUNCTION
   589 000004CD [9401000000000000]          dq .setHandleCount      ;AH = 67H, FILE OPERAITON       F/H
   590 000004D5 [9401000000000000]          dq .commitFile          ;AH = 68H, FILE OPERATION       HANDLE
   591 000004DD [9401000000000000]          dq .getsetDiskSerial    ;AH = 69H, RESERVED INTERNAL, GET/SET DISK SER. NUM
   592                                  dispatchTableL  equ $ - .dispatchTable 
   593                                  
   594                                  terminateHandler:   ;Int 42h
   595                                  ctrlCHandler:       ;Int 43h
   596                                  critErrorHandler:   ;Int 44h
   597                                  ;User Stack in usage here, must be swapped to before this is called
   598                                  ;Entered with:  
   599                                  ;               AH = Critical Error Bitfield
   600                                  ;               Bit 7 = 0 - Disk Error, Bit 7 = 1 - Char Device Error
   601                                  ;               Bit 6 - Reserved
   602                                  ;               Bit 5 = 0 - IGNORE not allowed, Bit 5 = 1 - IGNORE allowed
   603                                  ;               Bit 4 = 0 - RETRY not allowed, Bit 4 = 1 - RETRY allowed
   604                                  ;               Bit 3 = 0 - FAIL not allowed, Bit 3 = 1 - FAIL allowed
   605                                  ;               Bits [2-1] = Affected Disk Error
   606                                  ;                     0 0   DOS area
   607                                  ;                     0 1   FAT area
   608                                  ;                     1 0   Directory area
   609                                  ;                     1 1   Data area
   610                                  ;               Bit 0 = 0 - Read Operation, Bit 0 = 1 - Write Operation
   611                                  ;               AL  = Failing drive number if AH[7] = 0
   612                                  ;               DIL = Error code for errorMsg
   613                                  ;               RSI = EA of Device Header for which device the error occured
   614                                  ;Return:
   615                                  ;               AL = 0 - Ignore the Error       (Ignore)
   616                                  ;                  = 1 - Retry the Operation    (Retry)
   617                                  ;                  = 2 - Terminate the Program  (Abort)
   618                                  ;                  = 3 - Fail the DOS call      (Fail)
   619 000004E5 53                          push rbx
   620 000004E6 51                          push rcx
   621 000004E7 52                          push rdx
   622 000004E8 57                          push rdi
   623 000004E9 56                          push rsi
   624 000004EA FC                          cld         ;Make String ops go forward
   625                                  
   626 000004EB 6689C3                      mov bx, ax  ;Save ah in bh and al in bl (if needed)
   627 000004EE 488D155E020000              lea rdx, qword [.crlf]
   628 000004F5 B409                        mov ah, 09h ;Print String
   629 000004F7 CD41                        int 41h     ;Call DOS to print CRLF part of message
   630                                  
   631 000004F9 81E7FF000000                and edi, 00FFh   ;Zero the upper bytes of DI just in case
   632 000004FF B90C000000                  mov ecx, 0Ch
   633 00000504 39CF                        cmp edi, ecx  ;Check if the error number is erroniously above Gen Error
   634 00000506 0F47F9                      cmova edi, ecx  ;If it is, move Gen Error into edi
   635 00000509 480FB7FF                    movzx rdi, di
   636 0000050D 4889FA                      mov rdx, rdi    ;Copy error code
   637 00000510 48C1E704                    shl rdi, 4  ;Multiply by 16
   638 00000514 48D1E2                      shl rdx, 1  ;Multiply by 2
   639 00000517 4801D7                      add rdi, rdx    ;Add the resultant multiplications
   640 0000051A 488D1523010000              lea rdx, qword [.errorMsgTable]
   641 00000521 488D143A                    lea rdx, qword [rdx+rdi]   ;Load EA to rdx
   642 00000525 B409                        mov ah, 09h ;Print String
   643 00000527 CD41                        int 41h     ;Call DOS to print first part of message
   644                                  
   645 00000529 488D1505020000              lea rdx, qword [.readmsg]
   646 00000530 488D3D0D020000              lea rdi, qword [.writemsg]
   647 00000537 F6C701                      test bh, 1  ;Bit 0 is set if write operation
   648 0000053A 480F45D7                    cmovnz rdx, rdi ;Move the correct r/w part of the message to rdx
   649 0000053E B409                        mov ah, 09h ;Print String
   650 00000540 CD41                        int 41h     ;Call DOS to print error reading/writing portion
   651                                  
   652 00000542 F6C780                      test bh, 80h    ;Test bit 7 for char/Disk assertation
   653 00000545 0F85DF000000                jnz .charError
   654                                  ;Disk error continues here
   655 0000054B 488D15DC010000              lea rdx, qword [.drive] ;Drive message
   656 00000552 B409                        mov ah, 09h
   657 00000554 CD41                        int 41h
   658 00000556 88DA                        mov dl, bl  ;Get zero based drive number into dl
   659 00000558 80C241                      add dl, "A" ;Add ASCII code
   660 0000055B B402                        mov ah, 02h ;Print char in dl
   661 0000055D CD41                        int 41h
   662                                  .userInput:
   663 0000055F 488D15ED010000              lea rdx, qword [.crlf]  ;Print new line
   664 00000566 B409                        mov ah, 09h
   665 00000568 CD41                        int 41h
   666                                  ;Abort, Retry, Ignore, Fail is word order
   667                                  ;Last message gets a ?, otherwise a comma followed by a 20h (space)
   668                                  .userAbort:
   669                                  ;Abort is always an option
   670 0000056A 488D15E5010000              lea rdx, qword [.abortmsg]
   671 00000571 B409                        mov ah, 09h
   672 00000573 CD41                        int 41h ;Call DOS to prompt user for ABORT option
   673                                  .userRetry:
   674 00000575 F6C710                      test bh, 10h  ;Bit 4 is retry bit
   675 00000578 7416                        jz .userIgnore    ;If clear, dont print message
   676 0000057A 488D15ED010000              lea rdx, qword [.betweenMsg]
   677 00000581 B409                        mov ah, 09h
   678 00000583 CD41                        int 41h
   679 00000585 488D15D7010000              lea rdx, qword [.retrymsg]
   680 0000058C B409                        mov ah, 09h
   681 0000058E CD41                        int 41h
   682                                  .userIgnore:
   683 00000590 F6C720                      test bh, 20h    ;Bit 5 is ignore bit
   684 00000593 7416                        jz .userFail
   685 00000595 488D15D2010000              lea rdx, qword [.betweenMsg]
   686 0000059C B409                        mov ah, 09h
   687 0000059E CD41                        int 41h
   688 000005A0 488D15B5010000              lea rdx, qword [.ignoremsg]
   689 000005A7 B409                        mov ah, 09h
   690 000005A9 CD41                        int 41h
   691                                  .userFail:
   692 000005AB F6C708                      test bh, 08h    ;Bit 3 is Fail bit
   693 000005AE 7416                        jz .userMsgEnd
   694 000005B0 488D15B7010000              lea rdx, qword [.betweenMsg]
   695 000005B7 B409                        mov ah, 09h
   696 000005B9 CD41                        int 41h
   697 000005BB 488D15A7010000              lea rdx, qword [.failmsg]
   698 000005C2 B409                        mov ah, 09h
   699 000005C4 CD41                        int 41h
   700                                  .userMsgEnd:
   701 000005C6 488D15A4010000              lea rdx, qword [.endMsg]
   702 000005CD B409                        mov ah, 09h
   703 000005CF CD41                        int 41h
   704                                  ;Get user input now 
   705 000005D1 31C9                        xor ecx, ecx  ;4 Possible Responses
   706 000005D3 488D3D9A010000              lea rdi, qword [.responses] ;Go to start of string
   707 000005DA B401                        mov ah, 01h ;STDIN without Console Echo
   708 000005DC CD41                        int 41h ;Get char in al
   709 000005DE 3C61                        cmp al, "a" ;Chack if lowercase
   710 000005E0 7202                        jb .uip1    ;If the value is below, ignore subtraction
   711 000005E2 2C20                        sub al, "a"-"A"  ;Turn the char into uppercase
   712                                  .uip1:
   713 000005E4 AE                          scasb   ;Compare char to list, offset gives return code
   714 000005E5 740F                        je .validInput  ;If they are equal, ecx has return code
   715 000005E7 FFC1                        inc ecx
   716 000005E9 81F904000000                cmp ecx, 4
   717 000005EF 75F3                        jne .uip1
   718 000005F1 E969FFFFFF                  jmp .userInput ;If valid char not found, keep waiting 
   719                                  .validInput:
   720 000005F6 88C8                        mov al, cl  ;Move the offset into .responses into al
   721                                  ;Now check if the input is permitted
   722 000005F8 3C02                        cmp al, 2   ;Check if abort, abort always permitted
   723 000005FA 7427                        je .cehExit
   724 000005FC 84C0                        test al, al ;Check if 0 => Ignore
   725 000005FE 740F                        je .viIgnore
   726 00000600 3C01                        cmp al, 1   ;Check if 1 => Retry
   727 00000602 7416                        je .viRetry
   728                                  .viFail:    ;Fallthrough for fail (al = 3)
   729 00000604 F6C708                      test bh, 8  ;Bit 3 is Fail bit
   730 00000607 0F8452FFFFFF                jz .userInput  ;If bit 3 is zero, prompt and get input again
   731 0000060D EB14                        jmp short .cehExit
   732                                  .viIgnore:
   733 0000060F F6C720                      test bh, 20h    ;Bit 5 is Ignore bit
   734 00000612 0F8447FFFFFF                jz .userInput
   735 00000618 EB09                        jmp short .cehExit
   736                                  .viRetry:
   737 0000061A F6C710                      test bh, 10h    ;Bit 4 is Retry bit
   738 0000061D 0F843CFFFFFF                jz .userInput
   739                                  .cehExit:
   740 00000623 5E                          pop rsi
   741 00000624 5F                          pop rdi
   742 00000625 5A                          pop rdx
   743 00000626 59                          pop rcx
   744 00000627 5B                          pop rbx
   745 00000628 48CF                        iretq
   746                                  .charError:
   747 0000062A B908000000                  mov ecx, 8  ;8 chars in device name
   748 0000062F 4881C61A000000              add rsi, drvHdr.drvNam  ;Get the address of the Drive name
   749                                  .ce1:
   750 00000636 AC                          lodsb   ;Get a string char into al and inc rsi
   751 00000637 88C2                        mov dl, al  ;Move char into dl
   752 00000639 B402                        mov ah, 02h
   753 0000063B CD41                        int 41h ;Print char
   754 0000063D E2F7                        loop .ce1   ;Keep looping until all 8 char device chars have been printed
   755 0000063F E91BFFFFFF                  jmp .userInput
   756                                  
   757                                  .errorMsgTable: ;Each table entry is 18 chars long
   758 00000644 57726974652050726F-                 db "Write Protect $   "       ;Error 0
   758 0000064D 746563742024202020 
   759 00000656 556E6B6E6F776E2055-                 db "Unknown Unit $    "       ;Error 1
   759 0000065F 6E6974202420202020 
   760 00000668 4E6F74205265616479-                 db "Not Ready $       "       ;Error 2
   760 00000671 202420202020202020 
   761 0000067A 556E6B6E6F776E2043-                 db "Unknown Command $ "       ;Error 3
   761 00000683 6F6D6D616E64202420 
   762 0000068C 446174612024202020-                 db "Data $            "       ;Error 4
   762 00000695 202020202020202020 
   763 0000069E 426164205265717565-                 db "Bad Request $     "       ;Error 5
   763 000006A7 737420242020202020 
   764 000006B0 5365656B2024202020-                 db "Seek $            "       ;Error 6
   764 000006B9 202020202020202020 
   765 000006C2 556E6B6E6F776E204D-                 db "Unknown Media $   "       ;Error 7
   765 000006CB 656469612024202020 
   766 000006D4 536563746F72204E6F-                 db "Sector Not Found $"       ;Error 8
   766 000006DD 7420466F756E642024 
   767 000006E6 4F7574204F66205061-                 db "Out Of Paper $    "       ;Error 9
   767 000006EF 706572202420202020 
   768 000006F8 577269746520466175-                 db "Write Fault $     "       ;Error A
   768 00000701 6C7420242020202020 
   769 0000070A 52656164204661756C-                 db "Read Fault $      "       ;Error B
   769 00000713 742024202020202020 
   770 0000071C 47656E6572616C2046-                 db "General Failure $ "       ;Error C
   770 00000725 61696C757265202420 
   771                                  
   772 0000072E 64726976652024          .drive      db "drive $"
   773 00000735 6572726F7220726561-     .readmsg    db "error reading $"
   773 0000073E 64696E672024       
   774 00000744 6572726F7220777269-     .writemsg   db "error writing $"
   774 0000074D 74696E672024       
   775 00000753 0A0D24                  .crlf       db 0Ah, 0Dh, "$"
   776 00000756 41626F727424            .abortmsg   db "Abort$" 
   777 0000075C 49676E6F726524          .ignoremsg  db "Ignore$"
   778 00000763 526574727924            .retrymsg   db "Retry$"
   779 00000769 4661696C24              .failmsg    db "Fail$"
   780 0000076E 2C2024                  .betweenMsg db ", $"
   781 00000771 3F2024                  .endMsg     db "? $"
   782 00000774 49524146                .responses  db "IRAF"   ;Abort Retry Ignore Fail
   783                                  absDiskRead:        ;Int 45h
   784                                  ;al = Drive number
   785                                  ;rbx = Memory Buffer address
   786                                  ;ecx = Number of sectors to read (max 255 for now)
   787                                  ;rdx = Start LBA to read from
   788 00000778 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   789 0000077C 8A80[3A0D0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   790 00000782 4891                        xchg rax, rcx
   791 00000784 4887CA                      xchg rcx, rdx
   792 00000787 B482                        mov ah, 82h
   793 00000789 CD33                        int 33h
   794 0000078B 48CF                        iretq
   795                                  absDiskWrite:       ;Int 46h
   796 0000078D 480FB6C0                    movzx rax, al   ;Zero extend DOS drive number 
   797 00000791 8A80[3A0D0000]              mov al, byte [msdDriver.msdBIOSmap + rax] ;Get translated BIOS num into al
   798 00000797 4891                        xchg rax, rcx
   799 00000799 4887CA                      xchg rcx, rdx
   800 0000079C B483                        mov ah, 83h
   801 0000079E CD33                        int 33h
   802 000007A0 48CF                        iretq
   803                                  terminateResident:  ;Int 47h
   804                                  inDosHandler:       ;Int 48h
   805                                  ;Called when DOS idle
   806 000007A2 48CF                        iretq
   807                                  fastOutput:         ;Int 49h
   808                                  ;Called with char to transfer in al
   809 000007A4 50                          push rax
   810 000007A5 B40E                        mov ah, 0Eh
   811 000007A7 CD30                        int 30h
   812 000007A9 58                          pop rax
   813 000007AA 48CF                        iretq
   814                                  passCommand:        ;Int 4Eh, hooked by COMMAND.COM
   815 000007AC 48CF                        iretq
   816                                  multiplex:          ;Int 4Fh, kept as iretq for now
   817 000007AE 48CF                        iretq
   818                                  ;-----------------------------------:
   819                                  ;          Driver routines          :
   820                                  ;-----------------------------------:
   821                                  drivers:
   822                                  conHdr:
   823 000007B0 [D207000000000000]          dq auxHdr
   824 000007B8 1308                        dw 0813h
   825 000007BA [4809000000000000]          dq commonStrat
   826 000007C2 [5F09000000000000]          dq conDriver
   827 000007CA 434F4E2020202020            db "CON     "
   828                                  auxHdr:
   829 000007D2 [F407000000000000]          dq prnHdr
   830 000007DA 0080                        dw 08000h
   831 000007DC [4809000000000000]          dq commonStrat
   832 000007E4 [1A0A000000000000]          dq com1Intr
   833 000007EC 4155582020202020            db "AUX     "
   834                                  prnHdr:
   835 000007F4 [1608000000000000]          dq clkHdr
   836 000007FC 40A0                        dw 0A040h
   837 000007FE [4809000000000000]          dq commonStrat
   838 00000806 [E208000000000000]          dq lpt1Hdr
   839 0000080E 50524E2020202020            db "PRN     "
   840                                  clkHdr:
   841 00000816 [3808000000000000]          dq msdHdr
   842 0000081E 0880                        dw 08008h
   843 00000820 [4809000000000000]          dq commonStrat
   844 00000828 [1A0A000000000000]          dq clkDriver
   845 00000830 434C4F434B242020            db "CLOCK$  "
   846                                  msdHdr:
   847 00000838 [5A08000000000000]          dq com1Hdr
   848 00000840 0008                        dw 00800h   ;Once Generic IO implemented, change to 00840h
   849 00000842 [4809000000000000]          dq commonStrat
   850 0000084A [C50A000000000000]          dq msdDriver
   851 00000852 0000000000000000            db 0,0,0,0,0,0,0,0
   852                                  com1Hdr:
   853 0000085A [7C08000000000000]          dq com2Hdr
   854 00000862 0080                        dw 08000h
   855 00000864 [4809000000000000]          dq commonStrat
   856 0000086C [1A0A000000000000]          dq com1Intr
   857 00000874 434F4D3120202020            db "COM1    "
   858                                  com2Hdr:
   859 0000087C [9E08000000000000]          dq com3Hdr
   860 00000884 0080                        dw 08000h
   861 00000886 [4809000000000000]          dq commonStrat
   862 0000088E [230A000000000000]          dq com2Intr
   863 00000896 434F4D3220202020            db "COM2    "
   864                                  com3Hdr:
   865 0000089E [C008000000000000]          dq com4Hdr
   866 000008A6 0080                        dw 08000h
   867 000008A8 [4809000000000000]          dq commonStrat
   868 000008B0 [2C0A000000000000]          dq com3Intr
   869 000008B8 434F4D3320202020            db "COM3    "
   870                                  com4Hdr:
   871 000008C0 [E208000000000000]          dq lpt1Hdr
   872 000008C8 0080                        dw 08000h
   873 000008CA [4809000000000000]          dq commonStrat
   874 000008D2 [350A000000000000]          dq com4Intr
   875 000008DA 434F4D3420202020            db "COM4    "
   876                                  lpt1Hdr:
   877 000008E2 [0409000000000000]          dq lpt2Hdr
   878 000008EA 40A0                        dw 0A040h
   879 000008EC [4809000000000000]          dq commonStrat
   880 000008F4 [B50A000000000000]          dq lptDriver
   881 000008FC 4C50543120202020            db "LPT1    "
   882                                  lpt2Hdr:
   883 00000904 [2609000000000000]          dq lpt3Hdr
   884 0000090C 40A0                        dw 0A040h
   885 0000090E [4809000000000000]          dq commonStrat
   886 00000916 [B50A000000000000]          dq lptDriver
   887 0000091E 4C50543220202020            db "LPT2    "
   888                                  lpt3Hdr:
   889 00000926 FFFFFFFFFFFFFFFF            dq -1
   890 0000092E 40A0                        dw 0A040h
   891 00000930 [4809000000000000]          dq commonStrat
   892 00000938 [B50A000000000000]          dq lptDriver
   893 00000940 4C50543320202020            dq "LPT3    "
   894                                  
   895                                  commonStrat:
   896                                  ;DOS calls this function with rbx=Ptr to request header
   897 00000948 48891D01000000              mov qword [reqHdrPtr], rbx
   898 0000094F C3                          ret
   899 00000950 0000000000000000        reqHdrPtr  dq 0    ;Where the default device drivers store the ReqPtr
   900                                  
   901                                  nulStrat:
   902 00000958 66C743030001                mov word [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
   903                                  nulIntr:
   904 0000095E C3                          ret
   905                                  
   906                                  conDriver:
   907 0000095F 50                          push rax
   908 00000960 53                          push rbx
   909 00000961 488B1DE8FFFFFF              mov rbx, qword [reqHdrPtr]
   910 00000968 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
   911 0000096B 84C0                        test al, al
   912 0000096D 7421                        jz conInit
   913 0000096F 3C04                        cmp al, 4
   914 00000971 744D                        jz conRead
   915 00000973 3C05                        cmp al, 5
   916 00000975 7466                        jz conNondestructiveRead
   917 00000977 3C06                        cmp al, 6
   918 00000979 740C                        jz conExit
   919 0000097B 3C07                        cmp al, 7
   920 0000097D 7471                        jz conFlushInputBuffers
   921 0000097F 3C08                        cmp al, 8
   922 00000981 7479                        jz conWrite
   923 00000983 3C09                        cmp al, 9
   924 00000985 7475                        jz conWrite
   925                                  ;All other cases fall through here
   926                                  conExit:
   927 00000987 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
   928 0000098D 5B                          pop rbx
   929 0000098E 58                          pop rax
   930 0000098F C3                          ret
   931                                  conInit:    ;Function 0
   932 00000990 52                          push rdx
   933                                      ;Flush keyboard buffer
   934                                  .ci0:
   935 00000991 B401                        mov ah, 01      ;Get buffer status
   936 00000993 CD36                        int 36h
   937 00000995 7406                        jz .ci1      ;If zero clear => no more keys to read
   938 00000997 30E4                        xor ah, ah
   939 00000999 CD36                        int 36h ;Read key to flush from buffer
   940 0000099B EBF4                        jmp short .ci0
   941                                  .ci1:
   942 0000099D B800050000                  mov eax, 0500h  ;Set page zero as the default page
   943 000009A2 CD30                        int 30h
   944 000009A4 B402                        mov ah, 02h
   945 000009A6 31D2                        xor edx, edx    ;Set screen cursor to top right corner
   946 000009A8 88D7                        mov bh, dl      ;Set cursor for page 0
   947 000009AA CD30                        int 30h
   948 000009AC B707                        mov bh, 07h     ;Grey/Black attribs
   949 000009AE B800060000                  mov eax, 0600h  ;Clear whole screen
   950 000009B3 CD30                        int 30h
   951 000009B5 5A                          pop rdx
   952 000009B6 EBCF                        jmp short conExit
   953                                  conIORead:
   954 000009B8 66C743030380                mov word [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
   955 000009BE EBC7                        jmp short conExit
   956                                  conRead:    ;Function 4
   957 000009C0 57                          push rdi
   958 000009C1 51                          push rcx
   959 000009C2 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
   960 000009C6 31C9                        xor ecx, ecx    ;Zero the char counter
   961                                  .cr1:
   962 000009C8 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   963 000009CB 7409                        je .cre2
   964 000009CD 31C0                        xor eax, eax
   965 000009CF CD36                        int 36h
   966 000009D1 AA                          stosb   ;Store char in al into buffer and inc rdi
   967 000009D2 FFC1                        inc ecx
   968 000009D4 EBF2                        jmp short .cr1
   969                                  .cre2:
   970 000009D6 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
   971 000009D9 59                          pop rcx
   972 000009DA 5F                          pop rdi
   973 000009DB EBAA                        jmp short conExit
   974                                  conNondestructiveRead:  ;Function 5
   975 000009DD B401                        mov ah, 01h     ;Get key if exists
   976 000009DF CD36                        int 36h
   977 000009E1 7405                        jz .cnr           ;If zero clear => no key, go forwards
   978                                      ;Keystroke available
   979 000009E3 88430D                      mov byte [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
   980 000009E6 EB9F                        jmp short conExit
   981                                  .cnr: ;No keystroke available
   982 000009E8 66C743030003                mov word [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
   983 000009EE EB97                        jmp short conExit
   984                                  conFlushInputBuffers:   ;Function 7
   985 000009F0 B401                        mov ah, 01      ;Get buffer status
   986 000009F2 CD36                        int 36h
   987 000009F4 7491                        jz conExit      ;If zero clear => no more keys to read
   988 000009F6 30E4                        xor ah, ah
   989 000009F8 CD36                        int 36h ;Read key to flush from buffer
   990 000009FA EBF4                        jmp short conFlushInputBuffers
   991                                  conWrite:   ;Function 8 and 9
   992 000009FC 56                          push rsi
   993 000009FD 51                          push rcx
   994 000009FE 488B730E                    mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
   995 00000A02 31C9                        xor ecx, ecx    ;Zero the char counter
   996                                  .cw1: 
   997 00000A04 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
   998 00000A07 7407                        je .cw2
   999 00000A09 AC                          lodsb   ;Get char into al, and inc rsi
  1000 00000A0A CD49                        int 49h ;Fast print char
  1001 00000A0C FFC1                        inc ecx
  1002 00000A0E EBF4                        jmp short .cw1 ;keep printing until all chars printed
  1003                                  .cw2:
  1004 00000A10 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1005 00000A13 59                          pop rcx
  1006 00000A14 5E                          pop rsi
  1007 00000A15 E96DFFFFFF                  jmp conExit
  1008                                  
  1009                                  clkDriver:
  1010                                  
  1011                                  comDriver:
  1012                                  com1Intr:
  1013 00000A1A C6059300000000              mov byte [comDevice], 0
  1014 00000A21 EB19                        jmp short comIntr
  1015                                  com2Intr:
  1016 00000A23 C6058A00000001              mov byte [comDevice], 1
  1017 00000A2A EB10                        jmp short comIntr
  1018                                  com3Intr:
  1019 00000A2C C6058100000002              mov byte [comDevice], 2
  1020 00000A33 EB07                        jmp short comIntr
  1021                                  com4Intr:
  1022 00000A35 C6057800000003              mov byte [comDevice], 3
  1023                                  comIntr:
  1024 00000A3C 50                          push rax
  1025 00000A3D 53                          push rbx
  1026 00000A3E 51                          push rcx
  1027 00000A3F 52                          push rdx
  1028 00000A40 56                          push rsi
  1029 00000A41 488B1D08FFFFFF              mov rbx, qword [reqHdrPtr]
  1030 00000A48 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]
  1031 00000A4B 3C04                        cmp al, 4
  1032 00000A4D 7418                        jz comRead
  1033 00000A4F 3C05                        cmp al, 5
  1034 00000A51 7439                        jz comNondestructiveRead
  1035 00000A53 3C08                        cmp al, 8
  1036 00000A55 743D                        jz comWrite
  1037 00000A57 3C09                        cmp al, 9
  1038 00000A59 7439                        jz comWrite
  1039                                  ;All other cases fall through here
  1040                                  comExit:
  1041 00000A5B 66814B030001                or word [rbx + drvReqHdr.status], 0100h    ;Merge done bit
  1042 00000A61 5E                          pop rsi
  1043 00000A62 5A                          pop rdx
  1044 00000A63 59                          pop rcx
  1045 00000A64 5B                          pop rbx
  1046 00000A65 58                          pop rax
  1047 00000A66 C3                          ret
  1048                                  comRead:
  1049 00000A67 57                          push rdi
  1050 00000A68 488B7B0E                    mov rdi, qword [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
  1051 00000A6C 31C9                        xor ecx, ecx    ;Zero the char counter
  1052                                  .cr1:
  1053 00000A6E 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1054 00000A71 7413                        je .cre2
  1055 00000A73 B802000000                  mov eax, 02h    ;Recieve 
  1056 00000A78 668B1535000000              mov dx, word [comDevice]    ;Get transacting com device
  1057 00000A7F CD34                        int 34h ;Recieve Char
  1058 00000A81 AA                          stosb   ;Store char in al into buffer and inc rdi
  1059 00000A82 FFC1                        inc ecx
  1060 00000A84 EBE8                        jmp short .cr1
  1061                                  .cre2:
  1062 00000A86 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1063 00000A89 5F                          pop rdi
  1064 00000A8A EBCF                        jmp short comExit
  1065                                  comNondestructiveRead:
  1066 00000A8C 66C743030002                mov word [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
  1067 00000A92 EBC7                        jmp short comExit
  1068                                  comWrite:
  1069 00000A94 488B730E                 mov rsi, qword [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
  1070 00000A98 31C9                        xor ecx, ecx    ;Zero the char counter
  1071                                  .cw1: 
  1072 00000A9A 3B4B16                      cmp ecx, dword [rbx + ioReqPkt.tfrlen]
  1073 00000A9D 7410                        je .cw2
  1074 00000A9F AC                          lodsb   ;Get char into al, and inc rsi
  1075 00000AA0 B401                        mov ah, 01h ;Move function number into ah
  1076 00000AA2 668B150B000000              mov dx, word [comDevice]
  1077 00000AA9 CD34                        int 34h ;Transmit char
  1078 00000AAB FFC1                        inc ecx
  1079 00000AAD EBEB                        jmp short .cw1 ;keep printing until all chars printed
  1080                                  .cw2:
  1081 00000AAF 894B16                      mov dword [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
  1082 00000AB2 EBA7                        jmp short comExit
  1083 00000AB4 00                      comDevice   db 0
  1084                                  
  1085                                  lptDriver:    ;Drivers for LPT 1, 2, 3
  1086 00000AB5 57                          push rdi
  1087 00000AB6 488B3D93FEFFFF              mov rdi, qword [reqHdrPtr]
  1088 00000ABD 66C747030001                mov word [rdi + drvReqHdr.status], 0100h    ;Done bit set
  1089 00000AC3 5F                          pop rdi
  1090 00000AC4 C3                          ret
  1091                                  
  1092                                  msdDriver:
  1093 00000AC5 50                          push rax
  1094 00000AC6 53                          push rbx
  1095 00000AC7 51                          push rcx
  1096 00000AC8 52                          push rdx
  1097 00000AC9 56                          push rsi
  1098 00000ACA 57                          push rdi
  1099 00000ACB 55                          push rbp
  1100 00000ACC 488B1D7DFEFFFF              mov rbx, qword [reqHdrPtr]  ;Get the ptr to the req header in rbx
  1101 00000AD3 8A4302                      mov al, byte [rbx + drvReqHdr.cmdcde]   ;Get command code in al
  1102 00000AD6 3C18                        cmp al, 24  ;Check cmd num is valid
  1103 00000AD8 776C                        ja .msdError
  1104 00000ADA 84C0                        test al, al
  1105 00000ADC 7476                        jz .msdInit
  1106 00000ADE 3C01                        cmp al, 01
  1107 00000AE0 0F8409010000                jz .msdMedChk
  1108 00000AE6 3C02                        cmp al, 02
  1109 00000AE8 0F8442010000                jz .msdBuildBPB
  1110 00000AEE 3C03                        cmp al, 03
  1111 00000AF0 0F847B010000                jz .msdIOCTLRead
  1112 00000AF6 3C04                        cmp al, 04
  1113 00000AF8 0F8478010000                jz .msdRead
  1114 00000AFE 3C08                        cmp al, 08
  1115 00000B00 0F8482010000                jz .msdWrite
  1116 00000B06 3C09                        cmp al, 09
  1117 00000B08 0F848C010000                jz .msdWriteVerify
  1118 00000B0E 3C0C                        cmp al, 12
  1119 00000B10 0F849D010000                jz .msdIOCTLWrite
  1120 00000B16 3C0D                        cmp al, 13
  1121 00000B18 0F849A010000                jz .msdDevOpen
  1122 00000B1E 3C0E                        cmp al, 14
  1123 00000B20 0F84A2010000                jz .msdDevClose
  1124 00000B26 3C0F                        cmp al, 15
  1125 00000B28 0F84AA010000                jz .msdRemovableMedia
  1126 00000B2E 3C13                        cmp al, 19
  1127 00000B30 0F84C0010000                jz .msdGenericIOCTL
  1128 00000B36 3C17                        cmp al, 23
  1129 00000B38 0F84BD010000                jz .msdGetLogicalDev
  1130 00000B3E 3C18                        cmp al, 24
  1131 00000B40 0F84C3010000                jz .msdSetLogicalDev
  1132                                  .msdError:
  1133                                  .msdDriverExit:
  1134 00000B46 66814B030001                or word [rbx + drvReqHdr.status], 0100h ;Set done bit
  1135 00000B4C 5D                          pop rbp
  1136 00000B4D 5F                          pop rdi
  1137 00000B4E 5E                          pop rsi
  1138 00000B4F 5A                          pop rdx
  1139 00000B50 59                          pop rcx
  1140 00000B51 5B                          pop rbx
  1141 00000B52 58                          pop rax
  1142 00000B53 C3                          ret
  1143                                  .msdInit:            ;Function 0
  1144 00000B54 CD31                        int 31h ;Get number of Int 33h devices in r8b
  1145 00000B56 4D0FB6C0                    movzx r8, r8b   ;Keeps real count
  1146 00000B5A 4489C0                      mov eax, r8d
  1147 00000B5D 3C01                        cmp al, 1
  1148 00000B5F 7702                        ja .mi1
  1149 00000B61 FEC0                        inc al ;Make it two
  1150                                  .mi1:
  1151 00000B63 BA05000000                  mov edx, 5
  1152 00000B68 39D0                        cmp eax, edx
  1153 00000B6A 0F47C2                      cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
  1154 00000B6D 8805DFFCFFFF                mov byte [msdHdr + drvHdr.drvNam], al ;Save num of drvs in drvr hdr
  1155 00000B73 88430D                      mov byte [rbx + initReqPkt.numunt], al ;And in req packet
  1156 00000B76 440005(A9000000)            add byte [numMSDdrv], r8b ;Add the true number of devices to total
  1157 00000B7D 31ED                        xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
  1158 00000B7F 488D3DE6010000              lea rdi, qword [.msdBPBblks]
  1159 00000B86 53                          push rbx
  1160                                  .mi2:
  1161 00000B87 89EA                        mov edx, ebp
  1162 00000B89 488D1D34040000              lea rbx, qword [driverDataPtr]  ;Get effective address of scratch space
  1163 00000B90 31C9                        xor ecx, ecx    ;Sector 0
  1164 00000B92 B801820000                  mov eax, 8201h       ;Read 1 sector
  1165 00000B97 CD33                        int 33h
  1166 00000B99 724E                        jc .msdInitError
  1167                                  
  1168 00000B9B 488D3522040000              lea rsi, qword [driverDataPtr]  ;Point to start of data
  1169 00000BA2 B90F000000                  mov ecx, bpbEx_size/8
  1170 00000BA7 F348A5                      rep movsq   ;Move the BPB data into the right block
  1171                                  
  1172 00000BAA FFC5                        inc ebp
  1173 00000BAC 4C39C5                      cmp rbp, r8 ;Have we written the BPB for all physical drives?
  1174 00000BAF 75D6                        jne .mi2  ;No? Go again
  1175                                  
  1176 00000BB1 488D3D8C010000              lea rdi, qword [.msdBPBTbl]  ;Point to start of table
  1177 00000BB8 488D15AD010000              lea rdx, qword [.msdBPBblks]
  1178                                  .mi3:
  1179 00000BBF 488917                      mov qword [rdi], rdx   ;Move the block entry ptr to rdi
  1180 00000BC2 4881C278000000              add rdx, bpbEx_size      ;Make rdx point to the next block entry
  1181 00000BC9 FFCD                        dec ebp
  1182 00000BCB 75F2                        jnz .mi3  ;If not zero yet, go again
  1183                                  
  1184 00000BCD 5B                          pop rbx
  1185 00000BCE 488D156F010000              lea rdx, qword [.msdBPBTbl]  ;Get far pointer 
  1186 00000BD5 48895316                    mov qword [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
  1187 00000BD9 488D15E4030000              lea rdx, qword [driverDataPtr]
  1188 00000BE0 4889530E                    mov qword [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
  1189 00000BE4 E95DFFFFFF                  jmp .msdDriverExit
  1190                                  .msdInitError:
  1191 00000BE9 5B                          pop rbx
  1192 00000BEA E957FFFFFF                  jmp .msdDriverExit
  1193                                  .msdMedChk:          ;Function 1
  1194                                  ;Once the BIOS function is implmented that reads the changeline, use that!
  1195                                  ;For BIOSes that dont support the changeline, the following procedure will 
  1196                                  ; suffice.
  1197 00000BEF 480FB64301                  movzx rax, byte [rbx + mediaCheckReqPkt.unitnm]
  1198 00000BF4 8A90[3A0D0000]              mov dl, byte [.msdBIOSmap + rax]    ;Translate unitnum to BIOS num
  1199 00000BFA F6C280                      test dl, 80h    ;If it is a fixed disk, no change!
  1200 00000BFD 7528                        jnz .mmcNoChange
  1201                                  ;Now we test Media Descriptor
  1202 00000BFF 8A530D                      mov dl, byte [rbx + mediaCheckReqPkt.medesc]    ;Media descriptor
  1203 00000C02 488B3CC5[440D0000]          mov rdi, qword [.msdBPBTbl + 8*rax]
  1204 00000C0A 488B3F                      mov rdi, qword [rdi]    ;Dereference rdi
  1205 00000C0D 385715                      cmp byte [rdi + bpb32.media], dl    ;Compare media descriptor bytes
  1206 00000C10 740C                        je .mmcUnsure
  1207                                  .mmcChange: ;Fail safe, always assume the device has changed
  1208 00000C12 C6430EFF                    mov byte [rbx + mediaCheckReqPkt.medret], -1
  1209 00000C16 48C7430F[300D0000]          mov qword [rbx + mediaCheckReqPkt.desptr], .msdDefLabel ;Temp, ret def label
  1210                                  .mmcUnsure:
  1211 00000C1E C6430E00                    mov byte [rbx + mediaCheckReqPkt.medret], 0
  1212 00000C22 E91FFFFFFF                  jmp .msdDriverExit
  1213                                  .mmcNoChange:
  1214 00000C27 C6430E01                    mov byte [rbx + mediaCheckReqPkt.medret], 1
  1215 00000C2B E916FFFFFF                  jmp .msdDriverExit
  1216                                  
  1217                                  .msdBuildBPB:        ;Function 2
  1218 00000C30 4889DE                      mov rsi, rbx
  1219 00000C33 480FB64601                  movzx rax, byte [rsi + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1220 00000C38 8A90[3A0D0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1221 00000C3E 488B5E0E                    mov rbx, qword [rsi + bpbBuildReqPkt.bufptr]    ;Transfer buffer
  1222 00000C42 31C9                        xor ecx, ecx    ;Read Sector 0
  1223 00000C44 B801820000                  mov eax, 8201h  ;LBA Read 1 sector
  1224 00000C49 CD33                        int 33h
  1225 00000C4B 7224                        jc .mbbpbError
  1226 00000C4D 4887DE                      xchg rbx, rsi    ;Transf Buf(rbx) <-> ReqHdr(rsi)
  1227 00000C50 480FB64301                  movzx rax, byte [rbx + bpbBuildReqPkt.unitnm]  ;Get unit number into rax
  1228 00000C55 488B3CC5[440D0000]          mov rdi, qword [.msdBPBTbl + 8*rax] ;Get pointer to pointer to buffer
  1229 00000C5D 488B3F                      mov rdi, qword [rdi] ;Dereference to get pointer to buffer 
  1230 00000C60 48897B16                    mov qword [rbx + bpbBuildReqPkt.bpbptr], rdi ;rdi -> final bpb resting place
  1231 00000C64 B90F000000                  mov ecx, bpbEx_size/8
  1232 00000C69 F348A5                      rep movsq   ;Move the BPB data into the right space
  1233 00000C6C E9D5FEFFFF                  jmp .msdDriverExit
  1234                                  .mbbpbError:
  1235                                  .msdIOCTLRead:       ;Function 3, returns done
  1236 00000C71 E9D0FEFFFF                  jmp .msdDriverExit
  1237                                  .msdRead:            ;Function 4
  1238 00000C76 4889DD                      mov rbp, rbx
  1239 00000C79 B482                        mov ah, 82h ;LBA Read Sectors
  1240 00000C7B E897000000                  call .msdBlkIOCommon
  1241 00000C80 4889EB                      mov rbx, rbp
  1242 00000C83 E9BEFEFFFF                  jmp .msdDriverExit
  1243                                  .msdWrite:           ;Function 8
  1244 00000C88 4889DD                      mov rbp, rbx
  1245 00000C8B B483                        mov ah, 83h ;LBA Write Sectors
  1246 00000C8D E885000000                  call .msdBlkIOCommon
  1247 00000C92 4889EB                      mov rbx, rbp
  1248 00000C95 E9ACFEFFFF                  jmp .msdDriverExit
  1249                                  .msdWriteVerify:     ;Function 9, writes sectors then verifies them
  1250 00000C9A 4889DD                      mov rbp, rbx
  1251 00000C9D B483                        mov ah, 83h ;LBA Write Sectors
  1252 00000C9F E873000000                  call .msdBlkIOCommon
  1253 00000CA4 B484                        mov ah, 84h ;LBA Verify Sectors
  1254 00000CA6 E86C000000                  call .msdBlkIOCommon
  1255 00000CAB 4889EB                      mov rbx, rbp
  1256 00000CAE E993FEFFFF                  jmp .msdDriverExit
  1257                                  .msdIOCTLWrite:      ;Function 12, returns done
  1258 00000CB3 E98EFEFFFF                  jmp .msdDriverExit
  1259                                  .msdDevOpen:         ;Function 13
  1260 00000CB8 480FB64301                  movzx rax, byte [rbx + openReqPkt.unitnm]
  1261 00000CBD FE80[3F0D0000]              inc byte [.msdHdlCnt + rax]  ;Inc handle cnt for given unit
  1262 00000CC3 E97EFEFFFF                  jmp .msdDriverExit
  1263                                  .msdDevClose:        ;Function 14
  1264 00000CC8 480FB64301                  movzx rax, byte [rbx + closeReqPkt.unitnm]
  1265 00000CCD FE88[3F0D0000]              dec byte [.msdHdlCnt + rax]  ;Dec handle cnt for given unit
  1266 00000CD3 E96EFEFFFF                  jmp .msdDriverExit
  1267                                  .msdRemovableMedia:  ;Function 15
  1268 00000CD8 480FB64301                  movzx rax, byte [rbx + remMediaReqPkt.unitnm]
  1269 00000CDD 8A80[3A0D0000]              mov al, byte [.msdBIOSmap + rax]    ;Get BIOS number
  1270 00000CE3 A880                        test al, 80h
  1271 00000CE5 0F845BFEFFFF                jz .msdDriverExit   ;If removable, busy bit is clear
  1272 00000CEB 66C743032000                mov word [rbx + remMediaReqPkt.status], 20h ;Set Busy bit
  1273 00000CF1 E950FEFFFF                  jmp .msdDriverExit
  1274                                  .msdGenericIOCTL:    ;Function 19
  1275 00000CF6 E94BFEFFFF                  jmp .msdDriverExit
  1276                                  .msdGetLogicalDev:   ;Function 23
  1277 00000CFB 8A0538000000                mov al, byte [.msdCurDev]
  1278 00000D01 884301                      mov byte [rbx + getDevReqPkt.unitnm], al
  1279 00000D04 E93DFEFFFF                  jmp .msdDriverExit
  1280                                  .msdSetLogicalDev:   ;Function 24
  1281 00000D09 8A4301                      mov al, byte [rbx + getDevReqPkt.unitnm]
  1282 00000D0C 880527000000                mov byte [.msdCurDev], al
  1283 00000D12 E92FFEFFFF                  jmp .msdDriverExit
  1284                                  
  1285                                  .msdBlkIOCommon:  ;Does block IO
  1286                                  ;Called with rbp containing old rbx value and ah with function number
  1287                                  ;Error handled by caller
  1288 00000D17 480FB64501                  movzx rax, byte [rbp + ioReqPkt.unitnm]
  1289 00000D1C 8A90[3A0D0000]              mov dl, byte [.msdBIOSmap + rax]  ;Get translated BIOS number for req
  1290 00000D22 488B4D1A                    mov rcx, qword [rbp + ioReqPkt.strtsc]  ;Get start sector
  1291 00000D26 8A4516                      mov al, byte [rbp + ioReqPkt.tfrlen]    ;Get number of sectors, max 255
  1292 00000D29 488B5D0E                    mov rbx, qword [rbp + ioReqPkt.bufptr]  ;Get Memory Buffer
  1293 00000D2D CD33                        int 33h
  1294 00000D2F C3                          ret
  1295                                  
  1296 00000D30 4E4F204E414D452000      .msdDefLabel db "NO NAME ",0 ;Default volume label
  1297                                  ;LASTDRIVE default is 5
  1298 00000D39 00                      .msdCurDev   db 0  ;Dev to be used by the driver saved here! (usually 1-1)
  1299                                  ; Except when single drive in use, in which case Drive A and B refer to device 0
  1300 00000D3A 0000000000              .msdBIOSmap  db 5 dup (0)    ;Translates DOS drive number to BIOS number
  1301 00000D3F 0000000000              .msdHdlCnt   db 5 dup (0)    ;Keeps a count of open handles to drive N
  1302 00000D44 000000000000000000-     .msdBPBTbl   dq 5 dup (0)    ;BPB pointer table to be returned
  1302 00000D4D 000000000000000000-
  1302 00000D56 000000000000000000-
  1302 00000D5F 000000000000000000-
  1302 00000D68 00000000           
  1303 00000D6C 000000000000000000-     .msdBPBblks  db 5*bpbEx_size dup (0) ;Max 5 bpb records of exFAT bpb size
  1303 00000D75 000000000000000000-
  1303 00000D7E 000000000000000000-
  1303 00000D87 000000000000000000-
  1303 00000D90 000000000000000000-
  1303 00000D99 000000000000000000-
  1303 00000DA2 000000000000000000-
  1303 00000DAB 000000000000000000-
  1303 00000DB4 000000000000000000-
  1303 00000DBD 000000000000000000-
  1303 00000DC6 000000000000000000-
  1303 00000DCF 000000000000000000-
  1303 00000DD8 000000000000000000-
  1303 00000DE1 000000000000000000-
  1303 00000DEA 000000000000000000-
  1303 00000DF3 000000000000000000-
  1303 00000DFC 000000000000000000-
  1303 00000E05 000000000000000000-
  1303 00000E0E 000000000000000000-
  1303 00000E17 000000000000000000-
  1303 00000E20 000000000000000000-
  1303 00000E29 000000000000000000-
  1303 00000E32 000000000000000000-
  1303 00000E3B 000000000000000000-
  1303 00000E44 000000000000000000-
  1303 00000E4D 000000000000000000-
  1303 00000E56 000000000000000000-
  1303 00000E5F 000000000000000000-
  1303 00000E68 000000000000000000-
  1303 00000E71 000000000000000000-
  1303 00000E7A 000000000000000000-
  1303 00000E83 000000000000000000-
  1303 00000E8C 000000000000000000-
  1303 00000E95 000000000000000000-
  1303 00000E9E 000000000000000000-
  1303 00000EA7 000000000000000000-
  1303 00000EB0 000000000000000000-
  1303 00000EB9 000000000000000000-
  1303 00000EC2 000000000000000000-
  1303 00000ECB 000000000000000000-
  1303 00000ED4 000000000000000000-
  1303 00000EDD 000000000000000000-
  1303 00000EE6 000000000000000000-
  1303 00000EEF 000000000000000000-
  1303 00000EF8 000000000000000000-
  1303 00000F01 000000000000000000-
  1303 00000F0A 000000000000000000-
  1303 00000F13 000000000000000000-
  1303 00000F1C 000000000000000000-
  1303 00000F25 000000000000000000-
  1303 00000F2E 000000000000000000-
  1303 00000F37 000000000000000000-
  1303 00000F40 000000000000000000-
  1303 00000F49 000000000000000000-
  1303 00000F52 000000000000000000-
  1303 00000F5B 000000000000000000-
  1303 00000F64 000000000000000000-
  1303 00000F6D 000000000000000000-
  1303 00000F76 000000000000000000-
  1303 00000F7F 000000000000000000-
  1303 00000F88 000000000000000000-
  1303 00000F91 000000000000000000-
  1303 00000F9A 000000000000000000-
  1303 00000FA3 000000000000000000-
  1303 00000FAC 000000000000000000-
  1303 00000FB5 000000000000000000-
  1303 00000FBE 000000000000       
  1304                                  
  1305                                  driverDataPtr:
