
;-------------------------------------------------------------------------------
;Generic Macros file
;The following instruction extensions allow to conditionally return
;The idea was borrowed from the DOS Source Code
;
;-------------------------------------------------------------------------------
;The following three macros, named similarly to the below in use macros
; are experimental. Once, I figure out how to make them work, I will
; use the below macros as they will make my code much smaller by always
; trying to find the nearest returns and valid conditional returns.
;-------------------------------------------------------------------------------


;-------------------------------------------------------------------------------
;These macros are live and must not be touched
;-------------------------------------------------------------------------------
%macro jump 1   ;Argument = Label name
%%a:
%ifndef %1_j
    jmp %1  ;If %1_j not defined, just jump and define
%else
%if %1_j => ($$-%%a)
    jmp %1  ;If forward reference, long jump
%else
%if (($$-%%a) - %1_j) > 126
    jmp %1  ;Is the jump target more than 126 bytes behind, long jump
%else
    jmp short %1_j  ;Else short jump!
%endif
%endif
%endif
%assign %1_j ($$-%%a)   ;Redefine symbol %1_j
%endmacro


%macro return 0
%%_ret:
    ret
%assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
%endmacro

%macro cret 1
%%_base:
%assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    %ifdef retOff
    %if (baseVar - retOff <= 126) && (baseVar > retOff)
    j%+1 short (retOff+currSegVBase)
    %else 
    j%-1 short %%a
    return
%%a:
    %endif
    %else
    j%-1 short %%a
    return
%%a:
    %endif
%endmacro

%macro retz 0
cret z
%endmacro

%macro retnz 0
cret nz
%endmacro

%macro rete 0
cret e
%endmacro

%macro retne 0
cret ne
%endmacro

%macro retc 0
cret c
%endmacro

%macro retnc 0
cret nc
%endmacro

%macro retb 0
cret b
%endmacro

%macro retnb 0
cret nb
%endmacro