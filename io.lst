JWasm v2.11, Oct 20 2013
io.asm
                                    
                                    .x64p

                                    INCLUDE fatStruc.inc
                              C 
                              C ;-------------------------------------------------------;
                              C ; This include file contains miscellaneous FAT driver   ;
                              C ; structures. exFAT will have it's own files at a later ;
                              C ; stage.                                                ;
                              C ;-------------------------------------------------------;
                              C 
00000000                      C bpb STRUC          ;FAT 12 and 16 BPB, SIZE: 62 bytes
                              C 
00000000                      C     jmpBoot    db 3 dup (?)
00000003                      C     oemName    db 8 dup (?)  ;OEM name
0000000B                      C     bytsPerSec dw ?  ;Bytes per sector
0000000D                      C     secPerClus db ?  ;Sectors per cluster
0000000E                      C     revdSecCnt dw ?  ;Number of reserved sectors
00000010                      C     numFATs    db ?  ;Number of FATs on media
00000011                      C     rootEntCnt dw ?  ;Number of entries in Root directory
00000013                      C     totSec16   dw ?  ;Number of sectors on medium
00000015                      C     media      db ?  ;Media descriptor byte
00000016                      C     FATsz16    dw ?  ;Number of sectors per FAT
00000018                      C     secPerTrk  dw ?  ;Number of sectors per "track"
0000001A                      C     numHeads   dw ?  ;Number of read "heads"
0000001C                      C     hiddSec    dd ?  ;Number of hidden sectors
00000020                      C     totSec32   dd ?  ;32 bit count of sectors
                              C 
00000024                      C     drvNum     db ?  ;Logical drive number (00h or 80h)
00000025                      C     reserved1  db ?  ;Reserved byte
00000026                      C     bootSig    db ?  ;Extended boot signature (29h)
00000027                      C     volID      dd ?  ;Volume serial number
0000002B                      C     volLab     db 11 dup (?) ;Volume label string
00000036                      C     filSysType db 8 dup (?)  ;File system type string
                              C 
0000003E                      C bpb ENDS
                              C 
00000000                      C bpb32 STRUC       ;FAT 32 BPB, SIZE: 90 bytes
                              C 
00000000                      C     jmpBoot    db 3 dup (?)
00000003                      C     oemName    db 8 dup (?)  ;OEM name
0000000B                      C     bytsPerSec dw ?  ;Bytes per sector
0000000D                      C     secPerClus db ?  ;Sectors per cluster
0000000E                      C     revdSecCnt dw ?  ;Number of reserved sectors
00000010                      C     numFATs    db ?  ;Number of FATs on media
00000011                      C     rootEntCnt dw ?  ;Number of entries in Root directory
00000013                      C     totSec16   dw ?  ;Number of sectors on medium
00000015                      C     media      db ?  ;Media descriptor byte
00000016                      C     FATsz16    dw ?  ;Number of sectors per FAT, must be 0 for FAT 32
00000018                      C     secPerTrk  dw ?  ;Number of sectors per "track"
0000001A                      C     numHeads   dw ?  ;Number of read "heads"
0000001C                      C     hiddSec    dd ?  ;Number of hidden sectors
00000020                      C     totSec32   dd ?  ;32 bit count of sectors
                              C 
00000024                      C     FATsz32    dd ?  ;32 bit count of sectors occupied by one FAT
00000028                      C     extFlags   dw ?  ;Extended Flags word
0000002A                      C     FSver      dw ?  ;File system version word, must be 0
0000002C                      C     RootClus   dd ?  ;First Cluster of Root Directory
00000030                      C     FSinfo     dw ?  ;Sector number of FSINFO structure, usually 1
00000032                      C     BkBootSec  dw ?  ;Backup Boot sector, either 0 or 6
00000034                      C     reserved   db 12 dup (?) ;Reserved 12 bytes
                              C 
00000040                      C     drvNum     db ?  ;Logical drive number (00h or 80h)
00000041                      C     reserved1  db ?  ;Reserved byte
00000042                      C     bootSig    db ?  ;Extended boot signature (29h)
00000043                      C     volID      dd ?  ;Volume serial number
00000047                      C     volLab     db 11 dup (?) ;Volume label string
00000052                      C     filSysType db 8 dup (?)  ;File system type string
                              C 
0000005A                      C bpb32 ENDS
                              C 
                              C 
00000000                      C bpbEx STRUC   ;exFAT BPB, SIZE: 120 bytes
                              C 
00000000                      C     jmpBoot                db 3 dup (?) 
00000003                      C     oemName                db 8 dup (?) ;OEM name
0000000B                      C     MustBeZero             db 53 dup (?) ;Must be 0, 53 bytes
00000040                      C     partitionOffset        dq ?  ;in sectors, 0 means ignore this field
00000048                      C     volumeLength           dq ?  ;Volume Length in sectors
00000050                      C     FAToffset              dd ?  ;Volume rel offset of first FAT, in sectors
00000054                      C     FATlength              dd ?  ;FAT length, in sectors
00000058                      C     clusterHeapOffset      dd ?  ;Start of data area, in sectors
0000005C                      C     clusterCount           dd ?  ;Number of clusters on medium
00000060                      C     firstClusterOfRootDir  dd ?  ;First Cluster of Root Directory, min 2
00000064                      C     volumeSerialNum        dd ?  ;Volume Serial Number
00000068                      C     FSrevision             dw ?  ;Should be 0001 (v1.00)
0000006A                      C     volumeFlags            dw ?  ;Volume Flags, refer to documentation
0000006C                      C     bytesPerSectorShift    db ?  ;min 9 (512 bps), max 12 (4096 bps)
0000006D                      C     sectorsPerClusterShift db ?  ;Result of log_2(N) for N=sec per clus
0000006E                      C     numberOfFATs           db ?  ;Number of FATs, only 1 or 2
0000006F                      C     driveSelect            db ?  ;Drive Select, 0 or 80h (Int 13h)
00000070                      C     percentInUse           db ?  ;Rounded down. FFh means unknown
00000071                      C     reserved               db 7 dup (?)  ;Reserved for alignment
                              C 
00000078                      C bpbEx ENDS
                                    INCLUDE dosStruc.inc
                              C 
                              C ;-------------------------------------------------------;
                              C ; This include file contains miscellaneous internal     ;
                              C ; SCP/DOS structures.                                   ;
                              C ;-------------------------------------------------------;
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
                              C ; its file system structure. This is used to locate files and structures
                              C ; on the device itself and to translate file requests to cluster chains
                              C ; to LBAs to pass to the disk driver..
                              C ; The DPBs form a linked list, with each DPB formed after the devices 
                              C ; drivers Initialise routine has been called.
                              C ;------------------------------------------------------------------------;
00000000                      C dpb STRUC        ;Drive Parameter Block
                              C 
00000000                      C     bDriveNumber            db ?  ;Drive number (0=A, 1=B ...)
00000001                      C     bUnitNumber             db ?  ;Unit number in device
00000002                      C     bBytesPerSectorShift    db ?  ;min 9 (512 bps), max 12 (4096 bps)
00000003                      C     bMaxSectorInCluster     db ?  ;(Maximum sector in cluster) - 1
                              C ;                                       i.e. (2^bSectorsPerClusterShift) - 1
00000004                      C     bSectorsPerClusterShift db ?  ;Sectors per cluster exponent
00000005                      C     dFAToffset              dd ?  ;Vol rel offset of first FAT, in sectors
00000009                      C     bNumberOfFATs           db ?  ;Number of FATs
0000000A                      C     wNumberRootDirEntries   dw ?  ;In sectors
0000000C                      C     dClusterHeapOffset      dd ?  ;Start of data area, in sectors
00000010                      C     dClusterCount           dd ?  ;Total number of clusters (volume size)
00000014                      C     dFATlength              dd ?  ;FAT length, in sectors
00000018                      C     dFirstClusterOfRootDir  dd ?  ;First Cluster of Root Directory, min 2
0000001C                      C     qDriverHeaderPtr        dq ?  ;Pointer to device driver header
00000024                      C     bMediaDescriptor        db ?  ;Media descriptor
00000025                      C     bAccessFlag             db ?  ;Access Flag (0 if accessed, else -1)
00000026                      C     qNextDPBPtr             dq ?  ;Pointer to next DPB, -1 if at end
0000002E                      C     dFirstFreeCluster       dd ?  ;Starting cluster of free space search
00000032                      C     dNumberOfFreeClusters   dd ?  ;Number of free clusters, -1 unknown
                              C 
00000036                      C dpb ENDS
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
                              C ; All disk pathing requests go via the CDS for that drive.
                              C ; The default drive is the last accessed drive, this number is stored
                              C ; in the DOS data area.
                              C ; The CDS is stored as an array with the offset into the array being 
                              C ; given by the drive letter's offset into the alphabet (with A=0).
                              C ;
                              C ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
                              C ;------------------------------------------------------------------------;
00000000                      C cds STRUC       ;Current Directory Structure
00000000                      C     sCurrentPath        db 67 dup(?)    ;Current Directory Path String
00000043                      C     wFlags              dw ? ;CDS Flags - 
00000045                      C     qDPBPtr             dq ? ;Ptr to the DPB of the dev using this CDS
0000004D                      C     dStartCluster       dd ? ;Starting cluster of the directory on disk
00000051                      C     qReserved           dq ? ;Reserved for future expansions
00000059                      C     wBackslashOffset    dw ? ;How many chars to the start of current dir in the 
                              C ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
                              C ; another, we save the number of chars to skip to that deep level).
                              C ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
                              C ; Flags: Bit 15 set = Network drive
                              C ;        Bit 14 set = Physical drive
                              C ;        Bit 13 set = JOIN'ed drive
                              C ;        Bit 12 set = SUBST'ed drive
                              C ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
0000005B                      C cds ENDS
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; The SFT is a way to allow applications to open file handles to files 
                              C ; and devices. As things stand, the SFT chain will have 5 file handles
                              C ; under the first header, and then a second header will be linked to the 
                              C ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
                              C ; a size for the second SFT (default 10 files). Same for System FCBs, 
                              C ; using the FCBS= command. Default FCBS=5.
                              C ;
                              C ; A file handle describes the file, and the location within the file that
                              C ; we are reading. The file handle can be manipulated without the file
                              C ; being in memory, thus allowing the user to access data without needing 
                              C ; to take up large portions of memory. Similarly, file handles allow for
                              C ; accessing devices, by treating them as files with their drivers 
                              C ; responding and translating the manipulations of the file handle itself.
                              C ; Neither the driver nor the application should see or use the SFT for
                              C ; the handle, as it is subject to change (and will change when file 
                              C ; sharing provisions are included). The DOS will make requests to the 
                              C ; driver in a generic way and the driver will respond, with DOS keeping
                              C ; track of the information in the SFT entry for that handle. 
                              C ;
                              C ; One SFT entry can have multiple handles and multiple SFT entries
                              C ; can point to the same file. It all depends on what the applications 
                              C ; want to do with the File.
                              C ;
                              C ; !!!!IMPORTANT!!!!
                              C ; Currently there are plans for File Sharing, but I include minimal 
                              C ; provisions for it. I really just wanna get a DOS out the door.
                              C ;
                              C ;Each SFT may look like this:
                              C ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
                              C ;            |                |
                              C ;       wNumFiles*sft    wNumFiles*sft
                              C ;
                              C ; Two SFT chains are built; one for files, and a one for so called 
                              C ; System FCBs.
                              C ;
                              C ; Each SFT header has an array of SFT's below it, with the number of 
                              C ; SFTs given by wNumFiles. The SFT headers form a linked list.
                              C ;
                              C ; DEFAULT FILES=15, MINIMUM FILES=5
                              C ; DEFAULT FCBS=5, MINIMUM FCBS=5
                              C ;------------------------------------------------------------------------;
00000000                      C sfth STRUC   ;System file table header
                              C ; This is the SFT header.
                              C ; This structure comes before the start of the first file in the array/table.
00000000                      C     qNextSFTPtr dq ?    ;Pointer to the next SFT
00000008                      C     wNumFiles   dw ?    ;Number of files in this table
0000000A                      C sfth ENDS
                              C 
00000000                      C sft STRUC
                              C ;This is the file struc itself
00000000                      C     wNumHandles dw ?    ;Number of handles pointing to this file
00000002                      C     wOpenMode   dw ?    ;Bit 15 set if opened via FCB
00000004                      C     bFileAttrib db ?    ;Regular File Attributes
00000005                      C     wDeviceInfo dw ?    ;Includes Device number
00000007                      C     qPtr        dq ?    ;IF char, ptr to device driver, ELSE DPBptr
0000000F                      C     dStartClust dd ?    ;Start cluster of file
00000013                      C     wTime       dw ?    ;File Time
00000015                      C     wDate       dw ?    ;File Date
00000017                      C     dFileSize   dd ?    ;File Size, in bytes
0000001B                      C     dCurntOff   dd ?    ;Current Offset in file, in bytes
0000001F                      C     wRelClust   dw ?    ;Relative cluster in file of the last cluster accessed
00000021                      C     dDirSect    dd ?    ;Relative number of sector containing directory entry 
00000025                      C     bNumDirEnt  db ?    ;Number of dir entry within sector (byte offset/32)
00000026                      C     sFCBName    db 11 dup(?)    ;8.3 Filename
00000031                      C     qPSPOwner   dq ?    ;Address of PSP of program which first opened this file
00000039                      C     dAbsClusr   dd ?    ;Absolute cluster of last cluster accessed
0000003D                      C sft ENDS
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; Buffers allow for buffered drive IO, by first transferring a sector 
                              C ; to an internal buffer, and then copying it to the specified location
                              C ; in memory. The buffer is kept in the buffer chain,  in the event that 
                              C ; another request for the same sector from the same device is made, so 
                              C ; that is can be read from the device directly. Buffers are uniform in 
                              C ; size, selected according to the largest detected sector size during 
                              C ; the initial loadup.
                              C ;
                              C ; The buffer pointer in SysVars points to most recently used Buffer
                              C ;
                              C ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
                              C ;------------------------------------------------------------------------;
                              C 
00000000                      C bufferHdr   STRUC
00000000                      C     nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
00000008                      C     driveNumber db  ?   ;Drive number the buffer is used for
00000009                      C     bufferFlags db  ?   ;Standard Flags
0000000A                      C     bufferLBA   dd  ?   ;LBA the buffer contains
0000000E                      C     bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
0000000F                      C     bufFAToff   db  ?   ;Sector offset of the backup copy of the FAT on disk
00000010                      C     driveDPBPtr dq  ?   ;Pointer to the device DPB block
00000018                      C bufferHdr   ENDS
                                    INCLUDE driverStruc.inc
                              C 
                              C ;-------------------------------------------------------;
                              C ; This include file contains miscellaneous SCP/DOS      ;
                              C ; device driver related structures.                     ;
                              C ;-------------------------------------------------------;
                              C 
00000000                      C drvHdr STRUC  ;Device Driver Header for character and block devices
                              C 
00000000                      C     nxtPtr dq ?  ;Pointer to the next driver header, -1 if at the end
00000008                      C     atWord dw ?  ;Attribute Word
0000000A                      C     strPtr dq ?  ;Strategy Entry Pointer
00000012                      C     intPtr dq ?  ;Interrupt Entry Pointer
0000001A                      C     drvNam db 8 dup (?)  ;Driver name (Char) or Unit number byte (Block)
                              C 
00000022                      C drvHdr ENDS
                              C 
                              C drvReqHdrM MACRO  ;Driver Request Header Macro
 >                            C   ;Driver Request Header Macro
 >                            C     hdrlen db ?  ;Length of the request header  ;Driver Request Header Macro
 >                            C     unitnm db ?  ;Unit number, meaningless for character devs  ;Driver Request Header Macro
 >                            C     cmdcde db ?  ;Command code  ;Driver Request Header Macro
 >                            C     status dw ?  ;Status word  ;Driver Request Header Macro
 >                            C     devptr dq ?  ;Device queue pointer field  ;Driver Request Header Macro
 >                            C   ;Driver Request Header Macro
 >                            C ENDM  ;Driver Request Header Macro
                              C 
00000000                      C drvReqHdr   STRUC
                              C     drvReqHdrM
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C drvReqHdr   ENDS
                              C 
00000000                      C initReqPkt STRUC  ;Init Request Packet
                              C 
                              C     drvReqHdrM   ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     numunt db ?  ;Number of logical units (Block only, 0 for char)
0000000E                      C     endptr dq ?  ;Pointer to first free byte after driver
00000016                      C     optptr dq ?  ;Pointer to the BPB array (block) or optional args (char)
0000001E                      C     drvnum db ?  ;Drive number
                              C 
0000001F                      C initReqPkt ENDS
                              C 
00000000                      C mediaCheckReqPkt STRUC ;Media Check Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     medesc db ?  ;DOS media descriptor
0000000E                      C     medret db ?  ;Return byte (Has media been changed?)
0000000F                      C     desptr dq ?  ;Pointer to a valid volume id field
                              C 
00000017                      C mediaCheckReqPkt ENDS
                              C 
00000000                      C bpbBuildReqPkt STRUC  ;Build BPB Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     medesc db ?  ;DOS media descriptor
0000000E                      C     bufptr dq ?  ;Transfer buffer
00000016                      C     bpbptr dq ?  ;Pointer to the BPB
                              C 
0000001E                      C bpbBuildReqPkt ENDS
                              C 
00000000                      C ioReqPkt STRUC   ;IO Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     medesc db ?  ;DOS media descriptor
0000000E                      C     bufptr dq ?  ;Transfer buffer
00000016                      C     tfrlen dd ?  ;Number of Sectors/bytes to transfer
0000001A                      C     strtsc dq ?  ;Starting sector for transfer
00000022                      C     desptr dq ?  ;Pointer to a valid volume id field if error
                              C 
0000002A                      C ioReqPkt ENDS
                              C 
00000000                      C nonDestInNoWaitReqPkt STRUC    ;Nondestructive Input No Wait Request Packet
                              C     
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     retbyt db ?  ;Byte read non destructively
                              C 
0000000E                      C nonDestInNoWaitReqPkt ENDS
                              C 
00000000                      C statusReqPkt STRUC   ;Status Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C 
0000000D                      C statusReqPkt ENDS
                              C 
00000000                      C flushReqPkt STRUC ;Flush Request Packet, terminate all pending requests
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C flushReqPkt ENDS
                              C 
00000000                      C openReqPkt STRUC ;Open Device Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C openReqPkt ENDS
                              C 
00000000                      C closeReqPkt STRUC ;Close Device Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C closeReqPkt ENDS
                              C 
00000000                      C remMediaReqPkt STRUC ;Removeable Media? Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C remMediaReqPkt ENDS
                              C 
00000000                      C ioctlReqPkt STRUC    ;Generic IOCTL Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro  
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     majfun db ?  ;Major function number
0000000E                      C     minfun db ?  ;Minor function number
0000000F                      C     rsival dq ?  ;Contents of RSI
00000017                      C     rdival dq ?  ;Contents of RDI
0000001F                      C     ctlptr dq ?  ;Pointer to Generic IOCTL Request Packet
                              C 
00000027                      C ioctlReqPkt ENDS
                              C 
00000000                      C getDevReqPkt STRUC ;Get Logical Device Request Packet
                              C     
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     getcmd db ?  ;Command code
0000000E                      C     cmdsts dw ?  ;Command status word
                              C 
00000010                      C getDevReqPkt ENDS
                              C 
00000000                      C setDevReqPkt STRUC ;Set Logical Device Request Packet
                              C     
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     setcmd db ?  ;Command code
0000000E                      C     cmdsts dw ?  ;Command status word
                              C 
00000010                      C setDevReqPkt ENDS
                                    INCLUDE dosData.inc
                              C ; This file contains the structure of the DOS Data area
00000000                      C dSeg STRUC
00000000                      C     dataSegPtr  dq ?    ;Pointer to the data Segment itself
00000008                      C     codeSegPtr  dq ?    ;Pointer to the start of the resident Code segment
00000010                      C     bootDrive   db ?    ;The Int 33h device we booted from
00000011                      C     requestHdr  drvReqHdr    <,,,,>   ;The device driver header
0000001E                      C                 db 20 dup (?)    ;Reserve xtra space for cmd data, with padding
00000032                      C     sysVarsPtr  dq ?    ;Pointer to dpbHeadPtr, head of Sys Vars structure below
0000003A                      C     mcbChainPtr dq ?    ;Pointer to the MCB chain
00000042                      C     dpbHeadPtr  dq ?    ;Pointer to the first DPB in the DPB chain
0000004A                      C     sftHeadPtr  dq ?    ;Pointer to the first SFT header in SFT chain
00000052                      C     clockPtr    dq ?    ;Pointer to the current active CLOCK$ device header
                              C     ;                    The last driver loaded with the CLOCK$ bit[3] set 
0000005A                      C     conPtr      dq ?    ;Pointer to the current active CON device header 
                              C     ;                    The last driver loaded with the STDIN bit[0] set
00000062                      C     maxBytesSec dw ?    ;Maximum number of bytes per sector (size of buffers)
00000064                      C     bufHeadPtr  dq ?    ;Pointer to the head of the disk buffer chain
0000006C                      C     cdsHeadPtr  dq ?    ;Pointer to the head of the CDS array
00000074                      C     sfcbHeadPTr dq ?    ;Pointer to the head of the System FCB chain
0000007C                      C     numSafeSFCB dw ?    ;Number of protected FCBs (y in FCBS=x,y)
0000007E                      C     numMSDdrv   db ?    ;Number of mass storage devices detected in system
0000007F                      C     lastdrvNum  db ?    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
00000080                      C     numJoinDrv  db ?    ;Number of Joined Drives
00000081                      C     nulDevHdr   drvHdr <,,,,>
                              C 
                              C 
000000A3                      C     inDOS       db ?    ;Incremented on each DOS call, decremented when leaving
000000A4                      C     breakFlag   db ?    ;If set, check for CTRL+C on all DOS calls
000000A5                      C     defaultDrv  db ?    ;Default, last accessed drive
                              C 
000000A6                      C     critStack   dq 41 dup (?)
000001EE                      C     critStakTop dq ?
000001F6                      C     IOStack     dq 199 dup (?)
0000082E                      C     IOStakTop   dq ?
00000836                      C     DiskStack   dq 199 dup (?)
00000E6E                      C     DiskStakTop dq ?
00000E76                      C dSeg ENDS

00000000                        loadCode SEGMENT USE64
                                    ASSUME ds:FLAT, es:FLAT
                                ; We arrive here with the following values in the registers.
                                ; rbx =  LBA of first Logical Block after SCP/BIOS
                                ; dx  = Int 33h boot device number
                                ; fs  = userbase pointer (pointer to first usable block of RAM)
00000000  55AA                      dw 0AA55h           ;Initial signature

00000002  6488142510000000          mov byte ptr fs:[dSeg.bootDrive], dl ;Save the boot drive in memory

0000000A  B9000100C0                mov ecx, 0C0000100h ;Read FS MSR
0000000F  0F32                      rdmsr
00000011  8BFA                      mov edi, edx        ;Get the hi dword, and clear the upper bytes
00000013  48C1E720                  shl rdi, 20h        ;Shift high
00000017  8BF8                      mov edi, eax        ;Get the low dword in

00000019  6448893C2500000000        mov qword ptr fs:[dSeg.dataSegPtr], rdi  
00000022  4881C7760E0000            add rdi, SIZEOF dSeg
00000029  6448893C2508000000        mov qword ptr fs:[dSeg.codeSegPtr], rdi
00000032  488BC7                    mov rax, rdi    ;Save the codeSegment address in rax
00000035  488D3500000000            lea rsi, OFFSET resCode ;Get RIP relative address to copy high
0000003C  B900100000                mov ecx, 1000h
00000041  F348A5                    rep movsq
00000044  6687DB                    xchg bx, bx
00000047  48BB00000000000000        mov rbx, msdDriver 
00000051  48C7C1760E0000            mov rcx, SIZEOF dSeg
00000058  482BD9                    sub rbx, rcx
0000005B  488D1C03                  lea rbx, qword ptr [rax + rbx]
0000005F  32C0                      xor al, al
00000061  FFD3                      call rbx

00000063  488D2D00000000            lea rbp, startmsg   ;Get the absolute address of message
0000006A  B804130000                mov eax, 1304h
0000006F  CD30                      int 30h
00000071                        @@:
00000071  6633C0                    xor ax, ax
00000074  CD36                      int 36h
00000076  B40E                      mov ah, 0Eh
00000078  CD30                      int 30h
0000007A  EBF5                      jmp short @b

0000007C  0A0D5374617274696E        startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,0
00000094                        nData   LABEL QWORD
00000094  0000000000000000          dq conHdr
0000009C  0480                      dw 08004h
0000009E  0000000000000000          dq nulStrat
000000A6  0000000000000000          dq nulIntr
000000AE  4E554C2020202020          db "NUL     "
000000B6                        loadCode ENDS

                                ;codeSegment points to the start of this segment!
00000000                        resCode SEGMENT BYTE USE64
                                    ASSUME ds:FLAT, es:FLAT
                                ;-----------------------------------:
                                ;        Data Area Instance         :
                                ;-----------------------------------:
00000000  000000000000000000    data dSeg <>    ;Initialise data area as BSS 
                                        ORG $ 
                                ;Offset all addresses below here by size of data area since it is uninitialised
                                ; to not take up space in the binary file.
                                ;-----------------------------------:
                                ;       Misc System routines        :
                                ;-----------------------------------:
00000E76                        findLRUBuffer  PROC 
                                ;Finds least recently used buffer, links it and returns ptr to it in rbx
                                ;Input: Nothing
                                ;Output: rbx = Pointer to the buffer to use
00000E76  52                        push rdx
00000E77  488B1D64000000            mov rbx, qword ptr [data.bufHeadPtr]
00000E7E  48833BFF                  cmp qword ptr [rbx + bufferHdr.nextBufPtr], -1  ;Check if 1st entry is last
00000E82  7502                      jne @f
00000E84  5A                        pop rdx
00000E85                            ret
00000E85  C3                *   retn
00000E86                        @@:
00000E86  488BD3                    mov rdx, rbx    ;Save a ptr to the previous buffer header
00000E89  488B1A                    mov rbx, qword ptr [rdx + bufferHdr.nextBufPtr] ;Get next buffer header ptr
00000E8C  48833BFF                  cmp qword ptr [rbx + bufferHdr.nextBufPtr], -1 ;Check if at LRU buffer
00000E90  75F4                      jne @b   ;If not LRU, keep walking, else process
00000E92  48C702FFFFFFFF            mov qword ptr [rdx + bufferHdr.nextBufPtr], -1  ;Make prev node the LRU node
00000E99  488B1564000000            mov rdx, qword ptr [data.bufHeadPtr]    ;Now copy old MRU buffer ptr to rdx
00000EA0  48891D64000000            mov qword ptr [data.bufHeadPtr], rbx    ;Sysvars to point to new buffer
00000EA7  488913                    mov qword ptr [rbx + bufferHdr.nextBufPtr], rdx
00000EAA  5A                        pop rdx
00000EAB                            ret
00000EAB  C3                *   retn
00000EAC                        findLRUBuffer  ENDP
00000EAC                        findDPB     PROC
                                ;Finds the DPB for a given drive
                                ;Input:   dl = Drive number (0=A, 1=B etc...)
                                ;Output: al = 00, rbx = Pointer to the DPB
                                ;        al = -1, Failed, no DPB for device, rbx destroyed
00000EAC  488B1D42000000            mov rbx, qword ptr [data.dpbHeadPtr]
00000EB3                        @@:
00000EB3  32C0                      xor al, al
00000EB5  3813                      cmp byte ptr [rbx + dpb.bDriveNumber], dl
00000EB7  740E                      je @f
00000EB9  488B5B26                  mov rbx, qword ptr [rbx + dpb.qNextDPBPtr]
00000EBD  B0FF                      mov al, -1
00000EBF  4883FBFF                  cmp rbx, -1 ;If rbx followed last item in list, no DPB exists for dl
00000EC3  7402                      je @f
00000EC5  EBEC                      jmp short @b
00000EC7                        @@:
00000EC7                            ret
00000EC7  C3                *   retn
00000EC8                        findDPB     ENDP

                                ;-----------------------------------:
                                ;       File System routines        :
                                ;-----------------------------------:
00000EC8                        FATprocs    PROC
00000EC8                        FATprocs    ENDP

                                ;-----------------------------------:
                                ;        Interrupt routines         :
                                ;-----------------------------------:
00000EC8                        int49hHook  PROC    ;Called with char to transfer in al
00000EC8  50                        push rax
00000EC9  B40E                      mov ah, 0Eh
00000ECB  CD30                      int 30h
00000ECD  58                        pop rax
00000ECE                            iretq
00000ECE  48CF              *   iretq
00000ED0                        int49hHook  ENDP

                                ;-----------------------------------:
                                ;          Driver routines          :
                                ;-----------------------------------:

00000ED0                        drivers PROC
00000ED0  000000000000000013    conHdr  drvHdr <auxHdr,  08013h, commonStrat, conDriver, "CON     ">
00000EF2  000000000000000000    auxHdr  drvHdr <prnHdr,  08000h, commonStrat, com1Intr,  "AUX     ">
00000F14  000000000000000040    prnHdr  drvHdr <clkHdr,  0A040h, commonStrat, lpt1Hdr ,  "PRN     ">
00000F36  000000000000000008    clkHdr  drvHdr <msdHdr,  08008h, commonStrat, clkDriver, "CLOCK$  ">
00000F58  000000000000000040    msdHdr  drvHdr <com1Hdr, 00840h, commonStrat, msdIntr, <0,0,0,0,0,0,0,0>>
00000F7A  000000000000000000    com1Hdr drvHdr <com2Hdr, 08000h, commonStrat, com1Intr, "COM1    ">
00000F9C  000000000000000000    com2Hdr drvHdr <com3Hdr, 08000h, commonStrat, com2Intr, "COM2    ">
00000FBE  000000000000000000    com3Hdr drvHdr <com4Hdr, 08000h, commonStrat, com3Intr, "COM3    ">
00000FE0  000000000000000000    com4Hdr drvHdr <lpt1Hdr, 08000h, commonStrat, com4Intr, "COM4    ">
00001002  000000000000000040    lpt1Hdr drvHdr <lpt2Hdr, 0A040h, commonStrat, lptIntr, "LPT1    ">
00001024  000000000000000040    lpt2Hdr drvHdr <lpt3Hdr, 0A040h, commonStrat, lptIntr, "LPT2    ">
00001046  FFFFFFFFFFFFFFFF40    lpt3Hdr drvHdr <-1, 0A040h, commonStrat, lptIntr, "LPT3    ">
00001068                        commonStrat PROC
                                ;DOS calls this function with rbx=Ptr to request header
                                ;DOS also sets fs to point to its data segment when entered
00001068  48891D00000000            mov qword ptr [reqHdrPtr], rbx
0000106F                            ret
0000106F  C3                *   retn
00001070  0000000000000000      reqHdrPtr  dq ?    ;Where the default device drivers store the ReqPtr
00001078                        commonStrat ENDP

00001078                        nulStrat   PROC
00001078  66C743030001              mov word ptr [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
0000107E                        nulIntr PROC
0000107E                            ret
0000107E  C3                *   retn
0000107F                        nulIntr     ENDP
0000107F                        nulStrat    ENDP

0000107F                        conDriver   PROC
0000107F  50                        push rax
00001080  53                        push rbx
00001081  488B1D00000000            mov rbx, qword ptr [reqHdrPtr]
00001088  8A4302                    mov al, byte ptr [rbx + drvReqHdr.cmdcde]
0000108B  32C0                      xor al, al
0000108D  7421                      jz conInit
0000108F  3C04                      cmp al, 4
00001091  7446                      jz conRead
00001093  3C05                      cmp al, 5
00001095  745F                      jz conNondestructiveRead
00001097  3C06                      cmp al, 6
00001099  740C                      jz conExit
0000109B  3C07                      cmp al, 7
0000109D  746A                      jz conFlushInputBuffers
0000109F  3C08                      cmp al, 8
000010A1  7472                      jz conWrite
000010A3  3C09                      cmp al, 9
000010A5  746E                      jz conWrite
                                ;All other cases fall through here
000010A7                        conExit:
000010A7  66814B030001              or word ptr [rbx + drvReqHdr.status], 0100h    ;Merge done bit
000010AD  5B                        pop rbx
000010AE  58                        pop rax
000010AF                            ret
000010AF  C3                *   retn
000010B0                        conInit:    ;Function 0
000010B0  52                        push rdx
000010B1  E853000000                call conFlushInputBuffers  ;Call to flush keyboard buffer
000010B6  B800050000                mov eax, 0500h  ;Set page zero as the default page
000010BB  CD30                      int 30h
000010BD  B402                      mov ah, 02h
000010BF  33D2                      xor edx, edx    ;Set screen cursor to top right corner
000010C1  8AFA                      mov bh, dl      ;Set cursor for page 0
000010C3  CD30                      int 30h
000010C5  B707                      mov bh, 07h     ;Grey/Black attribs
000010C7  B800060000                mov eax, 0600h  ;Clear whole screen
000010CC  CD30                      int 30h
000010CE  5A                        pop rdx
000010CF  EBD6                      jmp short conExit
000010D1                        conIORead:
000010D1  66C743030380              mov word ptr [rbx + drvReqHdr.status], 8003h    ;Error, unknown command!
000010D7  EBCE                      jmp short conExit
000010D9                        conRead:    ;Function 4
000010D9  57                        push rdi
000010DA  51                        push rcx
000010DB  488B7B0E                  mov rdi, qword ptr [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
000010DF  33C9                      xor ecx, ecx    ;Zero the char counter
000010E1                        @@:
000010E1  3B4B16                    cmp ecx, dword ptr [rbx + ioReqPkt.tfrlen]
000010E4  7409                      je @f
000010E6  33C0                      xor eax, eax
000010E8  CD36                      int 36h
000010EA  AA                        stosb   ;Store char in al into buffer and inc rdi
000010EB  FFC1                      inc ecx
000010ED  EBF2                      jmp short @b
000010EF                        @@:
000010EF  894B16                    mov dword ptr [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
000010F2  59                        pop rcx
000010F3  5F                        pop rdi
000010F4  EBB1                      jmp short conExit
000010F6                        conNondestructiveRead:  ;Function 5
000010F6  B401                      mov ah, 01h     ;Get key if exists
000010F8  CD36                      int 36h
000010FA  7405                      jz @f           ;If zero clear => no key, go forwards
                                    ;Keystroke available
000010FC  88430D                    mov byte ptr [rbx + nonDestInNoWaitReqPkt.retbyt], al   ;Move char in al
000010FF  EBA6                      jmp short conExit
00001101                        @@: ;No keystroke available
00001101  66C743030003              mov word ptr [rbx + nonDestInNoWaitReqPkt.status], 0300h   ;Set busy bit
00001107  EB9E                      jmp short conExit
00001109                        conFlushInputBuffers:   ;Function 7
00001109  B401                      mov ah, 01      ;Get buffer status
0000110B  CD36                      int 36h
0000110D  7498                      jz conExit      ;If zero clear => no more keys to read
0000110F  32E4                      xor ah, ah
00001111  CD36                      int 36h ;Read key to flush from buffer
00001113  EBF4                      jmp short conFlushInputBuffers
00001115                        conWrite:   ;Function 8 and 9
00001115  56                        push rsi
00001116  51                        push rcx
00001117  488B730E                  mov rsi, qword ptr [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
0000111B  33C9                      xor ecx, ecx    ;Zero the char counter
0000111D                        @@: 
0000111D  3B4B16                    cmp ecx, dword ptr [rbx + ioReqPkt.tfrlen]
00001120  7407                      je @f
00001122  AC                        lodsb   ;Get char into al, and inc rsi
00001123  CD49                      int 49h ;Fast print char
00001125  FFC1                      inc ecx
00001127  EBF4                      jmp short @b ;keep printing until all chars printed
00001129                        @@:
00001129  894B16                    mov dword ptr [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
0000112C  59                        pop rcx
0000112D  5E                        pop rsi
0000112E  E974FFFFFF                jmp conExit
00001133                        conDriver   ENDP

00001133                        clkDriver   PROC
00001133                        clkDriver   ENDP

00001133                        comDriver   PROC
00001133                        com1Intr    PROC
00001133  C6050000000000            mov byte ptr [comDevice], 0
0000113A  EB1B                      jmp short comIntr
0000113C                        com1Intr    ENDP
0000113C                        com2Intr    PROC
0000113C  C6050000000001            mov byte ptr [comDevice], 1
00001143  EB12                      jmp short comIntr
00001145                        com2Intr    ENDP
00001145                        com3Intr    PROC
00001145  C6050000000002            mov byte ptr [comDevice], 2
0000114C  EB09                      jmp short comIntr
0000114E                        com3Intr    ENDP
0000114E                        com4Intr    PROC
0000114E  C6050000000003            mov byte ptr [comDevice], 3
00001155  EB00                      jmp short comIntr
00001157                        com4Intr    ENDP
00001157                        comIntr     PROC
00001157  50                        push rax
00001158  53                        push rbx
00001159  51                        push rcx
0000115A  52                        push rdx
0000115B  56                        push rsi
0000115C  488B1D00000000            mov rbx, qword ptr [reqHdrPtr]
00001163  8A4302                    mov al, byte ptr [rbx + drvReqHdr.cmdcde]
00001166  3C04                      cmp al, 4
00001168  7418                      jz comRead
0000116A  3C05                      cmp al, 5
0000116C  7439                      jz comNondestructiveRead
0000116E  3C08                      cmp al, 8
00001170  743D                      jz comWrite
00001172  3C09                      cmp al, 9
00001174  7439                      jz comWrite
                                ;All other cases fall through here
00001176                        comExit:
00001176  66814B030001              or word ptr [rbx + drvReqHdr.status], 0100h    ;Merge done bit
0000117C  5E                        pop rsi
0000117D  5A                        pop rdx
0000117E  59                        pop rcx
0000117F  5B                        pop rbx
00001180  58                        pop rax
00001181                            ret
00001181  C3                *   retn
00001182                        comRead:
00001182  57                        push rdi
00001183  488B7B0E                  mov rdi, qword ptr [rbx + ioReqPkt.bufptr]  ;Point rdi to caller buffer
00001187  33C9                      xor ecx, ecx    ;Zero the char counter
00001189                        @@:
00001189  3B4B16                    cmp ecx, dword ptr [rbx + ioReqPkt.tfrlen]
0000118C  7413                      je @f
0000118E  B802000000                mov eax, 02h    ;Recieve 
00001193  668B1500000000            mov dx, word ptr [comDevice]    ;Get transacting com device
0000119A  CD34                      int 34h ;Recieve Char
0000119C  AA                        stosb   ;Store char in al into buffer and inc rdi
0000119D  FFC1                      inc ecx
0000119F  EBE8                      jmp short @b
000011A1                        @@:
000011A1  894B16                    mov dword ptr [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
000011A4  5F                        pop rdi
000011A5  EBCF                      jmp short comExit
000011A7                        comNondestructiveRead:
000011A7  66C743030002              mov word ptr [rbx + nonDestInNoWaitReqPkt.status], 0200h    ;Set busy bit 
000011AD  EBC7                      jmp short comExit
000011AF                        comWrite:
000011AF  488B730E               mov rsi, qword ptr [rbx + ioReqPkt.bufptr] ;Point rsi to caller buffer 
000011B3  33C9                      xor ecx, ecx    ;Zero the char counter
000011B5                        @@: 
000011B5  3B4B16                    cmp ecx, dword ptr [rbx + ioReqPkt.tfrlen]
000011B8  7410                      je @f
000011BA  AC                        lodsb   ;Get char into al, and inc rsi
000011BB  B401                      mov ah, 01h ;Move function number into ah
000011BD  668B1500000000            mov dx, word ptr [comDevice]
000011C4  CD34                      int 34h ;Transmit char
000011C6  FFC1                      inc ecx
000011C8  EBEB                      jmp short @b ;keep printing until all chars printed
000011CA                        @@:
000011CA  894B16                    mov dword ptr [rbx + ioReqPkt.tfrlen], ecx  ;Move num of transferred chars
000011CD  EBA7                      jmp short comExit
000011CF  00                    comDevice   db ?
000011D0                        comIntr     ENDP

000011D0                        comDriver   ENDP

000011D0                        lptDriver   PROC    ;Drivers for LPT 1, 2, 3

000011D0                        lptIntr     PROC    ;LPT act as null device drivers
000011D0  57                        push rdi
000011D1  488B3D00000000            mov rdi, qword ptr [reqHdrPtr]
000011D8  66C747030001              mov word ptr [rdi + drvReqHdr.status], 0100h    ;Done bit set
000011DE  5F                        pop rdi
000011DF                            ret
000011DF  C3                *   retn
000011E0                        lptIntr     ENDP
000011E0                        lptDriver   ENDP
000011E0                        msdDriver   PROC
000011E0                        msdIntr     LABEL   BYTE
000011E0  50                        push rax
000011E1  53                        push rbx
                                    ;mov rbx, qword ptr [reqHdrPtr]  ;Get the ptr to the req header in rdi
                                    ;mov al, byte ptr [rbx + drvReqHdr.cmdcde]   ;Get command code in al
                                    ;cmp al, 24  ;Check cmd num is valid
                                    ;ja msdError
000011E2  84C0                      test al, al
000011E4  7471                      jz msdInit
000011E6  3C01                      cmp al, 01
000011E8  0F84F8000000              jz msdMedChk
000011EE  3C02                      cmp al, 02
000011F0  0F84F0000000              jz msdBuildBPB
000011F6  3C03                      cmp al, 03
000011F8  0F84E8000000              jz msdIOCTLRead
000011FE  3C04                      cmp al, 04
00001200  0F84E0000000              jz msdRead
00001206  3C08                      cmp al, 08
00001208  0F84D8000000              jz msdWrite
0000120E  3C09                      cmp al, 09
00001210  0F84D0000000              jz msdWriteVerify
00001216  3C0C                      cmp al, 12
00001218  0F84C8000000              jz msdIOCTLWrite
0000121E  3C0D                      cmp al, 13
00001220  0F84C0000000              jz msdDevOpen
00001226  3C0E                      cmp al, 14
00001228  0F84B8000000              jz msdDevClose
0000122E  3C0F                      cmp al, 15
00001230  0F84B0000000              jz msdRemovableMedia
00001236  3C13                      cmp al, 19
00001238  0F84A8000000              jz msdGenericIOCTL
0000123E  3C17                      cmp al, 23
00001240  0F84A0000000              jz msdGetLogicalDev
00001246  3C18                      cmp al, 24
00001248  0F8498000000              jz msdSetLogicalDev
0000124E                        msdError:
0000124E                        msdIntrExit:
0000124E  66814B030001              or word ptr [rbx + drvReqHdr.status], 0100h ;Set done bit
00001254  5B                        pop rbx
00001255  58                        pop rax
00001256                            ret
00001256  C3                *   retn
00001257                        msdInit:            ;Function 0
00001257  CD31                      int 31h ;Get number of Int 33h devices in r8b
00001259  4D0FB6C0                  movzx r8, r8b   ;Keeps real count
0000125D  418BC0                    mov eax, r8d
00001260  3C01                      cmp al, 1
00001262  7702                      ja @f
00001264  FEC0                      inc al ;Make it two
00001266                        @@:
00001266  BA05000000                mov edx, 5
0000126B  3BC2                      cmp eax, edx
0000126D  0F47C2                    cmova eax, edx  ;If num of drives is greater than 5, consider only first 5
00001270  88051A000000              mov byte ptr [msdHdr.drvNam], al ;Save num of drvs in drvr hdr
00001276  88430D                    mov byte ptr [rbx + initReqPkt.numunt], al ;And in req packet
00001279  4400057E000000            add byte ptr [data.numMSDdrv], r8b ;Add the true number of devices to total
00001280  33ED                      xor ebp, ebp    ;Use bpl as device counter, cmp to r8b
00001282  488D3D00000000            lea rdi, msdBPBblks
00001289  53                        push rbx
0000128A                        @@:
0000128A  8BD5                      mov edx, ebp
0000128C  488D1D00000000            lea rbx, driverDataPtr  ;Get address of scratch space
00001293  33C9                      xor ecx, ecx    ;Sector 0
00001295  B801820000                mov eax, 8201h       ;Read 1 sector
0000129A  CD33                      int 33h
0000129C  7246                      jc msdInitError

0000129E  488D3500000000            lea rsi, driverDataPtr  ;Point to start of data
000012A5  B90F000000                mov ecx, SIZEOF(bpbEx)/8
000012AA  F348A5                    rep movsq   ;Move the BPB data into the right block

000012AD  FFC5                      inc ebp
000012AF  493BE8                    cmp rbp, r8 ;Have we written the BPB for all physical drives?
000012B2  75D6                      jne @b  ;No? Go again

000012B4  488D3D00000000            lea rdi, msdBPBTbl  ;Point to start of table
000012BB  488D1500000000            lea rdx, msdBPBblks
000012C2                        @@:
000012C2  488917                    mov qword ptr [rdi], rdx    ;Move the block entry ptr to rdi
000012C5  4883C278                  add rdx, SIZEOF(bpbEx)      ;Make rdx point to the next block entry
000012C9  FFCD                      dec ebp
000012CB  75F5                      jnz @b  ;If not zero yet, go again

000012CD  5B                        pop rbx
000012CE  488D1500000000            lea rdx, msdBPBTbl  ;Get far pointer 
000012D5  48895316                  mov qword ptr [rbx + initReqPkt.optptr], rdx  ;Save ptr to array
000012D9  488D1500000000            lea rdx, driverDataPtr
000012E0  4889530E                  mov qword ptr [rbx + initReqPkt.endptr], rdx    ;Save free space ptr
000012E4                        msdInitError:
000012E4  5B                        pop rbx
000012E5                            ret
000012E5  C3                *   retn
000012E6                        msdMedChk:          ;Function 1
000012E6                        msdBuildBPB:        ;Function 2
000012E6                        msdIOCTLRead:       ;Function 3, returns done
000012E6                        msdRead:            ;Funciton 4
000012E6                        msdWrite:           ;Function 8
000012E6                        msdWriteVerify:     ;Function 9, writes sectors then verifies then

000012E6                        msdIOCTLWrite:      ;Function 12, returns done
000012E6                        msdDevOpen:         ;Function 13
000012E6                        msdDevClose:        ;Function 14
000012E6                        msdRemovableMedia:  ;Function 15
000012E6                        msdGenericIOCTL:    ;Function 19
000012E6                        msdGetLogicalDev:   ;Function 23
000012E6                        msdSetLogicalDev:   ;Function 24
000012E6  E963FFFFFF                jmp msdIntrExit
000012EB  4E4F204E414D452000    msdDefLabel db "NO NAME ",0 ;Default volume label
                                ;LASTDRIVE default is 5
000012F4  0000000000            msdBIOSmap  db 5 dup (?)    ;Translates DOS drive number to BIOS number
000012F9  0000000000            msdHdlCnt   db 5 dup (?)    ;Keeps a count of open handles to drive N
000012FE  000000000000000000    msdBPBTbl   dq 5 dup (?)    ;BPB pointer table to be returned
00001326  000000000000000000    msdBPBblks  db 5*SIZEOF(bpbEx) dup (?)    ;Keep up to 5 bpb records of exFAT bpb size
0000157E                        msdDriver   ENDP
0000157E                        driverDataPtr   LABEL   BYTE
0000157E                        drivers ENDP
0000157E                        resCode ENDS

                                END


Binary Map:

Segment                  Pos(file)     RVA  Size(fil) Size(mem)
---------------------------------------------------------------
loadCode                        0        0        B6        B6
resCode                        B6       B6       708      157E
---------------------------------------------------------------
                                                 7BE      1634


Macros:

                N a m e                 Type

@CatStr  . . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func
drvReqHdrM . . . . . . . . . . .        Proc


Structures and Unions:

                N a m e                 Size/Ofs   Type

bpb  . . . . . . . . . . . . . .              3E
  jmpBoot  . . . . . . . . . . .               0   Byte[3]
  oemName  . . . . . . . . . . .               3   Byte[8]
  bytsPerSec . . . . . . . . . .               B   Word
  secPerClus . . . . . . . . . .               D   Byte
  revdSecCnt . . . . . . . . . .               E   Word
  numFATs  . . . . . . . . . . .              10   Byte
  rootEntCnt . . . . . . . . . .              11   Word
  totSec16 . . . . . . . . . . .              13   Word
  media  . . . . . . . . . . . .              15   Byte
  FATsz16  . . . . . . . . . . .              16   Word
  secPerTrk  . . . . . . . . . .              18   Word
  numHeads . . . . . . . . . . .              1A   Word
  hiddSec  . . . . . . . . . . .              1C   DWord
  totSec32 . . . . . . . . . . .              20   DWord
  drvNum . . . . . . . . . . . .              24   Byte
  reserved1  . . . . . . . . . .              25   Byte
  bootSig  . . . . . . . . . . .              26   Byte
  volID  . . . . . . . . . . . .              27   DWord
  volLab . . . . . . . . . . . .              2B   Byte[11]
  filSysType . . . . . . . . . .              36   Byte[8]
bpb32  . . . . . . . . . . . . .              5A
  jmpBoot  . . . . . . . . . . .               0   Byte[3]
  oemName  . . . . . . . . . . .               3   Byte[8]
  bytsPerSec . . . . . . . . . .               B   Word
  secPerClus . . . . . . . . . .               D   Byte
  revdSecCnt . . . . . . . . . .               E   Word
  numFATs  . . . . . . . . . . .              10   Byte
  rootEntCnt . . . . . . . . . .              11   Word
  totSec16 . . . . . . . . . . .              13   Word
  media  . . . . . . . . . . . .              15   Byte
  FATsz16  . . . . . . . . . . .              16   Word
  secPerTrk  . . . . . . . . . .              18   Word
  numHeads . . . . . . . . . . .              1A   Word
  hiddSec  . . . . . . . . . . .              1C   DWord
  totSec32 . . . . . . . . . . .              20   DWord
  FATsz32  . . . . . . . . . . .              24   DWord
  extFlags . . . . . . . . . . .              28   Word
  FSver  . . . . . . . . . . . .              2A   Word
  RootClus . . . . . . . . . . .              2C   DWord
  FSinfo . . . . . . . . . . . .              30   Word
  BkBootSec  . . . . . . . . . .              32   Word
  reserved . . . . . . . . . . .              34   Byte[12]
  drvNum . . . . . . . . . . . .              40   Byte
  reserved1  . . . . . . . . . .              41   Byte
  bootSig  . . . . . . . . . . .              42   Byte
  volID  . . . . . . . . . . . .              43   DWord
  volLab . . . . . . . . . . . .              47   Byte[11]
  filSysType . . . . . . . . . .              52   Byte[8]
bpbBuildReqPkt . . . . . . . . .              1E
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  medesc . . . . . . . . . . . .               D   Byte
  bufptr . . . . . . . . . . . .               E   QWord
  bpbptr . . . . . . . . . . . .              16   QWord
bpbEx  . . . . . . . . . . . . .              78
  jmpBoot  . . . . . . . . . . .               0   Byte[3]
  oemName  . . . . . . . . . . .               3   Byte[8]
  MustBeZero . . . . . . . . . .               B   Byte[53]
  partitionOffset  . . . . . . .              40   QWord
  volumeLength . . . . . . . . .              48   QWord
  FAToffset  . . . . . . . . . .              50   DWord
  FATlength  . . . . . . . . . .              54   DWord
  clusterHeapOffset  . . . . . .              58   DWord
  clusterCount . . . . . . . . .              5C   DWord
  firstClusterOfRootDir  . . . .              60   DWord
  volumeSerialNum  . . . . . . .              64   DWord
  FSrevision . . . . . . . . . .              68   Word
  volumeFlags  . . . . . . . . .              6A   Word
  bytesPerSectorShift  . . . . .              6C   Byte
  sectorsPerClusterShift . . . .              6D   Byte
  numberOfFATs . . . . . . . . .              6E   Byte
  driveSelect  . . . . . . . . .              6F   Byte
  percentInUse . . . . . . . . .              70   Byte
  reserved . . . . . . . . . . .              71   Byte[7]
bufferHdr  . . . . . . . . . . .              18
  nextBufPtr . . . . . . . . . .               0   QWord
  driveNumber  . . . . . . . . .               8   Byte
  bufferFlags  . . . . . . . . .               9   Byte
  bufferLBA  . . . . . . . . . .               A   DWord
  bufFATcopy . . . . . . . . . .               E   Byte
  bufFAToff  . . . . . . . . . .               F   Byte
  driveDPBPtr  . . . . . . . . .              10   QWord
cds  . . . . . . . . . . . . . .              5B
  sCurrentPath . . . . . . . . .               0   Byte[67]
  wFlags . . . . . . . . . . . .              43   Word
  qDPBPtr  . . . . . . . . . . .              45   QWord
  dStartCluster  . . . . . . . .              4D   DWord
  qReserved  . . . . . . . . . .              51   QWord
  wBackslashOffset . . . . . . .              59   Word
closeReqPkt  . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
dSeg . . . . . . . . . . . . . .             E76
  dataSegPtr . . . . . . . . . .               0   QWord
  codeSegPtr . . . . . . . . . .               8   QWord
  bootDrive  . . . . . . . . . .              10   Byte
  requestHdr . . . . . . . . . .              11   drvReqHdr
  sysVarsPtr . . . . . . . . . .              32   QWord
  mcbChainPtr  . . . . . . . . .              3A   QWord
  dpbHeadPtr . . . . . . . . . .              42   QWord
  sftHeadPtr . . . . . . . . . .              4A   QWord
  clockPtr . . . . . . . . . . .              52   QWord
  conPtr . . . . . . . . . . . .              5A   QWord
  maxBytesSec  . . . . . . . . .              62   Word
  bufHeadPtr . . . . . . . . . .              64   QWord
  cdsHeadPtr . . . . . . . . . .              6C   QWord
  sfcbHeadPTr  . . . . . . . . .              74   QWord
  numSafeSFCB  . . . . . . . . .              7C   Word
  numMSDdrv  . . . . . . . . . .              7E   Byte
  lastdrvNum . . . . . . . . . .              7F   Byte
  numJoinDrv . . . . . . . . . .              80   Byte
  nulDevHdr  . . . . . . . . . .              81   drvHdr
  inDOS  . . . . . . . . . . . .              A3   Byte
  breakFlag  . . . . . . . . . .              A4   Byte
  defaultDrv . . . . . . . . . .              A5   Byte
  critStack  . . . . . . . . . .              A6   QWord[41]
  critStakTop  . . . . . . . . .             1EE   QWord
  IOStack  . . . . . . . . . . .             1F6   QWord[199]
  IOStakTop  . . . . . . . . . .             82E   QWord
  DiskStack  . . . . . . . . . .             836   QWord[199]
  DiskStakTop  . . . . . . . . .             E6E   QWord
dpb  . . . . . . . . . . . . . .              36
  bDriveNumber . . . . . . . . .               0   Byte
  bUnitNumber  . . . . . . . . .               1   Byte
  bBytesPerSectorShift . . . . .               2   Byte
  bMaxSectorInCluster  . . . . .               3   Byte
  bSectorsPerClusterShift  . . .               4   Byte
  dFAToffset . . . . . . . . . .               5   DWord
  bNumberOfFATs  . . . . . . . .               9   Byte
  wNumberRootDirEntries  . . . .               A   Word
  dClusterHeapOffset . . . . . .               C   DWord
  dClusterCount  . . . . . . . .              10   DWord
  dFATlength . . . . . . . . . .              14   DWord
  dFirstClusterOfRootDir . . . .              18   DWord
  qDriverHeaderPtr . . . . . . .              1C   QWord
  bMediaDescriptor . . . . . . .              24   Byte
  bAccessFlag  . . . . . . . . .              25   Byte
  qNextDPBPtr  . . . . . . . . .              26   QWord
  dFirstFreeCluster  . . . . . .              2E   DWord
  dNumberOfFreeClusters  . . . .              32   DWord
drvHdr . . . . . . . . . . . . .              22
  nxtPtr . . . . . . . . . . . .               0   QWord
  atWord . . . . . . . . . . . .               8   Word
  strPtr . . . . . . . . . . . .               A   QWord
  intPtr . . . . . . . . . . . .              12   QWord
  drvNam . . . . . . . . . . . .              1A   Byte[8]
drvReqHdr  . . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
flushReqPkt  . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
getDevReqPkt . . . . . . . . . .              10
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  getcmd . . . . . . . . . . . .               D   Byte
  cmdsts . . . . . . . . . . . .               E   Word
initReqPkt . . . . . . . . . . .              1F
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  numunt . . . . . . . . . . . .               D   Byte
  endptr . . . . . . . . . . . .               E   QWord
  optptr . . . . . . . . . . . .              16   QWord
  drvnum . . . . . . . . . . . .              1E   Byte
ioReqPkt . . . . . . . . . . . .              2A
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  medesc . . . . . . . . . . . .               D   Byte
  bufptr . . . . . . . . . . . .               E   QWord
  tfrlen . . . . . . . . . . . .              16   DWord
  strtsc . . . . . . . . . . . .              1A   QWord
  desptr . . . . . . . . . . . .              22   QWord
ioctlReqPkt  . . . . . . . . . .              27
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  majfun . . . . . . . . . . . .               D   Byte
  minfun . . . . . . . . . . . .               E   Byte
  rsival . . . . . . . . . . . .               F   QWord
  rdival . . . . . . . . . . . .              17   QWord
  ctlptr . . . . . . . . . . . .              1F   QWord
mediaCheckReqPkt . . . . . . . .              17
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  medesc . . . . . . . . . . . .               D   Byte
  medret . . . . . . . . . . . .               E   Byte
  desptr . . . . . . . . . . . .               F   QWord
nonDestInNoWaitReqPkt  . . . . .               E
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  retbyt . . . . . . . . . . . .               D   Byte
openReqPkt . . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
remMediaReqPkt . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
setDevReqPkt . . . . . . . . . .              10
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  setcmd . . . . . . . . . . . .               D   Byte
  cmdsts . . . . . . . . . . . .               E   Word
sft  . . . . . . . . . . . . . .              3D
  wNumHandles  . . . . . . . . .               0   Word
  wOpenMode  . . . . . . . . . .               2   Word
  bFileAttrib  . . . . . . . . .               4   Byte
  wDeviceInfo  . . . . . . . . .               5   Word
  qPtr . . . . . . . . . . . . .               7   QWord
  dStartClust  . . . . . . . . .               F   DWord
  wTime  . . . . . . . . . . . .              13   Word
  wDate  . . . . . . . . . . . .              15   Word
  dFileSize  . . . . . . . . . .              17   DWord
  dCurntOff  . . . . . . . . . .              1B   DWord
  wRelClust  . . . . . . . . . .              1F   Word
  dDirSect . . . . . . . . . . .              21   DWord
  bNumDirEnt . . . . . . . . . .              25   Byte
  sFCBName . . . . . . . . . . .              26   Byte[11]
  qPSPOwner  . . . . . . . . . .              31   QWord
  dAbsClusr  . . . . . . . . . .              39   DWord
sfth . . . . . . . . . . . . . .               A
  qNextSFTPtr  . . . . . . . . .               0   QWord
  wNumFiles  . . . . . . . . . .               8   Word
statusReqPkt . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

loadCode . . . . . . . . . . . .        64 Bit   000000B6 Para    Private ''
resCode  . . . . . . . . . . . .        64 Bit   0000157E Byte    Private ''
FLAT . . . . . . . . . . . . . .        GROUP


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

FATprocs . . . . . . . . . . . .        P Near   00000EC8 resCode  00000000 Public   
clkDriver  . . . . . . . . . . .        P Near   00001133 resCode  00000000 Public   
com1Intr . . . . . . . . . . . .        P Near   00001133 resCode  00000009 Public   
com2Intr . . . . . . . . . . . .        P Near   0000113C resCode  00000009 Public   
com3Intr . . . . . . . . . . . .        P Near   00001145 resCode  00000009 Public   
com4Intr . . . . . . . . . . . .        P Near   0000114E resCode  00000009 Public   
comDriver  . . . . . . . . . . .        P Near   00001133 resCode  0000009D Public   
comIntr  . . . . . . . . . . . .        P Near   00001157 resCode  00000079 Public   
  L&_0012  . . . . . . . . . . .        L Near   000011B5 resCode
  L&_0013  . . . . . . . . . . .        L Near   000011CA resCode
  L&_0010  . . . . . . . . . . .        L Near   00001189 resCode
  L&_0011  . . . . . . . . . . .        L Near   000011A1 resCode
  comWrite . . . . . . . . . . .        L Near   000011AF resCode
  comRead  . . . . . . . . . . .        L Near   00001182 resCode
  comExit  . . . . . . . . . . .        L Near   00001176 resCode
  comNondestructiveRead  . . . .        L Near   000011A7 resCode
commonStrat  . . . . . . . . . .        P Near   00001068 resCode  00000010 Public   
conDriver  . . . . . . . . . . .        P Near   0000107F resCode  000000B4 Public   
  conExit  . . . . . . . . . . .        L Near   000010A7 resCode
  conNondestructiveRead  . . . .        L Near   000010F6 resCode
  conInit  . . . . . . . . . . .        L Near   000010B0 resCode
  L&_0008  . . . . . . . . . . .        L Near   0000111D resCode
  L&_0009  . . . . . . . . . . .        L Near   00001129 resCode
  L&_0006  . . . . . . . . . . .        L Near   000010EF resCode
  L&_0007  . . . . . . . . . . .        L Near   00001101 resCode
  L&_0005  . . . . . . . . . . .        L Near   000010E1 resCode
  conWrite . . . . . . . . . . .        L Near   00001115 resCode
  conIORead  . . . . . . . . . .        L Near   000010D1 resCode
  conFlushInputBuffers . . . . .        L Near   00001109 resCode
  conRead  . . . . . . . . . . .        L Near   000010D9 resCode
drivers  . . . . . . . . . . . .        P Near   00000ED0 resCode  000006AE Public   
findDPB  . . . . . . . . . . . .        P Near   00000EAC resCode  0000001C Public   
  L&_0004  . . . . . . . . . . .        L Near   00000EC7 resCode
  L&_0003  . . . . . . . . . . .        L Near   00000EB3 resCode
findLRUBuffer  . . . . . . . . .        P Near   00000E76 resCode  00000036 Public   
  L&_0002  . . . . . . . . . . .        L Near   00000E86 resCode
int49hHook . . . . . . . . . . .        P Near   00000EC8 resCode  00000008 Public   
lptDriver  . . . . . . . . . . .        P Near   000011D0 resCode  00000010 Public   
lptIntr  . . . . . . . . . . . .        P Near   000011D0 resCode  00000010 Public   
msdDriver  . . . . . . . . . . .        P Near   000011E0 resCode  0000039E Public   
  L&_0015  . . . . . . . . . . .        L Near   0000128A resCode
  msdWriteVerify . . . . . . . .        L Near   000012E6 resCode
  msdDevOpen . . . . . . . . . .        L Near   000012E6 resCode
  msdDevClose  . . . . . . . . .        L Near   000012E6 resCode
  msdIOCTLRead . . . . . . . . .        L Near   000012E6 resCode
  msdInit  . . . . . . . . . . .        L Near   00001257 resCode
  msdBuildBPB  . . . . . . . . .        L Near   000012E6 resCode
  msdIOCTLWrite  . . . . . . . .        L Near   000012E6 resCode
  msdGetLogicalDev . . . . . . .        L Near   000012E6 resCode
  msdError . . . . . . . . . . .        L Near   0000124E resCode
  msdInitError . . . . . . . . .        L Near   000012E4 resCode
  msdSetLogicalDev . . . . . . .        L Near   000012E6 resCode
  msdRemovableMedia  . . . . . .        L Near   000012E6 resCode
  msdIntrExit  . . . . . . . . .        L Near   0000124E resCode
  msdGenericIOCTL  . . . . . . .        L Near   000012E6 resCode
  msdWrite . . . . . . . . . . .        L Near   000012E6 resCode
  msdMedChk  . . . . . . . . . .        L Near   000012E6 resCode
  msdRead  . . . . . . . . . . .        L Near   000012E6 resCode
  L&_0016  . . . . . . . . . . .        L Near   000012C2 resCode
  L&_0014  . . . . . . . . . . .        L Near   00001266 resCode
nulIntr  . . . . . . . . . . . .        P Near   0000107E resCode  00000001 Public   
nulStrat . . . . . . . . . . . .        P Near   00001078 resCode  00000007 Public   


Symbols:

                N a m e                 Type       Value     Attr

L&_0001  . . . . . . . . . . . .        L Near            71h loadCode 
auxHdr . . . . . . . . . . . . .        drvHdr           EF2h resCode 
clkHdr . . . . . . . . . . . . .        drvHdr           F36h resCode 
com1Hdr  . . . . . . . . . . . .        drvHdr           F7Ah resCode 
com2Hdr  . . . . . . . . . . . .        drvHdr           F9Ch resCode 
com3Hdr  . . . . . . . . . . . .        drvHdr           FBEh resCode 
com4Hdr  . . . . . . . . . . . .        drvHdr           FE0h resCode 
comDevice  . . . . . . . . . . .        Byte            11CFh resCode 
conHdr . . . . . . . . . . . . .        drvHdr           ED0h resCode 
data . . . . . . . . . . . . . .        dSeg               0h resCode 
driverDataPtr  . . . . . . . . .        Byte            157Eh resCode 
lpt1Hdr  . . . . . . . . . . . .        drvHdr          1002h resCode 
lpt2Hdr  . . . . . . . . . . . .        drvHdr          1024h resCode 
lpt3Hdr  . . . . . . . . . . . .        drvHdr          1046h resCode 
msdBIOSmap . . . . . . . . . . .        Byte[5]         12F4h resCode 
msdBPBTbl  . . . . . . . . . . .        QWord[5]        12FEh resCode 
msdBPBblks . . . . . . . . . . .        Byte[600]       1326h resCode 
msdDefLabel  . . . . . . . . . .        Byte[9]         12EBh resCode 
msdHdlCnt  . . . . . . . . . . .        Byte[5]         12F9h resCode 
msdHdr . . . . . . . . . . . . .        drvHdr           F58h resCode 
msdIntr  . . . . . . . . . . . .        Byte            11E0h resCode 
nData  . . . . . . . . . . . . .        QWord             94h loadCode 
prnHdr . . . . . . . . . . . . .        drvHdr           F14h resCode 
reqHdrPtr  . . . . . . . . . . .        QWord           1070h resCode 
startmsg . . . . . . . . . . . .        Byte[24]          7Ch loadCode 

io.asm: 470 lines, 3 passes, 15 ms, 0 warnings, 0 errors
