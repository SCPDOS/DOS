JWasm v2.11, Oct 20 2013
io.asm
                                    
                                    .x64p

                                    INCLUDE fatStruc.inc
                              C 
                              C ;-------------------------------------------------------;
                              C ; This include file contains miscellaneous FAT driver   ;
                              C ; structures. exFAT will have it's own files at a later ;
                              C ; stage.                                                ;
                              C ;-------------------------------------------------------;
                              C 
00000000                      C bpb STRUC          ;FAT 12 and 16 BPB
                              C 
00000000                      C     jmpBoot    db 3 dup (?)
00000003                      C     oemName    db 8 dup (?)  ;OEM name
0000000B                      C     bytsPerSec dw ?  ;Bytes per sector
0000000D                      C     secPerClus db ?  ;Sectors per cluster
0000000E                      C     revdSecCnt dw ?  ;Number of reserved sectors
00000010                      C     numFATs    db ?  ;Number of FATs on media
00000011                      C     rootEntCnt dw ?  ;Number of entries in Root directory
00000013                      C     totSec16   dw ?  ;Number of sectors on medium
00000015                      C     media      db ?  ;Media descriptor byte
00000016                      C     FATsz16    dw ?  ;Number of sectors per FAT
00000018                      C     secPerTrk  dw ?  ;Number of sectors per "track"
0000001A                      C     numHeads   dw ?  ;Number of read "heads"
0000001C                      C     hiddSec    dd ?  ;Number of hidden sectors
00000020                      C     totSec32   dd ?  ;32 bit count of sectors
                              C 
00000024                      C     drvNum     db ?  ;Logical drive number (00h or 80h)
00000025                      C     reserved1  db ?  ;Reserved byte
00000026                      C     bootSig    db ?  ;Extended boot signature (29h)
00000027                      C     volID      dd ?  ;Volume serial number
0000002B                      C     volLab     db 11 dup (?) ;Volume label string
00000036                      C     filSysType db 8 dup (?)  ;File system type string
                              C 
0000003E                      C bpb ENDS
                              C 
00000000                      C bpb32 STRUC       ;FAT 32 BPB
                              C 
00000000                      C     jmpBoot    db 3 dup (?)
00000003                      C     oemName    db 8 dup (?)  ;OEM name
0000000B                      C     bytsPerSec dw ?  ;Bytes per sector
0000000D                      C     secPerClus db ?  ;Sectors per cluster
0000000E                      C     revdSecCnt dw ?  ;Number of reserved sectors
00000010                      C     numFATs    db ?  ;Number of FATs on media
00000011                      C     rootEntCnt dw ?  ;Number of entries in Root directory
00000013                      C     totSec16   dw ?  ;Number of sectors on medium
00000015                      C     media      db ?  ;Media descriptor byte
00000016                      C     FATsz16    dw ?  ;Number of sectors per FAT, must be 0 for FAT 32
00000018                      C     secPerTrk  dw ?  ;Number of sectors per "track"
0000001A                      C     numHeads   dw ?  ;Number of read "heads"
0000001C                      C     hiddSec    dd ?  ;Number of hidden sectors
00000020                      C     totSec32   dd ?  ;32 bit count of sectors
                              C 
00000024                      C     FATsz32    dd ?  ;32 bit count of sectors occupied by one FAT
00000028                      C     extFlags   dw ?  ;Extended Flags word
0000002A                      C     FSver      dw ?  ;File system version word, must be 0
0000002C                      C     RootClus   dd ?  ;First Cluster of Root Directory
00000030                      C     FSinfo     dw ?  ;Sector number of FSINFO structure, usually 1
00000032                      C     BkBootSec  dw ?  ;Backup Boot sector, either 0 or 6
00000034                      C     reserved   db 12 dup (?) ;Reserved 12 bytes
                              C 
00000040                      C     drvNum     db ?  ;Logical drive number (00h or 80h)
00000041                      C     reserved1  db ?  ;Reserved byte
00000042                      C     bootSig    db ?  ;Extended boot signature (29h)
00000043                      C     volID      dd ?  ;Volume serial number
00000047                      C     volLab     db 11 dup (?) ;Volume label string
00000052                      C     filSysType db 8 dup (?)  ;File system type string
                              C 
0000005A                      C bpb32 ENDS
                              C 
                              C 
00000000                      C bpbEx STRUC   ;exFAT BPB
                              C 
00000000                      C     jmpBoot                db 3 dup (?) 
00000003                      C     oemName                db 8 dup (?) ;OEM name
0000000B                      C     MustBeZero             db 53 dup (?) ;Must be 0, 53 bytes
00000040                      C     partitionOffset        dq ?  ;in sectors, 0 means ignore this field
00000048                      C     volumeLength           dq ?  ;Volume Length in sectors
00000050                      C     FAToffset              dd ?  ;Volume rel offset of first FAT, in sectors
00000054                      C     FATlength              dd ?  ;FAT length, in sectors
00000058                      C     clusterHeapOffset      dd ?  ;Start of data area, in sectors
0000005C                      C     clusterCount           dd ?  ;Number of clusters on medium
00000060                      C     firstClusterOfRootDir  dd ?  ;First Cluster of Root Directory, min 2
00000064                      C     volumeSerialNum        dd ?  ;Volume Serial Number
00000068                      C     FSrevision             dw ?  ;Should be 0001 (v1.00)
0000006A                      C     volumeFlags            dw ?  ;Volume Flags, refer to documentation
0000006C                      C     bytesPerSectorShift    db ?  ;min 9 (512 bps), max 12 (4096 bps)
0000006D                      C     sectorsPerClusterShift db ?  ;Result of log_2(N) for N=sec per clus
0000006E                      C     numberOfFATs           db ?  ;Number of FATs, only 1 or 2
0000006F                      C     driveSelect            db ?  ;Drive Select, 0 or 80h (Int 13h)
00000070                      C     percentInUse           db ?  ;Rounded down. FFh means unknown
00000071                      C     reserved               db 7 dup (?)  ;Reserved for alignment
                              C 
00000078                      C bpbEx ENDS
                                    INCLUDE dosStruc.inc
                              C 
                              C ;-------------------------------------------------------;
                              C ; This include file contains miscellaneous internal     ;
                              C ; SCP/DOS structures.                                   ;
                              C ;-------------------------------------------------------;
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
                              C ; its file system structure. This is used to locate files and structures
                              C ; on the device itself and to translate file requests to cluster chains
                              C ; to LBAs to pass to the disk driver..
                              C ; The DPBs form a linked list, with each DPB formed after the devices 
                              C ; drivers Initialise routine has been called.
                              C ;------------------------------------------------------------------------;
00000000                      C dpb STRUC        ;Drive Parameter Block
                              C 
00000000                      C     bDriveNumber            db ?  ;Drive number
00000001                      C     bUnitNumber             db ?  ;Unit number in device
00000002                      C     bBytesPerSectorShift    db ?  ;min 9 (512 bps), max 12 (4096 bps)
00000003                      C     bMaxSectorInCluster     db ?  ;(Maximum sector in cluster) - 1
                              C ;                                       i.e. (2^bSectorsPerClusterShift) - 1
00000004                      C     bSectorsPerClusterShift db ?  ;Sectors per cluster exponent
00000005                      C     dFAToffset              dd ?  ;Vol rel offset of first FAT, in sectors
00000009                      C     bNumberOfFATs           db ?  ;Number of FATs
0000000A                      C     wNumberRootDirEntries   dw ?  ;In sectors
0000000C                      C     dClusterHeapOffset      dd ?  ;Start of data area, in sectors
00000010                      C     dClusterCount           dd ?  ;Total number of clusters (volume size)
00000014                      C     dFATlength              dd ?  ;FAT length, in sectors
00000018                      C     dFirstClusterOfRootDir  dd ?  ;First Cluster of Root Directory, min 2
0000001C                      C     qDriverHeaderPtr        dq ?  ;Pointer to device driver header
00000024                      C     bMediaDescriptor        db ?  ;Media descriptor
00000025                      C     bAccessFlag             db ?  ;Access Flag (0 if accessed, else -1)
00000026                      C     qNextDPBPtr             dq ?  ;Pointer to next DPB, -1 if at end
0000002E                      C     dFirstFreeCluster       dd ?  ;Starting cluster of free space search
00000032                      C     dNumberOfFreeClusters   dd ?  ;Number of free clusters, -1 unknown
                              C 
00000036                      C dpb ENDS
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
                              C ; All disk pathing requests go via the CDS for that drive.
                              C ; The default drive is the last accessed drive, this number is stored
                              C ; in the DOS data area.
                              C ; The CDS is stored as an array with the offset into the array being 
                              C ; given by the drive letter's offset into the alphabet (with A=0).
                              C ;
                              C ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
                              C ;------------------------------------------------------------------------;
00000000                      C cds STRUC       ;Current Directory Structure
00000000                      C     sCurrentPath        db 67 dup(?)    ;Current Directory Path String
00000043                      C     wFlags              dw ? ;CDS Flags - 
00000045                      C     qDPBPtr             dq ? ;Ptr to the DPB of the dev using this CDS
0000004D                      C     dStartCluster       dd ? ;Starting cluster of the directory on disk
00000051                      C     qReserved           dq ? ;Reserved for future expansions
00000059                      C     wBackslashOffset    dw ? ;How many chars to the start of current dir in the 
                              C ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
                              C ; another, we save the number of chars to skip to that deep level).
                              C ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
                              C ; Flags: Bit 15 set = Network drive
                              C ;        Bit 14 set = Physical drive
                              C ;        Bit 13 set = JOIN'ed drive
                              C ;        Bit 12 set = SUBST'ed drive
                              C ;        Bit 7  set = Redirected, not network, drive (This is how MSCDEX worked)
0000005B                      C cds ENDS
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; The SFT is a way to allow applications to open file handles to files 
                              C ; and devices. As things stand, the SFT chain will have 5 file handles
                              C ; under the first header, and then a second header will be linked to the 
                              C ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
                              C ; a size for the second SFT (default 10 files). Same for System FCBs, 
                              C ; using the FCBS= command. Default FCBS=5.
                              C ;
                              C ; A file handle describes the file, and the location within the file that
                              C ; we are reading. The file handle can be manipulated without the file
                              C ; being in memory, thus allowing the user to access data without needing 
                              C ; to take up large portions of memory. Similarly, file handles allow for
                              C ; accessing devices, by treating them as files with their drivers 
                              C ; responding and translating the manipulations of the file handle itself.
                              C ; Neither the driver nor the application should see or use the SFT for
                              C ; the handle, as it is subject to change (and will change when file 
                              C ; sharing provisions are included). The DOS will make requests to the 
                              C ; driver in a generic way and the driver will respond, with DOS keeping
                              C ; track of the information in the SFT entry for that handle. 
                              C ;
                              C ; One SFT entry can have multiple handles and multiple SFT entries
                              C ; can point to the same file. It all depends on what the applications 
                              C ; want to do with the File.
                              C ;
                              C ; !!!!IMPORTANT!!!!
                              C ; Currently there are plans for File Sharing, but I include minimal 
                              C ; provisions for it. I really just wanna get a DOS out the door.
                              C ;
                              C ;Each SFT may look like this:
                              C ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
                              C ;            |                |
                              C ;       wNumFiles*sft    wNumFiles*sft
                              C ;
                              C ; Two SFT chains are built; one for files, and a one for so called 
                              C ; System FCBs.
                              C ;
                              C ; Each SFT header has an array of SFT's below it, with the number of 
                              C ; SFTs given by wNumFiles. The SFT headers form a linked list.
                              C ;
                              C ; DEFAULT FILES=15, MINIMUM FILES=5
                              C ; DEFAULT FCBS=5, MINIMUM FCBS=5
                              C ;------------------------------------------------------------------------;
00000000                      C sfth STRUC   ;System file table header
                              C ; This is the SFT header.
                              C ; This structure comes before the start of the first file in the array/table.
00000000                      C     qNextSFTPtr dq ?    ;Pointer to the next SFT
00000008                      C     wNumFiles   dw ?    ;Number of files in this table
0000000A                      C sfth ENDS
                              C 
00000000                      C sft STRUC
                              C ;This is the file struc itself
00000000                      C     wNumHandles dw ?    ;Number of handles pointing to this file
00000002                      C     wOpenMode   dw ?    ;Bit 15 set if opened via FCB
00000004                      C     bFileAttrib db ?    ;Regular File Attributes
00000005                      C     wDeviceInfo dw ?    ;Includes Device number
00000007                      C     qPtr        dq ?    ;IF char, ptr to device driver, ELSE DPBptr
0000000F                      C     dStartClust dd ?    ;Start cluster of file
00000013                      C     wTime       dw ?    ;File Time
00000015                      C     wDate       dw ?    ;File Date
00000017                      C     dFileSize   dd ?    ;File Size, in bytes
0000001B                      C     dCurntOff   dd ?    ;Current Offset in file, in bytes
0000001F                      C     wRelClust   dw ?    ;Relative cluster in file of the last cluster accessed
00000021                      C     dDirSect    dd ?    ;Relative number of sector containing directory entry 
00000025                      C     bNumDirEnt  db ?    ;Number of dir entry within sector (byte offset/32)
00000026                      C     sFCBName    db 11 dup(?)    ;8.3 Filename
00000031                      C     qPSPOwner   dq ?    ;Address of PSP of program which first opened this file
00000039                      C     dAbsClusr   dd ?    ;Absolute cluster of last cluster accessed
0000003D                      C sft ENDS
                              C 
                              C ;------------------------------------------------------------------------;
                              C ; Buffers allow for buffered drive IO, by first transferring a sector 
                              C ; to an internal buffer, and then copying it to the specified location
                              C ; in memory. The buffer is kept in the buffer chain,  in the event that 
                              C ; another request for the same sector from the same device is made, so 
                              C ; that is can be read from the device directly. Buffers are uniform in 
                              C ; size, selected according to the largest detected sector size during 
                              C ; the initial loadup.
                              C ;
                              C ; The buffer pointer in SysVars points to the oldest unused buffer
                              C ;
                              C ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
                              C ;------------------------------------------------------------------------;
                              C 
00000000                      C bufferHdr   STRUC
00000000                      C     nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
00000008                      C     driveNumber db  ?   ;Drive number the buffer is used for
00000009                      C     bufferFlags db  ?   ;Standard Flags
0000000A                      C     bufferLBA   dd  ?   ;LBA the buffer contains
0000000E                      C     bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
0000000F                      C     bufFAToff   db  ?   ;Sector offset of the backup copy of the FAT on disk
00000010                      C     driveDPBPtr dq  ?   ;Pointer to the device DPB block
00000018                      C bufferHdr   ENDS
                                    INCLUDE driverStruc.inc
                              C 
                              C ;-------------------------------------------------------;
                              C ; This include file contains miscellaneous SCP/DOS      ;
                              C ; device driver related structures.                     ;
                              C ;-------------------------------------------------------;
                              C 
00000000                      C drvHdr STRUC  ;Device Driver Header for character and block devices
                              C 
00000000                      C     nxtPtr dq ?  ;Pointer to the next driver header, -1 if at the end
00000008                      C     atWord dw ?  ;Attribute Word
0000000A                      C     strPtr dq ?  ;Strategy Entry Pointer
00000012                      C     intPtr dq ?  ;Interrupt Entry Pointer
0000001A                      C     drvNam db 8 dup (?)  ;Driver name (Char) or Unit number byte (Block)
                              C 
00000022                      C drvHdr ENDS
                              C 
                              C drvReqHdrM MACRO  ;Driver Request Header Macro
 >                            C   ;Driver Request Header Macro
 >                            C     hdrlen db ?  ;Length of the request header  ;Driver Request Header Macro
 >                            C     unitnm db ?  ;Unit number, meaningless for character devs  ;Driver Request Header Macro
 >                            C     cmdcde db ?  ;Command code  ;Driver Request Header Macro
 >                            C     status dw ?  ;Status word  ;Driver Request Header Macro
 >                            C     devptr dq ?  ;Device queue pointer field  ;Driver Request Header Macro
 >                            C   ;Driver Request Header Macro
 >                            C ENDM  ;Driver Request Header Macro
                              C 
00000000                      C drvReqHdr   STRUC
                              C     drvReqHdrM
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C drvReqHdr   ENDS
                              C 
00000000                      C initReqPkt STRUC  ;Init Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     numunt db ?  ;Number of logical units (Block only, 0 for char)
0000000E                      C     endptr dq ?  ;Pointer to first free byte after driver
00000016                      C     optptr dq ?  ;Pointer to the BPB array (block) or optional args (char)
0000001E                      C     drvnum db ?  ;Drive number
                              C 
0000001F                      C initReqPkt ENDS
                              C 
00000000                      C mediaCheckReqPkt STRUC ;Media Check Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     medesc db ?  ;DOS media descriptor
0000000E                      C     medret db ?  ;Return byte (Has media been changed?)
0000000F                      C     desptr dq ?  ;Pointer to a valid volume id field
                              C 
00000017                      C mediaCheckReqPkt ENDS
                              C 
00000000                      C bpbBuildReqPkt STRUC  ;Build BPB Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     medesc db ?  ;DOS media descriptor
0000000E                      C     bufptr dq ?  ;Transfer buffer
00000016                      C     bpbptr dq ?  ;Pointer to the BPB
                              C 
0000001E                      C bpbBuildReqPkt ENDS
                              C 
00000000                      C ioReqPkt STRUC   ;IO Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     medesc db ?  ;DOS media descriptor
0000000E                      C     bufptr dq ?  ;Transfer buffer
00000016                      C     tfrlen dd ?  ;Number of Sectors/bytes to transfer
0000001A                      C     strtsc dq ?  ;Starting sector for transfer
00000022                      C     desptr dq ?  ;Pointer to a valid volume id field if error
                              C 
0000002A                      C ioReqPkt ENDS
                              C 
00000000                      C nonDestInNoWaitReqPkt STRUC    ;Nondestructive Input No Wait Request Packet
                              C     
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     retbyt db ?  ;Byte read non destructively
                              C 
0000000E                      C nonDestInNoWaitReqPkt ENDS
                              C 
00000000                      C statusReqPkt STRUC   ;Status Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C 
0000000D                      C statusReqPkt ENDS
                              C 
00000000                      C flushReqPkt STRUC ;Flush Request Packet, terminate all pending requests
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C flushReqPkt ENDS
                              C 
00000000                      C openReqPkt STRUC ;Open Device Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C openReqPkt ENDS
                              C 
00000000                      C closeReqPkt STRUC ;Close Device Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C closeReqPkt ENDS
                              C 
00000000                      C remMediaReqPkt STRUC ;Removeable Media? Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
                              C      
0000000D                      C remMediaReqPkt ENDS
                              C 
00000000                      C ioctlReqPkt STRUC    ;Generic IOCTL Request Packet
                              C 
                              C     drvReqHdrM    ;Common Driver Header Macro  
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     majfun db ?  ;Major function number
0000000E                      C     minfun db ?  ;Minor function number
0000000F                      C     rsival dq ?  ;Contents of RSI
00000017                      C     rdival dq ?  ;Contents of RDI
0000001F                      C     ctlptr dq ?  ;Pointer to Generic IOCTL Request Packet
                              C 
00000027                      C ioctlReqPkt ENDS
                              C 
00000000                      C getDevReqPkt STRUC ;Get Logical Device Request Packet
                              C     
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     getcmd db ?  ;Command code
0000000E                      C     cmdsts dw ?  ;Command status word
                              C 
00000010                      C getDevReqPkt ENDS
                              C 
00000000                      C setDevReqPkt STRUC ;Set Logical Device Request Packet
                              C     
                              C     drvReqHdrM    ;Common Driver Header Macro
                             1C 
00000000                     1C     hdrlen db ?  ;Length of the request header
00000001                     1C     unitnm db ?  ;Unit number, meaningless for character devs
00000002                     1C     cmdcde db ?  ;Command code
00000003                     1C     status dw ?  ;Status word
00000005                     1C     devptr dq ?  ;Device queue pointer field
                             1C 
0000000D                      C     setcmd db ?  ;Command code
0000000E                      C     cmdsts dw ?  ;Command status word
                              C 
00000010                      C setDevReqPkt ENDS
                                    INCLUDE dosData.inc
                              C ; This file contains the structure of the DOS Data area
00000000                      C dSeg STRUC 
00000000                      C     dataSegPtr  dq ?    ;Pointer to the data Segment itself
00000008                      C     codeSegPtr  dq ?    ;Pointer to the start of the resident Code segment
00000010                      C     bootDrive   db ?    ;The Int 33h device we booted from
00000011                      C     requestHdr  drvReqHdr    <,,,,>   ;The device driver header
0000001E                      C                 db 20 dup (?)    ;Reserve xtra space for cmd data, with padding
00000032                      C     sysVarsPtr  dq ?    ;Pointer to dpbHeadPtr, head of Sys Vars structure below
0000003A                      C     mcbChainPtr dq ?    ;Pointer to the MCB chain
00000042                      C     dpbHeadPtr  dq ?    ;Pointer to the first DPB in the DPB chain
0000004A                      C     sftHeadPtr  dq ?    ;Pointer to the first SFT header in SFT chain
00000052                      C     clockPtr    dq ?    ;Pointer to the current active CLOCK$ device header
                              C     ;                    The last driver loaded with the CLOCK$ bit[3] set 
0000005A                      C     conPtr      dq ?    ;Pointer to the current active CON device header 
                              C     ;                    The last driver loaded with the STDIN bit[0] set
00000062                      C     maxBytesSec dw ?    ;Maximum number of bytes per sector (size of buffers)
00000064                      C     bufHeadPtr  dq ?    ;Pointer to next usable disk buffer
0000006C                      C     cdsHeadPtr  dq ?    ;Pointer to the head of the CDS array
00000074                      C     sfcbHeadPTr dq ?    ;Pointer to the head of the System FCB chain
0000007C                      C     numSafeSFCB dw ?    ;Number of protected FCBs (y in FCBS=x,y)
0000007E                      C     numInt33drv db ?    ;Number of Int 33h drives detected in system
0000007F                      C     lastdrvNum  db ?    ;Value of LASTDRIVE (default = 5) [Size of CDS array]
00000080                      C     numJoinDrv  db ?    ;Number of Joined Drives
00000081                      C     nulDevHdr   drvHdr <,,,,>
                              C 
                              C 
000000A3                      C     inDOS       db ?    ;Incremented on each DOS call, decremented when leaving
000000A4                      C     breakFlag   db ?    ;If set, check for CTRL+C on all DOS calls
000000A5                      C     defaultDrv  db ?    ;Default, last accessed drive
                              C 
000000A6                      C     critStack   dq 41 dup (?)
000001EE                      C     critStakTop dq ?
000001F6                      C     IOStack     dq 199 dup (?)
0000082E                      C     IOStakTop   dq ?
00000836                      C     DiskStack   dq 199 dup (?)
00000E6E                      C     DiskStakTop dq ?
00000E76                      C dSeg ENDS

00000000                        loadCode SEGMENT USE64
                                    ASSUME ds:FLAT, es:FLAT
                                ; We arrive here with the following values in the registers.
                                ; rbx =  LBA of first Logical Block after SCP/BIOS
                                ; dx  = Int 33h boot device number
                                ; fs  = userbase pointer (pointer to first usable block of RAM)
00000000  55AA                      dw 0AA55h           ;Initial signature
00000002  6687DB                    xchg bx, bx
00000005  6488142510000000          mov byte ptr fs:[dSeg.bootDrive], dl ;Save the boot drive in memory

0000000D  B9000100C0                mov ecx, 0C0000100h ;Read FS MSR
00000012  0F32                      rdmsr
00000014  8BFA                      mov edi, edx        ;Get the hi dword, and clear the upper bytes
00000016  48C1E720                  shl rdi, 20h        ;Shift high
0000001A  8BF8                      mov edi, eax        ;Get the low dword in

0000001C  6448893C2500000000        mov qword ptr fs:[dSeg.dataSegPtr], rdi  
00000025  4881C7760E0000            add rdi, SIZEOF dSeg
0000002C  6448893C2508000000        mov qword ptr fs:[dSeg.codeSegPtr], rdi
00000035  488BC7                    mov rax, rdi    ;Save the codeSegment address in rax
00000038  488D3500000000            lea rsi, OFFSET resCode ;Get offset of the segment in the file into rsi
0000003F  B900100000                mov ecx, 1000h
00000044  F348A5                    rep movsq
00000047  488D3500000000            lea rsi, nData
0000004E  48014610                  add qword ptr [rsi + 10h], rax  ;Add the code segment address to the ptrs
00000052  48014618                  add qword ptr [rsi + 18h], rax
00000056  64488B3C2581000000        mov rdi, qword ptr fs:[dSeg.nulDevHdr]
0000005F  B922000000                mov ecx, 34
00000064  F3A4                      rep movsb


00000066  488D2D00000000            lea rbp, startmsg   ;Get the absolute address of message
0000006D  B804130000                mov eax, 1304h
00000072  CD30                      int 30h
00000074  EBFE                      jmp short $

00000076  0A0D5374617274696E        startmsg db 0Ah,0Dh,"Starting SCP/DOS...",0Ah,0Dh,0
0000008E                        nData   LABEL QWORD
0000008E  0000000000000000          dq conHdr
00000096  0480                      dw 08004h
00000098  0000000000000000          dq nulStrat
000000A0  0000000000000000          dq nulIntr
000000A8  4E554C2020202020          db "NUL     "
000000B0                        loadCode ENDS

                                ;codeSegment points to the start of this segment!
00000000                        resCode SEGMENT BYTE USE64
                                    ASSUME ds:FLAT, es:FLAT
00000000                        FATprocs    PROC
00000000                        FATprocs    ENDP

00000000                        drivers PROC
00000000  000000000000000013    conHdr  drvHdr <auxHdr,  08013h, commonStrat, conDriver, "CON     ">
00000022  000000000000000000    auxHdr  drvHdr <prnHdr,  08000h, commonStrat, auxDriver, "AUX     ">
00000044  000000000000000040    prnHdr  drvHdr <clkHdr,  0A040h, commonStrat, prnDriver, "PRN     ">
00000066  000000000000000008    clkHdr  drvHdr <msdHdr,  08008h, commonStrat, clkDriver, "CLOCK$  ">
00000088  000000000000000040    msdHdr  drvHdr <com1Hdr, 00840h, commonStrat, msdIntr, <0,0,0,0,0,0,0,0>>
000000AA  000000000000000000    com1Hdr drvHdr <com2Hdr, 08000h, commonStrat, com1Intr, "COM1    ">
000000CC  000000000000000000    com2Hdr drvHdr <com3Hdr, 08000h, commonStrat, com2Intr, "COM2    ">
000000EE  000000000000000000    com3Hdr drvHdr <com4Hdr, 08000h, commonStrat, com3Intr, "COM3    ">
00000110  000000000000000000    com4Hdr drvHdr <lpt1Hdr, 08000h, commonStrat, com4Intr, "COM4    ">
00000132  000000000000000040    lpt1Hdr drvHdr <lpt2Hdr, 0A040h, commonStrat, lptIntr, "LPT1    ">
00000154  000000000000000040    lpt2Hdr drvHdr <lpt3Hdr, 0A040h, commonStrat, lptIntr, "LPT2    ">
00000176  FFFFFFFFFFFFFFFF40    lpt3Hdr drvHdr <-1, 0A040h, commonStrat, lptIntr, "LPT3    ">
00000198                        commonStrat PROC
                                ;DOS calls this function with rbx=Ptr to request header
                                ;DOS also sets fs to point to its data segment when entered
00000198  48891D00000000            mov qword ptr [reqHdrPtr], rbx
0000019F                            ret
000001A0  FFFFFFFFFFFFFFFF      reqHdrPtr  dq -1    ;Where the default device drivers store the ReqPtr
000001A8                        commonStrat ENDP

000001A8                        nulStrat   PROC
000001A8  66C743030001              mov word ptr [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
000001AE                        nulIntr PROC
000001AE                            ret
000001AF                        nulIntr     ENDP
000001AF                        nulStrat    ENDP

000001AF                        conDriver   PROC
000001AF  50                        push rax
000001B0  53                        push rbx
000001B1  488B1D00000000            mov rbx, qword ptr [reqHdrPtr]
000001B8  8A4302                    mov al, byte ptr [rbx + drvReqHdr.cmdcde]
000001BB  5B                        pop rbx
000001BC  58                        pop rax
000001BD                            ret
000001BE                        conError:
000001BE                        conInit:
000001BE                        conIOCTLRead:
000001BE  66C743030001              mov word ptr [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
000001C4                            ret
000001C5                        conRead:
000001C5  57                        push rdi
000001C6  51                        push rcx
000001C7  488B7B0E                  mov rdi, qword ptr [rbx + ioReqPkt.bufptr] ;Point rdi to destination buffer
000001CB  8B4B16                    mov ecx, dword ptr [rbx + ioReqPkt.tfrlen] ;Number of chars to read
000001CE                        @@:
000001CE  6633C0                    xor ax, ax  ;Wait for char input
000001D1  CD36                      int 36h     ;Get the ASCII char into al
000001D3  AA                        stosb       ;Save al in buffer and inc rdi
000001D4  E2F8                      loop @b
000001D6  59                        pop rcx
000001D7  5F                        pop rdi
000001D8                            ret
000001D9                        conNondestructiveRead:
000001D9                        conInputStatus:
000001D9                        conFlushInputBuffers:
000001D9                        conWrite:
000001D9  56                        push rsi
000001DA  51                        push rcx
000001DB  488B730E                  mov rsi, qword ptr [rbx + ioReqPkt.bufptr] ;Point rsi to buffer pointer
000001DF  8B4B16                    mov ecx, dword ptr [rbx + ioReqPkt.tfrlen] ;Number of chars to transfer
000001E2                        @@: 
000001E2  AC                        lodsb   ;Get char into al, and inc rsi
000001E3  CD49                      int 49h ;Fast print char
000001E5  E2FB                      loop @b ;keep printing until ecx is zero
000001E7  59                        pop rcx
000001E8  5E                        pop rsi
000001E9  66C743030001              mov word ptr [rbx + drvReqHdr.status], 0100h    ;Request complete
000001EF                            ret
000001F0                        conOutputStatus:
000001F0                        conFlushOutputBuffers:
000001F0  66C743030001              mov word ptr [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
000001F6                            ret
000001F7                        conIOCTLWrite:
000001F7                        conOpen:
000001F7                        conClose:
000001F7                        conOutUntilBusy:
000001F7                        conGenericIOCTL:
000001F7  66C743030001              mov word ptr [rbx + drvReqHdr.status], 0100h    ;Set done bit directly
000001FD                            ret
000001FE  D380                  conWord dw  80D3h   ;Bit 5 set (20h) => Binary mode, else char mode
00000200  000000000000000000    conBuf  db  128 dup (?) ;Build a buffer of size 128 bytes
00000280                        conDriver   ENDP

00000280                        auxDriver   PROC
00000280  C080                  auxWord dw  80C0h
00000282                        auxDriver   ENDP

00000282                        prnDriver   PROC
00000282  C0A0                  prnWord dw  0A0C0h
00000284                        prnDriver   ENDP

00000284                        clkDriver   PROC
00000284                        clkDriver   ENDP

00000284                        msdDriver   PROC
00000284                        msdIntr     LABEL   BYTE
00000284  50                        push rax
00000285  57                        push rdi
00000286  4150                      push r8
00000288  4151                      push r9
0000028A  4152                      push r10
0000028C  4153                      push r11
0000028E  4154                      push r12
00000290  4155                      push r13
00000292  4156                      push r14
00000294  4157                      push r15
00000296  488B3D00000000            mov rdi, qword ptr [reqHdrPtr]  ;Get the ptr to the req header in rdi
0000029D  8A4702                    mov al, byte ptr [rdi + drvReqHdr.cmdcde]   ;Get command code in al
000002A0  3C18                      cmp al, 24  ;Check cmd num is valid
000002A2  7738                      ja msdError
000002A4  84C0                      test al, al
000002A6  744D                      jz msdInit
000002A8  3C01                      cmp al, 01
000002AA  7465                      jz msdMedChk
000002AC  3C02                      cmp al, 02
000002AE  7461                      jz msdBuildBPB
000002B0  3C03                      cmp al, 03
000002B2  745D                      jz msdIOCTLRead
000002B4  3C04                      cmp al, 04
000002B6  7459                      jz msdRead
000002B8  3C08                      cmp al, 08
000002BA  7455                      jz msdWrite
000002BC  3C09                      cmp al, 09
000002BE  7451                      jz msdWriteVerify
000002C0  3C0C                      cmp al, 12
000002C2  744D                      jz msdIOCTLWrite
000002C4  3C0D                      cmp al, 13
000002C6  7449                      jz msdDevOpen
000002C8  3C0E                      cmp al, 14
000002CA  7445                      jz msdDevClose
000002CC  3C0F                      cmp al, 15
000002CE  7441                      jz msdRemovableMedia
000002D0  3C13                      cmp al, 19
000002D2  743D                      jz msdGenericIOCTL
000002D4  3C17                      cmp al, 23
000002D6  7439                      jz msdGetLogicalDev
000002D8  3C18                      cmp al, 24
000002DA  7435                      jz msdSetLogicalDev
000002DC                        msdError:
                                ;Place Error, Unknown Command error in status field
000002DC  66C747030380              mov word ptr [rdi + drvReqHdr.status], 8003h
000002E2                        msdIntrExit:
000002E2  415F                      pop r15
000002E4  415E                      pop r14
000002E6  415D                      pop r13
000002E8  415C                      pop r12
000002EA  415B                      pop r11
000002EC  415A                      pop r10
000002EE  4159                      pop r9
000002F0  4158                      pop r8
000002F2  5F                        pop rdi
000002F3  58                        pop rax
000002F4                            ret
000002F5                        msdInit:            ;Function 0
000002F5  CD31                      int 31h ;Get number of Int 33h devices in R8b, and aux devices in byte 3
000002F7  4D0FB6D0                  movzx r10, r8b   ;Isolate the number of Int 33h devs only
000002FB  49C7C102000000            mov r9, 2
00000302  4983FA01                  cmp r10, 1
00000306  4D0F44C1                  cmove r8, r9    ;If we have one device detected only, make it two!
0000030A  4488051A000000            mov byte ptr [msdHdr + drvHdr.drvNam], r8b ;Save num Int 33h devs here
00000311                        msdMedChk:          ;Function 1
00000311                        msdBuildBPB:        ;Function 2
00000311                        msdIOCTLRead:       ;Function 3
00000311                        msdRead:            ;Funciton 4
00000311                        msdWrite:           ;Function 8
00000311                        msdWriteVerify:     ;Function 9
00000311                        msdIOCTLWrite:      ;Function 12
00000311                        msdDevOpen:         ;Function 13
00000311                        msdDevClose:        ;Function 14
00000311                        msdRemovableMedia:  ;Function 15
00000311                        msdGenericIOCTL:    ;Function 19
00000311                        msdGetLogicalDev:   ;Function 23
00000311                        msdSetLogicalDev:   ;Function 24
00000311  EBCF                      jmp short msdIntrExit
00000313                        msdDriver   ENDP

00000313                        comDriver   PROC
00000313                        com1Intr    PROC
00000313  EB04                      jmp short comIntr
00000315                        com1Intr    ENDP
00000315                        com2Intr    PROC
00000315  EB02                      jmp short comIntr
00000317                        com2Intr    ENDP
00000317                        com3Intr    PROC
00000317  EB00                      jmp short comIntr
00000319                        com3Intr    ENDP
00000319                        com4Intr    LABEL   BYTE
00000319                        comIntr     PROC
00000319                            ret
0000031A                        comIntr     ENDP
                                    

0000031A                        comDriver   ENDP

0000031A                        lptDriver   PROC    ;Drivers for LPT 1, 2, 3

0000031A                        lptIntr     PROC    ;LPT act as null device drivers
0000031A  57                        push rdi
0000031B  488B3D00000000            mov rdi, qword ptr [reqHdrPtr]
00000322  66C747030001              mov word ptr [rdi + drvReqHdr.status], 0100h    ;Done bit set
00000328  5F                        pop rdi
00000329                            ret
0000032A                        lptIntr     ENDP
0000032A                        lptDriver   ENDP

0000032A                        int49hHook  PROC ;Called with char to transfer in al
0000032A  50                        push rax
0000032B  B40E                      mov ah, 0Eh
0000032D  CD30                      int 30h
0000032F  58                        pop rax
00000330                            iretq
00000332                        int49hHook  ENDP

00000332                        driverDataPtr   LABEL   BYTE
00000332                        drivers ENDP

00000332                        resCode ENDS

                                END


Binary Map:

Segment                  Pos(file)     RVA  Size(fil) Size(mem)
---------------------------------------------------------------
loadCode                        0        0        B0        B0
resCode                        B0       B0       332       332
---------------------------------------------------------------
                                                 3E2       3E2


Macros:

                N a m e                 Type

@CatStr  . . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func
drvReqHdrM . . . . . . . . . . .        Proc


Structures and Unions:

                N a m e                 Size/Ofs   Type

bpb  . . . . . . . . . . . . . .              3E
  jmpBoot  . . . . . . . . . . .               0   Byte[3]
  oemName  . . . . . . . . . . .               3   Byte[8]
  bytsPerSec . . . . . . . . . .               B   Word
  secPerClus . . . . . . . . . .               D   Byte
  revdSecCnt . . . . . . . . . .               E   Word
  numFATs  . . . . . . . . . . .              10   Byte
  rootEntCnt . . . . . . . . . .              11   Word
  totSec16 . . . . . . . . . . .              13   Word
  media  . . . . . . . . . . . .              15   Byte
  FATsz16  . . . . . . . . . . .              16   Word
  secPerTrk  . . . . . . . . . .              18   Word
  numHeads . . . . . . . . . . .              1A   Word
  hiddSec  . . . . . . . . . . .              1C   DWord
  totSec32 . . . . . . . . . . .              20   DWord
  drvNum . . . . . . . . . . . .              24   Byte
  reserved1  . . . . . . . . . .              25   Byte
  bootSig  . . . . . . . . . . .              26   Byte
  volID  . . . . . . . . . . . .              27   DWord
  volLab . . . . . . . . . . . .              2B   Byte[11]
  filSysType . . . . . . . . . .              36   Byte[8]
bpb32  . . . . . . . . . . . . .              5A
  jmpBoot  . . . . . . . . . . .               0   Byte[3]
  oemName  . . . . . . . . . . .               3   Byte[8]
  bytsPerSec . . . . . . . . . .               B   Word
  secPerClus . . . . . . . . . .               D   Byte
  revdSecCnt . . . . . . . . . .               E   Word
  numFATs  . . . . . . . . . . .              10   Byte
  rootEntCnt . . . . . . . . . .              11   Word
  totSec16 . . . . . . . . . . .              13   Word
  media  . . . . . . . . . . . .              15   Byte
  FATsz16  . . . . . . . . . . .              16   Word
  secPerTrk  . . . . . . . . . .              18   Word
  numHeads . . . . . . . . . . .              1A   Word
  hiddSec  . . . . . . . . . . .              1C   DWord
  totSec32 . . . . . . . . . . .              20   DWord
  FATsz32  . . . . . . . . . . .              24   DWord
  extFlags . . . . . . . . . . .              28   Word
  FSver  . . . . . . . . . . . .              2A   Word
  RootClus . . . . . . . . . . .              2C   DWord
  FSinfo . . . . . . . . . . . .              30   Word
  BkBootSec  . . . . . . . . . .              32   Word
  reserved . . . . . . . . . . .              34   Byte[12]
  drvNum . . . . . . . . . . . .              40   Byte
  reserved1  . . . . . . . . . .              41   Byte
  bootSig  . . . . . . . . . . .              42   Byte
  volID  . . . . . . . . . . . .              43   DWord
  volLab . . . . . . . . . . . .              47   Byte[11]
  filSysType . . . . . . . . . .              52   Byte[8]
bpbBuildReqPkt . . . . . . . . .              1E
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  medesc . . . . . . . . . . . .               D   Byte
  bufptr . . . . . . . . . . . .               E   QWord
  bpbptr . . . . . . . . . . . .              16   QWord
bpbEx  . . . . . . . . . . . . .              78
  jmpBoot  . . . . . . . . . . .               0   Byte[3]
  oemName  . . . . . . . . . . .               3   Byte[8]
  MustBeZero . . . . . . . . . .               B   Byte[53]
  partitionOffset  . . . . . . .              40   QWord
  volumeLength . . . . . . . . .              48   QWord
  FAToffset  . . . . . . . . . .              50   DWord
  FATlength  . . . . . . . . . .              54   DWord
  clusterHeapOffset  . . . . . .              58   DWord
  clusterCount . . . . . . . . .              5C   DWord
  firstClusterOfRootDir  . . . .              60   DWord
  volumeSerialNum  . . . . . . .              64   DWord
  FSrevision . . . . . . . . . .              68   Word
  volumeFlags  . . . . . . . . .              6A   Word
  bytesPerSectorShift  . . . . .              6C   Byte
  sectorsPerClusterShift . . . .              6D   Byte
  numberOfFATs . . . . . . . . .              6E   Byte
  driveSelect  . . . . . . . . .              6F   Byte
  percentInUse . . . . . . . . .              70   Byte
  reserved . . . . . . . . . . .              71   Byte[7]
bufferHdr  . . . . . . . . . . .              18
  nextBufPtr . . . . . . . . . .               0   QWord
  driveNumber  . . . . . . . . .               8   Byte
  bufferFlags  . . . . . . . . .               9   Byte
  bufferLBA  . . . . . . . . . .               A   DWord
  bufFATcopy . . . . . . . . . .               E   Byte
  bufFAToff  . . . . . . . . . .               F   Byte
  driveDPBPtr  . . . . . . . . .              10   QWord
cds  . . . . . . . . . . . . . .              5B
  sCurrentPath . . . . . . . . .               0   Byte[67]
  wFlags . . . . . . . . . . . .              43   Word
  qDPBPtr  . . . . . . . . . . .              45   QWord
  dStartCluster  . . . . . . . .              4D   DWord
  qReserved  . . . . . . . . . .              51   QWord
  wBackslashOffset . . . . . . .              59   Word
closeReqPkt  . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
dSeg . . . . . . . . . . . . . .             E76
  dataSegPtr . . . . . . . . . .               0   QWord
  codeSegPtr . . . . . . . . . .               8   QWord
  bootDrive  . . . . . . . . . .              10   Byte
  requestHdr . . . . . . . . . .              11   drvReqHdr
  sysVarsPtr . . . . . . . . . .              32   QWord
  mcbChainPtr  . . . . . . . . .              3A   QWord
  dpbHeadPtr . . . . . . . . . .              42   QWord
  sftHeadPtr . . . . . . . . . .              4A   QWord
  clockPtr . . . . . . . . . . .              52   QWord
  conPtr . . . . . . . . . . . .              5A   QWord
  maxBytesSec  . . . . . . . . .              62   Word
  bufHeadPtr . . . . . . . . . .              64   QWord
  cdsHeadPtr . . . . . . . . . .              6C   QWord
  sfcbHeadPTr  . . . . . . . . .              74   QWord
  numSafeSFCB  . . . . . . . . .              7C   Word
  numInt33drv  . . . . . . . . .              7E   Byte
  lastdrvNum . . . . . . . . . .              7F   Byte
  numJoinDrv . . . . . . . . . .              80   Byte
  nulDevHdr  . . . . . . . . . .              81   drvHdr
  inDOS  . . . . . . . . . . . .              A3   Byte
  breakFlag  . . . . . . . . . .              A4   Byte
  defaultDrv . . . . . . . . . .              A5   Byte
  critStack  . . . . . . . . . .              A6   QWord[41]
  critStakTop  . . . . . . . . .             1EE   QWord
  IOStack  . . . . . . . . . . .             1F6   QWord[199]
  IOStakTop  . . . . . . . . . .             82E   QWord
  DiskStack  . . . . . . . . . .             836   QWord[199]
  DiskStakTop  . . . . . . . . .             E6E   QWord
dpb  . . . . . . . . . . . . . .              36
  bDriveNumber . . . . . . . . .               0   Byte
  bUnitNumber  . . . . . . . . .               1   Byte
  bBytesPerSectorShift . . . . .               2   Byte
  bMaxSectorInCluster  . . . . .               3   Byte
  bSectorsPerClusterShift  . . .               4   Byte
  dFAToffset . . . . . . . . . .               5   DWord
  bNumberOfFATs  . . . . . . . .               9   Byte
  wNumberRootDirEntries  . . . .               A   Word
  dClusterHeapOffset . . . . . .               C   DWord
  dClusterCount  . . . . . . . .              10   DWord
  dFATlength . . . . . . . . . .              14   DWord
  dFirstClusterOfRootDir . . . .              18   DWord
  qDriverHeaderPtr . . . . . . .              1C   QWord
  bMediaDescriptor . . . . . . .              24   Byte
  bAccessFlag  . . . . . . . . .              25   Byte
  qNextDPBPtr  . . . . . . . . .              26   QWord
  dFirstFreeCluster  . . . . . .              2E   DWord
  dNumberOfFreeClusters  . . . .              32   DWord
drvHdr . . . . . . . . . . . . .              22
  nxtPtr . . . . . . . . . . . .               0   QWord
  atWord . . . . . . . . . . . .               8   Word
  strPtr . . . . . . . . . . . .               A   QWord
  intPtr . . . . . . . . . . . .              12   QWord
  drvNam . . . . . . . . . . . .              1A   Byte[8]
drvReqHdr  . . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
flushReqPkt  . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
getDevReqPkt . . . . . . . . . .              10
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  getcmd . . . . . . . . . . . .               D   Byte
  cmdsts . . . . . . . . . . . .               E   Word
initReqPkt . . . . . . . . . . .              1F
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  numunt . . . . . . . . . . . .               D   Byte
  endptr . . . . . . . . . . . .               E   QWord
  optptr . . . . . . . . . . . .              16   QWord
  drvnum . . . . . . . . . . . .              1E   Byte
ioReqPkt . . . . . . . . . . . .              2A
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  medesc . . . . . . . . . . . .               D   Byte
  bufptr . . . . . . . . . . . .               E   QWord
  tfrlen . . . . . . . . . . . .              16   DWord
  strtsc . . . . . . . . . . . .              1A   QWord
  desptr . . . . . . . . . . . .              22   QWord
ioctlReqPkt  . . . . . . . . . .              27
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  majfun . . . . . . . . . . . .               D   Byte
  minfun . . . . . . . . . . . .               E   Byte
  rsival . . . . . . . . . . . .               F   QWord
  rdival . . . . . . . . . . . .              17   QWord
  ctlptr . . . . . . . . . . . .              1F   QWord
mediaCheckReqPkt . . . . . . . .              17
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  medesc . . . . . . . . . . . .               D   Byte
  medret . . . . . . . . . . . .               E   Byte
  desptr . . . . . . . . . . . .               F   QWord
nonDestInNoWaitReqPkt  . . . . .               E
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  retbyt . . . . . . . . . . . .               D   Byte
openReqPkt . . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
remMediaReqPkt . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
setDevReqPkt . . . . . . . . . .              10
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord
  setcmd . . . . . . . . . . . .               D   Byte
  cmdsts . . . . . . . . . . . .               E   Word
sft  . . . . . . . . . . . . . .              3D
  wNumHandles  . . . . . . . . .               0   Word
  wOpenMode  . . . . . . . . . .               2   Word
  bFileAttrib  . . . . . . . . .               4   Byte
  wDeviceInfo  . . . . . . . . .               5   Word
  qPtr . . . . . . . . . . . . .               7   QWord
  dStartClust  . . . . . . . . .               F   DWord
  wTime  . . . . . . . . . . . .              13   Word
  wDate  . . . . . . . . . . . .              15   Word
  dFileSize  . . . . . . . . . .              17   DWord
  dCurntOff  . . . . . . . . . .              1B   DWord
  wRelClust  . . . . . . . . . .              1F   Word
  dDirSect . . . . . . . . . . .              21   DWord
  bNumDirEnt . . . . . . . . . .              25   Byte
  sFCBName . . . . . . . . . . .              26   Byte[11]
  qPSPOwner  . . . . . . . . . .              31   QWord
  dAbsClusr  . . . . . . . . . .              39   DWord
sfth . . . . . . . . . . . . . .               A
  qNextSFTPtr  . . . . . . . . .               0   QWord
  wNumFiles  . . . . . . . . . .               8   Word
statusReqPkt . . . . . . . . . .               D
  hdrlen . . . . . . . . . . . .               0   Byte
  unitnm . . . . . . . . . . . .               1   Byte
  cmdcde . . . . . . . . . . . .               2   Byte
  status . . . . . . . . . . . .               3   Word
  devptr . . . . . . . . . . . .               5   QWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

loadCode . . . . . . . . . . . .        64 Bit   000000B0 Para    Private ''
resCode  . . . . . . . . . . . .        64 Bit   00000332 Byte    Private ''
FLAT . . . . . . . . . . . . . .        GROUP


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

FATprocs . . . . . . . . . . . .        P Near   00000000 resCode  00000000 Public   
auxDriver  . . . . . . . . . . .        P Near   00000280 resCode  00000002 Public   
clkDriver  . . . . . . . . . . .        P Near   00000284 resCode  00000000 Public   
com1Intr . . . . . . . . . . . .        P Near   00000313 resCode  00000002 Public   
com2Intr . . . . . . . . . . . .        P Near   00000315 resCode  00000002 Public   
com3Intr . . . . . . . . . . . .        P Near   00000317 resCode  00000002 Public   
comDriver  . . . . . . . . . . .        P Near   00000313 resCode  00000007 Public   
comIntr  . . . . . . . . . . . .        P Near   00000319 resCode  00000001 Public   
commonStrat  . . . . . . . . . .        P Near   00000198 resCode  00000010 Public   
conDriver  . . . . . . . . . . .        P Near   000001AF resCode  000000D1 Public   
  conNondestructiveRead  . . . .        L Near   000001D9 resCode
  conInit  . . . . . . . . . . .        L Near   000001BE resCode
  conFlushOutputBuffers  . . . .        L Near   000001F0 resCode
  conOutUntilBusy  . . . . . . .        L Near   000001F7 resCode
  L&_0002  . . . . . . . . . . .        L Near   000001E2 resCode
  L&_0001  . . . . . . . . . . .        L Near   000001CE resCode
  conOpen  . . . . . . . . . . .        L Near   000001F7 resCode
  conIOCTLRead . . . . . . . . .        L Near   000001BE resCode
  conError . . . . . . . . . . .        L Near   000001BE resCode
  conClose . . . . . . . . . . .        L Near   000001F7 resCode
  conWrite . . . . . . . . . . .        L Near   000001D9 resCode
  conIOCTLWrite  . . . . . . . .        L Near   000001F7 resCode
  conGenericIOCTL  . . . . . . .        L Near   000001F7 resCode
  conFlushInputBuffers . . . . .        L Near   000001D9 resCode
  conRead  . . . . . . . . . . .        L Near   000001C5 resCode
  conInputStatus . . . . . . . .        L Near   000001D9 resCode
  conOutputStatus  . . . . . . .        L Near   000001F0 resCode
drivers  . . . . . . . . . . . .        P Near   00000000 resCode  00000332 Public   
int49hHook . . . . . . . . . . .        P Near   0000032A resCode  00000008 Public   
lptDriver  . . . . . . . . . . .        P Near   0000031A resCode  00000010 Public   
lptIntr  . . . . . . . . . . . .        P Near   0000031A resCode  00000010 Public   
msdDriver  . . . . . . . . . . .        P Near   00000284 resCode  0000008F Public   
  msdWriteVerify . . . . . . . .        L Near   00000311 resCode
  msdDevOpen . . . . . . . . . .        L Near   00000311 resCode
  msdDevClose  . . . . . . . . .        L Near   00000311 resCode
  msdIOCTLRead . . . . . . . . .        L Near   00000311 resCode
  msdInit  . . . . . . . . . . .        L Near   000002F5 resCode
  msdBuildBPB  . . . . . . . . .        L Near   00000311 resCode
  msdIOCTLWrite  . . . . . . . .        L Near   00000311 resCode
  msdGetLogicalDev . . . . . . .        L Near   00000311 resCode
  msdError . . . . . . . . . . .        L Near   000002DC resCode
  msdSetLogicalDev . . . . . . .        L Near   00000311 resCode
  msdRemovableMedia  . . . . . .        L Near   00000311 resCode
  msdIntrExit  . . . . . . . . .        L Near   000002E2 resCode
  msdGenericIOCTL  . . . . . . .        L Near   00000311 resCode
  msdWrite . . . . . . . . . . .        L Near   00000311 resCode
  msdMedChk  . . . . . . . . . .        L Near   00000311 resCode
  msdRead  . . . . . . . . . . .        L Near   00000311 resCode
nulIntr  . . . . . . . . . . . .        P Near   000001AE resCode  00000001 Public   
nulStrat . . . . . . . . . . . .        P Near   000001A8 resCode  00000007 Public   
prnDriver  . . . . . . . . . . .        P Near   00000282 resCode  00000002 Public   


Symbols:

                N a m e                 Type       Value     Attr

auxHdr . . . . . . . . . . . . .        drvHdr            22h resCode 
auxWord  . . . . . . . . . . . .        Word             280h resCode 
clkHdr . . . . . . . . . . . . .        drvHdr            66h resCode 
com1Hdr  . . . . . . . . . . . .        drvHdr            AAh resCode 
com2Hdr  . . . . . . . . . . . .        drvHdr            CCh resCode 
com3Hdr  . . . . . . . . . . . .        drvHdr            EEh resCode 
com4Hdr  . . . . . . . . . . . .        drvHdr           110h resCode 
com4Intr . . . . . . . . . . . .        Byte             319h resCode 
conBuf . . . . . . . . . . . . .        Byte[128]        200h resCode 
conHdr . . . . . . . . . . . . .        drvHdr             0h resCode 
conWord  . . . . . . . . . . . .        Word             1FEh resCode 
driverDataPtr  . . . . . . . . .        Byte             332h resCode 
lpt1Hdr  . . . . . . . . . . . .        drvHdr           132h resCode 
lpt2Hdr  . . . . . . . . . . . .        drvHdr           154h resCode 
lpt3Hdr  . . . . . . . . . . . .        drvHdr           176h resCode 
msdHdr . . . . . . . . . . . . .        drvHdr            88h resCode 
msdIntr  . . . . . . . . . . . .        Byte             284h resCode 
nData  . . . . . . . . . . . . .        QWord             8Eh loadCode 
prnHdr . . . . . . . . . . . . .        drvHdr            44h resCode 
prnWord  . . . . . . . . . . . .        Word             282h resCode 
reqHdrPtr  . . . . . . . . . . .        QWord            1A0h resCode 
startmsg . . . . . . . . . . . .        Byte[24]          76h loadCode 

io.asm: 280 lines, 3 passes, 0 ms, 0 warnings, 0 errors
